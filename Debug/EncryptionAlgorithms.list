
EncryptionAlgorithms.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000e5c0  080001c8  080001c8  000101c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001fb8  0800e788  0800e788  0001e788  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08010740  08010740  000300b0  2**0
                  CONTENTS
  4 .ARM          00000008  08010740  08010740  00020740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08010748  08010748  000300b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08010748  08010748  00020748  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801074c  0801074c  0002074c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000000b0  20000000  08010750  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000170c  200000b0  08010800  000300b0  2**3
                  ALLOC
 10 ._user_heap_stack 00000604  200017bc  08010800  000317bc  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  000300b0  2**0
                  CONTENTS, READONLY
 12 .debug_info   00020c5a  00000000  00000000  000300e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00004a95  00000000  00000000  00050d3a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001658  00000000  00000000  000557d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001458  00000000  00000000  00056e28  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0002490e  00000000  00000000  00058280  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001f34f  00000000  00000000  0007cb8e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000db1d6  00000000  00000000  0009bedd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  001770b3  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00005fb8  00000000  00000000  00177104  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c05      	ldr	r4, [pc, #20]	; (80001e0 <__do_global_dtors_aux+0x18>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b933      	cbnz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d0:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001d2:	b113      	cbz	r3, 80001da <__do_global_dtors_aux+0x12>
 80001d4:	4804      	ldr	r0, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	f3af 8000 	nop.w
 80001da:	2301      	movs	r3, #1
 80001dc:	7023      	strb	r3, [r4, #0]
 80001de:	bd10      	pop	{r4, pc}
 80001e0:	200000b0 	.word	0x200000b0
 80001e4:	00000000 	.word	0x00000000
 80001e8:	0800e770 	.word	0x0800e770

080001ec <frame_dummy>:
 80001ec:	b508      	push	{r3, lr}
 80001ee:	4b03      	ldr	r3, [pc, #12]	; (80001fc <frame_dummy+0x10>)
 80001f0:	b11b      	cbz	r3, 80001fa <frame_dummy+0xe>
 80001f2:	4903      	ldr	r1, [pc, #12]	; (8000200 <frame_dummy+0x14>)
 80001f4:	4803      	ldr	r0, [pc, #12]	; (8000204 <frame_dummy+0x18>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	bd08      	pop	{r3, pc}
 80001fc:	00000000 	.word	0x00000000
 8000200:	200000b4 	.word	0x200000b4
 8000204:	0800e770 	.word	0x0800e770

08000208 <strlen>:
 8000208:	4603      	mov	r3, r0
 800020a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800020e:	2a00      	cmp	r2, #0
 8000210:	d1fb      	bne.n	800020a <strlen+0x2>
 8000212:	1a18      	subs	r0, r3, r0
 8000214:	3801      	subs	r0, #1
 8000216:	4770      	bx	lr

08000218 <__aeabi_uldivmod>:
 8000218:	b953      	cbnz	r3, 8000230 <__aeabi_uldivmod+0x18>
 800021a:	b94a      	cbnz	r2, 8000230 <__aeabi_uldivmod+0x18>
 800021c:	2900      	cmp	r1, #0
 800021e:	bf08      	it	eq
 8000220:	2800      	cmpeq	r0, #0
 8000222:	bf1c      	itt	ne
 8000224:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000228:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 800022c:	f000 b974 	b.w	8000518 <__aeabi_idiv0>
 8000230:	f1ad 0c08 	sub.w	ip, sp, #8
 8000234:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000238:	f000 f806 	bl	8000248 <__udivmoddi4>
 800023c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000240:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000244:	b004      	add	sp, #16
 8000246:	4770      	bx	lr

08000248 <__udivmoddi4>:
 8000248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800024c:	9d08      	ldr	r5, [sp, #32]
 800024e:	4604      	mov	r4, r0
 8000250:	468e      	mov	lr, r1
 8000252:	2b00      	cmp	r3, #0
 8000254:	d14d      	bne.n	80002f2 <__udivmoddi4+0xaa>
 8000256:	428a      	cmp	r2, r1
 8000258:	4694      	mov	ip, r2
 800025a:	d969      	bls.n	8000330 <__udivmoddi4+0xe8>
 800025c:	fab2 f282 	clz	r2, r2
 8000260:	b152      	cbz	r2, 8000278 <__udivmoddi4+0x30>
 8000262:	fa01 f302 	lsl.w	r3, r1, r2
 8000266:	f1c2 0120 	rsb	r1, r2, #32
 800026a:	fa20 f101 	lsr.w	r1, r0, r1
 800026e:	fa0c fc02 	lsl.w	ip, ip, r2
 8000272:	ea41 0e03 	orr.w	lr, r1, r3
 8000276:	4094      	lsls	r4, r2
 8000278:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800027c:	0c21      	lsrs	r1, r4, #16
 800027e:	fbbe f6f8 	udiv	r6, lr, r8
 8000282:	fa1f f78c 	uxth.w	r7, ip
 8000286:	fb08 e316 	mls	r3, r8, r6, lr
 800028a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800028e:	fb06 f107 	mul.w	r1, r6, r7
 8000292:	4299      	cmp	r1, r3
 8000294:	d90a      	bls.n	80002ac <__udivmoddi4+0x64>
 8000296:	eb1c 0303 	adds.w	r3, ip, r3
 800029a:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
 800029e:	f080 811f 	bcs.w	80004e0 <__udivmoddi4+0x298>
 80002a2:	4299      	cmp	r1, r3
 80002a4:	f240 811c 	bls.w	80004e0 <__udivmoddi4+0x298>
 80002a8:	3e02      	subs	r6, #2
 80002aa:	4463      	add	r3, ip
 80002ac:	1a5b      	subs	r3, r3, r1
 80002ae:	b2a4      	uxth	r4, r4
 80002b0:	fbb3 f0f8 	udiv	r0, r3, r8
 80002b4:	fb08 3310 	mls	r3, r8, r0, r3
 80002b8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80002bc:	fb00 f707 	mul.w	r7, r0, r7
 80002c0:	42a7      	cmp	r7, r4
 80002c2:	d90a      	bls.n	80002da <__udivmoddi4+0x92>
 80002c4:	eb1c 0404 	adds.w	r4, ip, r4
 80002c8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80002cc:	f080 810a 	bcs.w	80004e4 <__udivmoddi4+0x29c>
 80002d0:	42a7      	cmp	r7, r4
 80002d2:	f240 8107 	bls.w	80004e4 <__udivmoddi4+0x29c>
 80002d6:	4464      	add	r4, ip
 80002d8:	3802      	subs	r0, #2
 80002da:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80002de:	1be4      	subs	r4, r4, r7
 80002e0:	2600      	movs	r6, #0
 80002e2:	b11d      	cbz	r5, 80002ec <__udivmoddi4+0xa4>
 80002e4:	40d4      	lsrs	r4, r2
 80002e6:	2300      	movs	r3, #0
 80002e8:	e9c5 4300 	strd	r4, r3, [r5]
 80002ec:	4631      	mov	r1, r6
 80002ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002f2:	428b      	cmp	r3, r1
 80002f4:	d909      	bls.n	800030a <__udivmoddi4+0xc2>
 80002f6:	2d00      	cmp	r5, #0
 80002f8:	f000 80ef 	beq.w	80004da <__udivmoddi4+0x292>
 80002fc:	2600      	movs	r6, #0
 80002fe:	e9c5 0100 	strd	r0, r1, [r5]
 8000302:	4630      	mov	r0, r6
 8000304:	4631      	mov	r1, r6
 8000306:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800030a:	fab3 f683 	clz	r6, r3
 800030e:	2e00      	cmp	r6, #0
 8000310:	d14a      	bne.n	80003a8 <__udivmoddi4+0x160>
 8000312:	428b      	cmp	r3, r1
 8000314:	d302      	bcc.n	800031c <__udivmoddi4+0xd4>
 8000316:	4282      	cmp	r2, r0
 8000318:	f200 80f9 	bhi.w	800050e <__udivmoddi4+0x2c6>
 800031c:	1a84      	subs	r4, r0, r2
 800031e:	eb61 0303 	sbc.w	r3, r1, r3
 8000322:	2001      	movs	r0, #1
 8000324:	469e      	mov	lr, r3
 8000326:	2d00      	cmp	r5, #0
 8000328:	d0e0      	beq.n	80002ec <__udivmoddi4+0xa4>
 800032a:	e9c5 4e00 	strd	r4, lr, [r5]
 800032e:	e7dd      	b.n	80002ec <__udivmoddi4+0xa4>
 8000330:	b902      	cbnz	r2, 8000334 <__udivmoddi4+0xec>
 8000332:	deff      	udf	#255	; 0xff
 8000334:	fab2 f282 	clz	r2, r2
 8000338:	2a00      	cmp	r2, #0
 800033a:	f040 8092 	bne.w	8000462 <__udivmoddi4+0x21a>
 800033e:	eba1 010c 	sub.w	r1, r1, ip
 8000342:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000346:	fa1f fe8c 	uxth.w	lr, ip
 800034a:	2601      	movs	r6, #1
 800034c:	0c20      	lsrs	r0, r4, #16
 800034e:	fbb1 f3f7 	udiv	r3, r1, r7
 8000352:	fb07 1113 	mls	r1, r7, r3, r1
 8000356:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800035a:	fb0e f003 	mul.w	r0, lr, r3
 800035e:	4288      	cmp	r0, r1
 8000360:	d908      	bls.n	8000374 <__udivmoddi4+0x12c>
 8000362:	eb1c 0101 	adds.w	r1, ip, r1
 8000366:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800036a:	d202      	bcs.n	8000372 <__udivmoddi4+0x12a>
 800036c:	4288      	cmp	r0, r1
 800036e:	f200 80cb 	bhi.w	8000508 <__udivmoddi4+0x2c0>
 8000372:	4643      	mov	r3, r8
 8000374:	1a09      	subs	r1, r1, r0
 8000376:	b2a4      	uxth	r4, r4
 8000378:	fbb1 f0f7 	udiv	r0, r1, r7
 800037c:	fb07 1110 	mls	r1, r7, r0, r1
 8000380:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000384:	fb0e fe00 	mul.w	lr, lr, r0
 8000388:	45a6      	cmp	lr, r4
 800038a:	d908      	bls.n	800039e <__udivmoddi4+0x156>
 800038c:	eb1c 0404 	adds.w	r4, ip, r4
 8000390:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 8000394:	d202      	bcs.n	800039c <__udivmoddi4+0x154>
 8000396:	45a6      	cmp	lr, r4
 8000398:	f200 80bb 	bhi.w	8000512 <__udivmoddi4+0x2ca>
 800039c:	4608      	mov	r0, r1
 800039e:	eba4 040e 	sub.w	r4, r4, lr
 80003a2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 80003a6:	e79c      	b.n	80002e2 <__udivmoddi4+0x9a>
 80003a8:	f1c6 0720 	rsb	r7, r6, #32
 80003ac:	40b3      	lsls	r3, r6
 80003ae:	fa22 fc07 	lsr.w	ip, r2, r7
 80003b2:	ea4c 0c03 	orr.w	ip, ip, r3
 80003b6:	fa20 f407 	lsr.w	r4, r0, r7
 80003ba:	fa01 f306 	lsl.w	r3, r1, r6
 80003be:	431c      	orrs	r4, r3
 80003c0:	40f9      	lsrs	r1, r7
 80003c2:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80003c6:	fa00 f306 	lsl.w	r3, r0, r6
 80003ca:	fbb1 f8f9 	udiv	r8, r1, r9
 80003ce:	0c20      	lsrs	r0, r4, #16
 80003d0:	fa1f fe8c 	uxth.w	lr, ip
 80003d4:	fb09 1118 	mls	r1, r9, r8, r1
 80003d8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003dc:	fb08 f00e 	mul.w	r0, r8, lr
 80003e0:	4288      	cmp	r0, r1
 80003e2:	fa02 f206 	lsl.w	r2, r2, r6
 80003e6:	d90b      	bls.n	8000400 <__udivmoddi4+0x1b8>
 80003e8:	eb1c 0101 	adds.w	r1, ip, r1
 80003ec:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80003f0:	f080 8088 	bcs.w	8000504 <__udivmoddi4+0x2bc>
 80003f4:	4288      	cmp	r0, r1
 80003f6:	f240 8085 	bls.w	8000504 <__udivmoddi4+0x2bc>
 80003fa:	f1a8 0802 	sub.w	r8, r8, #2
 80003fe:	4461      	add	r1, ip
 8000400:	1a09      	subs	r1, r1, r0
 8000402:	b2a4      	uxth	r4, r4
 8000404:	fbb1 f0f9 	udiv	r0, r1, r9
 8000408:	fb09 1110 	mls	r1, r9, r0, r1
 800040c:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 8000410:	fb00 fe0e 	mul.w	lr, r0, lr
 8000414:	458e      	cmp	lr, r1
 8000416:	d908      	bls.n	800042a <__udivmoddi4+0x1e2>
 8000418:	eb1c 0101 	adds.w	r1, ip, r1
 800041c:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
 8000420:	d26c      	bcs.n	80004fc <__udivmoddi4+0x2b4>
 8000422:	458e      	cmp	lr, r1
 8000424:	d96a      	bls.n	80004fc <__udivmoddi4+0x2b4>
 8000426:	3802      	subs	r0, #2
 8000428:	4461      	add	r1, ip
 800042a:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800042e:	fba0 9402 	umull	r9, r4, r0, r2
 8000432:	eba1 010e 	sub.w	r1, r1, lr
 8000436:	42a1      	cmp	r1, r4
 8000438:	46c8      	mov	r8, r9
 800043a:	46a6      	mov	lr, r4
 800043c:	d356      	bcc.n	80004ec <__udivmoddi4+0x2a4>
 800043e:	d053      	beq.n	80004e8 <__udivmoddi4+0x2a0>
 8000440:	b15d      	cbz	r5, 800045a <__udivmoddi4+0x212>
 8000442:	ebb3 0208 	subs.w	r2, r3, r8
 8000446:	eb61 010e 	sbc.w	r1, r1, lr
 800044a:	fa01 f707 	lsl.w	r7, r1, r7
 800044e:	fa22 f306 	lsr.w	r3, r2, r6
 8000452:	40f1      	lsrs	r1, r6
 8000454:	431f      	orrs	r7, r3
 8000456:	e9c5 7100 	strd	r7, r1, [r5]
 800045a:	2600      	movs	r6, #0
 800045c:	4631      	mov	r1, r6
 800045e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000462:	f1c2 0320 	rsb	r3, r2, #32
 8000466:	40d8      	lsrs	r0, r3
 8000468:	fa0c fc02 	lsl.w	ip, ip, r2
 800046c:	fa21 f303 	lsr.w	r3, r1, r3
 8000470:	4091      	lsls	r1, r2
 8000472:	4301      	orrs	r1, r0
 8000474:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000478:	fa1f fe8c 	uxth.w	lr, ip
 800047c:	fbb3 f0f7 	udiv	r0, r3, r7
 8000480:	fb07 3610 	mls	r6, r7, r0, r3
 8000484:	0c0b      	lsrs	r3, r1, #16
 8000486:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800048a:	fb00 f60e 	mul.w	r6, r0, lr
 800048e:	429e      	cmp	r6, r3
 8000490:	fa04 f402 	lsl.w	r4, r4, r2
 8000494:	d908      	bls.n	80004a8 <__udivmoddi4+0x260>
 8000496:	eb1c 0303 	adds.w	r3, ip, r3
 800049a:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 800049e:	d22f      	bcs.n	8000500 <__udivmoddi4+0x2b8>
 80004a0:	429e      	cmp	r6, r3
 80004a2:	d92d      	bls.n	8000500 <__udivmoddi4+0x2b8>
 80004a4:	3802      	subs	r0, #2
 80004a6:	4463      	add	r3, ip
 80004a8:	1b9b      	subs	r3, r3, r6
 80004aa:	b289      	uxth	r1, r1
 80004ac:	fbb3 f6f7 	udiv	r6, r3, r7
 80004b0:	fb07 3316 	mls	r3, r7, r6, r3
 80004b4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004b8:	fb06 f30e 	mul.w	r3, r6, lr
 80004bc:	428b      	cmp	r3, r1
 80004be:	d908      	bls.n	80004d2 <__udivmoddi4+0x28a>
 80004c0:	eb1c 0101 	adds.w	r1, ip, r1
 80004c4:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
 80004c8:	d216      	bcs.n	80004f8 <__udivmoddi4+0x2b0>
 80004ca:	428b      	cmp	r3, r1
 80004cc:	d914      	bls.n	80004f8 <__udivmoddi4+0x2b0>
 80004ce:	3e02      	subs	r6, #2
 80004d0:	4461      	add	r1, ip
 80004d2:	1ac9      	subs	r1, r1, r3
 80004d4:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 80004d8:	e738      	b.n	800034c <__udivmoddi4+0x104>
 80004da:	462e      	mov	r6, r5
 80004dc:	4628      	mov	r0, r5
 80004de:	e705      	b.n	80002ec <__udivmoddi4+0xa4>
 80004e0:	4606      	mov	r6, r0
 80004e2:	e6e3      	b.n	80002ac <__udivmoddi4+0x64>
 80004e4:	4618      	mov	r0, r3
 80004e6:	e6f8      	b.n	80002da <__udivmoddi4+0x92>
 80004e8:	454b      	cmp	r3, r9
 80004ea:	d2a9      	bcs.n	8000440 <__udivmoddi4+0x1f8>
 80004ec:	ebb9 0802 	subs.w	r8, r9, r2
 80004f0:	eb64 0e0c 	sbc.w	lr, r4, ip
 80004f4:	3801      	subs	r0, #1
 80004f6:	e7a3      	b.n	8000440 <__udivmoddi4+0x1f8>
 80004f8:	4646      	mov	r6, r8
 80004fa:	e7ea      	b.n	80004d2 <__udivmoddi4+0x28a>
 80004fc:	4620      	mov	r0, r4
 80004fe:	e794      	b.n	800042a <__udivmoddi4+0x1e2>
 8000500:	4640      	mov	r0, r8
 8000502:	e7d1      	b.n	80004a8 <__udivmoddi4+0x260>
 8000504:	46d0      	mov	r8, sl
 8000506:	e77b      	b.n	8000400 <__udivmoddi4+0x1b8>
 8000508:	3b02      	subs	r3, #2
 800050a:	4461      	add	r1, ip
 800050c:	e732      	b.n	8000374 <__udivmoddi4+0x12c>
 800050e:	4630      	mov	r0, r6
 8000510:	e709      	b.n	8000326 <__udivmoddi4+0xde>
 8000512:	4464      	add	r4, ip
 8000514:	3802      	subs	r0, #2
 8000516:	e742      	b.n	800039e <__udivmoddi4+0x156>

08000518 <__aeabi_idiv0>:
 8000518:	4770      	bx	lr
 800051a:	bf00      	nop

0800051c <EcTest>:
	for ( uint8_t i = 0; i < 4; i++) {
	}
}

void EcTest(void)
{
 800051c:	b580      	push	{r7, lr}
 800051e:	af00      	add	r7, sp, #0
	RngInit();
 8000520:	f000 f92c 	bl	800077c <RngInit>

	EcInit();
 8000524:	f000 f804 	bl	8000530 <EcInit>

//	EcDSA();
//	EcDSASize();

	EdDSA();
 8000528:	f000 f872 	bl	8000610 <EdDSA>
}
 800052c:	bf00      	nop
 800052e:	bd80      	pop	{r7, pc}

08000530 <EcInit>:

void EcInit(void)
{
 8000530:	b580      	push	{r7, lr}
 8000532:	b082      	sub	sp, #8
 8000534:	af02      	add	r7, sp, #8

	ecInitDomainParameters(&ecParams[0]);
 8000536:	4821      	ldr	r0, [pc, #132]	; (80005bc <EcInit+0x8c>)
 8000538:	f002 f8ee 	bl	8002718 <ecInitDomainParameters>
	ecLoadDomainParameters(&ecParams[0], &secp256r1Curve);
 800053c:	4920      	ldr	r1, [pc, #128]	; (80005c0 <EcInit+0x90>)
 800053e:	481f      	ldr	r0, [pc, #124]	; (80005bc <EcInit+0x8c>)
 8000540:	f002 f914 	bl	800276c <ecLoadDomainParameters>

	ecGenerateKeyPair(&yarrowPrngAlgo, &contextYarrow, &ecParams[0], &ecPrivateKeys[0], &ecPublicKeys[0]);
 8000544:	4b1f      	ldr	r3, [pc, #124]	; (80005c4 <EcInit+0x94>)
 8000546:	9300      	str	r3, [sp, #0]
 8000548:	4b1f      	ldr	r3, [pc, #124]	; (80005c8 <EcInit+0x98>)
 800054a:	4a1c      	ldr	r2, [pc, #112]	; (80005bc <EcInit+0x8c>)
 800054c:	491f      	ldr	r1, [pc, #124]	; (80005cc <EcInit+0x9c>)
 800054e:	4820      	ldr	r0, [pc, #128]	; (80005d0 <EcInit+0xa0>)
 8000550:	f002 f9ae 	bl	80028b0 <ecGenerateKeyPair>

	ecInitDomainParameters(&ecParams[1]);
 8000554:	481f      	ldr	r0, [pc, #124]	; (80005d4 <EcInit+0xa4>)
 8000556:	f002 f8df 	bl	8002718 <ecInitDomainParameters>
	ecLoadDomainParameters(&ecParams[1], &secp384r1Curve);
 800055a:	491f      	ldr	r1, [pc, #124]	; (80005d8 <EcInit+0xa8>)
 800055c:	481d      	ldr	r0, [pc, #116]	; (80005d4 <EcInit+0xa4>)
 800055e:	f002 f905 	bl	800276c <ecLoadDomainParameters>

	ecGenerateKeyPair(&yarrowPrngAlgo, &contextYarrow, &ecParams[1], &ecPrivateKeys[1], &ecPublicKeys[1]);
 8000562:	4b1e      	ldr	r3, [pc, #120]	; (80005dc <EcInit+0xac>)
 8000564:	9300      	str	r3, [sp, #0]
 8000566:	4b1e      	ldr	r3, [pc, #120]	; (80005e0 <EcInit+0xb0>)
 8000568:	4a1a      	ldr	r2, [pc, #104]	; (80005d4 <EcInit+0xa4>)
 800056a:	4918      	ldr	r1, [pc, #96]	; (80005cc <EcInit+0x9c>)
 800056c:	4818      	ldr	r0, [pc, #96]	; (80005d0 <EcInit+0xa0>)
 800056e:	f002 f99f 	bl	80028b0 <ecGenerateKeyPair>

	ecInitDomainParameters(&ecParams[2]);
 8000572:	481c      	ldr	r0, [pc, #112]	; (80005e4 <EcInit+0xb4>)
 8000574:	f002 f8d0 	bl	8002718 <ecInitDomainParameters>
	ecLoadDomainParameters(&ecParams[2], &secp521r1Curve);
 8000578:	491b      	ldr	r1, [pc, #108]	; (80005e8 <EcInit+0xb8>)
 800057a:	481a      	ldr	r0, [pc, #104]	; (80005e4 <EcInit+0xb4>)
 800057c:	f002 f8f6 	bl	800276c <ecLoadDomainParameters>


	ecGenerateKeyPair(&yarrowPrngAlgo, &contextYarrow, &ecParams[2], &ecPrivateKeys[2], &ecPublicKeys[2]);
 8000580:	4b1a      	ldr	r3, [pc, #104]	; (80005ec <EcInit+0xbc>)
 8000582:	9300      	str	r3, [sp, #0]
 8000584:	4b1a      	ldr	r3, [pc, #104]	; (80005f0 <EcInit+0xc0>)
 8000586:	4a17      	ldr	r2, [pc, #92]	; (80005e4 <EcInit+0xb4>)
 8000588:	4910      	ldr	r1, [pc, #64]	; (80005cc <EcInit+0x9c>)
 800058a:	4811      	ldr	r0, [pc, #68]	; (80005d0 <EcInit+0xa0>)
 800058c:	f002 f990 	bl	80028b0 <ecGenerateKeyPair>

	ecdsaInitSignature(&ecdsaSig);
 8000590:	4818      	ldr	r0, [pc, #96]	; (80005f4 <EcInit+0xc4>)
 8000592:	f004 f967 	bl	8004864 <ecdsaInitSignature>

//----------EdDSA---------------------------------
	eddsaGenerateKeyPair(&yarrowPrngAlgo, &contextYarrow, &ed25519Curve, &edPrivateKeys[0], &edPublicKeys[0]);
 8000596:	4b18      	ldr	r3, [pc, #96]	; (80005f8 <EcInit+0xc8>)
 8000598:	9300      	str	r3, [sp, #0]
 800059a:	4b18      	ldr	r3, [pc, #96]	; (80005fc <EcInit+0xcc>)
 800059c:	4a18      	ldr	r2, [pc, #96]	; (8000600 <EcInit+0xd0>)
 800059e:	490b      	ldr	r1, [pc, #44]	; (80005cc <EcInit+0x9c>)
 80005a0:	480b      	ldr	r0, [pc, #44]	; (80005d0 <EcInit+0xa0>)
 80005a2:	f006 fb7b 	bl	8006c9c <eddsaGenerateKeyPair>
	eddsaGenerateKeyPair(&yarrowPrngAlgo, &contextYarrow, &ed448Curve, &edPrivateKeys[1], &edPublicKeys[1]);
 80005a6:	4b17      	ldr	r3, [pc, #92]	; (8000604 <EcInit+0xd4>)
 80005a8:	9300      	str	r3, [sp, #0]
 80005aa:	4b17      	ldr	r3, [pc, #92]	; (8000608 <EcInit+0xd8>)
 80005ac:	4a17      	ldr	r2, [pc, #92]	; (800060c <EcInit+0xdc>)
 80005ae:	4907      	ldr	r1, [pc, #28]	; (80005cc <EcInit+0x9c>)
 80005b0:	4807      	ldr	r0, [pc, #28]	; (80005d0 <EcInit+0xa0>)
 80005b2:	f006 fb73 	bl	8006c9c <eddsaGenerateKeyPair>

}
 80005b6:	bf00      	nop
 80005b8:	46bd      	mov	sp, r7
 80005ba:	bd80      	pop	{r7, pc}
 80005bc:	2000049c 	.word	0x2000049c
 80005c0:	0800e8a4 	.word	0x0800e8a4
 80005c4:	20000430 	.word	0x20000430
 80005c8:	20000400 	.word	0x20000400
 80005cc:	200000d0 	.word	0x200000d0
 80005d0:	0801069c 	.word	0x0801069c
 80005d4:	20000500 	.word	0x20000500
 80005d8:	0800ea68 	.word	0x0800ea68
 80005dc:	20000454 	.word	0x20000454
 80005e0:	20000410 	.word	0x20000410
 80005e4:	20000564 	.word	0x20000564
 80005e8:	0800ec2c 	.word	0x0800ec2c
 80005ec:	20000478 	.word	0x20000478
 80005f0:	20000420 	.word	0x20000420
 80005f4:	200005c8 	.word	0x200005c8
 80005f8:	20000648 	.word	0x20000648
 80005fc:	20000610 	.word	0x20000610
 8000600:	0800edf0 	.word	0x0800edf0
 8000604:	20000654 	.word	0x20000654
 8000608:	2000062c 	.word	0x2000062c
 800060c:	0800efb4 	.word	0x0800efb4

08000610 <EdDSA>:

void EdDSA(void)
{
 8000610:	b580      	push	{r7, lr}
 8000612:	b084      	sub	sp, #16
 8000614:	af04      	add	r7, sp, #16
	RsaCleanSig();
 8000616:	f000 f887 	bl	8000728 <RsaCleanSig>

	PrintInfo("EdDSA25519", 1024, 25519, NULL);
 800061a:	2300      	movs	r3, #0
 800061c:	f246 32af 	movw	r2, #25519	; 0x63af
 8000620:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000624:	4836      	ldr	r0, [pc, #216]	; (8000700 <EdDSA+0xf0>)
 8000626:	f00b fa07 	bl	800ba38 <PrintInfo>
	HAL_TIM_Base_Start(&htim2);
 800062a:	4836      	ldr	r0, [pc, #216]	; (8000704 <EdDSA+0xf4>)
 800062c:	f00d f828 	bl	800d680 <HAL_TIM_Base_Start>
	ed25519GenerateSignature(&edPrivateKeys[0], &edPublicKeys[0], input1024, 1024, NULL, 0, 0, &Ed25519sig);
 8000630:	4b35      	ldr	r3, [pc, #212]	; (8000708 <EdDSA+0xf8>)
 8000632:	9303      	str	r3, [sp, #12]
 8000634:	2300      	movs	r3, #0
 8000636:	9302      	str	r3, [sp, #8]
 8000638:	2300      	movs	r3, #0
 800063a:	9301      	str	r3, [sp, #4]
 800063c:	2300      	movs	r3, #0
 800063e:	9300      	str	r3, [sp, #0]
 8000640:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000644:	4a31      	ldr	r2, [pc, #196]	; (800070c <EdDSA+0xfc>)
 8000646:	4932      	ldr	r1, [pc, #200]	; (8000710 <EdDSA+0x100>)
 8000648:	4832      	ldr	r0, [pc, #200]	; (8000714 <EdDSA+0x104>)
 800064a:	f004 f9ab 	bl	80049a4 <ed25519GenerateSignature>
	HAL_TIM_Base_Stop(&htim2);
 800064e:	482d      	ldr	r0, [pc, #180]	; (8000704 <EdDSA+0xf4>)
 8000650:	f00d f87e 	bl	800d750 <HAL_TIM_Base_Stop>
	PrintTime(&htim2);
 8000654:	482b      	ldr	r0, [pc, #172]	; (8000704 <EdDSA+0xf4>)
 8000656:	f00b fa71 	bl	800bb3c <PrintTime>

	HAL_TIM_Base_Start(&htim2);
 800065a:	482a      	ldr	r0, [pc, #168]	; (8000704 <EdDSA+0xf4>)
 800065c:	f00d f810 	bl	800d680 <HAL_TIM_Base_Start>
	ed25519VerifySignature(&edPublicKeys[0], input1024, 1024, NULL, 0, 0, &Ed25519sig);
 8000660:	4b29      	ldr	r3, [pc, #164]	; (8000708 <EdDSA+0xf8>)
 8000662:	9302      	str	r3, [sp, #8]
 8000664:	2300      	movs	r3, #0
 8000666:	9301      	str	r3, [sp, #4]
 8000668:	2300      	movs	r3, #0
 800066a:	9300      	str	r3, [sp, #0]
 800066c:	2300      	movs	r3, #0
 800066e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000672:	4926      	ldr	r1, [pc, #152]	; (800070c <EdDSA+0xfc>)
 8000674:	4826      	ldr	r0, [pc, #152]	; (8000710 <EdDSA+0x100>)
 8000676:	f004 fb4f 	bl	8004d18 <ed25519VerifySignature>
	HAL_TIM_Base_Stop(&htim2);
 800067a:	4822      	ldr	r0, [pc, #136]	; (8000704 <EdDSA+0xf4>)
 800067c:	f00d f868 	bl	800d750 <HAL_TIM_Base_Stop>
	PrintTime(&htim2);
 8000680:	4820      	ldr	r0, [pc, #128]	; (8000704 <EdDSA+0xf4>)
 8000682:	f00b fa5b 	bl	800bb3c <PrintTime>

	RsaCleanSig();
 8000686:	f000 f84f 	bl	8000728 <RsaCleanSig>


	PrintInfo("EdDSA448", 1024, 448, NULL);
 800068a:	2300      	movs	r3, #0
 800068c:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 8000690:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000694:	4820      	ldr	r0, [pc, #128]	; (8000718 <EdDSA+0x108>)
 8000696:	f00b f9cf 	bl	800ba38 <PrintInfo>
	HAL_TIM_Base_Start(&htim2);
 800069a:	481a      	ldr	r0, [pc, #104]	; (8000704 <EdDSA+0xf4>)
 800069c:	f00c fff0 	bl	800d680 <HAL_TIM_Base_Start>
	ed448GenerateSignature(&edPrivateKeys[1], &edPublicKeys[1], input1024, 1024, NULL, 0, 0, &Ed488sig);
 80006a0:	4b1e      	ldr	r3, [pc, #120]	; (800071c <EdDSA+0x10c>)
 80006a2:	9303      	str	r3, [sp, #12]
 80006a4:	2300      	movs	r3, #0
 80006a6:	9302      	str	r3, [sp, #8]
 80006a8:	2300      	movs	r3, #0
 80006aa:	9301      	str	r3, [sp, #4]
 80006ac:	2300      	movs	r3, #0
 80006ae:	9300      	str	r3, [sp, #0]
 80006b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80006b4:	4a15      	ldr	r2, [pc, #84]	; (800070c <EdDSA+0xfc>)
 80006b6:	491a      	ldr	r1, [pc, #104]	; (8000720 <EdDSA+0x110>)
 80006b8:	481a      	ldr	r0, [pc, #104]	; (8000724 <EdDSA+0x114>)
 80006ba:	f005 f9d1 	bl	8005a60 <ed448GenerateSignature>
	HAL_TIM_Base_Stop(&htim2);
 80006be:	4811      	ldr	r0, [pc, #68]	; (8000704 <EdDSA+0xf4>)
 80006c0:	f00d f846 	bl	800d750 <HAL_TIM_Base_Stop>
	PrintTime(&htim2);
 80006c4:	480f      	ldr	r0, [pc, #60]	; (8000704 <EdDSA+0xf4>)
 80006c6:	f00b fa39 	bl	800bb3c <PrintTime>

	HAL_TIM_Base_Start(&htim2);
 80006ca:	480e      	ldr	r0, [pc, #56]	; (8000704 <EdDSA+0xf4>)
 80006cc:	f00c ffd8 	bl	800d680 <HAL_TIM_Base_Start>
	ed448VerifySignature(&edPublicKeys[1], input1024, 1024, NULL, 0, 0, &Ed488sig);
 80006d0:	4b12      	ldr	r3, [pc, #72]	; (800071c <EdDSA+0x10c>)
 80006d2:	9302      	str	r3, [sp, #8]
 80006d4:	2300      	movs	r3, #0
 80006d6:	9301      	str	r3, [sp, #4]
 80006d8:	2300      	movs	r3, #0
 80006da:	9300      	str	r3, [sp, #0]
 80006dc:	2300      	movs	r3, #0
 80006de:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80006e2:	490a      	ldr	r1, [pc, #40]	; (800070c <EdDSA+0xfc>)
 80006e4:	480e      	ldr	r0, [pc, #56]	; (8000720 <EdDSA+0x110>)
 80006e6:	f005 fb79 	bl	8005ddc <ed448VerifySignature>
	HAL_TIM_Base_Stop(&htim2);
 80006ea:	4806      	ldr	r0, [pc, #24]	; (8000704 <EdDSA+0xf4>)
 80006ec:	f00d f830 	bl	800d750 <HAL_TIM_Base_Stop>
	PrintTime(&htim2);
 80006f0:	4804      	ldr	r0, [pc, #16]	; (8000704 <EdDSA+0xf4>)
 80006f2:	f00b fa23 	bl	800bb3c <PrintTime>

	RsaCleanSig();
 80006f6:	f000 f817 	bl	8000728 <RsaCleanSig>
}
 80006fa:	bf00      	nop
 80006fc:	46bd      	mov	sp, r7
 80006fe:	bd80      	pop	{r7, pc}
 8000700:	0800e788 	.word	0x0800e788
 8000704:	2000171c 	.word	0x2000171c
 8000708:	20000660 	.word	0x20000660
 800070c:	0801025c 	.word	0x0801025c
 8000710:	20000648 	.word	0x20000648
 8000714:	20000610 	.word	0x20000610
 8000718:	0800e794 	.word	0x0800e794
 800071c:	200006a0 	.word	0x200006a0
 8000720:	20000654 	.word	0x20000654
 8000724:	2000062c 	.word	0x2000062c

08000728 <RsaCleanSig>:

	}
}

void RsaCleanSig(void)
{
 8000728:	b580      	push	{r7, lr}
 800072a:	b082      	sub	sp, #8
 800072c:	af00      	add	r7, sp, #0
	memset(sig, 0, sizeof(sig));
 800072e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000732:	2100      	movs	r1, #0
 8000734:	480e      	ldr	r0, [pc, #56]	; (8000770 <RsaCleanSig+0x48>)
 8000736:	f00d fed5 	bl	800e4e4 <memset>
	sigLen = 0;
 800073a:	4b0e      	ldr	r3, [pc, #56]	; (8000774 <RsaCleanSig+0x4c>)
 800073c:	2200      	movs	r2, #0
 800073e:	601a      	str	r2, [r3, #0]

	for (uint8_t i = 0; i < 3; i++){
 8000740:	2300      	movs	r3, #0
 8000742:	71fb      	strb	r3, [r7, #7]
 8000744:	e00c      	b.n	8000760 <RsaCleanSig+0x38>
		ecdsaFreeSignature(&ecdsaSig[i]);
 8000746:	79fa      	ldrb	r2, [r7, #7]
 8000748:	4613      	mov	r3, r2
 800074a:	005b      	lsls	r3, r3, #1
 800074c:	4413      	add	r3, r2
 800074e:	00db      	lsls	r3, r3, #3
 8000750:	4a09      	ldr	r2, [pc, #36]	; (8000778 <RsaCleanSig+0x50>)
 8000752:	4413      	add	r3, r2
 8000754:	4618      	mov	r0, r3
 8000756:	f004 f896 	bl	8004886 <ecdsaFreeSignature>
	for (uint8_t i = 0; i < 3; i++){
 800075a:	79fb      	ldrb	r3, [r7, #7]
 800075c:	3301      	adds	r3, #1
 800075e:	71fb      	strb	r3, [r7, #7]
 8000760:	79fb      	ldrb	r3, [r7, #7]
 8000762:	2b02      	cmp	r3, #2
 8000764:	d9ef      	bls.n	8000746 <RsaCleanSig+0x1e>
	}
}
 8000766:	bf00      	nop
 8000768:	bf00      	nop
 800076a:	3708      	adds	r7, #8
 800076c:	46bd      	mov	sp, r7
 800076e:	bd80      	pop	{r7, pc}
 8000770:	20000714 	.word	0x20000714
 8000774:	20001714 	.word	0x20001714
 8000778:	200005c8 	.word	0x200005c8

0800077c <RngInit>:
	mpiImport(&rsaPublicKeys[3].n, n4, sizeof(n4), MPI_FORMAT_BIG_ENDIAN);
	mpiImport(&rsaPublicKeys[3].e, e, sizeof(e), MPI_FORMAT_BIG_ENDIAN);
}

void RngInit(void)
{
 800077c:	b580      	push	{r7, lr}
 800077e:	af00      	add	r7, sp, #0
	yarrowInit(&contextYarrow);
 8000780:	4804      	ldr	r0, [pc, #16]	; (8000794 <RngInit+0x18>)
 8000782:	f00b fb81 	bl	800be88 <yarrowInit>
	yarrowSeed(&contextYarrow, seed, sizeof(seed));
 8000786:	2240      	movs	r2, #64	; 0x40
 8000788:	4903      	ldr	r1, [pc, #12]	; (8000798 <RngInit+0x1c>)
 800078a:	4802      	ldr	r0, [pc, #8]	; (8000794 <RngInit+0x18>)
 800078c:	f00b fba1 	bl	800bed2 <yarrowSeed>
}
 8000790:	bf00      	nop
 8000792:	bd80      	pop	{r7, pc}
 8000794:	200000d0 	.word	0x200000d0
 8000798:	20000000 	.word	0x20000000

0800079c <curve25519SetInt>:
 * @param[out] a Pointer to the integer to be initialized
 * @param[in] b Initial value
 **/

void curve25519SetInt(uint32_t *a, uint32_t b)
{
 800079c:	b480      	push	{r7}
 800079e:	b085      	sub	sp, #20
 80007a0:	af00      	add	r7, sp, #0
 80007a2:	6078      	str	r0, [r7, #4]
 80007a4:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Set the value of the least significant word
   a[0] = b;
 80007a6:	687b      	ldr	r3, [r7, #4]
 80007a8:	683a      	ldr	r2, [r7, #0]
 80007aa:	601a      	str	r2, [r3, #0]

   //Initialize the rest of the integer
   for(i = 1; i < 8; i++)
 80007ac:	2301      	movs	r3, #1
 80007ae:	60fb      	str	r3, [r7, #12]
 80007b0:	e008      	b.n	80007c4 <curve25519SetInt+0x28>
   {
      a[i] = 0;
 80007b2:	68fb      	ldr	r3, [r7, #12]
 80007b4:	009b      	lsls	r3, r3, #2
 80007b6:	687a      	ldr	r2, [r7, #4]
 80007b8:	4413      	add	r3, r2
 80007ba:	2200      	movs	r2, #0
 80007bc:	601a      	str	r2, [r3, #0]
   for(i = 1; i < 8; i++)
 80007be:	68fb      	ldr	r3, [r7, #12]
 80007c0:	3301      	adds	r3, #1
 80007c2:	60fb      	str	r3, [r7, #12]
 80007c4:	68fb      	ldr	r3, [r7, #12]
 80007c6:	2b07      	cmp	r3, #7
 80007c8:	d9f3      	bls.n	80007b2 <curve25519SetInt+0x16>
   }
}
 80007ca:	bf00      	nop
 80007cc:	bf00      	nop
 80007ce:	3714      	adds	r7, #20
 80007d0:	46bd      	mov	sp, r7
 80007d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007d6:	4770      	bx	lr

080007d8 <curve25519Add>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

void curve25519Add(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 80007d8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80007dc:	b08a      	sub	sp, #40	; 0x28
 80007de:	af00      	add	r7, sp, #0
 80007e0:	6178      	str	r0, [r7, #20]
 80007e2:	6139      	str	r1, [r7, #16]
 80007e4:	60fa      	str	r2, [r7, #12]
   uint_t i;
   uint64_t temp;

   //Compute R = A + B
   for(temp = 0, i = 0; i < 8; i++)
 80007e6:	f04f 0200 	mov.w	r2, #0
 80007ea:	f04f 0300 	mov.w	r3, #0
 80007ee:	e9c7 2306 	strd	r2, r3, [r7, #24]
 80007f2:	2300      	movs	r3, #0
 80007f4:	627b      	str	r3, [r7, #36]	; 0x24
 80007f6:	e036      	b.n	8000866 <curve25519Add+0x8e>
   {
      temp += a[i];
 80007f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80007fa:	009b      	lsls	r3, r3, #2
 80007fc:	693a      	ldr	r2, [r7, #16]
 80007fe:	4413      	add	r3, r2
 8000800:	681b      	ldr	r3, [r3, #0]
 8000802:	2200      	movs	r2, #0
 8000804:	461c      	mov	r4, r3
 8000806:	4615      	mov	r5, r2
 8000808:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800080c:	eb12 0a04 	adds.w	sl, r2, r4
 8000810:	eb43 0b05 	adc.w	fp, r3, r5
 8000814:	e9c7 ab06 	strd	sl, fp, [r7, #24]
      temp += b[i];
 8000818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800081a:	009b      	lsls	r3, r3, #2
 800081c:	68fa      	ldr	r2, [r7, #12]
 800081e:	4413      	add	r3, r2
 8000820:	681b      	ldr	r3, [r3, #0]
 8000822:	2200      	movs	r2, #0
 8000824:	4698      	mov	r8, r3
 8000826:	4691      	mov	r9, r2
 8000828:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800082c:	eb12 0108 	adds.w	r1, r2, r8
 8000830:	6039      	str	r1, [r7, #0]
 8000832:	eb43 0309 	adc.w	r3, r3, r9
 8000836:	607b      	str	r3, [r7, #4]
 8000838:	e9d7 2300 	ldrd	r2, r3, [r7]
 800083c:	e9c7 2306 	strd	r2, r3, [r7, #24]
      r[i] = temp & 0xFFFFFFFF;
 8000840:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000842:	009b      	lsls	r3, r3, #2
 8000844:	697a      	ldr	r2, [r7, #20]
 8000846:	4413      	add	r3, r2
 8000848:	69ba      	ldr	r2, [r7, #24]
 800084a:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 800084c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8000850:	f04f 0200 	mov.w	r2, #0
 8000854:	f04f 0300 	mov.w	r3, #0
 8000858:	000a      	movs	r2, r1
 800085a:	2300      	movs	r3, #0
 800085c:	e9c7 2306 	strd	r2, r3, [r7, #24]
   for(temp = 0, i = 0; i < 8; i++)
 8000860:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000862:	3301      	adds	r3, #1
 8000864:	627b      	str	r3, [r7, #36]	; 0x24
 8000866:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000868:	2b07      	cmp	r3, #7
 800086a:	d9c5      	bls.n	80007f8 <curve25519Add+0x20>
   }

   //Perform modular reduction
   curve25519Red(r, r);
 800086c:	6979      	ldr	r1, [r7, #20]
 800086e:	6978      	ldr	r0, [r7, #20]
 8000870:	f000 fb85 	bl	8000f7e <curve25519Red>
}
 8000874:	bf00      	nop
 8000876:	3728      	adds	r7, #40	; 0x28
 8000878:	46bd      	mov	sp, r7
 800087a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800087e <curve25519AddInt>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < (2^32 - 1)
 **/

void curve25519AddInt(uint32_t *r, const uint32_t *a, uint32_t b)
{
 800087e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8000882:	b088      	sub	sp, #32
 8000884:	af00      	add	r7, sp, #0
 8000886:	60f8      	str	r0, [r7, #12]
 8000888:	60b9      	str	r1, [r7, #8]
 800088a:	607a      	str	r2, [r7, #4]
   uint_t i;
   uint64_t temp;

   //Compute R = A + B
   for(temp = b, i = 0; i < 8; i++)
 800088c:	687b      	ldr	r3, [r7, #4]
 800088e:	2200      	movs	r2, #0
 8000890:	469a      	mov	sl, r3
 8000892:	4693      	mov	fp, r2
 8000894:	e9c7 ab04 	strd	sl, fp, [r7, #16]
 8000898:	2300      	movs	r3, #0
 800089a:	61fb      	str	r3, [r7, #28]
 800089c:	e022      	b.n	80008e4 <curve25519AddInt+0x66>
   {
      temp += a[i];
 800089e:	69fb      	ldr	r3, [r7, #28]
 80008a0:	009b      	lsls	r3, r3, #2
 80008a2:	68ba      	ldr	r2, [r7, #8]
 80008a4:	4413      	add	r3, r2
 80008a6:	681b      	ldr	r3, [r3, #0]
 80008a8:	2200      	movs	r2, #0
 80008aa:	461c      	mov	r4, r3
 80008ac:	4615      	mov	r5, r2
 80008ae:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80008b2:	eb12 0804 	adds.w	r8, r2, r4
 80008b6:	eb43 0905 	adc.w	r9, r3, r5
 80008ba:	e9c7 8904 	strd	r8, r9, [r7, #16]
      r[i] = temp & 0xFFFFFFFF;
 80008be:	69fb      	ldr	r3, [r7, #28]
 80008c0:	009b      	lsls	r3, r3, #2
 80008c2:	68fa      	ldr	r2, [r7, #12]
 80008c4:	4413      	add	r3, r2
 80008c6:	693a      	ldr	r2, [r7, #16]
 80008c8:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 80008ca:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80008ce:	f04f 0200 	mov.w	r2, #0
 80008d2:	f04f 0300 	mov.w	r3, #0
 80008d6:	000a      	movs	r2, r1
 80008d8:	2300      	movs	r3, #0
 80008da:	e9c7 2304 	strd	r2, r3, [r7, #16]
   for(temp = b, i = 0; i < 8; i++)
 80008de:	69fb      	ldr	r3, [r7, #28]
 80008e0:	3301      	adds	r3, #1
 80008e2:	61fb      	str	r3, [r7, #28]
 80008e4:	69fb      	ldr	r3, [r7, #28]
 80008e6:	2b07      	cmp	r3, #7
 80008e8:	d9d9      	bls.n	800089e <curve25519AddInt+0x20>
   }

   //Perform modular reduction
   curve25519Red(r, r);
 80008ea:	68f9      	ldr	r1, [r7, #12]
 80008ec:	68f8      	ldr	r0, [r7, #12]
 80008ee:	f000 fb46 	bl	8000f7e <curve25519Red>
}
 80008f2:	bf00      	nop
 80008f4:	3720      	adds	r7, #32
 80008f6:	46bd      	mov	sp, r7
 80008f8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080008fc <curve25519Sub>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

void curve25519Sub(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 80008fc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8000900:	b08a      	sub	sp, #40	; 0x28
 8000902:	af00      	add	r7, sp, #0
 8000904:	6178      	str	r0, [r7, #20]
 8000906:	6139      	str	r1, [r7, #16]
 8000908:	60fa      	str	r2, [r7, #12]
   uint_t i;
   int64_t temp;

   //Compute R = A - 19 - B
   for(temp = -19, i = 0; i < 8; i++)
 800090a:	f06f 0212 	mvn.w	r2, #18
 800090e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000912:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8000916:	2300      	movs	r3, #0
 8000918:	627b      	str	r3, [r7, #36]	; 0x24
 800091a:	e036      	b.n	800098a <curve25519Sub+0x8e>
   {
      temp += a[i];
 800091c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800091e:	009b      	lsls	r3, r3, #2
 8000920:	693a      	ldr	r2, [r7, #16]
 8000922:	4413      	add	r3, r2
 8000924:	681b      	ldr	r3, [r3, #0]
 8000926:	2200      	movs	r2, #0
 8000928:	461c      	mov	r4, r3
 800092a:	4615      	mov	r5, r2
 800092c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8000930:	eb12 0a04 	adds.w	sl, r2, r4
 8000934:	eb43 0b05 	adc.w	fp, r3, r5
 8000938:	e9c7 ab06 	strd	sl, fp, [r7, #24]
      temp -= b[i];
 800093c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800093e:	009b      	lsls	r3, r3, #2
 8000940:	68fa      	ldr	r2, [r7, #12]
 8000942:	4413      	add	r3, r2
 8000944:	681b      	ldr	r3, [r3, #0]
 8000946:	2200      	movs	r2, #0
 8000948:	4698      	mov	r8, r3
 800094a:	4691      	mov	r9, r2
 800094c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8000950:	ebb2 0108 	subs.w	r1, r2, r8
 8000954:	6039      	str	r1, [r7, #0]
 8000956:	eb63 0309 	sbc.w	r3, r3, r9
 800095a:	607b      	str	r3, [r7, #4]
 800095c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8000960:	e9c7 2306 	strd	r2, r3, [r7, #24]
      r[i] = temp & 0xFFFFFFFF;
 8000964:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000966:	009b      	lsls	r3, r3, #2
 8000968:	697a      	ldr	r2, [r7, #20]
 800096a:	4413      	add	r3, r2
 800096c:	69ba      	ldr	r2, [r7, #24]
 800096e:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 8000970:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8000974:	f04f 0200 	mov.w	r2, #0
 8000978:	f04f 0300 	mov.w	r3, #0
 800097c:	000a      	movs	r2, r1
 800097e:	17cb      	asrs	r3, r1, #31
 8000980:	e9c7 2306 	strd	r2, r3, [r7, #24]
   for(temp = -19, i = 0; i < 8; i++)
 8000984:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000986:	3301      	adds	r3, #1
 8000988:	627b      	str	r3, [r7, #36]	; 0x24
 800098a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800098c:	2b07      	cmp	r3, #7
 800098e:	d9c5      	bls.n	800091c <curve25519Sub+0x20>
   }

   //Compute R = A + (2^255 - 19) - B
   r[7] += 0x80000000;
 8000990:	697b      	ldr	r3, [r7, #20]
 8000992:	331c      	adds	r3, #28
 8000994:	681a      	ldr	r2, [r3, #0]
 8000996:	697b      	ldr	r3, [r7, #20]
 8000998:	331c      	adds	r3, #28
 800099a:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 800099e:	601a      	str	r2, [r3, #0]

   //Perform modular reduction
   curve25519Red(r, r);
 80009a0:	6979      	ldr	r1, [r7, #20]
 80009a2:	6978      	ldr	r0, [r7, #20]
 80009a4:	f000 faeb 	bl	8000f7e <curve25519Red>
}
 80009a8:	bf00      	nop
 80009aa:	3728      	adds	r7, #40	; 0x28
 80009ac:	46bd      	mov	sp, r7
 80009ae:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080009b2 <curve25519SubInt>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < (2^32 - 1)
 **/

void curve25519SubInt(uint32_t *r, const uint32_t *a, uint32_t b)
{
 80009b2:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80009b6:	b08a      	sub	sp, #40	; 0x28
 80009b8:	af00      	add	r7, sp, #0
 80009ba:	6178      	str	r0, [r7, #20]
 80009bc:	6139      	str	r1, [r7, #16]
 80009be:	60fa      	str	r2, [r7, #12]
   uint_t i;
   int64_t temp;

   //Set initial value
   temp = -19;
 80009c0:	f06f 0212 	mvn.w	r2, #18
 80009c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80009c8:	e9c7 2306 	strd	r2, r3, [r7, #24]
   temp -= b;
 80009cc:	68fb      	ldr	r3, [r7, #12]
 80009ce:	2200      	movs	r2, #0
 80009d0:	4698      	mov	r8, r3
 80009d2:	4691      	mov	r9, r2
 80009d4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80009d8:	ebb2 0108 	subs.w	r1, r2, r8
 80009dc:	6039      	str	r1, [r7, #0]
 80009de:	eb63 0309 	sbc.w	r3, r3, r9
 80009e2:	607b      	str	r3, [r7, #4]
 80009e4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80009e8:	e9c7 2306 	strd	r2, r3, [r7, #24]

   //Compute R = A - 19 - B
   for(i = 0; i < 8; i++)
 80009ec:	2300      	movs	r3, #0
 80009ee:	627b      	str	r3, [r7, #36]	; 0x24
 80009f0:	e022      	b.n	8000a38 <curve25519SubInt+0x86>
   {
      temp += a[i];
 80009f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80009f4:	009b      	lsls	r3, r3, #2
 80009f6:	693a      	ldr	r2, [r7, #16]
 80009f8:	4413      	add	r3, r2
 80009fa:	681b      	ldr	r3, [r3, #0]
 80009fc:	2200      	movs	r2, #0
 80009fe:	461c      	mov	r4, r3
 8000a00:	4615      	mov	r5, r2
 8000a02:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8000a06:	eb12 0a04 	adds.w	sl, r2, r4
 8000a0a:	eb43 0b05 	adc.w	fp, r3, r5
 8000a0e:	e9c7 ab06 	strd	sl, fp, [r7, #24]
      r[i] = temp & 0xFFFFFFFF;
 8000a12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a14:	009b      	lsls	r3, r3, #2
 8000a16:	697a      	ldr	r2, [r7, #20]
 8000a18:	4413      	add	r3, r2
 8000a1a:	69ba      	ldr	r2, [r7, #24]
 8000a1c:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 8000a1e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8000a22:	f04f 0200 	mov.w	r2, #0
 8000a26:	f04f 0300 	mov.w	r3, #0
 8000a2a:	000a      	movs	r2, r1
 8000a2c:	17cb      	asrs	r3, r1, #31
 8000a2e:	e9c7 2306 	strd	r2, r3, [r7, #24]
   for(i = 0; i < 8; i++)
 8000a32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a34:	3301      	adds	r3, #1
 8000a36:	627b      	str	r3, [r7, #36]	; 0x24
 8000a38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a3a:	2b07      	cmp	r3, #7
 8000a3c:	d9d9      	bls.n	80009f2 <curve25519SubInt+0x40>
   }

   //Compute R = A + (2^255 - 19) - B
   r[7] += 0x80000000;
 8000a3e:	697b      	ldr	r3, [r7, #20]
 8000a40:	331c      	adds	r3, #28
 8000a42:	681a      	ldr	r2, [r3, #0]
 8000a44:	697b      	ldr	r3, [r7, #20]
 8000a46:	331c      	adds	r3, #28
 8000a48:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 8000a4c:	601a      	str	r2, [r3, #0]

   //Perform modular reduction
   curve25519Red(r, r);
 8000a4e:	6979      	ldr	r1, [r7, #20]
 8000a50:	6978      	ldr	r0, [r7, #20]
 8000a52:	f000 fa94 	bl	8000f7e <curve25519Red>
}
 8000a56:	bf00      	nop
 8000a58:	3728      	adds	r7, #40	; 0x28
 8000a5a:	46bd      	mov	sp, r7
 8000a5c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08000a60 <curve25519Mul>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

__weak_func void curve25519Mul(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 8000a60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000a64:	b0cd      	sub	sp, #308	; 0x134
 8000a66:	af00      	add	r7, sp, #0
 8000a68:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
 8000a6c:	f8c7 10d0 	str.w	r1, [r7, #208]	; 0xd0
 8000a70:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
   uint64_t c;
   uint64_t temp;
   uint32_t u[16];

   //Initialize variables
   temp = 0;
 8000a74:	f04f 0200 	mov.w	r2, #0
 8000a78:	f04f 0300 	mov.w	r3, #0
 8000a7c:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
   c = 0;
 8000a80:	f04f 0200 	mov.w	r2, #0
 8000a84:	f04f 0300 	mov.w	r3, #0
 8000a88:	e9c7 2348 	strd	r2, r3, [r7, #288]	; 0x120

   //Comba's method is used to perform multiplication
   for(i = 0; i < 16; i++)
 8000a8c:	2300      	movs	r3, #0
 8000a8e:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000a92:	e10b      	b.n	8000cac <curve25519Mul+0x24c>
   {
      //The algorithm computes the products, column by column
      if(i < 8)
 8000a94:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000a98:	2b07      	cmp	r3, #7
 8000a9a:	d872      	bhi.n	8000b82 <curve25519Mul+0x122>
      {
         //Inner loop
         for(j = 0; j <= i; j++)
 8000a9c:	2300      	movs	r3, #0
 8000a9e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8000aa2:	e067      	b.n	8000b74 <curve25519Mul+0x114>
         {
            temp += (uint64_t) a[j] * b[i - j];
 8000aa4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000aa8:	009a      	lsls	r2, r3, #2
 8000aaa:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8000aae:	4413      	add	r3, r2
 8000ab0:	681b      	ldr	r3, [r3, #0]
 8000ab2:	2200      	movs	r2, #0
 8000ab4:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8000ab8:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
 8000abc:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8000ac0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000ac4:	1ad3      	subs	r3, r2, r3
 8000ac6:	009a      	lsls	r2, r3, #2
 8000ac8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8000acc:	4413      	add	r3, r2
 8000ace:	681b      	ldr	r3, [r3, #0]
 8000ad0:	2200      	movs	r2, #0
 8000ad2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8000ad6:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
 8000ada:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	; 0xa8
 8000ade:	460b      	mov	r3, r1
 8000ae0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8000ae4:	fb02 f203 	mul.w	r2, r2, r3
 8000ae8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8000aec:	e9c7 012a 	strd	r0, r1, [r7, #168]	; 0xa8
 8000af0:	4601      	mov	r1, r0
 8000af2:	fb01 f303 	mul.w	r3, r1, r3
 8000af6:	4413      	add	r3, r2
 8000af8:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8000afc:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8000b00:	fba2 1201 	umull	r1, r2, r2, r1
 8000b04:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 8000b08:	460a      	mov	r2, r1
 8000b0a:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 8000b0e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8000b12:	4413      	add	r3, r2
 8000b14:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8000b18:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000b1c:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8000b20:	1851      	adds	r1, r2, r1
 8000b22:	66b9      	str	r1, [r7, #104]	; 0x68
 8000b24:	f8d7 10c4 	ldr.w	r1, [r7, #196]	; 0xc4
 8000b28:	414b      	adcs	r3, r1
 8000b2a:	66fb      	str	r3, [r7, #108]	; 0x6c
 8000b2c:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
 8000b30:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
            c += temp >> 32;
 8000b34:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000b38:	f04f 0000 	mov.w	r0, #0
 8000b3c:	f04f 0100 	mov.w	r1, #0
 8000b40:	0018      	movs	r0, r3
 8000b42:	2100      	movs	r1, #0
 8000b44:	e9d7 2348 	ldrd	r2, r3, [r7, #288]	; 0x120
 8000b48:	1816      	adds	r6, r2, r0
 8000b4a:	663e      	str	r6, [r7, #96]	; 0x60
 8000b4c:	414b      	adcs	r3, r1
 8000b4e:	667b      	str	r3, [r7, #100]	; 0x64
 8000b50:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 8000b54:	e9c7 2348 	strd	r2, r3, [r7, #288]	; 0x120
            temp &= 0xFFFFFFFF;
 8000b58:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000b5c:	65ba      	str	r2, [r7, #88]	; 0x58
 8000b5e:	2300      	movs	r3, #0
 8000b60:	65fb      	str	r3, [r7, #92]	; 0x5c
 8000b62:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 8000b66:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
         for(j = 0; j <= i; j++)
 8000b6a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000b6e:	3301      	adds	r3, #1
 8000b70:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8000b74:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8000b78:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000b7c:	429a      	cmp	r2, r3
 8000b7e:	d991      	bls.n	8000aa4 <curve25519Mul+0x44>
 8000b80:	e071      	b.n	8000c66 <curve25519Mul+0x206>
         }
      }
      else
      {
         //Inner loop
         for(j = i - 7; j < 8; j++)
 8000b82:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000b86:	3b07      	subs	r3, #7
 8000b88:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8000b8c:	e067      	b.n	8000c5e <curve25519Mul+0x1fe>
         {
            temp += (uint64_t) a[j] * b[i - j];
 8000b8e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000b92:	009a      	lsls	r2, r3, #2
 8000b94:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8000b98:	4413      	add	r3, r2
 8000b9a:	681b      	ldr	r3, [r3, #0]
 8000b9c:	2200      	movs	r2, #0
 8000b9e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8000ba2:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
 8000ba6:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8000baa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000bae:	1ad3      	subs	r3, r2, r3
 8000bb0:	009a      	lsls	r2, r3, #2
 8000bb2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8000bb6:	4413      	add	r3, r2
 8000bb8:	681b      	ldr	r3, [r3, #0]
 8000bba:	2200      	movs	r2, #0
 8000bbc:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8000bc0:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
 8000bc4:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 8000bc8:	460b      	mov	r3, r1
 8000bca:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8000bce:	fb02 f203 	mul.w	r2, r2, r3
 8000bd2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8000bd6:	e9c7 0126 	strd	r0, r1, [r7, #152]	; 0x98
 8000bda:	4601      	mov	r1, r0
 8000bdc:	fb01 f303 	mul.w	r3, r1, r3
 8000be0:	4413      	add	r3, r2
 8000be2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8000be6:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 8000bea:	fba2 1201 	umull	r1, r2, r2, r1
 8000bee:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
 8000bf2:	460a      	mov	r2, r1
 8000bf4:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
 8000bf8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8000bfc:	4413      	add	r3, r2
 8000bfe:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8000c02:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000c06:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8000c0a:	1851      	adds	r1, r2, r1
 8000c0c:	6539      	str	r1, [r7, #80]	; 0x50
 8000c0e:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 8000c12:	414b      	adcs	r3, r1
 8000c14:	657b      	str	r3, [r7, #84]	; 0x54
 8000c16:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 8000c1a:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
            c += temp >> 32;
 8000c1e:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000c22:	f04f 0000 	mov.w	r0, #0
 8000c26:	f04f 0100 	mov.w	r1, #0
 8000c2a:	0018      	movs	r0, r3
 8000c2c:	2100      	movs	r1, #0
 8000c2e:	e9d7 2348 	ldrd	r2, r3, [r7, #288]	; 0x120
 8000c32:	1816      	adds	r6, r2, r0
 8000c34:	64be      	str	r6, [r7, #72]	; 0x48
 8000c36:	414b      	adcs	r3, r1
 8000c38:	64fb      	str	r3, [r7, #76]	; 0x4c
 8000c3a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8000c3e:	e9c7 2348 	strd	r2, r3, [r7, #288]	; 0x120
            temp &= 0xFFFFFFFF;
 8000c42:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000c46:	643a      	str	r2, [r7, #64]	; 0x40
 8000c48:	2300      	movs	r3, #0
 8000c4a:	647b      	str	r3, [r7, #68]	; 0x44
 8000c4c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8000c50:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
         for(j = i - 7; j < 8; j++)
 8000c54:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000c58:	3301      	adds	r3, #1
 8000c5a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8000c5e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8000c62:	2b07      	cmp	r3, #7
 8000c64:	d993      	bls.n	8000b8e <curve25519Mul+0x12e>
         }
      }

      //At the bottom of each column, the final result is written to memory
      u[i] = temp & 0xFFFFFFFF;
 8000c66:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8000c6a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000c6e:	009b      	lsls	r3, r3, #2
 8000c70:	3368      	adds	r3, #104	; 0x68
 8000c72:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 8000c76:	440b      	add	r3, r1
 8000c78:	f843 2c58 	str.w	r2, [r3, #-88]

      //Propagate the carry upwards
      temp = c & 0xFFFFFFFF;
 8000c7c:	e9d7 2348 	ldrd	r2, r3, [r7, #288]	; 0x120
 8000c80:	63ba      	str	r2, [r7, #56]	; 0x38
 8000c82:	2300      	movs	r3, #0
 8000c84:	63fb      	str	r3, [r7, #60]	; 0x3c
 8000c86:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 8000c8a:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
      c >>= 32;
 8000c8e:	e9d7 2348 	ldrd	r2, r3, [r7, #288]	; 0x120
 8000c92:	f04f 0000 	mov.w	r0, #0
 8000c96:	f04f 0100 	mov.w	r1, #0
 8000c9a:	0018      	movs	r0, r3
 8000c9c:	2100      	movs	r1, #0
 8000c9e:	e9c7 0148 	strd	r0, r1, [r7, #288]	; 0x120
   for(i = 0; i < 16; i++)
 8000ca2:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000ca6:	3301      	adds	r3, #1
 8000ca8:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000cac:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000cb0:	2b0f      	cmp	r3, #15
 8000cb2:	f67f aeef 	bls.w	8000a94 <curve25519Mul+0x34>
   }

   //Reduce bit 255 (2^255 = 19 mod p)
   temp = (u[7] >> 31) * 19;
 8000cb6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8000cba:	0fda      	lsrs	r2, r3, #31
 8000cbc:	4613      	mov	r3, r2
 8000cbe:	00db      	lsls	r3, r3, #3
 8000cc0:	4413      	add	r3, r2
 8000cc2:	005b      	lsls	r3, r3, #1
 8000cc4:	4413      	add	r3, r2
 8000cc6:	2200      	movs	r2, #0
 8000cc8:	633b      	str	r3, [r7, #48]	; 0x30
 8000cca:	637a      	str	r2, [r7, #52]	; 0x34
 8000ccc:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8000cd0:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
   //Mask the most significant bit
   u[7] &= 0x7FFFFFFF;
 8000cd4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8000cd8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8000cdc:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

   //Perform fast modular reduction (first pass)
   for(i = 0; i < 8; i++)
 8000ce0:	2300      	movs	r3, #0
 8000ce2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000ce6:	e085      	b.n	8000df4 <curve25519Mul+0x394>
   {
      temp += u[i];
 8000ce8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000cec:	009b      	lsls	r3, r3, #2
 8000cee:	3368      	adds	r3, #104	; 0x68
 8000cf0:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8000cf4:	4413      	add	r3, r2
 8000cf6:	f853 3c58 	ldr.w	r3, [r3, #-88]
 8000cfa:	2200      	movs	r2, #0
 8000cfc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8000d00:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 8000d04:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000d08:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8000d0c:	1851      	adds	r1, r2, r1
 8000d0e:	62b9      	str	r1, [r7, #40]	; 0x28
 8000d10:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8000d14:	414b      	adcs	r3, r1
 8000d16:	62fb      	str	r3, [r7, #44]	; 0x2c
 8000d18:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8000d1c:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
      temp += (uint64_t) u[i + 8] * 38;
 8000d20:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000d24:	3308      	adds	r3, #8
 8000d26:	009b      	lsls	r3, r3, #2
 8000d28:	3368      	adds	r3, #104	; 0x68
 8000d2a:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8000d2e:	4413      	add	r3, r2
 8000d30:	f853 3c58 	ldr.w	r3, [r3, #-88]
 8000d34:	2200      	movs	r2, #0
 8000d36:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8000d3a:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
 8000d3e:	e9d7 232c 	ldrd	r2, r3, [r7, #176]	; 0xb0
 8000d42:	f04f 0000 	mov.w	r0, #0
 8000d46:	f04f 0100 	mov.w	r1, #0
 8000d4a:	0099      	lsls	r1, r3, #2
 8000d4c:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8000d50:	0090      	lsls	r0, r2, #2
 8000d52:	4602      	mov	r2, r0
 8000d54:	460b      	mov	r3, r1
 8000d56:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8000d5a:	1854      	adds	r4, r2, r1
 8000d5c:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 8000d60:	eb43 0501 	adc.w	r5, r3, r1
 8000d64:	f04f 0200 	mov.w	r2, #0
 8000d68:	f04f 0300 	mov.w	r3, #0
 8000d6c:	00ab      	lsls	r3, r5, #2
 8000d6e:	ea43 7394 	orr.w	r3, r3, r4, lsr #30
 8000d72:	00a2      	lsls	r2, r4, #2
 8000d74:	4614      	mov	r4, r2
 8000d76:	461d      	mov	r5, r3
 8000d78:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
 8000d7c:	460b      	mov	r3, r1
 8000d7e:	1ae3      	subs	r3, r4, r3
 8000d80:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8000d84:	4613      	mov	r3, r2
 8000d86:	eb65 0303 	sbc.w	r3, r5, r3
 8000d8a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8000d8e:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
 8000d92:	460b      	mov	r3, r1
 8000d94:	18db      	adds	r3, r3, r3
 8000d96:	623b      	str	r3, [r7, #32]
 8000d98:	4613      	mov	r3, r2
 8000d9a:	eb42 0303 	adc.w	r3, r2, r3
 8000d9e:	627b      	str	r3, [r7, #36]	; 0x24
 8000da0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8000da4:	e9c7 2320 	strd	r2, r3, [r7, #128]	; 0x80
 8000da8:	4610      	mov	r0, r2
 8000daa:	4619      	mov	r1, r3
 8000dac:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000db0:	1816      	adds	r6, r2, r0
 8000db2:	61be      	str	r6, [r7, #24]
 8000db4:	414b      	adcs	r3, r1
 8000db6:	61fb      	str	r3, [r7, #28]
 8000db8:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8000dbc:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
      u[i] = temp & 0xFFFFFFFF;
 8000dc0:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8000dc4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000dc8:	009b      	lsls	r3, r3, #2
 8000dca:	3368      	adds	r3, #104	; 0x68
 8000dcc:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 8000dd0:	440b      	add	r3, r1
 8000dd2:	f843 2c58 	str.w	r2, [r3, #-88]
      temp >>= 32;
 8000dd6:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000dda:	f04f 0000 	mov.w	r0, #0
 8000dde:	f04f 0100 	mov.w	r1, #0
 8000de2:	0018      	movs	r0, r3
 8000de4:	2100      	movs	r1, #0
 8000de6:	e9c7 0146 	strd	r0, r1, [r7, #280]	; 0x118
   for(i = 0; i < 8; i++)
 8000dea:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000dee:	3301      	adds	r3, #1
 8000df0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000df4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000df8:	2b07      	cmp	r3, #7
 8000dfa:	f67f af75 	bls.w	8000ce8 <curve25519Mul+0x288>
   }

   //Reduce bit 256 (2^256 = 38 mod p)
   temp *= 38;
 8000dfe:	e9d7 4546 	ldrd	r4, r5, [r7, #280]	; 0x118
 8000e02:	4622      	mov	r2, r4
 8000e04:	462b      	mov	r3, r5
 8000e06:	f04f 0000 	mov.w	r0, #0
 8000e0a:	f04f 0100 	mov.w	r1, #0
 8000e0e:	0099      	lsls	r1, r3, #2
 8000e10:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8000e14:	0090      	lsls	r0, r2, #2
 8000e16:	4602      	mov	r2, r0
 8000e18:	460b      	mov	r3, r1
 8000e1a:	eb12 0a04 	adds.w	sl, r2, r4
 8000e1e:	eb43 0b05 	adc.w	fp, r3, r5
 8000e22:	f04f 0200 	mov.w	r2, #0
 8000e26:	f04f 0300 	mov.w	r3, #0
 8000e2a:	ea4f 038b 	mov.w	r3, fp, lsl #2
 8000e2e:	ea43 739a 	orr.w	r3, r3, sl, lsr #30
 8000e32:	ea4f 028a 	mov.w	r2, sl, lsl #2
 8000e36:	4692      	mov	sl, r2
 8000e38:	469b      	mov	fp, r3
 8000e3a:	ebba 0804 	subs.w	r8, sl, r4
 8000e3e:	eb6b 0905 	sbc.w	r9, fp, r5
 8000e42:	eb18 0308 	adds.w	r3, r8, r8
 8000e46:	613b      	str	r3, [r7, #16]
 8000e48:	eb49 0309 	adc.w	r3, r9, r9
 8000e4c:	617b      	str	r3, [r7, #20]
 8000e4e:	e9d7 8904 	ldrd	r8, r9, [r7, #16]
 8000e52:	e9c7 8946 	strd	r8, r9, [r7, #280]	; 0x118
   //Reduce bit 255 (2^255 = 19 mod p)
   temp += (u[7] >> 31) * 19;
 8000e56:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8000e5a:	0fda      	lsrs	r2, r3, #31
 8000e5c:	4613      	mov	r3, r2
 8000e5e:	00db      	lsls	r3, r3, #3
 8000e60:	4413      	add	r3, r2
 8000e62:	005b      	lsls	r3, r3, #1
 8000e64:	4413      	add	r3, r2
 8000e66:	2200      	movs	r2, #0
 8000e68:	67bb      	str	r3, [r7, #120]	; 0x78
 8000e6a:	67fa      	str	r2, [r7, #124]	; 0x7c
 8000e6c:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000e70:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	; 0x78
 8000e74:	4621      	mov	r1, r4
 8000e76:	1851      	adds	r1, r2, r1
 8000e78:	60b9      	str	r1, [r7, #8]
 8000e7a:	4629      	mov	r1, r5
 8000e7c:	eb43 0101 	adc.w	r1, r3, r1
 8000e80:	60f9      	str	r1, [r7, #12]
 8000e82:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8000e86:	e9c7 3446 	strd	r3, r4, [r7, #280]	; 0x118
   //Mask the most significant bit
   u[7] &= 0x7FFFFFFF;
 8000e8a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8000e8e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8000e92:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

   //Perform fast modular reduction (second pass)
   for(i = 0; i < 8; i++)
 8000e96:	2300      	movs	r3, #0
 8000e98:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000e9c:	e033      	b.n	8000f06 <curve25519Mul+0x4a6>
   {
      temp += u[i];
 8000e9e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000ea2:	009b      	lsls	r3, r3, #2
 8000ea4:	3368      	adds	r3, #104	; 0x68
 8000ea6:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8000eaa:	4413      	add	r3, r2
 8000eac:	f853 3c58 	ldr.w	r3, [r3, #-88]
 8000eb0:	2200      	movs	r2, #0
 8000eb2:	673b      	str	r3, [r7, #112]	; 0x70
 8000eb4:	677a      	str	r2, [r7, #116]	; 0x74
 8000eb6:	e9d7 2346 	ldrd	r2, r3, [r7, #280]	; 0x118
 8000eba:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	; 0x70
 8000ebe:	4621      	mov	r1, r4
 8000ec0:	1851      	adds	r1, r2, r1
 8000ec2:	6039      	str	r1, [r7, #0]
 8000ec4:	4629      	mov	r1, r5
 8000ec6:	414b      	adcs	r3, r1
 8000ec8:	607b      	str	r3, [r7, #4]
 8000eca:	e9d7 3400 	ldrd	r3, r4, [r7]
 8000ece:	e9c7 3446 	strd	r3, r4, [r7, #280]	; 0x118
      u[i] = temp & 0xFFFFFFFF;
 8000ed2:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8000ed6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000eda:	009b      	lsls	r3, r3, #2
 8000edc:	3368      	adds	r3, #104	; 0x68
 8000ede:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 8000ee2:	440b      	add	r3, r1
 8000ee4:	f843 2c58 	str.w	r2, [r3, #-88]
      temp >>= 32;
 8000ee8:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	; 0x118
 8000eec:	f04f 0200 	mov.w	r2, #0
 8000ef0:	f04f 0300 	mov.w	r3, #0
 8000ef4:	000a      	movs	r2, r1
 8000ef6:	2300      	movs	r3, #0
 8000ef8:	e9c7 2346 	strd	r2, r3, [r7, #280]	; 0x118
   for(i = 0; i < 8; i++)
 8000efc:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000f00:	3301      	adds	r3, #1
 8000f02:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8000f06:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8000f0a:	2b07      	cmp	r3, #7
 8000f0c:	d9c7      	bls.n	8000e9e <curve25519Mul+0x43e>
   }

   //Reduce non-canonical values
   curve25519Red(r, u);
 8000f0e:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8000f12:	4619      	mov	r1, r3
 8000f14:	f8d7 00d4 	ldr.w	r0, [r7, #212]	; 0xd4
 8000f18:	f000 f831 	bl	8000f7e <curve25519Red>
}
 8000f1c:	bf00      	nop
 8000f1e:	f507 779a 	add.w	r7, r7, #308	; 0x134
 8000f22:	46bd      	mov	sp, r7
 8000f24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000f28 <curve25519Sqr>:
 * @param[out] r Resulting integer R = (A ^ 2) mod p
 * @param[in] a An integer such as 0 <= A < p
 **/

__weak_func void curve25519Sqr(uint32_t *r, const uint32_t *a)
{
 8000f28:	b580      	push	{r7, lr}
 8000f2a:	b082      	sub	sp, #8
 8000f2c:	af00      	add	r7, sp, #0
 8000f2e:	6078      	str	r0, [r7, #4]
 8000f30:	6039      	str	r1, [r7, #0]
   //Compute R = (A ^ 2) mod p
   curve25519Mul(r, a, a);
 8000f32:	683a      	ldr	r2, [r7, #0]
 8000f34:	6839      	ldr	r1, [r7, #0]
 8000f36:	6878      	ldr	r0, [r7, #4]
 8000f38:	f7ff fd92 	bl	8000a60 <curve25519Mul>
}
 8000f3c:	bf00      	nop
 8000f3e:	3708      	adds	r7, #8
 8000f40:	46bd      	mov	sp, r7
 8000f42:	bd80      	pop	{r7, pc}

08000f44 <curve25519Pwr2>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] n An integer such as n >= 1
 **/

void curve25519Pwr2(uint32_t *r, const uint32_t *a, uint_t n)
{
 8000f44:	b580      	push	{r7, lr}
 8000f46:	b086      	sub	sp, #24
 8000f48:	af00      	add	r7, sp, #0
 8000f4a:	60f8      	str	r0, [r7, #12]
 8000f4c:	60b9      	str	r1, [r7, #8]
 8000f4e:	607a      	str	r2, [r7, #4]
   uint_t i;

   //Pre-compute (A ^ 2) mod p
   curve25519Sqr(r, a);
 8000f50:	68b9      	ldr	r1, [r7, #8]
 8000f52:	68f8      	ldr	r0, [r7, #12]
 8000f54:	f7ff ffe8 	bl	8000f28 <curve25519Sqr>

   //Compute R = (A ^ (2^n)) mod p
   for(i = 1; i < n; i++)
 8000f58:	2301      	movs	r3, #1
 8000f5a:	617b      	str	r3, [r7, #20]
 8000f5c:	e006      	b.n	8000f6c <curve25519Pwr2+0x28>
   {
      curve25519Sqr(r, r);
 8000f5e:	68f9      	ldr	r1, [r7, #12]
 8000f60:	68f8      	ldr	r0, [r7, #12]
 8000f62:	f7ff ffe1 	bl	8000f28 <curve25519Sqr>
   for(i = 1; i < n; i++)
 8000f66:	697b      	ldr	r3, [r7, #20]
 8000f68:	3301      	adds	r3, #1
 8000f6a:	617b      	str	r3, [r7, #20]
 8000f6c:	697a      	ldr	r2, [r7, #20]
 8000f6e:	687b      	ldr	r3, [r7, #4]
 8000f70:	429a      	cmp	r2, r3
 8000f72:	d3f4      	bcc.n	8000f5e <curve25519Pwr2+0x1a>
   }
}
 8000f74:	bf00      	nop
 8000f76:	bf00      	nop
 8000f78:	3718      	adds	r7, #24
 8000f7a:	46bd      	mov	sp, r7
 8000f7c:	bd80      	pop	{r7, pc}

08000f7e <curve25519Red>:
 * @param[out] r Resulting integer R = A mod p
 * @param[in] a An integer such as 0 <= A < (2 * p)
 **/

void curve25519Red(uint32_t *r, const uint32_t *a)
{
 8000f7e:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8000f82:	b08e      	sub	sp, #56	; 0x38
 8000f84:	af00      	add	r7, sp, #0
 8000f86:	6078      	str	r0, [r7, #4]
 8000f88:	6039      	str	r1, [r7, #0]
   uint_t i;
   uint64_t temp;
   uint32_t b[8];

   //Compute B = A + 19
   for(temp = 19, i = 0; i < 8; i++)
 8000f8a:	f04f 0213 	mov.w	r2, #19
 8000f8e:	f04f 0300 	mov.w	r3, #0
 8000f92:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8000f96:	2300      	movs	r3, #0
 8000f98:	637b      	str	r3, [r7, #52]	; 0x34
 8000f9a:	e023      	b.n	8000fe4 <curve25519Red+0x66>
   {
      temp += a[i];
 8000f9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000f9e:	009b      	lsls	r3, r3, #2
 8000fa0:	683a      	ldr	r2, [r7, #0]
 8000fa2:	4413      	add	r3, r2
 8000fa4:	681b      	ldr	r3, [r3, #0]
 8000fa6:	2200      	movs	r2, #0
 8000fa8:	461c      	mov	r4, r3
 8000faa:	4615      	mov	r5, r2
 8000fac:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8000fb0:	eb12 0804 	adds.w	r8, r2, r4
 8000fb4:	eb43 0905 	adc.w	r9, r3, r5
 8000fb8:	e9c7 890a 	strd	r8, r9, [r7, #40]	; 0x28
      b[i] = temp & 0xFFFFFFFF;
 8000fbc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8000fbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000fc0:	009b      	lsls	r3, r3, #2
 8000fc2:	3338      	adds	r3, #56	; 0x38
 8000fc4:	443b      	add	r3, r7
 8000fc6:	f843 2c30 	str.w	r2, [r3, #-48]
      temp >>= 32;
 8000fca:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8000fce:	f04f 0200 	mov.w	r2, #0
 8000fd2:	f04f 0300 	mov.w	r3, #0
 8000fd6:	000a      	movs	r2, r1
 8000fd8:	2300      	movs	r3, #0
 8000fda:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   for(temp = 19, i = 0; i < 8; i++)
 8000fde:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000fe0:	3301      	adds	r3, #1
 8000fe2:	637b      	str	r3, [r7, #52]	; 0x34
 8000fe4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000fe6:	2b07      	cmp	r3, #7
 8000fe8:	d9d8      	bls.n	8000f9c <curve25519Red+0x1e>
   }

   //Compute B = A - (2^255 - 19)
   b[7] -= 0x80000000;
 8000fea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000fec:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8000ff0:	627b      	str	r3, [r7, #36]	; 0x24

   //If B < (2^255 - 19) then R = B, else R = A
   curve25519Select(r, b, a, (b[7] & 0x80000000) >> 31);
 8000ff2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ff4:	0fdb      	lsrs	r3, r3, #31
 8000ff6:	f107 0108 	add.w	r1, r7, #8
 8000ffa:	683a      	ldr	r2, [r7, #0]
 8000ffc:	6878      	ldr	r0, [r7, #4]
 8000ffe:	f000 faa8 	bl	8001552 <curve25519Select>
}
 8001002:	bf00      	nop
 8001004:	3738      	adds	r7, #56	; 0x38
 8001006:	46bd      	mov	sp, r7
 8001008:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800100c <curve25519Inv>:
 * @param[out] r Resulting integer R = A^-1 mod p
 * @param[in] a An integer such as 0 <= A < p
 **/

void curve25519Inv(uint32_t *r, const uint32_t *a)
{
 800100c:	b580      	push	{r7, lr}
 800100e:	b092      	sub	sp, #72	; 0x48
 8001010:	af00      	add	r7, sp, #0
 8001012:	6078      	str	r0, [r7, #4]
 8001014:	6039      	str	r1, [r7, #0]
   uint32_t u[8];
   uint32_t v[8];

   //Since GF(p) is a prime field, the Fermat's little theorem can be
   //used to find the multiplicative inverse of A modulo p
   curve25519Sqr(u, a);
 8001016:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800101a:	6839      	ldr	r1, [r7, #0]
 800101c:	4618      	mov	r0, r3
 800101e:	f7ff ff83 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(u, u, a); //A^(2^2 - 1)
 8001022:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001026:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800102a:	683a      	ldr	r2, [r7, #0]
 800102c:	4618      	mov	r0, r3
 800102e:	f7ff fd17 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 8001032:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8001036:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800103a:	4611      	mov	r1, r2
 800103c:	4618      	mov	r0, r3
 800103e:	f7ff ff73 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, a); //A^(2^3 - 1)
 8001042:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001046:	f107 0308 	add.w	r3, r7, #8
 800104a:	683a      	ldr	r2, [r7, #0]
 800104c:	4618      	mov	r0, r3
 800104e:	f7ff fd07 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 3);
 8001052:	f107 0108 	add.w	r1, r7, #8
 8001056:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800105a:	2203      	movs	r2, #3
 800105c:	4618      	mov	r0, r3
 800105e:	f7ff ff71 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //A^(2^6 - 1)
 8001062:	f107 0208 	add.w	r2, r7, #8
 8001066:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800106a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800106e:	4618      	mov	r0, r3
 8001070:	f7ff fcf6 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 8001074:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8001078:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800107c:	4611      	mov	r1, r2
 800107e:	4618      	mov	r0, r3
 8001080:	f7ff ff52 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, a); //A^(2^7 - 1)
 8001084:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001088:	f107 0308 	add.w	r3, r7, #8
 800108c:	683a      	ldr	r2, [r7, #0]
 800108e:	4618      	mov	r0, r3
 8001090:	f7ff fce6 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 7);
 8001094:	f107 0108 	add.w	r1, r7, #8
 8001098:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800109c:	2207      	movs	r2, #7
 800109e:	4618      	mov	r0, r3
 80010a0:	f7ff ff50 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //A^(2^14 - 1)
 80010a4:	f107 0208 	add.w	r2, r7, #8
 80010a8:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80010ac:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80010b0:	4618      	mov	r0, r3
 80010b2:	f7ff fcd5 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80010b6:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80010ba:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80010be:	4611      	mov	r1, r2
 80010c0:	4618      	mov	r0, r3
 80010c2:	f7ff ff31 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, a); //A^(2^15 - 1)
 80010c6:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80010ca:	f107 0308 	add.w	r3, r7, #8
 80010ce:	683a      	ldr	r2, [r7, #0]
 80010d0:	4618      	mov	r0, r3
 80010d2:	f7ff fcc5 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 15);
 80010d6:	f107 0108 	add.w	r1, r7, #8
 80010da:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80010de:	220f      	movs	r2, #15
 80010e0:	4618      	mov	r0, r3
 80010e2:	f7ff ff2f 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //A^(2^30 - 1)
 80010e6:	f107 0208 	add.w	r2, r7, #8
 80010ea:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80010ee:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80010f2:	4618      	mov	r0, r3
 80010f4:	f7ff fcb4 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80010f8:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80010fc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001100:	4611      	mov	r1, r2
 8001102:	4618      	mov	r0, r3
 8001104:	f7ff ff10 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, a); //A^(2^31 - 1)
 8001108:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800110c:	f107 0308 	add.w	r3, r7, #8
 8001110:	683a      	ldr	r2, [r7, #0]
 8001112:	4618      	mov	r0, r3
 8001114:	f7ff fca4 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 31);
 8001118:	f107 0108 	add.w	r1, r7, #8
 800111c:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001120:	221f      	movs	r2, #31
 8001122:	4618      	mov	r0, r3
 8001124:	f7ff ff0e 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(v, u, v); //A^(2^62 - 1)
 8001128:	f107 0208 	add.w	r2, r7, #8
 800112c:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001130:	f107 0308 	add.w	r3, r7, #8
 8001134:	4618      	mov	r0, r3
 8001136:	f7ff fc93 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 62);
 800113a:	f107 0108 	add.w	r1, r7, #8
 800113e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001142:	223e      	movs	r2, #62	; 0x3e
 8001144:	4618      	mov	r0, r3
 8001146:	f7ff fefd 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //A^(2^124 - 1)
 800114a:	f107 0208 	add.w	r2, r7, #8
 800114e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001152:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001156:	4618      	mov	r0, r3
 8001158:	f7ff fc82 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 800115c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8001160:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001164:	4611      	mov	r1, r2
 8001166:	4618      	mov	r0, r3
 8001168:	f7ff fede 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, a); //A^(2^125 - 1)
 800116c:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001170:	f107 0308 	add.w	r3, r7, #8
 8001174:	683a      	ldr	r2, [r7, #0]
 8001176:	4618      	mov	r0, r3
 8001178:	f7ff fc72 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 125);
 800117c:	f107 0108 	add.w	r1, r7, #8
 8001180:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001184:	227d      	movs	r2, #125	; 0x7d
 8001186:	4618      	mov	r0, r3
 8001188:	f7ff fedc 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //A^(2^250 - 1)
 800118c:	f107 0208 	add.w	r2, r7, #8
 8001190:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8001194:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001198:	4618      	mov	r0, r3
 800119a:	f7ff fc61 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 800119e:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80011a2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011a6:	4611      	mov	r1, r2
 80011a8:	4618      	mov	r0, r3
 80011aa:	f7ff febd 	bl	8000f28 <curve25519Sqr>
   curve25519Sqr(u, u);
 80011ae:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80011b2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011b6:	4611      	mov	r1, r2
 80011b8:	4618      	mov	r0, r3
 80011ba:	f7ff feb5 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(u, u, a);
 80011be:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80011c2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011c6:	683a      	ldr	r2, [r7, #0]
 80011c8:	4618      	mov	r0, r3
 80011ca:	f7ff fc49 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80011ce:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80011d2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011d6:	4611      	mov	r1, r2
 80011d8:	4618      	mov	r0, r3
 80011da:	f7ff fea5 	bl	8000f28 <curve25519Sqr>
   curve25519Sqr(u, u);
 80011de:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80011e2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011e6:	4611      	mov	r1, r2
 80011e8:	4618      	mov	r0, r3
 80011ea:	f7ff fe9d 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(u, u, a);
 80011ee:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80011f2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80011f6:	683a      	ldr	r2, [r7, #0]
 80011f8:	4618      	mov	r0, r3
 80011fa:	f7ff fc31 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80011fe:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8001202:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001206:	4611      	mov	r1, r2
 8001208:	4618      	mov	r0, r3
 800120a:	f7ff fe8d 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(r, u, a); //A^(2^255 - 21)
 800120e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8001212:	683a      	ldr	r2, [r7, #0]
 8001214:	4619      	mov	r1, r3
 8001216:	6878      	ldr	r0, [r7, #4]
 8001218:	f7ff fc22 	bl	8000a60 <curve25519Mul>
}
 800121c:	bf00      	nop
 800121e:	3748      	adds	r7, #72	; 0x48
 8001220:	46bd      	mov	sp, r7
 8001222:	bd80      	pop	{r7, pc}

08001224 <curve25519Sqrt>:
 * @param[in] b An integer such as 0 < B < p
 * @return The function returns 0 if the square root exists, else 1
 **/

uint32_t curve25519Sqrt(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 8001224:	b580      	push	{r7, lr}
 8001226:	b09e      	sub	sp, #120	; 0x78
 8001228:	af00      	add	r7, sp, #0
 800122a:	60f8      	str	r0, [r7, #12]
 800122c:	60b9      	str	r1, [r7, #8]
 800122e:	607a      	str	r2, [r7, #4]
   uint32_t v[8];

   //Compute the candidate root (A / B)^((p + 3) / 8). This can be done
   //with the following trick, using a single modular powering for both the
   //inversion of B and the square root: A * B^3 * (A * B^7)^((p - 5) / 8)
   curve25519Sqr(v, b);
 8001230:	f107 0310 	add.w	r3, r7, #16
 8001234:	6879      	ldr	r1, [r7, #4]
 8001236:	4618      	mov	r0, r3
 8001238:	f7ff fe76 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, v, b);
 800123c:	f107 0110 	add.w	r1, r7, #16
 8001240:	f107 0310 	add.w	r3, r7, #16
 8001244:	687a      	ldr	r2, [r7, #4]
 8001246:	4618      	mov	r0, r3
 8001248:	f7ff fc0a 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(v, v);
 800124c:	f107 0210 	add.w	r2, r7, #16
 8001250:	f107 0310 	add.w	r3, r7, #16
 8001254:	4611      	mov	r1, r2
 8001256:	4618      	mov	r0, r3
 8001258:	f7ff fe66 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, v, b);
 800125c:	f107 0110 	add.w	r1, r7, #16
 8001260:	f107 0310 	add.w	r3, r7, #16
 8001264:	687a      	ldr	r2, [r7, #4]
 8001266:	4618      	mov	r0, r3
 8001268:	f7ff fbfa 	bl	8000a60 <curve25519Mul>

   //Compute C = A * B^7
   curve25519Mul(c, a, v);
 800126c:	f107 0210 	add.w	r2, r7, #16
 8001270:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8001274:	68b9      	ldr	r1, [r7, #8]
 8001276:	4618      	mov	r0, r3
 8001278:	f7ff fbf2 	bl	8000a60 <curve25519Mul>

   //Compute U = C^((p - 5) / 8)
   curve25519Sqr(u, c);
 800127c:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8001280:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001284:	4611      	mov	r1, r2
 8001286:	4618      	mov	r0, r3
 8001288:	f7ff fe4e 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(u, u, c); //C^(2^2 - 1)
 800128c:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8001290:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8001294:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001298:	4618      	mov	r0, r3
 800129a:	f7ff fbe1 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 800129e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80012a2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80012a6:	4611      	mov	r1, r2
 80012a8:	4618      	mov	r0, r3
 80012aa:	f7ff fe3d 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, c); //C^(2^3 - 1)
 80012ae:	f107 0250 	add.w	r2, r7, #80	; 0x50
 80012b2:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80012b6:	f107 0310 	add.w	r3, r7, #16
 80012ba:	4618      	mov	r0, r3
 80012bc:	f7ff fbd0 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 3);
 80012c0:	f107 0110 	add.w	r1, r7, #16
 80012c4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80012c8:	2203      	movs	r2, #3
 80012ca:	4618      	mov	r0, r3
 80012cc:	f7ff fe3a 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //C^(2^6 - 1)
 80012d0:	f107 0210 	add.w	r2, r7, #16
 80012d4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80012d8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80012dc:	4618      	mov	r0, r3
 80012de:	f7ff fbbf 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80012e2:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80012e6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80012ea:	4611      	mov	r1, r2
 80012ec:	4618      	mov	r0, r3
 80012ee:	f7ff fe1b 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, c); //C^(2^7 - 1)
 80012f2:	f107 0250 	add.w	r2, r7, #80	; 0x50
 80012f6:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80012fa:	f107 0310 	add.w	r3, r7, #16
 80012fe:	4618      	mov	r0, r3
 8001300:	f7ff fbae 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 7);
 8001304:	f107 0110 	add.w	r1, r7, #16
 8001308:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800130c:	2207      	movs	r2, #7
 800130e:	4618      	mov	r0, r3
 8001310:	f7ff fe18 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //C^(2^14 - 1)
 8001314:	f107 0210 	add.w	r2, r7, #16
 8001318:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800131c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001320:	4618      	mov	r0, r3
 8001322:	f7ff fb9d 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 8001326:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800132a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800132e:	4611      	mov	r1, r2
 8001330:	4618      	mov	r0, r3
 8001332:	f7ff fdf9 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, c); //C^(2^15 - 1)
 8001336:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800133a:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800133e:	f107 0310 	add.w	r3, r7, #16
 8001342:	4618      	mov	r0, r3
 8001344:	f7ff fb8c 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 15);
 8001348:	f107 0110 	add.w	r1, r7, #16
 800134c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001350:	220f      	movs	r2, #15
 8001352:	4618      	mov	r0, r3
 8001354:	f7ff fdf6 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //C^(2^30 - 1)
 8001358:	f107 0210 	add.w	r2, r7, #16
 800135c:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8001360:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001364:	4618      	mov	r0, r3
 8001366:	f7ff fb7b 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 800136a:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800136e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001372:	4611      	mov	r1, r2
 8001374:	4618      	mov	r0, r3
 8001376:	f7ff fdd7 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, c); //C^(2^31 - 1)
 800137a:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800137e:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8001382:	f107 0310 	add.w	r3, r7, #16
 8001386:	4618      	mov	r0, r3
 8001388:	f7ff fb6a 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 31);
 800138c:	f107 0110 	add.w	r1, r7, #16
 8001390:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001394:	221f      	movs	r2, #31
 8001396:	4618      	mov	r0, r3
 8001398:	f7ff fdd4 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(v, u, v); //C^(2^62 - 1)
 800139c:	f107 0210 	add.w	r2, r7, #16
 80013a0:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80013a4:	f107 0310 	add.w	r3, r7, #16
 80013a8:	4618      	mov	r0, r3
 80013aa:	f7ff fb59 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 62);
 80013ae:	f107 0110 	add.w	r1, r7, #16
 80013b2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80013b6:	223e      	movs	r2, #62	; 0x3e
 80013b8:	4618      	mov	r0, r3
 80013ba:	f7ff fdc3 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //C^(2^124 - 1)
 80013be:	f107 0210 	add.w	r2, r7, #16
 80013c2:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80013c6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80013ca:	4618      	mov	r0, r3
 80013cc:	f7ff fb48 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 80013d0:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80013d4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80013d8:	4611      	mov	r1, r2
 80013da:	4618      	mov	r0, r3
 80013dc:	f7ff fda4 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, u, c); //C^(2^125 - 1)
 80013e0:	f107 0250 	add.w	r2, r7, #80	; 0x50
 80013e4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80013e8:	f107 0310 	add.w	r3, r7, #16
 80013ec:	4618      	mov	r0, r3
 80013ee:	f7ff fb37 	bl	8000a60 <curve25519Mul>
   curve25519Pwr2(u, v, 125);
 80013f2:	f107 0110 	add.w	r1, r7, #16
 80013f6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80013fa:	227d      	movs	r2, #125	; 0x7d
 80013fc:	4618      	mov	r0, r3
 80013fe:	f7ff fda1 	bl	8000f44 <curve25519Pwr2>
   curve25519Mul(u, u, v); //C^(2^250 - 1)
 8001402:	f107 0210 	add.w	r2, r7, #16
 8001406:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800140a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800140e:	4618      	mov	r0, r3
 8001410:	f7ff fb26 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(u, u);
 8001414:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8001418:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800141c:	4611      	mov	r1, r2
 800141e:	4618      	mov	r0, r3
 8001420:	f7ff fd82 	bl	8000f28 <curve25519Sqr>
   curve25519Sqr(u, u);
 8001424:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8001428:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800142c:	4611      	mov	r1, r2
 800142e:	4618      	mov	r0, r3
 8001430:	f7ff fd7a 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(u, u, c); //C^(2^252 - 3)
 8001434:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8001438:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800143c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8001440:	4618      	mov	r0, r3
 8001442:	f7ff fb0d 	bl	8000a60 <curve25519Mul>

   //The first candidate root is U = A * B^3 * (A * B^7)^((p - 5) / 8)
   curve25519Mul(u, u, a);
 8001446:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800144a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800144e:	68ba      	ldr	r2, [r7, #8]
 8001450:	4618      	mov	r0, r3
 8001452:	f7ff fb05 	bl	8000a60 <curve25519Mul>
   curve25519Sqr(v, b);
 8001456:	f107 0310 	add.w	r3, r7, #16
 800145a:	6879      	ldr	r1, [r7, #4]
 800145c:	4618      	mov	r0, r3
 800145e:	f7ff fd63 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(v, v, b);
 8001462:	f107 0110 	add.w	r1, r7, #16
 8001466:	f107 0310 	add.w	r3, r7, #16
 800146a:	687a      	ldr	r2, [r7, #4]
 800146c:	4618      	mov	r0, r3
 800146e:	f7ff faf7 	bl	8000a60 <curve25519Mul>
   curve25519Mul(u, u, v);
 8001472:	f107 0210 	add.w	r2, r7, #16
 8001476:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800147a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800147e:	4618      	mov	r0, r3
 8001480:	f7ff faee 	bl	8000a60 <curve25519Mul>

   //The second candidate root is V = U * sqrt(-1)
   curve25519Mul(v, u, CURVE25519_SQRT_MINUS_1);
 8001484:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8001488:	f107 0310 	add.w	r3, r7, #16
 800148c:	4a20      	ldr	r2, [pc, #128]	; (8001510 <curve25519Sqrt+0x2ec>)
 800148e:	4618      	mov	r0, r3
 8001490:	f7ff fae6 	bl	8000a60 <curve25519Mul>

   //Calculate C = B * U^2
   curve25519Sqr(c, u);
 8001494:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8001498:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800149c:	4611      	mov	r1, r2
 800149e:	4618      	mov	r0, r3
 80014a0:	f7ff fd42 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(c, c, b);
 80014a4:	f107 0150 	add.w	r1, r7, #80	; 0x50
 80014a8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80014ac:	687a      	ldr	r2, [r7, #4]
 80014ae:	4618      	mov	r0, r3
 80014b0:	f7ff fad6 	bl	8000a60 <curve25519Mul>

   //Check whether B * U^2 = A
   res1 = curve25519Comp(c, a);
 80014b4:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80014b8:	68b9      	ldr	r1, [r7, #8]
 80014ba:	4618      	mov	r0, r3
 80014bc:	f000 f879 	bl	80015b2 <curve25519Comp>
 80014c0:	6778      	str	r0, [r7, #116]	; 0x74

   //Calculate C = B * V^2
   curve25519Sqr(c, v);
 80014c2:	f107 0210 	add.w	r2, r7, #16
 80014c6:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80014ca:	4611      	mov	r1, r2
 80014cc:	4618      	mov	r0, r3
 80014ce:	f7ff fd2b 	bl	8000f28 <curve25519Sqr>
   curve25519Mul(c, c, b);
 80014d2:	f107 0150 	add.w	r1, r7, #80	; 0x50
 80014d6:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80014da:	687a      	ldr	r2, [r7, #4]
 80014dc:	4618      	mov	r0, r3
 80014de:	f7ff fabf 	bl	8000a60 <curve25519Mul>

   //Check whether B * V^2 = A
   res2 = curve25519Comp(c, a);
 80014e2:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80014e6:	68b9      	ldr	r1, [r7, #8]
 80014e8:	4618      	mov	r0, r3
 80014ea:	f000 f862 	bl	80015b2 <curve25519Comp>
 80014ee:	6738      	str	r0, [r7, #112]	; 0x70

   //Select the first or the second candidate root
   curve25519Select(r, u, v, res1);
 80014f0:	f107 0210 	add.w	r2, r7, #16
 80014f4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80014f8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80014fa:	68f8      	ldr	r0, [r7, #12]
 80014fc:	f000 f829 	bl	8001552 <curve25519Select>

   //Return 0 if the square root exists
   return res1 & res2;
 8001500:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8001502:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8001504:	4013      	ands	r3, r2
}
 8001506:	4618      	mov	r0, r3
 8001508:	3778      	adds	r7, #120	; 0x78
 800150a:	46bd      	mov	sp, r7
 800150c:	bd80      	pop	{r7, pc}
 800150e:	bf00      	nop
 8001510:	0800e864 	.word	0x0800e864

08001514 <curve25519Copy>:
 * @param[out] a Pointer to the destination integer
 * @param[in] b Pointer to the source integer
 **/

void curve25519Copy(uint32_t *a, const uint32_t *b)
{
 8001514:	b480      	push	{r7}
 8001516:	b085      	sub	sp, #20
 8001518:	af00      	add	r7, sp, #0
 800151a:	6078      	str	r0, [r7, #4]
 800151c:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Copy the value of the integer
   for(i = 0; i < 8; i++)
 800151e:	2300      	movs	r3, #0
 8001520:	60fb      	str	r3, [r7, #12]
 8001522:	e00c      	b.n	800153e <curve25519Copy+0x2a>
   {
      a[i] = b[i];
 8001524:	68fb      	ldr	r3, [r7, #12]
 8001526:	009b      	lsls	r3, r3, #2
 8001528:	683a      	ldr	r2, [r7, #0]
 800152a:	441a      	add	r2, r3
 800152c:	68fb      	ldr	r3, [r7, #12]
 800152e:	009b      	lsls	r3, r3, #2
 8001530:	6879      	ldr	r1, [r7, #4]
 8001532:	440b      	add	r3, r1
 8001534:	6812      	ldr	r2, [r2, #0]
 8001536:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 8; i++)
 8001538:	68fb      	ldr	r3, [r7, #12]
 800153a:	3301      	adds	r3, #1
 800153c:	60fb      	str	r3, [r7, #12]
 800153e:	68fb      	ldr	r3, [r7, #12]
 8001540:	2b07      	cmp	r3, #7
 8001542:	d9ef      	bls.n	8001524 <curve25519Copy+0x10>
   }
}
 8001544:	bf00      	nop
 8001546:	bf00      	nop
 8001548:	3714      	adds	r7, #20
 800154a:	46bd      	mov	sp, r7
 800154c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001550:	4770      	bx	lr

08001552 <curve25519Select>:
 * @param[in] c Condition variable
 **/

void curve25519Select(uint32_t *r, const uint32_t *a, const uint32_t *b,
   uint32_t c)
{
 8001552:	b480      	push	{r7}
 8001554:	b087      	sub	sp, #28
 8001556:	af00      	add	r7, sp, #0
 8001558:	60f8      	str	r0, [r7, #12]
 800155a:	60b9      	str	r1, [r7, #8]
 800155c:	607a      	str	r2, [r7, #4]
 800155e:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint32_t mask;

   //The mask is the all-1 or all-0 word
   mask = c - 1;
 8001560:	683b      	ldr	r3, [r7, #0]
 8001562:	3b01      	subs	r3, #1
 8001564:	613b      	str	r3, [r7, #16]

   //Select between A and B
   for(i = 0; i < 8; i++)
 8001566:	2300      	movs	r3, #0
 8001568:	617b      	str	r3, [r7, #20]
 800156a:	e018      	b.n	800159e <curve25519Select+0x4c>
   {
      //Constant time implementation
      r[i] = (a[i] & mask) | (b[i] & ~mask);
 800156c:	697b      	ldr	r3, [r7, #20]
 800156e:	009b      	lsls	r3, r3, #2
 8001570:	68ba      	ldr	r2, [r7, #8]
 8001572:	4413      	add	r3, r2
 8001574:	681a      	ldr	r2, [r3, #0]
 8001576:	693b      	ldr	r3, [r7, #16]
 8001578:	ea02 0103 	and.w	r1, r2, r3
 800157c:	697b      	ldr	r3, [r7, #20]
 800157e:	009b      	lsls	r3, r3, #2
 8001580:	687a      	ldr	r2, [r7, #4]
 8001582:	4413      	add	r3, r2
 8001584:	681a      	ldr	r2, [r3, #0]
 8001586:	693b      	ldr	r3, [r7, #16]
 8001588:	43db      	mvns	r3, r3
 800158a:	401a      	ands	r2, r3
 800158c:	697b      	ldr	r3, [r7, #20]
 800158e:	009b      	lsls	r3, r3, #2
 8001590:	68f8      	ldr	r0, [r7, #12]
 8001592:	4403      	add	r3, r0
 8001594:	430a      	orrs	r2, r1
 8001596:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 8; i++)
 8001598:	697b      	ldr	r3, [r7, #20]
 800159a:	3301      	adds	r3, #1
 800159c:	617b      	str	r3, [r7, #20]
 800159e:	697b      	ldr	r3, [r7, #20]
 80015a0:	2b07      	cmp	r3, #7
 80015a2:	d9e3      	bls.n	800156c <curve25519Select+0x1a>
   }
}
 80015a4:	bf00      	nop
 80015a6:	bf00      	nop
 80015a8:	371c      	adds	r7, #28
 80015aa:	46bd      	mov	sp, r7
 80015ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015b0:	4770      	bx	lr

080015b2 <curve25519Comp>:
 * @param[in] b Pointer to the second integer
 * @return The function returns 0 if the A = B, else 1
 **/

uint32_t curve25519Comp(const uint32_t *a, const uint32_t *b)
{
 80015b2:	b480      	push	{r7}
 80015b4:	b085      	sub	sp, #20
 80015b6:	af00      	add	r7, sp, #0
 80015b8:	6078      	str	r0, [r7, #4]
 80015ba:	6039      	str	r1, [r7, #0]
   uint_t i;
   uint32_t mask;

   //Initialize mask
   mask = 0;
 80015bc:	2300      	movs	r3, #0
 80015be:	60bb      	str	r3, [r7, #8]

   //Compare A and B
   for(i = 0; i < 8; i++)
 80015c0:	2300      	movs	r3, #0
 80015c2:	60fb      	str	r3, [r7, #12]
 80015c4:	e010      	b.n	80015e8 <curve25519Comp+0x36>
   {
      //Constant time implementation
      mask |= a[i] ^ b[i];
 80015c6:	68fb      	ldr	r3, [r7, #12]
 80015c8:	009b      	lsls	r3, r3, #2
 80015ca:	687a      	ldr	r2, [r7, #4]
 80015cc:	4413      	add	r3, r2
 80015ce:	681a      	ldr	r2, [r3, #0]
 80015d0:	68fb      	ldr	r3, [r7, #12]
 80015d2:	009b      	lsls	r3, r3, #2
 80015d4:	6839      	ldr	r1, [r7, #0]
 80015d6:	440b      	add	r3, r1
 80015d8:	681b      	ldr	r3, [r3, #0]
 80015da:	4053      	eors	r3, r2
 80015dc:	68ba      	ldr	r2, [r7, #8]
 80015de:	4313      	orrs	r3, r2
 80015e0:	60bb      	str	r3, [r7, #8]
   for(i = 0; i < 8; i++)
 80015e2:	68fb      	ldr	r3, [r7, #12]
 80015e4:	3301      	adds	r3, #1
 80015e6:	60fb      	str	r3, [r7, #12]
 80015e8:	68fb      	ldr	r3, [r7, #12]
 80015ea:	2b07      	cmp	r3, #7
 80015ec:	d9eb      	bls.n	80015c6 <curve25519Comp+0x14>
   }

   //Return 0 if A = B, else 1
   return ((uint32_t) (mask | (~mask + 1))) >> 31;
 80015ee:	68bb      	ldr	r3, [r7, #8]
 80015f0:	425a      	negs	r2, r3
 80015f2:	68bb      	ldr	r3, [r7, #8]
 80015f4:	4313      	orrs	r3, r2
 80015f6:	0fdb      	lsrs	r3, r3, #31
}
 80015f8:	4618      	mov	r0, r3
 80015fa:	3714      	adds	r7, #20
 80015fc:	46bd      	mov	sp, r7
 80015fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001602:	4770      	bx	lr

08001604 <curve25519Import>:
 * @param[out] a Pointer to resulting integer
 * @param[in] data Octet string to be converted
 **/

void curve25519Import(uint32_t *a, const uint8_t *data)
{
 8001604:	b580      	push	{r7, lr}
 8001606:	b084      	sub	sp, #16
 8001608:	af00      	add	r7, sp, #0
 800160a:	6078      	str	r0, [r7, #4]
 800160c:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Import the octet string
   osMemcpy(a, data, 32);
 800160e:	2220      	movs	r2, #32
 8001610:	6839      	ldr	r1, [r7, #0]
 8001612:	6878      	ldr	r0, [r7, #4]
 8001614:	f00c ff58 	bl	800e4c8 <memcpy>

   //Convert from little-endian byte order to host byte order
   for(i = 0; i < 8; i++)
 8001618:	2300      	movs	r3, #0
 800161a:	60fb      	str	r3, [r7, #12]
 800161c:	e00c      	b.n	8001638 <curve25519Import+0x34>
   {
      a[i] = letoh32(a[i]);
 800161e:	68fb      	ldr	r3, [r7, #12]
 8001620:	009b      	lsls	r3, r3, #2
 8001622:	687a      	ldr	r2, [r7, #4]
 8001624:	441a      	add	r2, r3
 8001626:	68fb      	ldr	r3, [r7, #12]
 8001628:	009b      	lsls	r3, r3, #2
 800162a:	6879      	ldr	r1, [r7, #4]
 800162c:	440b      	add	r3, r1
 800162e:	6812      	ldr	r2, [r2, #0]
 8001630:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 8; i++)
 8001632:	68fb      	ldr	r3, [r7, #12]
 8001634:	3301      	adds	r3, #1
 8001636:	60fb      	str	r3, [r7, #12]
 8001638:	68fb      	ldr	r3, [r7, #12]
 800163a:	2b07      	cmp	r3, #7
 800163c:	d9ef      	bls.n	800161e <curve25519Import+0x1a>
   }
}
 800163e:	bf00      	nop
 8001640:	bf00      	nop
 8001642:	3710      	adds	r7, #16
 8001644:	46bd      	mov	sp, r7
 8001646:	bd80      	pop	{r7, pc}

08001648 <curve25519Export>:
 * @param[in] a Pointer to the integer to be exported
 * @param[out] data Octet string resulting from the conversion
 **/

void curve25519Export(uint32_t *a, uint8_t *data)
{
 8001648:	b580      	push	{r7, lr}
 800164a:	b084      	sub	sp, #16
 800164c:	af00      	add	r7, sp, #0
 800164e:	6078      	str	r0, [r7, #4]
 8001650:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Convert from host byte order to little-endian byte order
   for(i = 0; i < 8; i++)
 8001652:	2300      	movs	r3, #0
 8001654:	60fb      	str	r3, [r7, #12]
 8001656:	e00c      	b.n	8001672 <curve25519Export+0x2a>
   {
      a[i] = htole32(a[i]);
 8001658:	68fb      	ldr	r3, [r7, #12]
 800165a:	009b      	lsls	r3, r3, #2
 800165c:	687a      	ldr	r2, [r7, #4]
 800165e:	441a      	add	r2, r3
 8001660:	68fb      	ldr	r3, [r7, #12]
 8001662:	009b      	lsls	r3, r3, #2
 8001664:	6879      	ldr	r1, [r7, #4]
 8001666:	440b      	add	r3, r1
 8001668:	6812      	ldr	r2, [r2, #0]
 800166a:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 8; i++)
 800166c:	68fb      	ldr	r3, [r7, #12]
 800166e:	3301      	adds	r3, #1
 8001670:	60fb      	str	r3, [r7, #12]
 8001672:	68fb      	ldr	r3, [r7, #12]
 8001674:	2b07      	cmp	r3, #7
 8001676:	d9ef      	bls.n	8001658 <curve25519Export+0x10>
   }

   //Export the octet string
   osMemcpy(data, a, 32);
 8001678:	2220      	movs	r2, #32
 800167a:	6879      	ldr	r1, [r7, #4]
 800167c:	6838      	ldr	r0, [r7, #0]
 800167e:	f00c ff23 	bl	800e4c8 <memcpy>
}
 8001682:	bf00      	nop
 8001684:	3710      	adds	r7, #16
 8001686:	46bd      	mov	sp, r7
 8001688:	bd80      	pop	{r7, pc}

0800168a <curve448SetInt>:
 * @param[out] a Pointer to the integer to be initialized
 * @param[in] b Initial value
 **/

void curve448SetInt(uint32_t *a, uint32_t b)
{
 800168a:	b480      	push	{r7}
 800168c:	b085      	sub	sp, #20
 800168e:	af00      	add	r7, sp, #0
 8001690:	6078      	str	r0, [r7, #4]
 8001692:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Set the value of the least significant word
   a[0] = b;
 8001694:	687b      	ldr	r3, [r7, #4]
 8001696:	683a      	ldr	r2, [r7, #0]
 8001698:	601a      	str	r2, [r3, #0]

   //Initialize the rest of the integer
   for(i = 1; i < 14; i++)
 800169a:	2301      	movs	r3, #1
 800169c:	60fb      	str	r3, [r7, #12]
 800169e:	e008      	b.n	80016b2 <curve448SetInt+0x28>
   {
      a[i] = 0;
 80016a0:	68fb      	ldr	r3, [r7, #12]
 80016a2:	009b      	lsls	r3, r3, #2
 80016a4:	687a      	ldr	r2, [r7, #4]
 80016a6:	4413      	add	r3, r2
 80016a8:	2200      	movs	r2, #0
 80016aa:	601a      	str	r2, [r3, #0]
   for(i = 1; i < 14; i++)
 80016ac:	68fb      	ldr	r3, [r7, #12]
 80016ae:	3301      	adds	r3, #1
 80016b0:	60fb      	str	r3, [r7, #12]
 80016b2:	68fb      	ldr	r3, [r7, #12]
 80016b4:	2b0d      	cmp	r3, #13
 80016b6:	d9f3      	bls.n	80016a0 <curve448SetInt+0x16>
   }
}
 80016b8:	bf00      	nop
 80016ba:	bf00      	nop
 80016bc:	3714      	adds	r7, #20
 80016be:	46bd      	mov	sp, r7
 80016c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016c4:	4770      	bx	lr

080016c6 <curve448Add>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

void curve448Add(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 80016c6:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80016ca:	b08a      	sub	sp, #40	; 0x28
 80016cc:	af00      	add	r7, sp, #0
 80016ce:	6178      	str	r0, [r7, #20]
 80016d0:	6139      	str	r1, [r7, #16]
 80016d2:	60fa      	str	r2, [r7, #12]
   uint_t i;
   uint64_t temp;

   //Compute R = A + B
   for(temp = 0, i = 0; i < 14; i++)
 80016d4:	f04f 0200 	mov.w	r2, #0
 80016d8:	f04f 0300 	mov.w	r3, #0
 80016dc:	e9c7 2306 	strd	r2, r3, [r7, #24]
 80016e0:	2300      	movs	r3, #0
 80016e2:	627b      	str	r3, [r7, #36]	; 0x24
 80016e4:	e036      	b.n	8001754 <curve448Add+0x8e>
   {
      temp += a[i];
 80016e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80016e8:	009b      	lsls	r3, r3, #2
 80016ea:	693a      	ldr	r2, [r7, #16]
 80016ec:	4413      	add	r3, r2
 80016ee:	681b      	ldr	r3, [r3, #0]
 80016f0:	2200      	movs	r2, #0
 80016f2:	461c      	mov	r4, r3
 80016f4:	4615      	mov	r5, r2
 80016f6:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80016fa:	eb12 0a04 	adds.w	sl, r2, r4
 80016fe:	eb43 0b05 	adc.w	fp, r3, r5
 8001702:	e9c7 ab06 	strd	sl, fp, [r7, #24]
      temp += b[i];
 8001706:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001708:	009b      	lsls	r3, r3, #2
 800170a:	68fa      	ldr	r2, [r7, #12]
 800170c:	4413      	add	r3, r2
 800170e:	681b      	ldr	r3, [r3, #0]
 8001710:	2200      	movs	r2, #0
 8001712:	4698      	mov	r8, r3
 8001714:	4691      	mov	r9, r2
 8001716:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800171a:	eb12 0108 	adds.w	r1, r2, r8
 800171e:	6039      	str	r1, [r7, #0]
 8001720:	eb43 0309 	adc.w	r3, r3, r9
 8001724:	607b      	str	r3, [r7, #4]
 8001726:	e9d7 2300 	ldrd	r2, r3, [r7]
 800172a:	e9c7 2306 	strd	r2, r3, [r7, #24]
      r[i] = temp & 0xFFFFFFFF;
 800172e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001730:	009b      	lsls	r3, r3, #2
 8001732:	697a      	ldr	r2, [r7, #20]
 8001734:	4413      	add	r3, r2
 8001736:	69ba      	ldr	r2, [r7, #24]
 8001738:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 800173a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800173e:	f04f 0200 	mov.w	r2, #0
 8001742:	f04f 0300 	mov.w	r3, #0
 8001746:	000a      	movs	r2, r1
 8001748:	2300      	movs	r3, #0
 800174a:	e9c7 2306 	strd	r2, r3, [r7, #24]
   for(temp = 0, i = 0; i < 14; i++)
 800174e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001750:	3301      	adds	r3, #1
 8001752:	627b      	str	r3, [r7, #36]	; 0x24
 8001754:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001756:	2b0d      	cmp	r3, #13
 8001758:	d9c5      	bls.n	80016e6 <curve448Add+0x20>
   }

   //Perform modular reduction
   curve448Red(r, r, (uint32_t) temp);
 800175a:	69bb      	ldr	r3, [r7, #24]
 800175c:	461a      	mov	r2, r3
 800175e:	6979      	ldr	r1, [r7, #20]
 8001760:	6978      	ldr	r0, [r7, #20]
 8001762:	f000 fc2e 	bl	8001fc2 <curve448Red>
}
 8001766:	bf00      	nop
 8001768:	3728      	adds	r7, #40	; 0x28
 800176a:	46bd      	mov	sp, r7
 800176c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08001770 <curve448Sub>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

void curve448Sub(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 8001770:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8001774:	b096      	sub	sp, #88	; 0x58
 8001776:	af00      	add	r7, sp, #0
 8001778:	6478      	str	r0, [r7, #68]	; 0x44
 800177a:	6439      	str	r1, [r7, #64]	; 0x40
 800177c:	63fa      	str	r2, [r7, #60]	; 0x3c
   uint_t i;
   int64_t temp;

   //Compute R = A + (2^448 - 2^224 - 1) - B
   for(temp = -1, i = 0; i < 7; i++)
 800177e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001782:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001786:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
 800178a:	2300      	movs	r3, #0
 800178c:	657b      	str	r3, [r7, #84]	; 0x54
 800178e:	e03b      	b.n	8001808 <curve448Sub+0x98>
   {
      temp += a[i];
 8001790:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001792:	009a      	lsls	r2, r3, #2
 8001794:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8001796:	4413      	add	r3, r2
 8001798:	681b      	ldr	r3, [r3, #0]
 800179a:	2200      	movs	r2, #0
 800179c:	633b      	str	r3, [r7, #48]	; 0x30
 800179e:	637a      	str	r2, [r7, #52]	; 0x34
 80017a0:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 80017a4:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80017a6:	1851      	adds	r1, r2, r1
 80017a8:	6239      	str	r1, [r7, #32]
 80017aa:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80017ac:	414b      	adcs	r3, r1
 80017ae:	627b      	str	r3, [r7, #36]	; 0x24
 80017b0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80017b4:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
      temp -= b[i];
 80017b8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80017ba:	009a      	lsls	r2, r3, #2
 80017bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80017be:	4413      	add	r3, r2
 80017c0:	681b      	ldr	r3, [r3, #0]
 80017c2:	2200      	movs	r2, #0
 80017c4:	62bb      	str	r3, [r7, #40]	; 0x28
 80017c6:	62fa      	str	r2, [r7, #44]	; 0x2c
 80017c8:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 80017cc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80017ce:	1a51      	subs	r1, r2, r1
 80017d0:	61b9      	str	r1, [r7, #24]
 80017d2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80017d4:	eb63 0301 	sbc.w	r3, r3, r1
 80017d8:	61fb      	str	r3, [r7, #28]
 80017da:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80017de:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
      r[i] = temp & 0xFFFFFFFF;
 80017e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80017e4:	009a      	lsls	r2, r3, #2
 80017e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80017e8:	441a      	add	r2, r3
 80017ea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80017ec:	6013      	str	r3, [r2, #0]
      temp >>= 32;
 80017ee:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 80017f2:	f04f 0000 	mov.w	r0, #0
 80017f6:	f04f 0100 	mov.w	r1, #0
 80017fa:	0018      	movs	r0, r3
 80017fc:	17d9      	asrs	r1, r3, #31
 80017fe:	e9c7 0112 	strd	r0, r1, [r7, #72]	; 0x48
   for(temp = -1, i = 0; i < 7; i++)
 8001802:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001804:	3301      	adds	r3, #1
 8001806:	657b      	str	r3, [r7, #84]	; 0x54
 8001808:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800180a:	2b06      	cmp	r3, #6
 800180c:	d9c0      	bls.n	8001790 <curve448Sub+0x20>
   }

   for(temp -= 1, i = 7; i < 14; i++)
 800180e:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8001812:	1e51      	subs	r1, r2, #1
 8001814:	6139      	str	r1, [r7, #16]
 8001816:	f143 33ff 	adc.w	r3, r3, #4294967295	; 0xffffffff
 800181a:	617b      	str	r3, [r7, #20]
 800181c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8001820:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
 8001824:	2307      	movs	r3, #7
 8001826:	657b      	str	r3, [r7, #84]	; 0x54
 8001828:	e038      	b.n	800189c <curve448Sub+0x12c>
   {
      temp += a[i];
 800182a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800182c:	009b      	lsls	r3, r3, #2
 800182e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8001830:	4413      	add	r3, r2
 8001832:	681b      	ldr	r3, [r3, #0]
 8001834:	2200      	movs	r2, #0
 8001836:	461c      	mov	r4, r3
 8001838:	4615      	mov	r5, r2
 800183a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800183e:	1911      	adds	r1, r2, r4
 8001840:	60b9      	str	r1, [r7, #8]
 8001842:	416b      	adcs	r3, r5
 8001844:	60fb      	str	r3, [r7, #12]
 8001846:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800184a:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
      temp -= b[i];
 800184e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001850:	009b      	lsls	r3, r3, #2
 8001852:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8001854:	4413      	add	r3, r2
 8001856:	681b      	ldr	r3, [r3, #0]
 8001858:	2200      	movs	r2, #0
 800185a:	4698      	mov	r8, r3
 800185c:	4691      	mov	r9, r2
 800185e:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8001862:	ebb2 0108 	subs.w	r1, r2, r8
 8001866:	6039      	str	r1, [r7, #0]
 8001868:	eb63 0309 	sbc.w	r3, r3, r9
 800186c:	607b      	str	r3, [r7, #4]
 800186e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8001872:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
      r[i] = temp & 0xFFFFFFFF;
 8001876:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001878:	009b      	lsls	r3, r3, #2
 800187a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800187c:	4413      	add	r3, r2
 800187e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001880:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 8001882:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 8001886:	f04f 0200 	mov.w	r2, #0
 800188a:	f04f 0300 	mov.w	r3, #0
 800188e:	000a      	movs	r2, r1
 8001890:	17cb      	asrs	r3, r1, #31
 8001892:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
   for(temp -= 1, i = 7; i < 14; i++)
 8001896:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001898:	3301      	adds	r3, #1
 800189a:	657b      	str	r3, [r7, #84]	; 0x54
 800189c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800189e:	2b0d      	cmp	r3, #13
 80018a0:	d9c3      	bls.n	800182a <curve448Sub+0xba>
   }

   //Compute the highest term of the result
   temp += 1;
 80018a2:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 80018a6:	f112 0a01 	adds.w	sl, r2, #1
 80018aa:	f143 0b00 	adc.w	fp, r3, #0
 80018ae:	e9c7 ab12 	strd	sl, fp, [r7, #72]	; 0x48

   //Perform modular reduction
   curve448Red(r, r, (uint32_t) temp);
 80018b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80018b4:	461a      	mov	r2, r3
 80018b6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80018b8:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80018ba:	f000 fb82 	bl	8001fc2 <curve448Red>
}
 80018be:	bf00      	nop
 80018c0:	3758      	adds	r7, #88	; 0x58
 80018c2:	46bd      	mov	sp, r7
 80018c4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080018c8 <curve448SubInt>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < (2^32 - 1)
 **/

void curve448SubInt(uint32_t *r, const uint32_t *a, uint32_t b)
{
 80018c8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80018cc:	b092      	sub	sp, #72	; 0x48
 80018ce:	af00      	add	r7, sp, #0
 80018d0:	6378      	str	r0, [r7, #52]	; 0x34
 80018d2:	6339      	str	r1, [r7, #48]	; 0x30
 80018d4:	62fa      	str	r2, [r7, #44]	; 0x2c
   uint_t i;
   int64_t temp;

   //Set initial value
   temp = -1;
 80018d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80018da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80018de:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
   temp -= b;
 80018e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80018e4:	2200      	movs	r2, #0
 80018e6:	461c      	mov	r4, r3
 80018e8:	4615      	mov	r5, r2
 80018ea:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80018ee:	ebb2 0804 	subs.w	r8, r2, r4
 80018f2:	eb63 0905 	sbc.w	r9, r3, r5
 80018f6:	e9c7 890e 	strd	r8, r9, [r7, #56]	; 0x38

   //Compute R = A + (2^448 - 2^224 - 1) - B
   for(i = 0; i < 7; i++)
 80018fa:	2300      	movs	r3, #0
 80018fc:	647b      	str	r3, [r7, #68]	; 0x44
 80018fe:	e028      	b.n	8001952 <curve448SubInt+0x8a>
   {
      temp += a[i];
 8001900:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001902:	009b      	lsls	r3, r3, #2
 8001904:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001906:	4413      	add	r3, r2
 8001908:	681b      	ldr	r3, [r3, #0]
 800190a:	2200      	movs	r2, #0
 800190c:	623b      	str	r3, [r7, #32]
 800190e:	627a      	str	r2, [r7, #36]	; 0x24
 8001910:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 8001914:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 8001918:	4621      	mov	r1, r4
 800191a:	1851      	adds	r1, r2, r1
 800191c:	61b9      	str	r1, [r7, #24]
 800191e:	4629      	mov	r1, r5
 8001920:	414b      	adcs	r3, r1
 8001922:	61fb      	str	r3, [r7, #28]
 8001924:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8001928:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
      r[i] = temp & 0xFFFFFFFF;
 800192c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800192e:	009b      	lsls	r3, r3, #2
 8001930:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8001932:	4413      	add	r3, r2
 8001934:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8001936:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 8001938:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 800193c:	f04f 0000 	mov.w	r0, #0
 8001940:	f04f 0100 	mov.w	r1, #0
 8001944:	0018      	movs	r0, r3
 8001946:	17d9      	asrs	r1, r3, #31
 8001948:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
   for(i = 0; i < 7; i++)
 800194c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800194e:	3301      	adds	r3, #1
 8001950:	647b      	str	r3, [r7, #68]	; 0x44
 8001952:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001954:	2b06      	cmp	r3, #6
 8001956:	d9d3      	bls.n	8001900 <curve448SubInt+0x38>
   }

   for(temp -= 1, i = 7; i < 14; i++)
 8001958:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 800195c:	1e51      	subs	r1, r2, #1
 800195e:	6139      	str	r1, [r7, #16]
 8001960:	f143 33ff 	adc.w	r3, r3, #4294967295	; 0xffffffff
 8001964:	617b      	str	r3, [r7, #20]
 8001966:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800196a:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
 800196e:	2307      	movs	r3, #7
 8001970:	647b      	str	r3, [r7, #68]	; 0x44
 8001972:	e026      	b.n	80019c2 <curve448SubInt+0xfa>
   {
      temp += a[i];
 8001974:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001976:	009b      	lsls	r3, r3, #2
 8001978:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800197a:	4413      	add	r3, r2
 800197c:	681b      	ldr	r3, [r3, #0]
 800197e:	2200      	movs	r2, #0
 8001980:	469a      	mov	sl, r3
 8001982:	4693      	mov	fp, r2
 8001984:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 8001988:	eb12 010a 	adds.w	r1, r2, sl
 800198c:	60b9      	str	r1, [r7, #8]
 800198e:	eb43 030b 	adc.w	r3, r3, fp
 8001992:	60fb      	str	r3, [r7, #12]
 8001994:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8001998:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
      r[i] = temp & 0xFFFFFFFF;
 800199c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800199e:	009b      	lsls	r3, r3, #2
 80019a0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80019a2:	4413      	add	r3, r2
 80019a4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80019a6:	601a      	str	r2, [r3, #0]
      temp >>= 32;
 80019a8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80019ac:	f04f 0200 	mov.w	r2, #0
 80019b0:	f04f 0300 	mov.w	r3, #0
 80019b4:	000a      	movs	r2, r1
 80019b6:	17cb      	asrs	r3, r1, #31
 80019b8:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
   for(temp -= 1, i = 7; i < 14; i++)
 80019bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80019be:	3301      	adds	r3, #1
 80019c0:	647b      	str	r3, [r7, #68]	; 0x44
 80019c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80019c4:	2b0d      	cmp	r3, #13
 80019c6:	d9d5      	bls.n	8001974 <curve448SubInt+0xac>
   }

   //Compute the highest term of the result
   temp += 1;
 80019c8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80019cc:	1c51      	adds	r1, r2, #1
 80019ce:	6039      	str	r1, [r7, #0]
 80019d0:	f143 0300 	adc.w	r3, r3, #0
 80019d4:	607b      	str	r3, [r7, #4]
 80019d6:	e9d7 3400 	ldrd	r3, r4, [r7]
 80019da:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38

   //Perform modular reduction
   curve448Red(r, r, (uint32_t) temp);
 80019de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80019e0:	461a      	mov	r2, r3
 80019e2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80019e4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80019e6:	f000 faec 	bl	8001fc2 <curve448Red>
}
 80019ea:	bf00      	nop
 80019ec:	3748      	adds	r7, #72	; 0x48
 80019ee:	46bd      	mov	sp, r7
 80019f0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080019f4 <curve448Mul>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] b An integer such as 0 <= B < p
 **/

__weak_func void curve448Mul(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 80019f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019f8:	b0e1      	sub	sp, #388	; 0x184
 80019fa:	af00      	add	r7, sp, #0
 80019fc:	f8c7 00f4 	str.w	r0, [r7, #244]	; 0xf4
 8001a00:	f8c7 10f0 	str.w	r1, [r7, #240]	; 0xf0
 8001a04:	f8c7 20ec 	str.w	r2, [r7, #236]	; 0xec
   uint64_t c;
   uint64_t temp;
   uint32_t u[28];

   //Initialize variables
   temp = 0;
 8001a08:	f04f 0200 	mov.w	r2, #0
 8001a0c:	f04f 0300 	mov.w	r3, #0
 8001a10:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
   c = 0;
 8001a14:	f04f 0200 	mov.w	r2, #0
 8001a18:	f04f 0300 	mov.w	r3, #0
 8001a1c:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170

   //Comba's method is used to perform multiplication
   for(i = 0; i < 28; i++)
 8001a20:	2300      	movs	r3, #0
 8001a22:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001a26:	e0ec      	b.n	8001c02 <curve448Mul+0x20e>
   {
      //The algorithm computes the products, column by column
      if(i < 14)
 8001a28:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001a2c:	2b0d      	cmp	r3, #13
 8001a2e:	d85d      	bhi.n	8001aec <curve448Mul+0xf8>
      {
         //Inner loop
         for(j = 0; j <= i; j++)
 8001a30:	2300      	movs	r3, #0
 8001a32:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8001a36:	e052      	b.n	8001ade <curve448Mul+0xea>
         {
            temp += (uint64_t) a[j] * b[i - j];
 8001a38:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001a3c:	009a      	lsls	r2, r3, #2
 8001a3e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8001a42:	4413      	add	r3, r2
 8001a44:	681b      	ldr	r3, [r3, #0]
 8001a46:	2200      	movs	r2, #0
 8001a48:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8001a4c:	f8c7 20d4 	str.w	r2, [r7, #212]	; 0xd4
 8001a50:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 8001a54:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001a58:	1ad3      	subs	r3, r2, r3
 8001a5a:	009a      	lsls	r2, r3, #2
 8001a5c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8001a60:	4413      	add	r3, r2
 8001a62:	681b      	ldr	r3, [r3, #0]
 8001a64:	2200      	movs	r2, #0
 8001a66:	469a      	mov	sl, r3
 8001a68:	4693      	mov	fp, r2
 8001a6a:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	; 0xd0
 8001a6e:	460b      	mov	r3, r1
 8001a70:	fb0a f203 	mul.w	r2, sl, r3
 8001a74:	4603      	mov	r3, r0
 8001a76:	fb03 f30b 	mul.w	r3, r3, fp
 8001a7a:	4413      	add	r3, r2
 8001a7c:	4602      	mov	r2, r0
 8001a7e:	fba2 450a 	umull	r4, r5, r2, sl
 8001a82:	442b      	add	r3, r5
 8001a84:	461d      	mov	r5, r3
 8001a86:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001a8a:	1911      	adds	r1, r2, r4
 8001a8c:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
 8001a90:	416b      	adcs	r3, r5
 8001a92:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8001a96:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	; 0x80
 8001a9a:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
            c += temp >> 32;
 8001a9e:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001aa2:	f04f 0000 	mov.w	r0, #0
 8001aa6:	f04f 0100 	mov.w	r1, #0
 8001aaa:	0018      	movs	r0, r3
 8001aac:	2100      	movs	r1, #0
 8001aae:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 8001ab2:	1816      	adds	r6, r2, r0
 8001ab4:	67be      	str	r6, [r7, #120]	; 0x78
 8001ab6:	414b      	adcs	r3, r1
 8001ab8:	67fb      	str	r3, [r7, #124]	; 0x7c
 8001aba:	e9d7 231e 	ldrd	r2, r3, [r7, #120]	; 0x78
 8001abe:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170
            temp &= 0xFFFFFFFF;
 8001ac2:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001ac6:	673a      	str	r2, [r7, #112]	; 0x70
 8001ac8:	2300      	movs	r3, #0
 8001aca:	677b      	str	r3, [r7, #116]	; 0x74
 8001acc:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 8001ad0:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
         for(j = 0; j <= i; j++)
 8001ad4:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001ad8:	3301      	adds	r3, #1
 8001ada:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8001ade:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 8001ae2:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001ae6:	429a      	cmp	r2, r3
 8001ae8:	d9a6      	bls.n	8001a38 <curve448Mul+0x44>
 8001aea:	e067      	b.n	8001bbc <curve448Mul+0x1c8>
         }
      }
      else
      {
         //Inner loop
         for(j = i - 13; j < 14; j++)
 8001aec:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001af0:	3b0d      	subs	r3, #13
 8001af2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8001af6:	e05d      	b.n	8001bb4 <curve448Mul+0x1c0>
         {
            temp += (uint64_t) a[j] * b[i - j];
 8001af8:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001afc:	009a      	lsls	r2, r3, #2
 8001afe:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8001b02:	4413      	add	r3, r2
 8001b04:	681b      	ldr	r3, [r3, #0]
 8001b06:	2200      	movs	r2, #0
 8001b08:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8001b0c:	f8c7 20e4 	str.w	r2, [r7, #228]	; 0xe4
 8001b10:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 8001b14:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001b18:	1ad3      	subs	r3, r2, r3
 8001b1a:	009a      	lsls	r2, r3, #2
 8001b1c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8001b20:	4413      	add	r3, r2
 8001b22:	681b      	ldr	r3, [r3, #0]
 8001b24:	2200      	movs	r2, #0
 8001b26:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8001b2a:	f8c7 20dc 	str.w	r2, [r7, #220]	; 0xdc
 8001b2e:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	; 0xe0
 8001b32:	460b      	mov	r3, r1
 8001b34:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8001b38:	fb02 f203 	mul.w	r2, r2, r3
 8001b3c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8001b40:	e9c7 0138 	strd	r0, r1, [r7, #224]	; 0xe0
 8001b44:	4601      	mov	r1, r0
 8001b46:	fb01 f303 	mul.w	r3, r1, r3
 8001b4a:	4413      	add	r3, r2
 8001b4c:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8001b50:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
 8001b54:	fba2 8901 	umull	r8, r9, r2, r1
 8001b58:	444b      	add	r3, r9
 8001b5a:	4699      	mov	r9, r3
 8001b5c:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001b60:	eb12 0108 	adds.w	r1, r2, r8
 8001b64:	66b9      	str	r1, [r7, #104]	; 0x68
 8001b66:	eb43 0309 	adc.w	r3, r3, r9
 8001b6a:	66fb      	str	r3, [r7, #108]	; 0x6c
 8001b6c:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
 8001b70:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
            c += temp >> 32;
 8001b74:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001b78:	f04f 0000 	mov.w	r0, #0
 8001b7c:	f04f 0100 	mov.w	r1, #0
 8001b80:	0018      	movs	r0, r3
 8001b82:	2100      	movs	r1, #0
 8001b84:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 8001b88:	1816      	adds	r6, r2, r0
 8001b8a:	663e      	str	r6, [r7, #96]	; 0x60
 8001b8c:	414b      	adcs	r3, r1
 8001b8e:	667b      	str	r3, [r7, #100]	; 0x64
 8001b90:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 8001b94:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170
            temp &= 0xFFFFFFFF;
 8001b98:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001b9c:	65ba      	str	r2, [r7, #88]	; 0x58
 8001b9e:	2300      	movs	r3, #0
 8001ba0:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001ba2:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 8001ba6:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
         for(j = i - 13; j < 14; j++)
 8001baa:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001bae:	3301      	adds	r3, #1
 8001bb0:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8001bb4:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8001bb8:	2b0d      	cmp	r3, #13
 8001bba:	d99d      	bls.n	8001af8 <curve448Mul+0x104>
         }
      }

      //At the bottom of each column, the final result is written to memory
      u[i] = temp & 0xFFFFFFFF;
 8001bbc:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001bc0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001bc4:	009b      	lsls	r3, r3, #2
 8001bc6:	3398      	adds	r3, #152	; 0x98
 8001bc8:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 8001bcc:	440b      	add	r3, r1
 8001bce:	f843 2c88 	str.w	r2, [r3, #-136]

      //Propagate the carry upwards
      temp = c & 0xFFFFFFFF;
 8001bd2:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 8001bd6:	653a      	str	r2, [r7, #80]	; 0x50
 8001bd8:	2300      	movs	r3, #0
 8001bda:	657b      	str	r3, [r7, #84]	; 0x54
 8001bdc:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 8001be0:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
      c >>= 32;
 8001be4:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 8001be8:	f04f 0000 	mov.w	r0, #0
 8001bec:	f04f 0100 	mov.w	r1, #0
 8001bf0:	0018      	movs	r0, r3
 8001bf2:	2100      	movs	r1, #0
 8001bf4:	e9c7 015c 	strd	r0, r1, [r7, #368]	; 0x170
   for(i = 0; i < 28; i++)
 8001bf8:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001bfc:	3301      	adds	r3, #1
 8001bfe:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001c02:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001c06:	2b1b      	cmp	r3, #27
 8001c08:	f67f af0e 	bls.w	8001a28 <curve448Mul+0x34>
   }

   //Perform fast modular reduction (first pass)
   for(temp = 0, i = 0; i < 7; i++)
 8001c0c:	f04f 0200 	mov.w	r2, #0
 8001c10:	f04f 0300 	mov.w	r3, #0
 8001c14:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
 8001c18:	2300      	movs	r3, #0
 8001c1a:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001c1e:	e06f      	b.n	8001d00 <curve448Mul+0x30c>
   {
      temp += u[i];
 8001c20:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001c24:	009b      	lsls	r3, r3, #2
 8001c26:	3398      	adds	r3, #152	; 0x98
 8001c28:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001c2c:	4413      	add	r3, r2
 8001c2e:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001c32:	2200      	movs	r2, #0
 8001c34:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8001c38:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
 8001c3c:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001c40:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	; 0xc8
 8001c44:	4621      	mov	r1, r4
 8001c46:	1851      	adds	r1, r2, r1
 8001c48:	64b9      	str	r1, [r7, #72]	; 0x48
 8001c4a:	4629      	mov	r1, r5
 8001c4c:	414b      	adcs	r3, r1
 8001c4e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8001c50:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 8001c54:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      temp += u[i + 14];
 8001c58:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001c5c:	330e      	adds	r3, #14
 8001c5e:	009b      	lsls	r3, r3, #2
 8001c60:	3398      	adds	r3, #152	; 0x98
 8001c62:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001c66:	4413      	add	r3, r2
 8001c68:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001c6c:	2200      	movs	r2, #0
 8001c6e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8001c72:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 8001c76:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001c7a:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	; 0xc0
 8001c7e:	4621      	mov	r1, r4
 8001c80:	1851      	adds	r1, r2, r1
 8001c82:	6439      	str	r1, [r7, #64]	; 0x40
 8001c84:	4629      	mov	r1, r5
 8001c86:	414b      	adcs	r3, r1
 8001c88:	647b      	str	r3, [r7, #68]	; 0x44
 8001c8a:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 8001c8e:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      temp += u[i + 21];
 8001c92:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001c96:	3315      	adds	r3, #21
 8001c98:	009b      	lsls	r3, r3, #2
 8001c9a:	3398      	adds	r3, #152	; 0x98
 8001c9c:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001ca0:	4413      	add	r3, r2
 8001ca2:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001ca6:	2200      	movs	r2, #0
 8001ca8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8001cac:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
 8001cb0:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001cb4:	e9d7 452e 	ldrd	r4, r5, [r7, #184]	; 0xb8
 8001cb8:	4621      	mov	r1, r4
 8001cba:	1851      	adds	r1, r2, r1
 8001cbc:	63b9      	str	r1, [r7, #56]	; 0x38
 8001cbe:	4629      	mov	r1, r5
 8001cc0:	414b      	adcs	r3, r1
 8001cc2:	63fb      	str	r3, [r7, #60]	; 0x3c
 8001cc4:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 8001cc8:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      u[i] = temp & 0xFFFFFFFF;
 8001ccc:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001cd0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001cd4:	009b      	lsls	r3, r3, #2
 8001cd6:	3398      	adds	r3, #152	; 0x98
 8001cd8:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 8001cdc:	440b      	add	r3, r1
 8001cde:	f843 2c88 	str.w	r2, [r3, #-136]
      temp >>= 32;
 8001ce2:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001ce6:	f04f 0000 	mov.w	r0, #0
 8001cea:	f04f 0100 	mov.w	r1, #0
 8001cee:	0018      	movs	r0, r3
 8001cf0:	2100      	movs	r1, #0
 8001cf2:	e9c7 015a 	strd	r0, r1, [r7, #360]	; 0x168
   for(temp = 0, i = 0; i < 7; i++)
 8001cf6:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001cfa:	3301      	adds	r3, #1
 8001cfc:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001d00:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001d04:	2b06      	cmp	r3, #6
 8001d06:	d98b      	bls.n	8001c20 <curve448Mul+0x22c>
   }

   for(i = 7; i < 14; i++)
 8001d08:	2307      	movs	r3, #7
 8001d0a:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001d0e:	e08c      	b.n	8001e2a <curve448Mul+0x436>
   {
      temp += u[i];
 8001d10:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001d14:	009b      	lsls	r3, r3, #2
 8001d16:	3398      	adds	r3, #152	; 0x98
 8001d18:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001d1c:	4413      	add	r3, r2
 8001d1e:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001d22:	2200      	movs	r2, #0
 8001d24:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8001d28:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
 8001d2c:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001d30:	e9d7 452c 	ldrd	r4, r5, [r7, #176]	; 0xb0
 8001d34:	4621      	mov	r1, r4
 8001d36:	1851      	adds	r1, r2, r1
 8001d38:	6339      	str	r1, [r7, #48]	; 0x30
 8001d3a:	4629      	mov	r1, r5
 8001d3c:	414b      	adcs	r3, r1
 8001d3e:	637b      	str	r3, [r7, #52]	; 0x34
 8001d40:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 8001d44:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      temp += u[i + 7];
 8001d48:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001d4c:	3307      	adds	r3, #7
 8001d4e:	009b      	lsls	r3, r3, #2
 8001d50:	3398      	adds	r3, #152	; 0x98
 8001d52:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001d56:	4413      	add	r3, r2
 8001d58:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001d5c:	2200      	movs	r2, #0
 8001d5e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8001d62:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
 8001d66:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001d6a:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	; 0xa8
 8001d6e:	4621      	mov	r1, r4
 8001d70:	1851      	adds	r1, r2, r1
 8001d72:	62b9      	str	r1, [r7, #40]	; 0x28
 8001d74:	4629      	mov	r1, r5
 8001d76:	414b      	adcs	r3, r1
 8001d78:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001d7a:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	; 0x28
 8001d7e:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      temp += u[i + 14];
 8001d82:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001d86:	330e      	adds	r3, #14
 8001d88:	009b      	lsls	r3, r3, #2
 8001d8a:	3398      	adds	r3, #152	; 0x98
 8001d8c:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001d90:	4413      	add	r3, r2
 8001d92:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001d96:	2200      	movs	r2, #0
 8001d98:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8001d9c:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
 8001da0:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001da4:	e9d7 4528 	ldrd	r4, r5, [r7, #160]	; 0xa0
 8001da8:	4621      	mov	r1, r4
 8001daa:	1851      	adds	r1, r2, r1
 8001dac:	6239      	str	r1, [r7, #32]
 8001dae:	4629      	mov	r1, r5
 8001db0:	414b      	adcs	r3, r1
 8001db2:	627b      	str	r3, [r7, #36]	; 0x24
 8001db4:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 8001db8:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      temp += u[i + 14];
 8001dbc:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001dc0:	330e      	adds	r3, #14
 8001dc2:	009b      	lsls	r3, r3, #2
 8001dc4:	3398      	adds	r3, #152	; 0x98
 8001dc6:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001dca:	4413      	add	r3, r2
 8001dcc:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001dd0:	2200      	movs	r2, #0
 8001dd2:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8001dd6:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
 8001dda:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001dde:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	; 0x98
 8001de2:	4621      	mov	r1, r4
 8001de4:	1851      	adds	r1, r2, r1
 8001de6:	61b9      	str	r1, [r7, #24]
 8001de8:	4629      	mov	r1, r5
 8001dea:	414b      	adcs	r3, r1
 8001dec:	61fb      	str	r3, [r7, #28]
 8001dee:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8001df2:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      u[i] = temp & 0xFFFFFFFF;
 8001df6:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001dfa:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001dfe:	009b      	lsls	r3, r3, #2
 8001e00:	3398      	adds	r3, #152	; 0x98
 8001e02:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 8001e06:	440b      	add	r3, r1
 8001e08:	f843 2c88 	str.w	r2, [r3, #-136]
      temp >>= 32;
 8001e0c:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001e10:	f04f 0000 	mov.w	r0, #0
 8001e14:	f04f 0100 	mov.w	r1, #0
 8001e18:	0018      	movs	r0, r3
 8001e1a:	2100      	movs	r1, #0
 8001e1c:	e9c7 015a 	strd	r0, r1, [r7, #360]	; 0x168
   for(i = 7; i < 14; i++)
 8001e20:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001e24:	3301      	adds	r3, #1
 8001e26:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001e2a:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001e2e:	2b0d      	cmp	r3, #13
 8001e30:	f67f af6e 	bls.w	8001d10 <curve448Mul+0x31c>
   }

   //Perform fast modular reduction (second pass)
   for(c = temp, i = 0; i < 7; i++)
 8001e34:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001e38:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170
 8001e3c:	2300      	movs	r3, #0
 8001e3e:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001e42:	e035      	b.n	8001eb0 <curve448Mul+0x4bc>
   {
      temp += u[i];
 8001e44:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001e48:	009b      	lsls	r3, r3, #2
 8001e4a:	3398      	adds	r3, #152	; 0x98
 8001e4c:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001e50:	4413      	add	r3, r2
 8001e52:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001e56:	2200      	movs	r2, #0
 8001e58:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8001e5c:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
 8001e60:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001e64:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	; 0x90
 8001e68:	4621      	mov	r1, r4
 8001e6a:	1851      	adds	r1, r2, r1
 8001e6c:	6139      	str	r1, [r7, #16]
 8001e6e:	4629      	mov	r1, r5
 8001e70:	414b      	adcs	r3, r1
 8001e72:	617b      	str	r3, [r7, #20]
 8001e74:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8001e78:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      u[i] = temp & 0xFFFFFFFF;
 8001e7c:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001e80:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001e84:	009b      	lsls	r3, r3, #2
 8001e86:	3398      	adds	r3, #152	; 0x98
 8001e88:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 8001e8c:	440b      	add	r3, r1
 8001e8e:	f843 2c88 	str.w	r2, [r3, #-136]
      temp >>= 32;
 8001e92:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	; 0x168
 8001e96:	f04f 0200 	mov.w	r2, #0
 8001e9a:	f04f 0300 	mov.w	r3, #0
 8001e9e:	000a      	movs	r2, r1
 8001ea0:	2300      	movs	r3, #0
 8001ea2:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
   for(c = temp, i = 0; i < 7; i++)
 8001ea6:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001eaa:	3301      	adds	r3, #1
 8001eac:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001eb0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001eb4:	2b06      	cmp	r3, #6
 8001eb6:	d9c5      	bls.n	8001e44 <curve448Mul+0x450>
   }

   for(temp += c, i = 7; i < 14; i++)
 8001eb8:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	; 0x168
 8001ebc:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 8001ec0:	1884      	adds	r4, r0, r2
 8001ec2:	60bc      	str	r4, [r7, #8]
 8001ec4:	eb41 0303 	adc.w	r3, r1, r3
 8001ec8:	60fb      	str	r3, [r7, #12]
 8001eca:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8001ece:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
 8001ed2:	2307      	movs	r3, #7
 8001ed4:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001ed8:	e035      	b.n	8001f46 <curve448Mul+0x552>
   {
      temp += u[i];
 8001eda:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001ede:	009b      	lsls	r3, r3, #2
 8001ee0:	3398      	adds	r3, #152	; 0x98
 8001ee2:	f107 02e8 	add.w	r2, r7, #232	; 0xe8
 8001ee6:	4413      	add	r3, r2
 8001ee8:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8001eec:	2200      	movs	r2, #0
 8001eee:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8001ef2:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 8001ef6:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	; 0x168
 8001efa:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	; 0x88
 8001efe:	4621      	mov	r1, r4
 8001f00:	1851      	adds	r1, r2, r1
 8001f02:	6039      	str	r1, [r7, #0]
 8001f04:	4629      	mov	r1, r5
 8001f06:	414b      	adcs	r3, r1
 8001f08:	607b      	str	r3, [r7, #4]
 8001f0a:	e9d7 3400 	ldrd	r3, r4, [r7]
 8001f0e:	e9c7 345a 	strd	r3, r4, [r7, #360]	; 0x168
      u[i] = temp & 0xFFFFFFFF;
 8001f12:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001f16:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001f1a:	009b      	lsls	r3, r3, #2
 8001f1c:	3398      	adds	r3, #152	; 0x98
 8001f1e:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 8001f22:	440b      	add	r3, r1
 8001f24:	f843 2c88 	str.w	r2, [r3, #-136]
      temp >>= 32;
 8001f28:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	; 0x168
 8001f2c:	f04f 0200 	mov.w	r2, #0
 8001f30:	f04f 0300 	mov.w	r3, #0
 8001f34:	000a      	movs	r2, r1
 8001f36:	2300      	movs	r3, #0
 8001f38:	e9c7 235a 	strd	r2, r3, [r7, #360]	; 0x168
   for(temp += c, i = 7; i < 14; i++)
 8001f3c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001f40:	3301      	adds	r3, #1
 8001f42:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8001f46:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8001f4a:	2b0d      	cmp	r3, #13
 8001f4c:	d9c5      	bls.n	8001eda <curve448Mul+0x4e6>
   }

   //Reduce non-canonical values
   curve448Red(r, u, (uint32_t) temp);
 8001f4e:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 8001f52:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
 8001f56:	4619      	mov	r1, r3
 8001f58:	f8d7 00f4 	ldr.w	r0, [r7, #244]	; 0xf4
 8001f5c:	f000 f831 	bl	8001fc2 <curve448Red>
}
 8001f60:	bf00      	nop
 8001f62:	f507 77c2 	add.w	r7, r7, #388	; 0x184
 8001f66:	46bd      	mov	sp, r7
 8001f68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001f6c <curve448Sqr>:
 * @param[out] r Resulting integer R = (A ^ 2) mod p
 * @param[in] a An integer such as 0 <= A < p
 **/

void curve448Sqr(uint32_t *r, const uint32_t *a)
{
 8001f6c:	b580      	push	{r7, lr}
 8001f6e:	b082      	sub	sp, #8
 8001f70:	af00      	add	r7, sp, #0
 8001f72:	6078      	str	r0, [r7, #4]
 8001f74:	6039      	str	r1, [r7, #0]
   //Compute R = (A ^ 2) mod p
   curve448Mul(r, a, a);
 8001f76:	683a      	ldr	r2, [r7, #0]
 8001f78:	6839      	ldr	r1, [r7, #0]
 8001f7a:	6878      	ldr	r0, [r7, #4]
 8001f7c:	f7ff fd3a 	bl	80019f4 <curve448Mul>
}
 8001f80:	bf00      	nop
 8001f82:	3708      	adds	r7, #8
 8001f84:	46bd      	mov	sp, r7
 8001f86:	bd80      	pop	{r7, pc}

08001f88 <curve448Pwr2>:
 * @param[in] a An integer such as 0 <= A < p
 * @param[in] n An integer such as n >= 1
 **/

void curve448Pwr2(uint32_t *r, const uint32_t *a, uint_t n)
{
 8001f88:	b580      	push	{r7, lr}
 8001f8a:	b086      	sub	sp, #24
 8001f8c:	af00      	add	r7, sp, #0
 8001f8e:	60f8      	str	r0, [r7, #12]
 8001f90:	60b9      	str	r1, [r7, #8]
 8001f92:	607a      	str	r2, [r7, #4]
   uint_t i;

   //Pre-compute (A ^ 2) mod p
   curve448Sqr(r, a);
 8001f94:	68b9      	ldr	r1, [r7, #8]
 8001f96:	68f8      	ldr	r0, [r7, #12]
 8001f98:	f7ff ffe8 	bl	8001f6c <curve448Sqr>

   //Compute R = (A ^ (2^n)) mod p
   for(i = 1; i < n; i++)
 8001f9c:	2301      	movs	r3, #1
 8001f9e:	617b      	str	r3, [r7, #20]
 8001fa0:	e006      	b.n	8001fb0 <curve448Pwr2+0x28>
   {
      curve448Sqr(r, r);
 8001fa2:	68f9      	ldr	r1, [r7, #12]
 8001fa4:	68f8      	ldr	r0, [r7, #12]
 8001fa6:	f7ff ffe1 	bl	8001f6c <curve448Sqr>
   for(i = 1; i < n; i++)
 8001faa:	697b      	ldr	r3, [r7, #20]
 8001fac:	3301      	adds	r3, #1
 8001fae:	617b      	str	r3, [r7, #20]
 8001fb0:	697a      	ldr	r2, [r7, #20]
 8001fb2:	687b      	ldr	r3, [r7, #4]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d3f4      	bcc.n	8001fa2 <curve448Pwr2+0x1a>
   }
}
 8001fb8:	bf00      	nop
 8001fba:	bf00      	nop
 8001fbc:	3718      	adds	r7, #24
 8001fbe:	46bd      	mov	sp, r7
 8001fc0:	bd80      	pop	{r7, pc}

08001fc2 <curve448Red>:
 * @param[in] a An integer such as 0 <= A < (2 * p)
 * @param[in] h The highest term of A
 **/

void curve448Red(uint32_t *r, const uint32_t *a, uint32_t h)
{
 8001fc2:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8001fc6:	b09a      	sub	sp, #104	; 0x68
 8001fc8:	af00      	add	r7, sp, #0
 8001fca:	61f8      	str	r0, [r7, #28]
 8001fcc:	61b9      	str	r1, [r7, #24]
 8001fce:	617a      	str	r2, [r7, #20]
   uint_t i;
   uint64_t temp;
   uint32_t b[14];

   //Compute B = A - (2^448 - 2^224 - 1)
   for(temp = 1, i = 0; i < 7; i++)
 8001fd0:	f04f 0201 	mov.w	r2, #1
 8001fd4:	f04f 0300 	mov.w	r3, #0
 8001fd8:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
 8001fdc:	2300      	movs	r3, #0
 8001fde:	667b      	str	r3, [r7, #100]	; 0x64
 8001fe0:	e029      	b.n	8002036 <curve448Red+0x74>
   {
      temp += a[i];
 8001fe2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fe4:	009b      	lsls	r3, r3, #2
 8001fe6:	69ba      	ldr	r2, [r7, #24]
 8001fe8:	4413      	add	r3, r2
 8001fea:	681b      	ldr	r3, [r3, #0]
 8001fec:	2200      	movs	r2, #0
 8001fee:	4698      	mov	r8, r3
 8001ff0:	4691      	mov	r9, r2
 8001ff2:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 8001ff6:	eb12 0108 	adds.w	r1, r2, r8
 8001ffa:	60b9      	str	r1, [r7, #8]
 8001ffc:	eb43 0309 	adc.w	r3, r3, r9
 8002000:	60fb      	str	r3, [r7, #12]
 8002002:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8002006:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
      b[i] = temp & 0xFFFFFFFF;
 800200a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800200c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800200e:	009b      	lsls	r3, r3, #2
 8002010:	3358      	adds	r3, #88	; 0x58
 8002012:	f107 0110 	add.w	r1, r7, #16
 8002016:	440b      	add	r3, r1
 8002018:	f843 2c48 	str.w	r2, [r3, #-72]
      temp >>= 32;
 800201c:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 8002020:	f04f 0200 	mov.w	r2, #0
 8002024:	f04f 0300 	mov.w	r3, #0
 8002028:	000a      	movs	r2, r1
 800202a:	2300      	movs	r3, #0
 800202c:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
   for(temp = 1, i = 0; i < 7; i++)
 8002030:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002032:	3301      	adds	r3, #1
 8002034:	667b      	str	r3, [r7, #100]	; 0x64
 8002036:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002038:	2b06      	cmp	r3, #6
 800203a:	d9d2      	bls.n	8001fe2 <curve448Red+0x20>
   }

   for(temp += 1, i = 7; i < 14; i++)
 800203c:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 8002040:	1c51      	adds	r1, r2, #1
 8002042:	6039      	str	r1, [r7, #0]
 8002044:	f143 0300 	adc.w	r3, r3, #0
 8002048:	607b      	str	r3, [r7, #4]
 800204a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800204e:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
 8002052:	2307      	movs	r3, #7
 8002054:	667b      	str	r3, [r7, #100]	; 0x64
 8002056:	e025      	b.n	80020a4 <curve448Red+0xe2>
   {
      temp += a[i];
 8002058:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800205a:	009b      	lsls	r3, r3, #2
 800205c:	69ba      	ldr	r2, [r7, #24]
 800205e:	4413      	add	r3, r2
 8002060:	681b      	ldr	r3, [r3, #0]
 8002062:	2200      	movs	r2, #0
 8002064:	461c      	mov	r4, r3
 8002066:	4615      	mov	r5, r2
 8002068:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800206c:	eb12 0a04 	adds.w	sl, r2, r4
 8002070:	eb43 0b05 	adc.w	fp, r3, r5
 8002074:	e9c7 ab16 	strd	sl, fp, [r7, #88]	; 0x58
      b[i] = temp & 0xFFFFFFFF;
 8002078:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800207a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800207c:	009b      	lsls	r3, r3, #2
 800207e:	3358      	adds	r3, #88	; 0x58
 8002080:	f107 0110 	add.w	r1, r7, #16
 8002084:	440b      	add	r3, r1
 8002086:	f843 2c48 	str.w	r2, [r3, #-72]
      temp >>= 32;
 800208a:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 800208e:	f04f 0200 	mov.w	r2, #0
 8002092:	f04f 0300 	mov.w	r3, #0
 8002096:	000a      	movs	r2, r1
 8002098:	2300      	movs	r3, #0
 800209a:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
   for(temp += 1, i = 7; i < 14; i++)
 800209e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80020a0:	3301      	adds	r3, #1
 80020a2:	667b      	str	r3, [r7, #100]	; 0x64
 80020a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80020a6:	2b0d      	cmp	r3, #13
 80020a8:	d9d6      	bls.n	8002058 <curve448Red+0x96>
   }

   //Compute the highest term of the result
   h += (uint32_t) temp - 1;
 80020aa:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80020ac:	697b      	ldr	r3, [r7, #20]
 80020ae:	4413      	add	r3, r2
 80020b0:	3b01      	subs	r3, #1
 80020b2:	617b      	str	r3, [r7, #20]

   //If B < (2^448 - 2^224 + 1) then R = B, else R = A
   curve448Select(r, b, a, h & 1);
 80020b4:	697b      	ldr	r3, [r7, #20]
 80020b6:	f003 0301 	and.w	r3, r3, #1
 80020ba:	f107 0120 	add.w	r1, r7, #32
 80020be:	69ba      	ldr	r2, [r7, #24]
 80020c0:	69f8      	ldr	r0, [r7, #28]
 80020c2:	f000 fa8d 	bl	80025e0 <curve448Select>
}
 80020c6:	bf00      	nop
 80020c8:	3768      	adds	r7, #104	; 0x68
 80020ca:	46bd      	mov	sp, r7
 80020cc:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080020d0 <curve448Inv>:
 * @param[out] r Resulting integer R = A^-1 mod p
 * @param[in] a An integer such as 0 <= A < p
 **/

void curve448Inv(uint32_t *r, const uint32_t *a)
{
 80020d0:	b580      	push	{r7, lr}
 80020d2:	b09e      	sub	sp, #120	; 0x78
 80020d4:	af00      	add	r7, sp, #0
 80020d6:	6078      	str	r0, [r7, #4]
 80020d8:	6039      	str	r1, [r7, #0]
   uint32_t u[14];
   uint32_t v[14];

   //Since GF(p) is a prime field, the Fermat's little theorem can be
   //used to find the multiplicative inverse of A modulo p
   curve448Sqr(u, a);
 80020da:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80020de:	6839      	ldr	r1, [r7, #0]
 80020e0:	4618      	mov	r0, r3
 80020e2:	f7ff ff43 	bl	8001f6c <curve448Sqr>
   curve448Mul(u, u, a); //A^(2^2 - 1)
 80020e6:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80020ea:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80020ee:	683a      	ldr	r2, [r7, #0]
 80020f0:	4618      	mov	r0, r3
 80020f2:	f7ff fc7f 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 80020f6:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80020fa:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80020fe:	4611      	mov	r1, r2
 8002100:	4618      	mov	r0, r3
 8002102:	f7ff ff33 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, a); //A^(2^3 - 1)
 8002106:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800210a:	f107 0308 	add.w	r3, r7, #8
 800210e:	683a      	ldr	r2, [r7, #0]
 8002110:	4618      	mov	r0, r3
 8002112:	f7ff fc6f 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 3);
 8002116:	f107 0108 	add.w	r1, r7, #8
 800211a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800211e:	2203      	movs	r2, #3
 8002120:	4618      	mov	r0, r3
 8002122:	f7ff ff31 	bl	8001f88 <curve448Pwr2>
   curve448Mul(v, u, v); //A^(2^6 - 1)
 8002126:	f107 0208 	add.w	r2, r7, #8
 800212a:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800212e:	f107 0308 	add.w	r3, r7, #8
 8002132:	4618      	mov	r0, r3
 8002134:	f7ff fc5e 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 6);
 8002138:	f107 0108 	add.w	r1, r7, #8
 800213c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002140:	2206      	movs	r2, #6
 8002142:	4618      	mov	r0, r3
 8002144:	f7ff ff20 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //A^(2^12 - 1)
 8002148:	f107 0208 	add.w	r2, r7, #8
 800214c:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002150:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002154:	4618      	mov	r0, r3
 8002156:	f7ff fc4d 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 800215a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800215e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002162:	4611      	mov	r1, r2
 8002164:	4618      	mov	r0, r3
 8002166:	f7ff ff01 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, a); //A^(2^13 - 1)
 800216a:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800216e:	f107 0308 	add.w	r3, r7, #8
 8002172:	683a      	ldr	r2, [r7, #0]
 8002174:	4618      	mov	r0, r3
 8002176:	f7ff fc3d 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 13);
 800217a:	f107 0108 	add.w	r1, r7, #8
 800217e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002182:	220d      	movs	r2, #13
 8002184:	4618      	mov	r0, r3
 8002186:	f7ff feff 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //A^(2^26 - 1)
 800218a:	f107 0208 	add.w	r2, r7, #8
 800218e:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002192:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002196:	4618      	mov	r0, r3
 8002198:	f7ff fc2c 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 800219c:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80021a0:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80021a4:	4611      	mov	r1, r2
 80021a6:	4618      	mov	r0, r3
 80021a8:	f7ff fee0 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, a); //A^(2^27 - 1)
 80021ac:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80021b0:	f107 0308 	add.w	r3, r7, #8
 80021b4:	683a      	ldr	r2, [r7, #0]
 80021b6:	4618      	mov	r0, r3
 80021b8:	f7ff fc1c 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 27);
 80021bc:	f107 0108 	add.w	r1, r7, #8
 80021c0:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80021c4:	221b      	movs	r2, #27
 80021c6:	4618      	mov	r0, r3
 80021c8:	f7ff fede 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //A^(2^54 - 1)
 80021cc:	f107 0208 	add.w	r2, r7, #8
 80021d0:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80021d4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80021d8:	4618      	mov	r0, r3
 80021da:	f7ff fc0b 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 80021de:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80021e2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80021e6:	4611      	mov	r1, r2
 80021e8:	4618      	mov	r0, r3
 80021ea:	f7ff febf 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, a); //A^(2^55 - 1)
 80021ee:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80021f2:	f107 0308 	add.w	r3, r7, #8
 80021f6:	683a      	ldr	r2, [r7, #0]
 80021f8:	4618      	mov	r0, r3
 80021fa:	f7ff fbfb 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 55);
 80021fe:	f107 0108 	add.w	r1, r7, #8
 8002202:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002206:	2237      	movs	r2, #55	; 0x37
 8002208:	4618      	mov	r0, r3
 800220a:	f7ff febd 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //A^(2^110 - 1)
 800220e:	f107 0208 	add.w	r2, r7, #8
 8002212:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002216:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800221a:	4618      	mov	r0, r3
 800221c:	f7ff fbea 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 8002220:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002224:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002228:	4611      	mov	r1, r2
 800222a:	4618      	mov	r0, r3
 800222c:	f7ff fe9e 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, a); //A^(2^111 - 1)
 8002230:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002234:	f107 0308 	add.w	r3, r7, #8
 8002238:	683a      	ldr	r2, [r7, #0]
 800223a:	4618      	mov	r0, r3
 800223c:	f7ff fbda 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 111);
 8002240:	f107 0108 	add.w	r1, r7, #8
 8002244:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002248:	226f      	movs	r2, #111	; 0x6f
 800224a:	4618      	mov	r0, r3
 800224c:	f7ff fe9c 	bl	8001f88 <curve448Pwr2>
   curve448Mul(v, u, v); //A^(2^222 - 1)
 8002250:	f107 0208 	add.w	r2, r7, #8
 8002254:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002258:	f107 0308 	add.w	r3, r7, #8
 800225c:	4618      	mov	r0, r3
 800225e:	f7ff fbc9 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, v);
 8002262:	f107 0208 	add.w	r2, r7, #8
 8002266:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800226a:	4611      	mov	r1, r2
 800226c:	4618      	mov	r0, r3
 800226e:	f7ff fe7d 	bl	8001f6c <curve448Sqr>
   curve448Mul(u, u, a); //A^(2^223 - 1)
 8002272:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002276:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800227a:	683a      	ldr	r2, [r7, #0]
 800227c:	4618      	mov	r0, r3
 800227e:	f7ff fbb9 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, u, 223);
 8002282:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002286:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800228a:	22df      	movs	r2, #223	; 0xdf
 800228c:	4618      	mov	r0, r3
 800228e:	f7ff fe7b 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //A^(2^446 - 2^222 - 1)
 8002292:	f107 0208 	add.w	r2, r7, #8
 8002296:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800229a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800229e:	4618      	mov	r0, r3
 80022a0:	f7ff fba8 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 80022a4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80022a8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80022ac:	4611      	mov	r1, r2
 80022ae:	4618      	mov	r0, r3
 80022b0:	f7ff fe5c 	bl	8001f6c <curve448Sqr>
   curve448Sqr(u, u);
 80022b4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80022b8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80022bc:	4611      	mov	r1, r2
 80022be:	4618      	mov	r0, r3
 80022c0:	f7ff fe54 	bl	8001f6c <curve448Sqr>
   curve448Mul(r, u, a); //A^(2^448 - 2^224 - 3)
 80022c4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80022c8:	683a      	ldr	r2, [r7, #0]
 80022ca:	4619      	mov	r1, r3
 80022cc:	6878      	ldr	r0, [r7, #4]
 80022ce:	f7ff fb91 	bl	80019f4 <curve448Mul>
}
 80022d2:	bf00      	nop
 80022d4:	3778      	adds	r7, #120	; 0x78
 80022d6:	46bd      	mov	sp, r7
 80022d8:	bd80      	pop	{r7, pc}

080022da <curve448Sqrt>:
 * @param[in] b An integer such as 0 < B < p
 * @return The function returns 0 if the square root exists, else 1
 **/

uint32_t curve448Sqrt(uint32_t *r, const uint32_t *a, const uint32_t *b)
{
 80022da:	b580      	push	{r7, lr}
 80022dc:	b0b0      	sub	sp, #192	; 0xc0
 80022de:	af00      	add	r7, sp, #0
 80022e0:	60f8      	str	r0, [r7, #12]
 80022e2:	60b9      	str	r1, [r7, #8]
 80022e4:	607a      	str	r2, [r7, #4]
   uint32_t v[14];

   //Compute the candidate root (A / B)^((p + 1) / 4). This can be done
   //with the following trick, using a single modular powering for both the
   //inversion of B and the square root: A^3 * B * (A^5 * B^3)^((p - 3) / 4)
   curve448Sqr(u, a);
 80022e6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80022ea:	68b9      	ldr	r1, [r7, #8]
 80022ec:	4618      	mov	r0, r3
 80022ee:	f7ff fe3d 	bl	8001f6c <curve448Sqr>
   curve448Sqr(u, u);
 80022f2:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 80022f6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80022fa:	4611      	mov	r1, r2
 80022fc:	4618      	mov	r0, r3
 80022fe:	f7ff fe35 	bl	8001f6c <curve448Sqr>
   curve448Mul(u, u, a);
 8002302:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002306:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800230a:	68ba      	ldr	r2, [r7, #8]
 800230c:	4618      	mov	r0, r3
 800230e:	f7ff fb71 	bl	80019f4 <curve448Mul>
   curve448Sqr(v, b);
 8002312:	f107 0314 	add.w	r3, r7, #20
 8002316:	6879      	ldr	r1, [r7, #4]
 8002318:	4618      	mov	r0, r3
 800231a:	f7ff fe27 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, v, b);
 800231e:	f107 0114 	add.w	r1, r7, #20
 8002322:	f107 0314 	add.w	r3, r7, #20
 8002326:	687a      	ldr	r2, [r7, #4]
 8002328:	4618      	mov	r0, r3
 800232a:	f7ff fb63 	bl	80019f4 <curve448Mul>

   //Compute C = A^5 * B^3
   curve448Mul(c, u, v);
 800232e:	f107 0214 	add.w	r2, r7, #20
 8002332:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002336:	f107 0384 	add.w	r3, r7, #132	; 0x84
 800233a:	4618      	mov	r0, r3
 800233c:	f7ff fb5a 	bl	80019f4 <curve448Mul>

   //Compute U = C^((p - 3) / 4)
   curve448Sqr(u, c);
 8002340:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8002344:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002348:	4611      	mov	r1, r2
 800234a:	4618      	mov	r0, r3
 800234c:	f7ff fe0e 	bl	8001f6c <curve448Sqr>
   curve448Mul(u, u, c); //C^(2^2 - 1)
 8002350:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8002354:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002358:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800235c:	4618      	mov	r0, r3
 800235e:	f7ff fb49 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 8002362:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8002366:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800236a:	4611      	mov	r1, r2
 800236c:	4618      	mov	r0, r3
 800236e:	f7ff fdfd 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, c); //C^(2^3 - 1)
 8002372:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8002376:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800237a:	f107 0314 	add.w	r3, r7, #20
 800237e:	4618      	mov	r0, r3
 8002380:	f7ff fb38 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 3);
 8002384:	f107 0114 	add.w	r1, r7, #20
 8002388:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800238c:	2203      	movs	r2, #3
 800238e:	4618      	mov	r0, r3
 8002390:	f7ff fdfa 	bl	8001f88 <curve448Pwr2>
   curve448Mul(v, u, v); //C^(2^6 - 1)
 8002394:	f107 0214 	add.w	r2, r7, #20
 8002398:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800239c:	f107 0314 	add.w	r3, r7, #20
 80023a0:	4618      	mov	r0, r3
 80023a2:	f7ff fb27 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 6);
 80023a6:	f107 0114 	add.w	r1, r7, #20
 80023aa:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023ae:	2206      	movs	r2, #6
 80023b0:	4618      	mov	r0, r3
 80023b2:	f7ff fde9 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //C^(2^12 - 1)
 80023b6:	f107 0214 	add.w	r2, r7, #20
 80023ba:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80023be:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023c2:	4618      	mov	r0, r3
 80023c4:	f7ff fb16 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 80023c8:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 80023cc:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023d0:	4611      	mov	r1, r2
 80023d2:	4618      	mov	r0, r3
 80023d4:	f7ff fdca 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, c); //C^(2^13 - 1)
 80023d8:	f107 0284 	add.w	r2, r7, #132	; 0x84
 80023dc:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80023e0:	f107 0314 	add.w	r3, r7, #20
 80023e4:	4618      	mov	r0, r3
 80023e6:	f7ff fb05 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 13);
 80023ea:	f107 0114 	add.w	r1, r7, #20
 80023ee:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023f2:	220d      	movs	r2, #13
 80023f4:	4618      	mov	r0, r3
 80023f6:	f7ff fdc7 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //C^(2^26 - 1)
 80023fa:	f107 0214 	add.w	r2, r7, #20
 80023fe:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002402:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002406:	4618      	mov	r0, r3
 8002408:	f7ff faf4 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 800240c:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8002410:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002414:	4611      	mov	r1, r2
 8002416:	4618      	mov	r0, r3
 8002418:	f7ff fda8 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, c); //C^(2^27 - 1)
 800241c:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8002420:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002424:	f107 0314 	add.w	r3, r7, #20
 8002428:	4618      	mov	r0, r3
 800242a:	f7ff fae3 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 27);
 800242e:	f107 0114 	add.w	r1, r7, #20
 8002432:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002436:	221b      	movs	r2, #27
 8002438:	4618      	mov	r0, r3
 800243a:	f7ff fda5 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //C^(2^54 - 1)
 800243e:	f107 0214 	add.w	r2, r7, #20
 8002442:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002446:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800244a:	4618      	mov	r0, r3
 800244c:	f7ff fad2 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 8002450:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8002454:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002458:	4611      	mov	r1, r2
 800245a:	4618      	mov	r0, r3
 800245c:	f7ff fd86 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, c); //C^(2^55 - 1)
 8002460:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8002464:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002468:	f107 0314 	add.w	r3, r7, #20
 800246c:	4618      	mov	r0, r3
 800246e:	f7ff fac1 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 55);
 8002472:	f107 0114 	add.w	r1, r7, #20
 8002476:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800247a:	2237      	movs	r2, #55	; 0x37
 800247c:	4618      	mov	r0, r3
 800247e:	f7ff fd83 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //C^(2^110 - 1)
 8002482:	f107 0214 	add.w	r2, r7, #20
 8002486:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800248a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800248e:	4618      	mov	r0, r3
 8002490:	f7ff fab0 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, u);
 8002494:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8002498:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800249c:	4611      	mov	r1, r2
 800249e:	4618      	mov	r0, r3
 80024a0:	f7ff fd64 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, u, c); //C^(2^111 - 1)
 80024a4:	f107 0284 	add.w	r2, r7, #132	; 0x84
 80024a8:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80024ac:	f107 0314 	add.w	r3, r7, #20
 80024b0:	4618      	mov	r0, r3
 80024b2:	f7ff fa9f 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, v, 111);
 80024b6:	f107 0114 	add.w	r1, r7, #20
 80024ba:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80024be:	226f      	movs	r2, #111	; 0x6f
 80024c0:	4618      	mov	r0, r3
 80024c2:	f7ff fd61 	bl	8001f88 <curve448Pwr2>
   curve448Mul(v, u, v); //C^(2^222 - 1)
 80024c6:	f107 0214 	add.w	r2, r7, #20
 80024ca:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80024ce:	f107 0314 	add.w	r3, r7, #20
 80024d2:	4618      	mov	r0, r3
 80024d4:	f7ff fa8e 	bl	80019f4 <curve448Mul>
   curve448Sqr(u, v);
 80024d8:	f107 0214 	add.w	r2, r7, #20
 80024dc:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80024e0:	4611      	mov	r1, r2
 80024e2:	4618      	mov	r0, r3
 80024e4:	f7ff fd42 	bl	8001f6c <curve448Sqr>
   curve448Mul(u, u, c); //C^(2^223 - 1)
 80024e8:	f107 0284 	add.w	r2, r7, #132	; 0x84
 80024ec:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80024f0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80024f4:	4618      	mov	r0, r3
 80024f6:	f7ff fa7d 	bl	80019f4 <curve448Mul>
   curve448Pwr2(u, u, 223);
 80024fa:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80024fe:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002502:	22df      	movs	r2, #223	; 0xdf
 8002504:	4618      	mov	r0, r3
 8002506:	f7ff fd3f 	bl	8001f88 <curve448Pwr2>
   curve448Mul(u, u, v); //C^(2^446 - 2^222 - 1)
 800250a:	f107 0214 	add.w	r2, r7, #20
 800250e:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002512:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002516:	4618      	mov	r0, r3
 8002518:	f7ff fa6c 	bl	80019f4 <curve448Mul>

   //The candidate root is U = A^3 * B * (A^5 * B^3)^((p - 3) / 4)
   curve448Sqr(v, a);
 800251c:	f107 0314 	add.w	r3, r7, #20
 8002520:	68b9      	ldr	r1, [r7, #8]
 8002522:	4618      	mov	r0, r3
 8002524:	f7ff fd22 	bl	8001f6c <curve448Sqr>
   curve448Mul(v, v, a);
 8002528:	f107 0114 	add.w	r1, r7, #20
 800252c:	f107 0314 	add.w	r3, r7, #20
 8002530:	68ba      	ldr	r2, [r7, #8]
 8002532:	4618      	mov	r0, r3
 8002534:	f7ff fa5e 	bl	80019f4 <curve448Mul>
   curve448Mul(u, u, v);
 8002538:	f107 0214 	add.w	r2, r7, #20
 800253c:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8002540:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002544:	4618      	mov	r0, r3
 8002546:	f7ff fa55 	bl	80019f4 <curve448Mul>
   curve448Mul(u, u, b);
 800254a:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800254e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8002552:	687a      	ldr	r2, [r7, #4]
 8002554:	4618      	mov	r0, r3
 8002556:	f7ff fa4d 	bl	80019f4 <curve448Mul>

   //Calculate C = B * U^2
   curve448Sqr(c, u);
 800255a:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800255e:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8002562:	4611      	mov	r1, r2
 8002564:	4618      	mov	r0, r3
 8002566:	f7ff fd01 	bl	8001f6c <curve448Sqr>
   curve448Mul(c, c, b);
 800256a:	f107 0184 	add.w	r1, r7, #132	; 0x84
 800256e:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8002572:	687a      	ldr	r2, [r7, #4]
 8002574:	4618      	mov	r0, r3
 8002576:	f7ff fa3d 	bl	80019f4 <curve448Mul>

   //Check whether B * U^2 = A
   res = curve448Comp(c, a);
 800257a:	f107 0384 	add.w	r3, r7, #132	; 0x84
 800257e:	68b9      	ldr	r1, [r7, #8]
 8002580:	4618      	mov	r0, r3
 8002582:	f000 f85d 	bl	8002640 <curve448Comp>
 8002586:	f8c7 00bc 	str.w	r0, [r7, #188]	; 0xbc

   //Copy the candidate root
   curve448Copy(r, u);
 800258a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800258e:	4619      	mov	r1, r3
 8002590:	68f8      	ldr	r0, [r7, #12]
 8002592:	f000 f806 	bl	80025a2 <curve448Copy>

   //Return 0 if the square root exists
   return res;
 8002596:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
}
 800259a:	4618      	mov	r0, r3
 800259c:	37c0      	adds	r7, #192	; 0xc0
 800259e:	46bd      	mov	sp, r7
 80025a0:	bd80      	pop	{r7, pc}

080025a2 <curve448Copy>:
 * @param[out] a Pointer to the destination integer
 * @param[in] b Pointer to the source integer
 **/

void curve448Copy(uint32_t *a, const uint32_t *b)
{
 80025a2:	b480      	push	{r7}
 80025a4:	b085      	sub	sp, #20
 80025a6:	af00      	add	r7, sp, #0
 80025a8:	6078      	str	r0, [r7, #4]
 80025aa:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Copy the value of the integer
   for(i = 0; i < 14; i++)
 80025ac:	2300      	movs	r3, #0
 80025ae:	60fb      	str	r3, [r7, #12]
 80025b0:	e00c      	b.n	80025cc <curve448Copy+0x2a>
   {
      a[i] = b[i];
 80025b2:	68fb      	ldr	r3, [r7, #12]
 80025b4:	009b      	lsls	r3, r3, #2
 80025b6:	683a      	ldr	r2, [r7, #0]
 80025b8:	441a      	add	r2, r3
 80025ba:	68fb      	ldr	r3, [r7, #12]
 80025bc:	009b      	lsls	r3, r3, #2
 80025be:	6879      	ldr	r1, [r7, #4]
 80025c0:	440b      	add	r3, r1
 80025c2:	6812      	ldr	r2, [r2, #0]
 80025c4:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 14; i++)
 80025c6:	68fb      	ldr	r3, [r7, #12]
 80025c8:	3301      	adds	r3, #1
 80025ca:	60fb      	str	r3, [r7, #12]
 80025cc:	68fb      	ldr	r3, [r7, #12]
 80025ce:	2b0d      	cmp	r3, #13
 80025d0:	d9ef      	bls.n	80025b2 <curve448Copy+0x10>
   }
}
 80025d2:	bf00      	nop
 80025d4:	bf00      	nop
 80025d6:	3714      	adds	r7, #20
 80025d8:	46bd      	mov	sp, r7
 80025da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80025de:	4770      	bx	lr

080025e0 <curve448Select>:
 * @param[in] c Condition variable
 **/

void curve448Select(uint32_t *r, const uint32_t *a, const uint32_t *b,
   uint32_t c)
{
 80025e0:	b480      	push	{r7}
 80025e2:	b087      	sub	sp, #28
 80025e4:	af00      	add	r7, sp, #0
 80025e6:	60f8      	str	r0, [r7, #12]
 80025e8:	60b9      	str	r1, [r7, #8]
 80025ea:	607a      	str	r2, [r7, #4]
 80025ec:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint32_t mask;

   //The mask is the all-1 or all-0 word
   mask = c - 1;
 80025ee:	683b      	ldr	r3, [r7, #0]
 80025f0:	3b01      	subs	r3, #1
 80025f2:	613b      	str	r3, [r7, #16]

   //Select between A and B
   for(i = 0; i < 14; i++)
 80025f4:	2300      	movs	r3, #0
 80025f6:	617b      	str	r3, [r7, #20]
 80025f8:	e018      	b.n	800262c <curve448Select+0x4c>
   {
      //Constant time implementation
      r[i] = (a[i] & mask) | (b[i] & ~mask);
 80025fa:	697b      	ldr	r3, [r7, #20]
 80025fc:	009b      	lsls	r3, r3, #2
 80025fe:	68ba      	ldr	r2, [r7, #8]
 8002600:	4413      	add	r3, r2
 8002602:	681a      	ldr	r2, [r3, #0]
 8002604:	693b      	ldr	r3, [r7, #16]
 8002606:	ea02 0103 	and.w	r1, r2, r3
 800260a:	697b      	ldr	r3, [r7, #20]
 800260c:	009b      	lsls	r3, r3, #2
 800260e:	687a      	ldr	r2, [r7, #4]
 8002610:	4413      	add	r3, r2
 8002612:	681a      	ldr	r2, [r3, #0]
 8002614:	693b      	ldr	r3, [r7, #16]
 8002616:	43db      	mvns	r3, r3
 8002618:	401a      	ands	r2, r3
 800261a:	697b      	ldr	r3, [r7, #20]
 800261c:	009b      	lsls	r3, r3, #2
 800261e:	68f8      	ldr	r0, [r7, #12]
 8002620:	4403      	add	r3, r0
 8002622:	430a      	orrs	r2, r1
 8002624:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 14; i++)
 8002626:	697b      	ldr	r3, [r7, #20]
 8002628:	3301      	adds	r3, #1
 800262a:	617b      	str	r3, [r7, #20]
 800262c:	697b      	ldr	r3, [r7, #20]
 800262e:	2b0d      	cmp	r3, #13
 8002630:	d9e3      	bls.n	80025fa <curve448Select+0x1a>
   }
}
 8002632:	bf00      	nop
 8002634:	bf00      	nop
 8002636:	371c      	adds	r7, #28
 8002638:	46bd      	mov	sp, r7
 800263a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800263e:	4770      	bx	lr

08002640 <curve448Comp>:
 * @param[in] b Pointer to the second integer
 * @return The function returns 0 if the A = B, else 1
 **/

uint32_t curve448Comp(const uint32_t *a, const uint32_t *b)
{
 8002640:	b480      	push	{r7}
 8002642:	b085      	sub	sp, #20
 8002644:	af00      	add	r7, sp, #0
 8002646:	6078      	str	r0, [r7, #4]
 8002648:	6039      	str	r1, [r7, #0]
   uint_t i;
   uint32_t mask;

   //Initialize mask
   mask = 0;
 800264a:	2300      	movs	r3, #0
 800264c:	60bb      	str	r3, [r7, #8]

   //Compare A and B
   for(i = 0; i < 14; i++)
 800264e:	2300      	movs	r3, #0
 8002650:	60fb      	str	r3, [r7, #12]
 8002652:	e010      	b.n	8002676 <curve448Comp+0x36>
   {
      //Constant time implementation
      mask |= a[i] ^ b[i];
 8002654:	68fb      	ldr	r3, [r7, #12]
 8002656:	009b      	lsls	r3, r3, #2
 8002658:	687a      	ldr	r2, [r7, #4]
 800265a:	4413      	add	r3, r2
 800265c:	681a      	ldr	r2, [r3, #0]
 800265e:	68fb      	ldr	r3, [r7, #12]
 8002660:	009b      	lsls	r3, r3, #2
 8002662:	6839      	ldr	r1, [r7, #0]
 8002664:	440b      	add	r3, r1
 8002666:	681b      	ldr	r3, [r3, #0]
 8002668:	4053      	eors	r3, r2
 800266a:	68ba      	ldr	r2, [r7, #8]
 800266c:	4313      	orrs	r3, r2
 800266e:	60bb      	str	r3, [r7, #8]
   for(i = 0; i < 14; i++)
 8002670:	68fb      	ldr	r3, [r7, #12]
 8002672:	3301      	adds	r3, #1
 8002674:	60fb      	str	r3, [r7, #12]
 8002676:	68fb      	ldr	r3, [r7, #12]
 8002678:	2b0d      	cmp	r3, #13
 800267a:	d9eb      	bls.n	8002654 <curve448Comp+0x14>
   }

   //Return 0 if A = B, else 1
   return ((uint32_t) (mask | (~mask + 1))) >> 31;
 800267c:	68bb      	ldr	r3, [r7, #8]
 800267e:	425a      	negs	r2, r3
 8002680:	68bb      	ldr	r3, [r7, #8]
 8002682:	4313      	orrs	r3, r2
 8002684:	0fdb      	lsrs	r3, r3, #31
}
 8002686:	4618      	mov	r0, r3
 8002688:	3714      	adds	r7, #20
 800268a:	46bd      	mov	sp, r7
 800268c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002690:	4770      	bx	lr

08002692 <curve448Import>:
 * @param[out] a Pointer to resulting integer
 * @param[in] data Octet string to be converted
 **/

void curve448Import(uint32_t *a, const uint8_t *data)
{
 8002692:	b580      	push	{r7, lr}
 8002694:	b084      	sub	sp, #16
 8002696:	af00      	add	r7, sp, #0
 8002698:	6078      	str	r0, [r7, #4]
 800269a:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Import the octet string
   osMemcpy(a, data, 56);
 800269c:	2238      	movs	r2, #56	; 0x38
 800269e:	6839      	ldr	r1, [r7, #0]
 80026a0:	6878      	ldr	r0, [r7, #4]
 80026a2:	f00b ff11 	bl	800e4c8 <memcpy>

   //Convert from little-endian byte order to host byte order
   for(i = 0; i < 14; i++)
 80026a6:	2300      	movs	r3, #0
 80026a8:	60fb      	str	r3, [r7, #12]
 80026aa:	e00c      	b.n	80026c6 <curve448Import+0x34>
   {
      a[i] = letoh32(a[i]);
 80026ac:	68fb      	ldr	r3, [r7, #12]
 80026ae:	009b      	lsls	r3, r3, #2
 80026b0:	687a      	ldr	r2, [r7, #4]
 80026b2:	441a      	add	r2, r3
 80026b4:	68fb      	ldr	r3, [r7, #12]
 80026b6:	009b      	lsls	r3, r3, #2
 80026b8:	6879      	ldr	r1, [r7, #4]
 80026ba:	440b      	add	r3, r1
 80026bc:	6812      	ldr	r2, [r2, #0]
 80026be:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 14; i++)
 80026c0:	68fb      	ldr	r3, [r7, #12]
 80026c2:	3301      	adds	r3, #1
 80026c4:	60fb      	str	r3, [r7, #12]
 80026c6:	68fb      	ldr	r3, [r7, #12]
 80026c8:	2b0d      	cmp	r3, #13
 80026ca:	d9ef      	bls.n	80026ac <curve448Import+0x1a>
   }
}
 80026cc:	bf00      	nop
 80026ce:	bf00      	nop
 80026d0:	3710      	adds	r7, #16
 80026d2:	46bd      	mov	sp, r7
 80026d4:	bd80      	pop	{r7, pc}

080026d6 <curve448Export>:
 * @param[in] a Pointer to the integer to be exported
 * @param[out] data Octet string resulting from the conversion
 **/

void curve448Export(uint32_t *a, uint8_t *data)
{
 80026d6:	b580      	push	{r7, lr}
 80026d8:	b084      	sub	sp, #16
 80026da:	af00      	add	r7, sp, #0
 80026dc:	6078      	str	r0, [r7, #4]
 80026de:	6039      	str	r1, [r7, #0]
   uint_t i;

   //Convert from host byte order to little-endian byte order
   for(i = 0; i < 14; i++)
 80026e0:	2300      	movs	r3, #0
 80026e2:	60fb      	str	r3, [r7, #12]
 80026e4:	e00c      	b.n	8002700 <curve448Export+0x2a>
   {
      a[i] = htole32(a[i]);
 80026e6:	68fb      	ldr	r3, [r7, #12]
 80026e8:	009b      	lsls	r3, r3, #2
 80026ea:	687a      	ldr	r2, [r7, #4]
 80026ec:	441a      	add	r2, r3
 80026ee:	68fb      	ldr	r3, [r7, #12]
 80026f0:	009b      	lsls	r3, r3, #2
 80026f2:	6879      	ldr	r1, [r7, #4]
 80026f4:	440b      	add	r3, r1
 80026f6:	6812      	ldr	r2, [r2, #0]
 80026f8:	601a      	str	r2, [r3, #0]
   for(i = 0; i < 14; i++)
 80026fa:	68fb      	ldr	r3, [r7, #12]
 80026fc:	3301      	adds	r3, #1
 80026fe:	60fb      	str	r3, [r7, #12]
 8002700:	68fb      	ldr	r3, [r7, #12]
 8002702:	2b0d      	cmp	r3, #13
 8002704:	d9ef      	bls.n	80026e6 <curve448Export+0x10>
   }

   //Export the octet string
   osMemcpy(data, a, 56);
 8002706:	2238      	movs	r2, #56	; 0x38
 8002708:	6879      	ldr	r1, [r7, #4]
 800270a:	6838      	ldr	r0, [r7, #0]
 800270c:	f00b fedc 	bl	800e4c8 <memcpy>
}
 8002710:	bf00      	nop
 8002712:	3710      	adds	r7, #16
 8002714:	46bd      	mov	sp, r7
 8002716:	bd80      	pop	{r7, pc}

08002718 <ecInitDomainParameters>:
 * @brief Initialize EC domain parameters
 * @param[in] params Pointer to the EC domain parameters to initialize
 **/

void ecInitDomainParameters(EcDomainParameters *params)
{
 8002718:	b580      	push	{r7, lr}
 800271a:	b082      	sub	sp, #8
 800271c:	af00      	add	r7, sp, #0
 800271e:	6078      	str	r0, [r7, #4]
   //Initialize structure
   params->name = NULL;
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	2200      	movs	r2, #0
 8002724:	601a      	str	r2, [r3, #0]
   params->type = EC_CURVE_TYPE_NONE;
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	2200      	movs	r2, #0
 800272a:	711a      	strb	r2, [r3, #4]
   params->mod = NULL;
 800272c:	687b      	ldr	r3, [r7, #4]
 800272e:	2200      	movs	r2, #0
 8002730:	661a      	str	r2, [r3, #96]	; 0x60

   //Initialize EC domain parameters
   mpiInit(&params->p);
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	3308      	adds	r3, #8
 8002736:	4618      	mov	r0, r3
 8002738:	f004 fb88 	bl	8006e4c <mpiInit>
   mpiInit(&params->a);
 800273c:	687b      	ldr	r3, [r7, #4]
 800273e:	3314      	adds	r3, #20
 8002740:	4618      	mov	r0, r3
 8002742:	f004 fb83 	bl	8006e4c <mpiInit>
   mpiInit(&params->b);
 8002746:	687b      	ldr	r3, [r7, #4]
 8002748:	3320      	adds	r3, #32
 800274a:	4618      	mov	r0, r3
 800274c:	f004 fb7e 	bl	8006e4c <mpiInit>
   ecInit(&params->g);
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	332c      	adds	r3, #44	; 0x2c
 8002754:	4618      	mov	r0, r3
 8002756:	f000 f91b 	bl	8002990 <ecInit>
   mpiInit(&params->q);
 800275a:	687b      	ldr	r3, [r7, #4]
 800275c:	3350      	adds	r3, #80	; 0x50
 800275e:	4618      	mov	r0, r3
 8002760:	f004 fb74 	bl	8006e4c <mpiInit>
}
 8002764:	bf00      	nop
 8002766:	3708      	adds	r7, #8
 8002768:	46bd      	mov	sp, r7
 800276a:	bd80      	pop	{r7, pc}

0800276c <ecLoadDomainParameters>:
 * @return Error code
 **/

error_t ecLoadDomainParameters(EcDomainParameters *params,
   const EcCurveInfo *curveInfo)
{
 800276c:	b580      	push	{r7, lr}
 800276e:	b084      	sub	sp, #16
 8002770:	af00      	add	r7, sp, #0
 8002772:	6078      	str	r0, [r7, #4]
 8002774:	6039      	str	r1, [r7, #0]
   error_t error;

   //Check parameters
   if(params == NULL || curveInfo == NULL)
 8002776:	687b      	ldr	r3, [r7, #4]
 8002778:	2b00      	cmp	r3, #0
 800277a:	d002      	beq.n	8002782 <ecLoadDomainParameters+0x16>
 800277c:	683b      	ldr	r3, [r7, #0]
 800277e:	2b00      	cmp	r3, #0
 8002780:	d101      	bne.n	8002786 <ecLoadDomainParameters+0x1a>
      return ERROR_INVALID_PARAMETER;
 8002782:	2302      	movs	r3, #2
 8002784:	e090      	b.n	80028a8 <ecLoadDomainParameters+0x13c>

   //Debug message
   TRACE_DEBUG("Loading %s EC domain parameters...\r\n", curveInfo->name);

   //Curve name
   params->name = curveInfo->name;
 8002786:	683b      	ldr	r3, [r7, #0]
 8002788:	681a      	ldr	r2, [r3, #0]
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	601a      	str	r2, [r3, #0]
   //Curve type
   params->type = curveInfo->type;
 800278e:	683b      	ldr	r3, [r7, #0]
 8002790:	7b1a      	ldrb	r2, [r3, #12]
 8002792:	687b      	ldr	r3, [r7, #4]
 8002794:	711a      	strb	r2, [r3, #4]

   //Import prime modulus
   MPI_CHECK(mpiReadRaw(&params->p, curveInfo->p, curveInfo->pLen));
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	f103 0008 	add.w	r0, r3, #8
 800279c:	683b      	ldr	r3, [r7, #0]
 800279e:	f103 010d 	add.w	r1, r3, #13
 80027a2:	683b      	ldr	r3, [r7, #0]
 80027a4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80027a6:	2301      	movs	r3, #1
 80027a8:	f004 feb3 	bl	8007512 <mpiImport>
 80027ac:	4603      	mov	r3, r0
 80027ae:	81fb      	strh	r3, [r7, #14]
 80027b0:	89fb      	ldrh	r3, [r7, #14]
 80027b2:	2b00      	cmp	r3, #0
 80027b4:	d16a      	bne.n	800288c <ecLoadDomainParameters+0x120>
   //Import parameter a
   MPI_CHECK(mpiReadRaw(&params->a, curveInfo->a, curveInfo->aLen));
 80027b6:	687b      	ldr	r3, [r7, #4]
 80027b8:	f103 0014 	add.w	r0, r3, #20
 80027bc:	683b      	ldr	r3, [r7, #0]
 80027be:	f103 0154 	add.w	r1, r3, #84	; 0x54
 80027c2:	683b      	ldr	r3, [r7, #0]
 80027c4:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80027c8:	2301      	movs	r3, #1
 80027ca:	f004 fea2 	bl	8007512 <mpiImport>
 80027ce:	4603      	mov	r3, r0
 80027d0:	81fb      	strh	r3, [r7, #14]
 80027d2:	89fb      	ldrh	r3, [r7, #14]
 80027d4:	2b00      	cmp	r3, #0
 80027d6:	d15b      	bne.n	8002890 <ecLoadDomainParameters+0x124>
   //Import parameter b
   MPI_CHECK(mpiReadRaw(&params->b, curveInfo->b, curveInfo->bLen));
 80027d8:	687b      	ldr	r3, [r7, #4]
 80027da:	f103 0020 	add.w	r0, r3, #32
 80027de:	683b      	ldr	r3, [r7, #0]
 80027e0:	f103 019c 	add.w	r1, r3, #156	; 0x9c
 80027e4:	683b      	ldr	r3, [r7, #0]
 80027e6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80027ea:	2301      	movs	r3, #1
 80027ec:	f004 fe91 	bl	8007512 <mpiImport>
 80027f0:	4603      	mov	r3, r0
 80027f2:	81fb      	strh	r3, [r7, #14]
 80027f4:	89fb      	ldrh	r3, [r7, #14]
 80027f6:	2b00      	cmp	r3, #0
 80027f8:	d14c      	bne.n	8002894 <ecLoadDomainParameters+0x128>
   //Import the x-coordinate of the base point G
   MPI_CHECK(mpiReadRaw(&params->g.x, curveInfo->gx, curveInfo->gxLen));
 80027fa:	687b      	ldr	r3, [r7, #4]
 80027fc:	f103 002c 	add.w	r0, r3, #44	; 0x2c
 8002800:	683b      	ldr	r3, [r7, #0]
 8002802:	f103 01e4 	add.w	r1, r3, #228	; 0xe4
 8002806:	683b      	ldr	r3, [r7, #0]
 8002808:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 800280c:	2301      	movs	r3, #1
 800280e:	f004 fe80 	bl	8007512 <mpiImport>
 8002812:	4603      	mov	r3, r0
 8002814:	81fb      	strh	r3, [r7, #14]
 8002816:	89fb      	ldrh	r3, [r7, #14]
 8002818:	2b00      	cmp	r3, #0
 800281a:	d13d      	bne.n	8002898 <ecLoadDomainParameters+0x12c>
   //Import the y-coordinate of the base point G
   MPI_CHECK(mpiReadRaw(&params->g.y, curveInfo->gy, curveInfo->gyLen));
 800281c:	687b      	ldr	r3, [r7, #4]
 800281e:	f103 0038 	add.w	r0, r3, #56	; 0x38
 8002822:	683b      	ldr	r3, [r7, #0]
 8002824:	f503 7196 	add.w	r1, r3, #300	; 0x12c
 8002828:	683b      	ldr	r3, [r7, #0]
 800282a:	f8d3 2170 	ldr.w	r2, [r3, #368]	; 0x170
 800282e:	2301      	movs	r3, #1
 8002830:	f004 fe6f 	bl	8007512 <mpiImport>
 8002834:	4603      	mov	r3, r0
 8002836:	81fb      	strh	r3, [r7, #14]
 8002838:	89fb      	ldrh	r3, [r7, #14]
 800283a:	2b00      	cmp	r3, #0
 800283c:	d12e      	bne.n	800289c <ecLoadDomainParameters+0x130>
   //Import base point order q
   MPI_CHECK(mpiReadRaw(&params->q, curveInfo->q, curveInfo->qLen));
 800283e:	687b      	ldr	r3, [r7, #4]
 8002840:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8002844:	683b      	ldr	r3, [r7, #0]
 8002846:	f503 71ba 	add.w	r1, r3, #372	; 0x174
 800284a:	683b      	ldr	r3, [r7, #0]
 800284c:	f8d3 21b8 	ldr.w	r2, [r3, #440]	; 0x1b8
 8002850:	2301      	movs	r3, #1
 8002852:	f004 fe5e 	bl	8007512 <mpiImport>
 8002856:	4603      	mov	r3, r0
 8002858:	81fb      	strh	r3, [r7, #14]
 800285a:	89fb      	ldrh	r3, [r7, #14]
 800285c:	2b00      	cmp	r3, #0
 800285e:	d11f      	bne.n	80028a0 <ecLoadDomainParameters+0x134>

   //Normalize base point G
   MPI_CHECK(mpiSetValue(&params->g.z, 1));
 8002860:	687b      	ldr	r3, [r7, #4]
 8002862:	3344      	adds	r3, #68	; 0x44
 8002864:	2101      	movs	r1, #1
 8002866:	4618      	mov	r0, r3
 8002868:	f004 fd74 	bl	8007354 <mpiSetValue>
 800286c:	4603      	mov	r3, r0
 800286e:	81fb      	strh	r3, [r7, #14]
 8002870:	89fb      	ldrh	r3, [r7, #14]
 8002872:	2b00      	cmp	r3, #0
 8002874:	d116      	bne.n	80028a4 <ecLoadDomainParameters+0x138>

   //Cofactor h
   params->h = curveInfo->h;
 8002876:	683b      	ldr	r3, [r7, #0]
 8002878:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
 800287c:	687b      	ldr	r3, [r7, #4]
 800287e:	65da      	str	r2, [r3, #92]	; 0x5c
   //Fast modular reduction
   params->mod = curveInfo->mod;
 8002880:	683b      	ldr	r3, [r7, #0]
 8002882:	f8d3 21c0 	ldr.w	r2, [r3, #448]	; 0x1c0
 8002886:	687b      	ldr	r3, [r7, #4]
 8002888:	661a      	str	r2, [r3, #96]	; 0x60
 800288a:	e00c      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->p, curveInfo->p, curveInfo->pLen));
 800288c:	bf00      	nop
 800288e:	e00a      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->a, curveInfo->a, curveInfo->aLen));
 8002890:	bf00      	nop
 8002892:	e008      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->b, curveInfo->b, curveInfo->bLen));
 8002894:	bf00      	nop
 8002896:	e006      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->g.x, curveInfo->gx, curveInfo->gxLen));
 8002898:	bf00      	nop
 800289a:	e004      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->g.y, curveInfo->gy, curveInfo->gyLen));
 800289c:	bf00      	nop
 800289e:	e002      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiReadRaw(&params->q, curveInfo->q, curveInfo->qLen));
 80028a0:	bf00      	nop
 80028a2:	e000      	b.n	80028a6 <ecLoadDomainParameters+0x13a>
   MPI_CHECK(mpiSetValue(&params->g.z, 1));
 80028a4:	bf00      	nop
   TRACE_DEBUG("  q:\r\n");
   TRACE_DEBUG_MPI("    ", &params->q);

end:
   //Return status code
   return error;
 80028a6:	89fb      	ldrh	r3, [r7, #14]
}
 80028a8:	4618      	mov	r0, r3
 80028aa:	3710      	adds	r7, #16
 80028ac:	46bd      	mov	sp, r7
 80028ae:	bd80      	pop	{r7, pc}

080028b0 <ecGenerateKeyPair>:
 **/

__weak_func error_t ecGenerateKeyPair(const PrngAlgo *prngAlgo, void *prngContext,
   const EcDomainParameters *params, EcPrivateKey *privateKey,
   EcPublicKey *publicKey)
{
 80028b0:	b580      	push	{r7, lr}
 80028b2:	b086      	sub	sp, #24
 80028b4:	af00      	add	r7, sp, #0
 80028b6:	60f8      	str	r0, [r7, #12]
 80028b8:	60b9      	str	r1, [r7, #8]
 80028ba:	607a      	str	r2, [r7, #4]
 80028bc:	603b      	str	r3, [r7, #0]
   error_t error;

   //Generate a private key
   error = ecGeneratePrivateKey(prngAlgo, prngContext, params, privateKey);
 80028be:	683b      	ldr	r3, [r7, #0]
 80028c0:	687a      	ldr	r2, [r7, #4]
 80028c2:	68b9      	ldr	r1, [r7, #8]
 80028c4:	68f8      	ldr	r0, [r7, #12]
 80028c6:	f000 f811 	bl	80028ec <ecGeneratePrivateKey>
 80028ca:	4603      	mov	r3, r0
 80028cc:	82fb      	strh	r3, [r7, #22]

   //Check status code
   if(!error)
 80028ce:	8afb      	ldrh	r3, [r7, #22]
 80028d0:	2b00      	cmp	r3, #0
 80028d2:	d106      	bne.n	80028e2 <ecGenerateKeyPair+0x32>
   {
      //Derive the public key from the private key
      error = ecGeneratePublicKey(params, privateKey, publicKey);
 80028d4:	6a3a      	ldr	r2, [r7, #32]
 80028d6:	6839      	ldr	r1, [r7, #0]
 80028d8:	6878      	ldr	r0, [r7, #4]
 80028da:	f000 f82b 	bl	8002934 <ecGeneratePublicKey>
 80028de:	4603      	mov	r3, r0
 80028e0:	82fb      	strh	r3, [r7, #22]
   }

   //Return status code
   return error;
 80028e2:	8afb      	ldrh	r3, [r7, #22]
}
 80028e4:	4618      	mov	r0, r3
 80028e6:	3718      	adds	r7, #24
 80028e8:	46bd      	mov	sp, r7
 80028ea:	bd80      	pop	{r7, pc}

080028ec <ecGeneratePrivateKey>:
 * @return Error code
 **/

error_t ecGeneratePrivateKey(const PrngAlgo *prngAlgo, void *prngContext,
   const EcDomainParameters *params, EcPrivateKey *privateKey)
{
 80028ec:	b580      	push	{r7, lr}
 80028ee:	b086      	sub	sp, #24
 80028f0:	af00      	add	r7, sp, #0
 80028f2:	60f8      	str	r0, [r7, #12]
 80028f4:	60b9      	str	r1, [r7, #8]
 80028f6:	607a      	str	r2, [r7, #4]
 80028f8:	603b      	str	r3, [r7, #0]
   error_t error;

   //Check parameters
   if(prngAlgo == NULL || prngContext == NULL || params == NULL ||
 80028fa:	68fb      	ldr	r3, [r7, #12]
 80028fc:	2b00      	cmp	r3, #0
 80028fe:	d008      	beq.n	8002912 <ecGeneratePrivateKey+0x26>
 8002900:	68bb      	ldr	r3, [r7, #8]
 8002902:	2b00      	cmp	r3, #0
 8002904:	d005      	beq.n	8002912 <ecGeneratePrivateKey+0x26>
 8002906:	687b      	ldr	r3, [r7, #4]
 8002908:	2b00      	cmp	r3, #0
 800290a:	d002      	beq.n	8002912 <ecGeneratePrivateKey+0x26>
 800290c:	683b      	ldr	r3, [r7, #0]
 800290e:	2b00      	cmp	r3, #0
 8002910:	d101      	bne.n	8002916 <ecGeneratePrivateKey+0x2a>
      privateKey == NULL)
   {
      return ERROR_INVALID_PARAMETER;
 8002912:	2302      	movs	r3, #2
 8002914:	e00a      	b.n	800292c <ecGeneratePrivateKey+0x40>
   }

   //Generate a random number d such as 0 < d < q - 1
   error = mpiRandRange(&privateKey->d, &params->q, prngAlgo, prngContext);
 8002916:	6838      	ldr	r0, [r7, #0]
 8002918:	687b      	ldr	r3, [r7, #4]
 800291a:	f103 0150 	add.w	r1, r3, #80	; 0x50
 800291e:	68bb      	ldr	r3, [r7, #8]
 8002920:	68fa      	ldr	r2, [r7, #12]
 8002922:	f004 fd9f 	bl	8007464 <mpiRandRange>
 8002926:	4603      	mov	r3, r0
 8002928:	82fb      	strh	r3, [r7, #22]
      TRACE_DEBUG("  Private key:\r\n");
      TRACE_DEBUG_MPI("    ", &privateKey->d);
   }

   //Return status code
   return error;
 800292a:	8afb      	ldrh	r3, [r7, #22]
}
 800292c:	4618      	mov	r0, r3
 800292e:	3718      	adds	r7, #24
 8002930:	46bd      	mov	sp, r7
 8002932:	bd80      	pop	{r7, pc}

08002934 <ecGeneratePublicKey>:
 * @return Error code
 **/

error_t ecGeneratePublicKey(const EcDomainParameters *params,
   const EcPrivateKey *privateKey, EcPublicKey *publicKey)
{
 8002934:	b580      	push	{r7, lr}
 8002936:	b086      	sub	sp, #24
 8002938:	af00      	add	r7, sp, #0
 800293a:	60f8      	str	r0, [r7, #12]
 800293c:	60b9      	str	r1, [r7, #8]
 800293e:	607a      	str	r2, [r7, #4]
   error_t error;

   //Check parameters
   if(params == NULL || privateKey == NULL || publicKey == NULL)
 8002940:	68fb      	ldr	r3, [r7, #12]
 8002942:	2b00      	cmp	r3, #0
 8002944:	d005      	beq.n	8002952 <ecGeneratePublicKey+0x1e>
 8002946:	68bb      	ldr	r3, [r7, #8]
 8002948:	2b00      	cmp	r3, #0
 800294a:	d002      	beq.n	8002952 <ecGeneratePublicKey+0x1e>
 800294c:	687b      	ldr	r3, [r7, #4]
 800294e:	2b00      	cmp	r3, #0
 8002950:	d101      	bne.n	8002956 <ecGeneratePublicKey+0x22>
      return ERROR_INVALID_PARAMETER;
 8002952:	2302      	movs	r3, #2
 8002954:	e018      	b.n	8002988 <ecGeneratePublicKey+0x54>

   //Compute Q = d.G
   EC_CHECK(ecMult(params, &publicKey->q, &privateKey->d, &params->g));
 8002956:	6879      	ldr	r1, [r7, #4]
 8002958:	68ba      	ldr	r2, [r7, #8]
 800295a:	68fb      	ldr	r3, [r7, #12]
 800295c:	332c      	adds	r3, #44	; 0x2c
 800295e:	68f8      	ldr	r0, [r7, #12]
 8002960:	f001 f8dd 	bl	8003b1e <ecMult>
 8002964:	4603      	mov	r3, r0
 8002966:	82fb      	strh	r3, [r7, #22]
 8002968:	8afb      	ldrh	r3, [r7, #22]
 800296a:	2b00      	cmp	r3, #0
 800296c:	d10a      	bne.n	8002984 <ecGeneratePublicKey+0x50>

   //Convert the public key to affine representation
   EC_CHECK(ecAffinify(params, &publicKey->q, &publicKey->q));
 800296e:	687b      	ldr	r3, [r7, #4]
 8002970:	687a      	ldr	r2, [r7, #4]
 8002972:	4619      	mov	r1, r3
 8002974:	68f8      	ldr	r0, [r7, #12]
 8002976:	f000 f891 	bl	8002a9c <ecAffinify>
 800297a:	4603      	mov	r3, r0
 800297c:	82fb      	strh	r3, [r7, #22]
 800297e:	8afb      	ldrh	r3, [r7, #22]
 8002980:	2b00      	cmp	r3, #0
   TRACE_DEBUG("  Public key X:\r\n");
   TRACE_DEBUG_MPI("    ", &publicKey->q.x);
   TRACE_DEBUG("  Public key Y:\r\n");
   TRACE_DEBUG_MPI("    ", &publicKey->q.y);

end:
 8002982:	e000      	b.n	8002986 <ecGeneratePublicKey+0x52>
   EC_CHECK(ecMult(params, &publicKey->q, &privateKey->d, &params->g));
 8002984:	bf00      	nop
   //Return status code
   return error;
 8002986:	8afb      	ldrh	r3, [r7, #22]
}
 8002988:	4618      	mov	r0, r3
 800298a:	3718      	adds	r7, #24
 800298c:	46bd      	mov	sp, r7
 800298e:	bd80      	pop	{r7, pc}

08002990 <ecInit>:
 * @brief Initialize elliptic curve point
 * @param[in,out] r Pointer to the EC point to be initialized
 **/

void ecInit(EcPoint *r)
{
 8002990:	b580      	push	{r7, lr}
 8002992:	b082      	sub	sp, #8
 8002994:	af00      	add	r7, sp, #0
 8002996:	6078      	str	r0, [r7, #4]
   //Initialize structure
   mpiInit(&r->x);
 8002998:	687b      	ldr	r3, [r7, #4]
 800299a:	4618      	mov	r0, r3
 800299c:	f004 fa56 	bl	8006e4c <mpiInit>
   mpiInit(&r->y);
 80029a0:	687b      	ldr	r3, [r7, #4]
 80029a2:	330c      	adds	r3, #12
 80029a4:	4618      	mov	r0, r3
 80029a6:	f004 fa51 	bl	8006e4c <mpiInit>
   mpiInit(&r->z);
 80029aa:	687b      	ldr	r3, [r7, #4]
 80029ac:	3318      	adds	r3, #24
 80029ae:	4618      	mov	r0, r3
 80029b0:	f004 fa4c 	bl	8006e4c <mpiInit>
}
 80029b4:	bf00      	nop
 80029b6:	3708      	adds	r7, #8
 80029b8:	46bd      	mov	sp, r7
 80029ba:	bd80      	pop	{r7, pc}

080029bc <ecFree>:
 * @brief Release an elliptic curve point
 * @param[in,out] r Pointer to the EC point to initialize to free
 **/

void ecFree(EcPoint *r)
{
 80029bc:	b580      	push	{r7, lr}
 80029be:	b082      	sub	sp, #8
 80029c0:	af00      	add	r7, sp, #0
 80029c2:	6078      	str	r0, [r7, #4]
   //Release previously allocated resources
   mpiFree(&r->x);
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	4618      	mov	r0, r3
 80029c8:	f004 fa53 	bl	8006e72 <mpiFree>
   mpiFree(&r->y);
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	330c      	adds	r3, #12
 80029d0:	4618      	mov	r0, r3
 80029d2:	f004 fa4e 	bl	8006e72 <mpiFree>
   mpiFree(&r->z);
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	3318      	adds	r3, #24
 80029da:	4618      	mov	r0, r3
 80029dc:	f004 fa49 	bl	8006e72 <mpiFree>
}
 80029e0:	bf00      	nop
 80029e2:	3708      	adds	r7, #8
 80029e4:	46bd      	mov	sp, r7
 80029e6:	bd80      	pop	{r7, pc}

080029e8 <ecCopy>:
 * @param[in] s Source EC point
 * @return Error code
 **/

error_t ecCopy(EcPoint *r, const EcPoint *s)
{
 80029e8:	b580      	push	{r7, lr}
 80029ea:	b084      	sub	sp, #16
 80029ec:	af00      	add	r7, sp, #0
 80029ee:	6078      	str	r0, [r7, #4]
 80029f0:	6039      	str	r1, [r7, #0]
   error_t error;

   //R and S are the same instance?
   if(r == s)
 80029f2:	687a      	ldr	r2, [r7, #4]
 80029f4:	683b      	ldr	r3, [r7, #0]
 80029f6:	429a      	cmp	r2, r3
 80029f8:	d101      	bne.n	80029fe <ecCopy+0x16>
      return NO_ERROR;
 80029fa:	2300      	movs	r3, #0
 80029fc:	e02a      	b.n	8002a54 <ecCopy+0x6c>

   //Copy coordinates
   MPI_CHECK(mpiCopy(&r->x, &s->x));
 80029fe:	687b      	ldr	r3, [r7, #4]
 8002a00:	683a      	ldr	r2, [r7, #0]
 8002a02:	4611      	mov	r1, r2
 8002a04:	4618      	mov	r0, r3
 8002a06:	f004 fc70 	bl	80072ea <mpiCopy>
 8002a0a:	4603      	mov	r3, r0
 8002a0c:	81fb      	strh	r3, [r7, #14]
 8002a0e:	89fb      	ldrh	r3, [r7, #14]
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	d11b      	bne.n	8002a4c <ecCopy+0x64>
   MPI_CHECK(mpiCopy(&r->y, &s->y));
 8002a14:	687b      	ldr	r3, [r7, #4]
 8002a16:	f103 020c 	add.w	r2, r3, #12
 8002a1a:	683b      	ldr	r3, [r7, #0]
 8002a1c:	330c      	adds	r3, #12
 8002a1e:	4619      	mov	r1, r3
 8002a20:	4610      	mov	r0, r2
 8002a22:	f004 fc62 	bl	80072ea <mpiCopy>
 8002a26:	4603      	mov	r3, r0
 8002a28:	81fb      	strh	r3, [r7, #14]
 8002a2a:	89fb      	ldrh	r3, [r7, #14]
 8002a2c:	2b00      	cmp	r3, #0
 8002a2e:	d10f      	bne.n	8002a50 <ecCopy+0x68>
   MPI_CHECK(mpiCopy(&r->z, &s->z));
 8002a30:	687b      	ldr	r3, [r7, #4]
 8002a32:	f103 0218 	add.w	r2, r3, #24
 8002a36:	683b      	ldr	r3, [r7, #0]
 8002a38:	3318      	adds	r3, #24
 8002a3a:	4619      	mov	r1, r3
 8002a3c:	4610      	mov	r0, r2
 8002a3e:	f004 fc54 	bl	80072ea <mpiCopy>
 8002a42:	4603      	mov	r3, r0
 8002a44:	81fb      	strh	r3, [r7, #14]
 8002a46:	89fb      	ldrh	r3, [r7, #14]
 8002a48:	2b00      	cmp	r3, #0

end:
 8002a4a:	e002      	b.n	8002a52 <ecCopy+0x6a>
   MPI_CHECK(mpiCopy(&r->x, &s->x));
 8002a4c:	bf00      	nop
 8002a4e:	e000      	b.n	8002a52 <ecCopy+0x6a>
   MPI_CHECK(mpiCopy(&r->y, &s->y));
 8002a50:	bf00      	nop
   //Return status code
   return error;
 8002a52:	89fb      	ldrh	r3, [r7, #14]
}
 8002a54:	4618      	mov	r0, r3
 8002a56:	3710      	adds	r7, #16
 8002a58:	46bd      	mov	sp, r7
 8002a5a:	bd80      	pop	{r7, pc}

08002a5c <ecProjectify>:
 * @return Error code
 **/

error_t ecProjectify(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s)
{
 8002a5c:	b580      	push	{r7, lr}
 8002a5e:	b086      	sub	sp, #24
 8002a60:	af00      	add	r7, sp, #0
 8002a62:	60f8      	str	r0, [r7, #12]
 8002a64:	60b9      	str	r1, [r7, #8]
 8002a66:	607a      	str	r2, [r7, #4]
   error_t error;

   //Copy point
   EC_CHECK(ecCopy(r, s));
 8002a68:	6879      	ldr	r1, [r7, #4]
 8002a6a:	68b8      	ldr	r0, [r7, #8]
 8002a6c:	f7ff ffbc 	bl	80029e8 <ecCopy>
 8002a70:	4603      	mov	r3, r0
 8002a72:	82fb      	strh	r3, [r7, #22]
 8002a74:	8afb      	ldrh	r3, [r7, #22]
 8002a76:	2b00      	cmp	r3, #0
 8002a78:	d10a      	bne.n	8002a90 <ecProjectify+0x34>
   //Map the point to projective space
   MPI_CHECK(mpiSetValue(&r->z, 1));
 8002a7a:	68bb      	ldr	r3, [r7, #8]
 8002a7c:	3318      	adds	r3, #24
 8002a7e:	2101      	movs	r1, #1
 8002a80:	4618      	mov	r0, r3
 8002a82:	f004 fc67 	bl	8007354 <mpiSetValue>
 8002a86:	4603      	mov	r3, r0
 8002a88:	82fb      	strh	r3, [r7, #22]
 8002a8a:	8afb      	ldrh	r3, [r7, #22]
 8002a8c:	2b00      	cmp	r3, #0

end:
 8002a8e:	e000      	b.n	8002a92 <ecProjectify+0x36>
   EC_CHECK(ecCopy(r, s));
 8002a90:	bf00      	nop
   //Return status code
   return error;
 8002a92:	8afb      	ldrh	r3, [r7, #22]
}
 8002a94:	4618      	mov	r0, r3
 8002a96:	3718      	adds	r7, #24
 8002a98:	46bd      	mov	sp, r7
 8002a9a:	bd80      	pop	{r7, pc}

08002a9c <ecAffinify>:
 * @return Error code
 **/

__weak_func error_t ecAffinify(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s)
{
 8002a9c:	b580      	push	{r7, lr}
 8002a9e:	b08c      	sub	sp, #48	; 0x30
 8002aa0:	af00      	add	r7, sp, #0
 8002aa2:	60f8      	str	r0, [r7, #12]
 8002aa4:	60b9      	str	r1, [r7, #8]
 8002aa6:	607a      	str	r2, [r7, #4]
   error_t error;
   Mpi a;
   Mpi b;

   //Point at the infinity?
   if(mpiCompInt(&s->z, 0) == 0)
 8002aa8:	687b      	ldr	r3, [r7, #4]
 8002aaa:	3318      	adds	r3, #24
 8002aac:	2100      	movs	r1, #0
 8002aae:	4618      	mov	r0, r3
 8002ab0:	f004 fbac 	bl	800720c <mpiCompInt>
 8002ab4:	4603      	mov	r3, r0
 8002ab6:	2b00      	cmp	r3, #0
 8002ab8:	d101      	bne.n	8002abe <ecAffinify+0x22>
      return ERROR_INVALID_PARAMETER;
 8002aba:	2302      	movs	r3, #2
 8002abc:	e06e      	b.n	8002b9c <ecAffinify+0x100>

   //Initialize multiple precision integers
   mpiInit(&a);
 8002abe:	f107 0320 	add.w	r3, r7, #32
 8002ac2:	4618      	mov	r0, r3
 8002ac4:	f004 f9c2 	bl	8006e4c <mpiInit>
   mpiInit(&b);
 8002ac8:	f107 0314 	add.w	r3, r7, #20
 8002acc:	4618      	mov	r0, r3
 8002ace:	f004 f9bd 	bl	8006e4c <mpiInit>

   //Compute a = 1/Sz mod p
   MPI_CHECK(mpiInvMod(&a, &s->z, &params->p));
 8002ad2:	687b      	ldr	r3, [r7, #4]
 8002ad4:	f103 0118 	add.w	r1, r3, #24
 8002ad8:	68fb      	ldr	r3, [r7, #12]
 8002ada:	f103 0208 	add.w	r2, r3, #8
 8002ade:	f107 0320 	add.w	r3, r7, #32
 8002ae2:	4618      	mov	r0, r3
 8002ae4:	f005 fba3 	bl	800822e <mpiInvMod>
 8002ae8:	4603      	mov	r3, r0
 8002aea:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002aec:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002aee:	2b00      	cmp	r3, #0
 8002af0:	d140      	bne.n	8002b74 <ecAffinify+0xd8>

   //Set Rx = a^2 * Sx mod p
   EC_CHECK(ecSqrMod(params, &b, &a));
 8002af2:	f107 0220 	add.w	r2, r7, #32
 8002af6:	f107 0314 	add.w	r3, r7, #20
 8002afa:	4619      	mov	r1, r3
 8002afc:	68f8      	ldr	r0, [r7, #12]
 8002afe:	f001 fa02 	bl	8003f06 <ecSqrMod>
 8002b02:	4603      	mov	r3, r0
 8002b04:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002b06:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002b08:	2b00      	cmp	r3, #0
 8002b0a:	d135      	bne.n	8002b78 <ecAffinify+0xdc>
   EC_CHECK(ecMulMod(params, &r->x, &b, &s->x));
 8002b0c:	68b9      	ldr	r1, [r7, #8]
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	f107 0214 	add.w	r2, r7, #20
 8002b14:	68f8      	ldr	r0, [r7, #12]
 8002b16:	f001 f9c3 	bl	8003ea0 <ecMulMod>
 8002b1a:	4603      	mov	r3, r0
 8002b1c:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002b1e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002b20:	2b00      	cmp	r3, #0
 8002b22:	d12b      	bne.n	8002b7c <ecAffinify+0xe0>

   //Set Ry = a^3 * Sy mod p
   EC_CHECK(ecMulMod(params, &b, &b, &a));
 8002b24:	f107 0320 	add.w	r3, r7, #32
 8002b28:	f107 0214 	add.w	r2, r7, #20
 8002b2c:	f107 0114 	add.w	r1, r7, #20
 8002b30:	68f8      	ldr	r0, [r7, #12]
 8002b32:	f001 f9b5 	bl	8003ea0 <ecMulMod>
 8002b36:	4603      	mov	r3, r0
 8002b38:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002b3a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002b3c:	2b00      	cmp	r3, #0
 8002b3e:	d11f      	bne.n	8002b80 <ecAffinify+0xe4>
   EC_CHECK(ecMulMod(params, &r->y, &b, &s->y));
 8002b40:	68bb      	ldr	r3, [r7, #8]
 8002b42:	f103 010c 	add.w	r1, r3, #12
 8002b46:	687b      	ldr	r3, [r7, #4]
 8002b48:	330c      	adds	r3, #12
 8002b4a:	f107 0214 	add.w	r2, r7, #20
 8002b4e:	68f8      	ldr	r0, [r7, #12]
 8002b50:	f001 f9a6 	bl	8003ea0 <ecMulMod>
 8002b54:	4603      	mov	r3, r0
 8002b56:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002b58:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002b5a:	2b00      	cmp	r3, #0
 8002b5c:	d112      	bne.n	8002b84 <ecAffinify+0xe8>

   //Set Rz = 1
   MPI_CHECK(mpiSetValue(&r->z, 1));
 8002b5e:	68bb      	ldr	r3, [r7, #8]
 8002b60:	3318      	adds	r3, #24
 8002b62:	2101      	movs	r1, #1
 8002b64:	4618      	mov	r0, r3
 8002b66:	f004 fbf5 	bl	8007354 <mpiSetValue>
 8002b6a:	4603      	mov	r3, r0
 8002b6c:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8002b6e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8002b70:	2b00      	cmp	r3, #0

end:
 8002b72:	e008      	b.n	8002b86 <ecAffinify+0xea>
   MPI_CHECK(mpiInvMod(&a, &s->z, &params->p));
 8002b74:	bf00      	nop
 8002b76:	e006      	b.n	8002b86 <ecAffinify+0xea>
   EC_CHECK(ecSqrMod(params, &b, &a));
 8002b78:	bf00      	nop
 8002b7a:	e004      	b.n	8002b86 <ecAffinify+0xea>
   EC_CHECK(ecMulMod(params, &r->x, &b, &s->x));
 8002b7c:	bf00      	nop
 8002b7e:	e002      	b.n	8002b86 <ecAffinify+0xea>
   EC_CHECK(ecMulMod(params, &b, &b, &a));
 8002b80:	bf00      	nop
 8002b82:	e000      	b.n	8002b86 <ecAffinify+0xea>
   EC_CHECK(ecMulMod(params, &r->y, &b, &s->y));
 8002b84:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&a);
 8002b86:	f107 0320 	add.w	r3, r7, #32
 8002b8a:	4618      	mov	r0, r3
 8002b8c:	f004 f971 	bl	8006e72 <mpiFree>
   mpiFree(&b);
 8002b90:	f107 0314 	add.w	r3, r7, #20
 8002b94:	4618      	mov	r0, r3
 8002b96:	f004 f96c 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8002b9a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
}
 8002b9c:	4618      	mov	r0, r3
 8002b9e:	3730      	adds	r7, #48	; 0x30
 8002ba0:	46bd      	mov	sp, r7
 8002ba2:	bd80      	pop	{r7, pc}

08002ba4 <ecDouble>:
 * @return Error code
 **/

error_t ecDouble(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s)
{
 8002ba4:	b580      	push	{r7, lr}
 8002ba6:	b094      	sub	sp, #80	; 0x50
 8002ba8:	af00      	add	r7, sp, #0
 8002baa:	60f8      	str	r0, [r7, #12]
 8002bac:	60b9      	str	r1, [r7, #8]
 8002bae:	607a      	str	r2, [r7, #4]
   Mpi t3;
   Mpi t4;
   Mpi t5;

   //Initialize multiple precision integers
   mpiInit(&t1);
 8002bb0:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002bb4:	4618      	mov	r0, r3
 8002bb6:	f004 f949 	bl	8006e4c <mpiInit>
   mpiInit(&t2);
 8002bba:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002bbe:	4618      	mov	r0, r3
 8002bc0:	f004 f944 	bl	8006e4c <mpiInit>
   mpiInit(&t3);
 8002bc4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8002bc8:	4618      	mov	r0, r3
 8002bca:	f004 f93f 	bl	8006e4c <mpiInit>
   mpiInit(&t4);
 8002bce:	f107 031c 	add.w	r3, r7, #28
 8002bd2:	4618      	mov	r0, r3
 8002bd4:	f004 f93a 	bl	8006e4c <mpiInit>
   mpiInit(&t5);
 8002bd8:	f107 0310 	add.w	r3, r7, #16
 8002bdc:	4618      	mov	r0, r3
 8002bde:	f004 f935 	bl	8006e4c <mpiInit>

   //Set t1 = Sx
   MPI_CHECK(mpiCopy(&t1, &s->x));
 8002be2:	687a      	ldr	r2, [r7, #4]
 8002be4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002be8:	4611      	mov	r1, r2
 8002bea:	4618      	mov	r0, r3
 8002bec:	f004 fb7d 	bl	80072ea <mpiCopy>
 8002bf0:	4603      	mov	r3, r0
 8002bf2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002bf6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002bfa:	2b00      	cmp	r3, #0
 8002bfc:	f040 829e 	bne.w	800313c <ecDouble+0x598>
   //Set t2 = Sy
   MPI_CHECK(mpiCopy(&t2, &s->y));
 8002c00:	687b      	ldr	r3, [r7, #4]
 8002c02:	f103 020c 	add.w	r2, r3, #12
 8002c06:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002c0a:	4611      	mov	r1, r2
 8002c0c:	4618      	mov	r0, r3
 8002c0e:	f004 fb6c 	bl	80072ea <mpiCopy>
 8002c12:	4603      	mov	r3, r0
 8002c14:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002c18:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002c1c:	2b00      	cmp	r3, #0
 8002c1e:	f040 828f 	bne.w	8003140 <ecDouble+0x59c>
   //Set t3 = Sz
   MPI_CHECK(mpiCopy(&t3, &s->z));
 8002c22:	687b      	ldr	r3, [r7, #4]
 8002c24:	f103 0218 	add.w	r2, r3, #24
 8002c28:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8002c2c:	4611      	mov	r1, r2
 8002c2e:	4618      	mov	r0, r3
 8002c30:	f004 fb5b 	bl	80072ea <mpiCopy>
 8002c34:	4603      	mov	r3, r0
 8002c36:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002c3a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002c3e:	2b00      	cmp	r3, #0
 8002c40:	f040 8280 	bne.w	8003144 <ecDouble+0x5a0>

   //Point at the infinity?
   if(mpiCompInt(&t3, 0) == 0)
 8002c44:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8002c48:	2100      	movs	r1, #0
 8002c4a:	4618      	mov	r0, r3
 8002c4c:	f004 fade 	bl	800720c <mpiCompInt>
 8002c50:	4603      	mov	r3, r0
 8002c52:	2b00      	cmp	r3, #0
 8002c54:	d127      	bne.n	8002ca6 <ecDouble+0x102>
   {
      //Set R = (1, 1, 0)
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8002c56:	68bb      	ldr	r3, [r7, #8]
 8002c58:	2101      	movs	r1, #1
 8002c5a:	4618      	mov	r0, r3
 8002c5c:	f004 fb7a 	bl	8007354 <mpiSetValue>
 8002c60:	4603      	mov	r3, r0
 8002c62:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002c66:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	f040 826c 	bne.w	8003148 <ecDouble+0x5a4>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 8002c70:	68bb      	ldr	r3, [r7, #8]
 8002c72:	330c      	adds	r3, #12
 8002c74:	2101      	movs	r1, #1
 8002c76:	4618      	mov	r0, r3
 8002c78:	f004 fb6c 	bl	8007354 <mpiSetValue>
 8002c7c:	4603      	mov	r3, r0
 8002c7e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002c82:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002c86:	2b00      	cmp	r3, #0
 8002c88:	f040 8260 	bne.w	800314c <ecDouble+0x5a8>
      MPI_CHECK(mpiSetValue(&r->z, 0));
 8002c8c:	68bb      	ldr	r3, [r7, #8]
 8002c8e:	3318      	adds	r3, #24
 8002c90:	2100      	movs	r1, #0
 8002c92:	4618      	mov	r0, r3
 8002c94:	f004 fb5e 	bl	8007354 <mpiSetValue>
 8002c98:	4603      	mov	r3, r0
 8002c9a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002c9e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002ca2:	2b00      	cmp	r3, #0
 8002ca4:	e293      	b.n	80031ce <ecDouble+0x62a>
   }
   else
   {
      //SECP K1 elliptic curve?
      if(params->type == EC_CURVE_TYPE_SECP_K1)
 8002ca6:	68fb      	ldr	r3, [r7, #12]
 8002ca8:	791b      	ldrb	r3, [r3, #4]
 8002caa:	2b04      	cmp	r3, #4
 8002cac:	d132      	bne.n	8002d14 <ecDouble+0x170>
      {
         //Compute t5 = t1^2
         EC_CHECK(ecSqrMod(params, &t5, &t1));
 8002cae:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002cb2:	f107 0310 	add.w	r3, r7, #16
 8002cb6:	4619      	mov	r1, r3
 8002cb8:	68f8      	ldr	r0, [r7, #12]
 8002cba:	f001 f924 	bl	8003f06 <ecSqrMod>
 8002cbe:	4603      	mov	r3, r0
 8002cc0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002cc4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002cc8:	2b00      	cmp	r3, #0
 8002cca:	f040 8241 	bne.w	8003150 <ecDouble+0x5ac>
         //Compute t4 = 3 * t5
         EC_CHECK(ecAddMod(params, &t4, &t5, &t5));
 8002cce:	f107 0310 	add.w	r3, r7, #16
 8002cd2:	f107 0210 	add.w	r2, r7, #16
 8002cd6:	f107 011c 	add.w	r1, r7, #28
 8002cda:	68f8      	ldr	r0, [r7, #12]
 8002cdc:	f001 f886 	bl	8003dec <ecAddMod>
 8002ce0:	4603      	mov	r3, r0
 8002ce2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ce6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002cea:	2b00      	cmp	r3, #0
 8002cec:	f040 8232 	bne.w	8003154 <ecDouble+0x5b0>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8002cf0:	f107 0310 	add.w	r3, r7, #16
 8002cf4:	f107 021c 	add.w	r2, r7, #28
 8002cf8:	f107 011c 	add.w	r1, r7, #28
 8002cfc:	68f8      	ldr	r0, [r7, #12]
 8002cfe:	f001 f875 	bl	8003dec <ecAddMod>
 8002d02:	4603      	mov	r3, r0
 8002d04:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002d08:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002d0c:	2b00      	cmp	r3, #0
 8002d0e:	f000 80de 	beq.w	8002ece <ecDouble+0x32a>
 8002d12:	e25c      	b.n	80031ce <ecDouble+0x62a>
      }
      //SECP R1 elliptic curve?
      else if(params->type == EC_CURVE_TYPE_SECP_R1)
 8002d14:	68fb      	ldr	r3, [r7, #12]
 8002d16:	791b      	ldrb	r3, [r3, #4]
 8002d18:	2b05      	cmp	r3, #5
 8002d1a:	d164      	bne.n	8002de6 <ecDouble+0x242>
      {
         //Compute t4 = t3^2
         EC_CHECK(ecSqrMod(params, &t4, &t3));
 8002d1c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8002d20:	f107 031c 	add.w	r3, r7, #28
 8002d24:	4619      	mov	r1, r3
 8002d26:	68f8      	ldr	r0, [r7, #12]
 8002d28:	f001 f8ed 	bl	8003f06 <ecSqrMod>
 8002d2c:	4603      	mov	r3, r0
 8002d2e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002d32:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002d36:	2b00      	cmp	r3, #0
 8002d38:	f040 820e 	bne.w	8003158 <ecDouble+0x5b4>
         //Compute t5 = t1 - t4
         EC_CHECK(ecSubMod(params, &t5, &t1, &t4));
 8002d3c:	f107 031c 	add.w	r3, r7, #28
 8002d40:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002d44:	f107 0110 	add.w	r1, r7, #16
 8002d48:	68f8      	ldr	r0, [r7, #12]
 8002d4a:	f001 f87d 	bl	8003e48 <ecSubMod>
 8002d4e:	4603      	mov	r3, r0
 8002d50:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002d54:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002d58:	2b00      	cmp	r3, #0
 8002d5a:	f040 81ff 	bne.w	800315c <ecDouble+0x5b8>
         //Compute t4 = t1 + t4
         EC_CHECK(ecAddMod(params, &t4, &t1, &t4));
 8002d5e:	f107 031c 	add.w	r3, r7, #28
 8002d62:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002d66:	f107 011c 	add.w	r1, r7, #28
 8002d6a:	68f8      	ldr	r0, [r7, #12]
 8002d6c:	f001 f83e 	bl	8003dec <ecAddMod>
 8002d70:	4603      	mov	r3, r0
 8002d72:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002d76:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002d7a:	2b00      	cmp	r3, #0
 8002d7c:	f040 81f0 	bne.w	8003160 <ecDouble+0x5bc>
         //Compute t5 = t4 * t5
         EC_CHECK(ecMulMod(params, &t5, &t4, &t5));
 8002d80:	f107 0310 	add.w	r3, r7, #16
 8002d84:	f107 021c 	add.w	r2, r7, #28
 8002d88:	f107 0110 	add.w	r1, r7, #16
 8002d8c:	68f8      	ldr	r0, [r7, #12]
 8002d8e:	f001 f887 	bl	8003ea0 <ecMulMod>
 8002d92:	4603      	mov	r3, r0
 8002d94:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002d98:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002d9c:	2b00      	cmp	r3, #0
 8002d9e:	f040 81e1 	bne.w	8003164 <ecDouble+0x5c0>
         //Compute t4 = 3 * t5
         EC_CHECK(ecAddMod(params, &t4, &t5, &t5));
 8002da2:	f107 0310 	add.w	r3, r7, #16
 8002da6:	f107 0210 	add.w	r2, r7, #16
 8002daa:	f107 011c 	add.w	r1, r7, #28
 8002dae:	68f8      	ldr	r0, [r7, #12]
 8002db0:	f001 f81c 	bl	8003dec <ecAddMod>
 8002db4:	4603      	mov	r3, r0
 8002db6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002dba:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002dbe:	2b00      	cmp	r3, #0
 8002dc0:	f040 81d2 	bne.w	8003168 <ecDouble+0x5c4>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8002dc4:	f107 0310 	add.w	r3, r7, #16
 8002dc8:	f107 021c 	add.w	r2, r7, #28
 8002dcc:	f107 011c 	add.w	r1, r7, #28
 8002dd0:	68f8      	ldr	r0, [r7, #12]
 8002dd2:	f001 f80b 	bl	8003dec <ecAddMod>
 8002dd6:	4603      	mov	r3, r0
 8002dd8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ddc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002de0:	2b00      	cmp	r3, #0
 8002de2:	d074      	beq.n	8002ece <ecDouble+0x32a>
 8002de4:	e1f3      	b.n	80031ce <ecDouble+0x62a>
      }
      else
      {
         //Compute t4 = t3^4
         EC_CHECK(ecSqrMod(params, &t4, &t3));
 8002de6:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8002dea:	f107 031c 	add.w	r3, r7, #28
 8002dee:	4619      	mov	r1, r3
 8002df0:	68f8      	ldr	r0, [r7, #12]
 8002df2:	f001 f888 	bl	8003f06 <ecSqrMod>
 8002df6:	4603      	mov	r3, r0
 8002df8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002dfc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002e00:	2b00      	cmp	r3, #0
 8002e02:	f040 81b3 	bne.w	800316c <ecDouble+0x5c8>
         EC_CHECK(ecSqrMod(params, &t4, &t4));
 8002e06:	f107 021c 	add.w	r2, r7, #28
 8002e0a:	f107 031c 	add.w	r3, r7, #28
 8002e0e:	4619      	mov	r1, r3
 8002e10:	68f8      	ldr	r0, [r7, #12]
 8002e12:	f001 f878 	bl	8003f06 <ecSqrMod>
 8002e16:	4603      	mov	r3, r0
 8002e18:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002e1c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002e20:	2b00      	cmp	r3, #0
 8002e22:	f040 81a5 	bne.w	8003170 <ecDouble+0x5cc>
         //Compute t4 = a * t4
         EC_CHECK(ecMulMod(params, &t4, &t4, &params->a));
 8002e26:	68fb      	ldr	r3, [r7, #12]
 8002e28:	3314      	adds	r3, #20
 8002e2a:	f107 021c 	add.w	r2, r7, #28
 8002e2e:	f107 011c 	add.w	r1, r7, #28
 8002e32:	68f8      	ldr	r0, [r7, #12]
 8002e34:	f001 f834 	bl	8003ea0 <ecMulMod>
 8002e38:	4603      	mov	r3, r0
 8002e3a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002e3e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002e42:	2b00      	cmp	r3, #0
 8002e44:	f040 8196 	bne.w	8003174 <ecDouble+0x5d0>
         //Compute t5 = t1^2
         EC_CHECK(ecSqrMod(params, &t5, &t1));
 8002e48:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002e4c:	f107 0310 	add.w	r3, r7, #16
 8002e50:	4619      	mov	r1, r3
 8002e52:	68f8      	ldr	r0, [r7, #12]
 8002e54:	f001 f857 	bl	8003f06 <ecSqrMod>
 8002e58:	4603      	mov	r3, r0
 8002e5a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002e5e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002e62:	2b00      	cmp	r3, #0
 8002e64:	f040 8188 	bne.w	8003178 <ecDouble+0x5d4>
         //Compute t4 = t4 + 3 * t5
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8002e68:	f107 0310 	add.w	r3, r7, #16
 8002e6c:	f107 021c 	add.w	r2, r7, #28
 8002e70:	f107 011c 	add.w	r1, r7, #28
 8002e74:	68f8      	ldr	r0, [r7, #12]
 8002e76:	f000 ffb9 	bl	8003dec <ecAddMod>
 8002e7a:	4603      	mov	r3, r0
 8002e7c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002e80:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002e84:	2b00      	cmp	r3, #0
 8002e86:	f040 8179 	bne.w	800317c <ecDouble+0x5d8>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8002e8a:	f107 0310 	add.w	r3, r7, #16
 8002e8e:	f107 021c 	add.w	r2, r7, #28
 8002e92:	f107 011c 	add.w	r1, r7, #28
 8002e96:	68f8      	ldr	r0, [r7, #12]
 8002e98:	f000 ffa8 	bl	8003dec <ecAddMod>
 8002e9c:	4603      	mov	r3, r0
 8002e9e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ea2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002ea6:	2b00      	cmp	r3, #0
 8002ea8:	f040 816a 	bne.w	8003180 <ecDouble+0x5dc>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8002eac:	f107 0310 	add.w	r3, r7, #16
 8002eb0:	f107 021c 	add.w	r2, r7, #28
 8002eb4:	f107 011c 	add.w	r1, r7, #28
 8002eb8:	68f8      	ldr	r0, [r7, #12]
 8002eba:	f000 ff97 	bl	8003dec <ecAddMod>
 8002ebe:	4603      	mov	r3, r0
 8002ec0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ec4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002ec8:	2b00      	cmp	r3, #0
 8002eca:	f040 815b 	bne.w	8003184 <ecDouble+0x5e0>
      }

      //Compute t3 = t3 * t2
      EC_CHECK(ecMulMod(params, &t3, &t3, &t2));
 8002ece:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002ed2:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8002ed6:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8002eda:	68f8      	ldr	r0, [r7, #12]
 8002edc:	f000 ffe0 	bl	8003ea0 <ecMulMod>
 8002ee0:	4603      	mov	r3, r0
 8002ee2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ee6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002eea:	2b00      	cmp	r3, #0
 8002eec:	f040 814c 	bne.w	8003188 <ecDouble+0x5e4>
      //Compute t3 = 2 * t3
      EC_CHECK(ecAddMod(params, &t3, &t3, &t3));
 8002ef0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8002ef4:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8002ef8:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8002efc:	68f8      	ldr	r0, [r7, #12]
 8002efe:	f000 ff75 	bl	8003dec <ecAddMod>
 8002f02:	4603      	mov	r3, r0
 8002f04:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002f08:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002f0c:	2b00      	cmp	r3, #0
 8002f0e:	f040 813d 	bne.w	800318c <ecDouble+0x5e8>
      //Compute t2 = t2^2
      EC_CHECK(ecSqrMod(params, &t2, &t2));
 8002f12:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8002f16:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002f1a:	4619      	mov	r1, r3
 8002f1c:	68f8      	ldr	r0, [r7, #12]
 8002f1e:	f000 fff2 	bl	8003f06 <ecSqrMod>
 8002f22:	4603      	mov	r3, r0
 8002f24:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002f28:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002f2c:	2b00      	cmp	r3, #0
 8002f2e:	f040 812f 	bne.w	8003190 <ecDouble+0x5ec>
      //Compute t5 = t1 * t2
      EC_CHECK(ecMulMod(params, &t5, &t1, &t2));
 8002f32:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8002f36:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002f3a:	f107 0110 	add.w	r1, r7, #16
 8002f3e:	68f8      	ldr	r0, [r7, #12]
 8002f40:	f000 ffae 	bl	8003ea0 <ecMulMod>
 8002f44:	4603      	mov	r3, r0
 8002f46:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002f4a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002f4e:	2b00      	cmp	r3, #0
 8002f50:	f040 8120 	bne.w	8003194 <ecDouble+0x5f0>
      //Compute t5 = 4 * t5
      EC_CHECK(ecAddMod(params, &t5, &t5, &t5));
 8002f54:	f107 0310 	add.w	r3, r7, #16
 8002f58:	f107 0210 	add.w	r2, r7, #16
 8002f5c:	f107 0110 	add.w	r1, r7, #16
 8002f60:	68f8      	ldr	r0, [r7, #12]
 8002f62:	f000 ff43 	bl	8003dec <ecAddMod>
 8002f66:	4603      	mov	r3, r0
 8002f68:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002f6c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002f70:	2b00      	cmp	r3, #0
 8002f72:	f040 8111 	bne.w	8003198 <ecDouble+0x5f4>
      EC_CHECK(ecAddMod(params, &t5, &t5, &t5));
 8002f76:	f107 0310 	add.w	r3, r7, #16
 8002f7a:	f107 0210 	add.w	r2, r7, #16
 8002f7e:	f107 0110 	add.w	r1, r7, #16
 8002f82:	68f8      	ldr	r0, [r7, #12]
 8002f84:	f000 ff32 	bl	8003dec <ecAddMod>
 8002f88:	4603      	mov	r3, r0
 8002f8a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002f8e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002f92:	2b00      	cmp	r3, #0
 8002f94:	f040 8102 	bne.w	800319c <ecDouble+0x5f8>
      //Compute t1 = t4^2
      EC_CHECK(ecSqrMod(params, &t1, &t4));
 8002f98:	f107 021c 	add.w	r2, r7, #28
 8002f9c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002fa0:	4619      	mov	r1, r3
 8002fa2:	68f8      	ldr	r0, [r7, #12]
 8002fa4:	f000 ffaf 	bl	8003f06 <ecSqrMod>
 8002fa8:	4603      	mov	r3, r0
 8002faa:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002fae:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002fb2:	2b00      	cmp	r3, #0
 8002fb4:	f040 80f4 	bne.w	80031a0 <ecDouble+0x5fc>
      //Compute t1 = t1 - 2 * t5
      EC_CHECK(ecSubMod(params, &t1, &t1, &t5));
 8002fb8:	f107 0310 	add.w	r3, r7, #16
 8002fbc:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002fc0:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002fc4:	68f8      	ldr	r0, [r7, #12]
 8002fc6:	f000 ff3f 	bl	8003e48 <ecSubMod>
 8002fca:	4603      	mov	r3, r0
 8002fcc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002fd0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002fd4:	2b00      	cmp	r3, #0
 8002fd6:	f040 80e5 	bne.w	80031a4 <ecDouble+0x600>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t5));
 8002fda:	f107 0310 	add.w	r3, r7, #16
 8002fde:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002fe2:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8002fe6:	68f8      	ldr	r0, [r7, #12]
 8002fe8:	f000 ff2e 	bl	8003e48 <ecSubMod>
 8002fec:	4603      	mov	r3, r0
 8002fee:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8002ff2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8002ff6:	2b00      	cmp	r3, #0
 8002ff8:	f040 80d6 	bne.w	80031a8 <ecDouble+0x604>
      //Compute t2 = t2^2
      EC_CHECK(ecSqrMod(params, &t2, &t2));
 8002ffc:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003000:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003004:	4619      	mov	r1, r3
 8003006:	68f8      	ldr	r0, [r7, #12]
 8003008:	f000 ff7d 	bl	8003f06 <ecSqrMod>
 800300c:	4603      	mov	r3, r0
 800300e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003012:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8003016:	2b00      	cmp	r3, #0
 8003018:	f040 80c8 	bne.w	80031ac <ecDouble+0x608>
      //Compute t2 = 8 * t2
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 800301c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003020:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003024:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8003028:	68f8      	ldr	r0, [r7, #12]
 800302a:	f000 fedf 	bl	8003dec <ecAddMod>
 800302e:	4603      	mov	r3, r0
 8003030:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003034:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8003038:	2b00      	cmp	r3, #0
 800303a:	f040 80b9 	bne.w	80031b0 <ecDouble+0x60c>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 800303e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003042:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003046:	f107 0134 	add.w	r1, r7, #52	; 0x34
 800304a:	68f8      	ldr	r0, [r7, #12]
 800304c:	f000 fece 	bl	8003dec <ecAddMod>
 8003050:	4603      	mov	r3, r0
 8003052:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003056:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800305a:	2b00      	cmp	r3, #0
 800305c:	f040 80aa 	bne.w	80031b4 <ecDouble+0x610>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 8003060:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003064:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003068:	f107 0134 	add.w	r1, r7, #52	; 0x34
 800306c:	68f8      	ldr	r0, [r7, #12]
 800306e:	f000 febd 	bl	8003dec <ecAddMod>
 8003072:	4603      	mov	r3, r0
 8003074:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003078:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800307c:	2b00      	cmp	r3, #0
 800307e:	f040 809b 	bne.w	80031b8 <ecDouble+0x614>
      //Compute t5 = t5 - t1
      EC_CHECK(ecSubMod(params, &t5, &t5, &t1));
 8003082:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8003086:	f107 0210 	add.w	r2, r7, #16
 800308a:	f107 0110 	add.w	r1, r7, #16
 800308e:	68f8      	ldr	r0, [r7, #12]
 8003090:	f000 feda 	bl	8003e48 <ecSubMod>
 8003094:	4603      	mov	r3, r0
 8003096:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 800309a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800309e:	2b00      	cmp	r3, #0
 80030a0:	f040 808c 	bne.w	80031bc <ecDouble+0x618>
      //Compute t5 = t4 * t5
      EC_CHECK(ecMulMod(params, &t5, &t4, &t5));
 80030a4:	f107 0310 	add.w	r3, r7, #16
 80030a8:	f107 021c 	add.w	r2, r7, #28
 80030ac:	f107 0110 	add.w	r1, r7, #16
 80030b0:	68f8      	ldr	r0, [r7, #12]
 80030b2:	f000 fef5 	bl	8003ea0 <ecMulMod>
 80030b6:	4603      	mov	r3, r0
 80030b8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 80030bc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80030c0:	2b00      	cmp	r3, #0
 80030c2:	d17d      	bne.n	80031c0 <ecDouble+0x61c>
      //Compute t2 = t5 - t2
      EC_CHECK(ecSubMod(params, &t2, &t5, &t2));
 80030c4:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80030c8:	f107 0210 	add.w	r2, r7, #16
 80030cc:	f107 0134 	add.w	r1, r7, #52	; 0x34
 80030d0:	68f8      	ldr	r0, [r7, #12]
 80030d2:	f000 feb9 	bl	8003e48 <ecSubMod>
 80030d6:	4603      	mov	r3, r0
 80030d8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 80030dc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80030e0:	2b00      	cmp	r3, #0
 80030e2:	d16f      	bne.n	80031c4 <ecDouble+0x620>

      //Set Rx = t1
      MPI_CHECK(mpiCopy(&r->x, &t1));
 80030e4:	68bb      	ldr	r3, [r7, #8]
 80030e6:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80030ea:	4611      	mov	r1, r2
 80030ec:	4618      	mov	r0, r3
 80030ee:	f004 f8fc 	bl	80072ea <mpiCopy>
 80030f2:	4603      	mov	r3, r0
 80030f4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 80030f8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80030fc:	2b00      	cmp	r3, #0
 80030fe:	d163      	bne.n	80031c8 <ecDouble+0x624>
      //Set Ry = t2
      MPI_CHECK(mpiCopy(&r->y, &t2));
 8003100:	68bb      	ldr	r3, [r7, #8]
 8003102:	330c      	adds	r3, #12
 8003104:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003108:	4611      	mov	r1, r2
 800310a:	4618      	mov	r0, r3
 800310c:	f004 f8ed 	bl	80072ea <mpiCopy>
 8003110:	4603      	mov	r3, r0
 8003112:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003116:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800311a:	2b00      	cmp	r3, #0
 800311c:	d156      	bne.n	80031cc <ecDouble+0x628>
      //Set Rz = t3
      MPI_CHECK(mpiCopy(&r->z, &t3));
 800311e:	68bb      	ldr	r3, [r7, #8]
 8003120:	3318      	adds	r3, #24
 8003122:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8003126:	4611      	mov	r1, r2
 8003128:	4618      	mov	r0, r3
 800312a:	f004 f8de 	bl	80072ea <mpiCopy>
 800312e:	4603      	mov	r3, r0
 8003130:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8003134:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8003138:	2b00      	cmp	r3, #0
   }

end:
 800313a:	e048      	b.n	80031ce <ecDouble+0x62a>
   MPI_CHECK(mpiCopy(&t1, &s->x));
 800313c:	bf00      	nop
 800313e:	e046      	b.n	80031ce <ecDouble+0x62a>
   MPI_CHECK(mpiCopy(&t2, &s->y));
 8003140:	bf00      	nop
 8003142:	e044      	b.n	80031ce <ecDouble+0x62a>
   MPI_CHECK(mpiCopy(&t3, &s->z));
 8003144:	bf00      	nop
 8003146:	e042      	b.n	80031ce <ecDouble+0x62a>
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8003148:	bf00      	nop
 800314a:	e040      	b.n	80031ce <ecDouble+0x62a>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 800314c:	bf00      	nop
 800314e:	e03e      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSqrMod(params, &t5, &t1));
 8003150:	bf00      	nop
 8003152:	e03c      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t5, &t5));
 8003154:	bf00      	nop
 8003156:	e03a      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSqrMod(params, &t4, &t3));
 8003158:	bf00      	nop
 800315a:	e038      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSubMod(params, &t5, &t1, &t4));
 800315c:	bf00      	nop
 800315e:	e036      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t1, &t4));
 8003160:	bf00      	nop
 8003162:	e034      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecMulMod(params, &t5, &t4, &t5));
 8003164:	bf00      	nop
 8003166:	e032      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t5, &t5));
 8003168:	bf00      	nop
 800316a:	e030      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSqrMod(params, &t4, &t3));
 800316c:	bf00      	nop
 800316e:	e02e      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSqrMod(params, &t4, &t4));
 8003170:	bf00      	nop
 8003172:	e02c      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecMulMod(params, &t4, &t4, &params->a));
 8003174:	bf00      	nop
 8003176:	e02a      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecSqrMod(params, &t5, &t1));
 8003178:	bf00      	nop
 800317a:	e028      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 800317c:	bf00      	nop
 800317e:	e026      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8003180:	bf00      	nop
 8003182:	e024      	b.n	80031ce <ecDouble+0x62a>
         EC_CHECK(ecAddMod(params, &t4, &t4, &t5));
 8003184:	bf00      	nop
 8003186:	e022      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecMulMod(params, &t3, &t3, &t2));
 8003188:	bf00      	nop
 800318a:	e020      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t3, &t3, &t3));
 800318c:	bf00      	nop
 800318e:	e01e      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSqrMod(params, &t2, &t2));
 8003190:	bf00      	nop
 8003192:	e01c      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecMulMod(params, &t5, &t1, &t2));
 8003194:	bf00      	nop
 8003196:	e01a      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t5, &t5, &t5));
 8003198:	bf00      	nop
 800319a:	e018      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t5, &t5, &t5));
 800319c:	bf00      	nop
 800319e:	e016      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSqrMod(params, &t1, &t4));
 80031a0:	bf00      	nop
 80031a2:	e014      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t5));
 80031a4:	bf00      	nop
 80031a6:	e012      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t5));
 80031a8:	bf00      	nop
 80031aa:	e010      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSqrMod(params, &t2, &t2));
 80031ac:	bf00      	nop
 80031ae:	e00e      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 80031b0:	bf00      	nop
 80031b2:	e00c      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 80031b4:	bf00      	nop
 80031b6:	e00a      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 80031b8:	bf00      	nop
 80031ba:	e008      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSubMod(params, &t5, &t5, &t1));
 80031bc:	bf00      	nop
 80031be:	e006      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecMulMod(params, &t5, &t4, &t5));
 80031c0:	bf00      	nop
 80031c2:	e004      	b.n	80031ce <ecDouble+0x62a>
      EC_CHECK(ecSubMod(params, &t2, &t5, &t2));
 80031c4:	bf00      	nop
 80031c6:	e002      	b.n	80031ce <ecDouble+0x62a>
      MPI_CHECK(mpiCopy(&r->x, &t1));
 80031c8:	bf00      	nop
 80031ca:	e000      	b.n	80031ce <ecDouble+0x62a>
      MPI_CHECK(mpiCopy(&r->y, &t2));
 80031cc:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&t1);
 80031ce:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80031d2:	4618      	mov	r0, r3
 80031d4:	f003 fe4d 	bl	8006e72 <mpiFree>
   mpiFree(&t2);
 80031d8:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80031dc:	4618      	mov	r0, r3
 80031de:	f003 fe48 	bl	8006e72 <mpiFree>
   mpiFree(&t3);
 80031e2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80031e6:	4618      	mov	r0, r3
 80031e8:	f003 fe43 	bl	8006e72 <mpiFree>
   mpiFree(&t4);
 80031ec:	f107 031c 	add.w	r3, r7, #28
 80031f0:	4618      	mov	r0, r3
 80031f2:	f003 fe3e 	bl	8006e72 <mpiFree>
   mpiFree(&t5);
 80031f6:	f107 0310 	add.w	r3, r7, #16
 80031fa:	4618      	mov	r0, r3
 80031fc:	f003 fe39 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8003200:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
}
 8003204:	4618      	mov	r0, r3
 8003206:	3750      	adds	r7, #80	; 0x50
 8003208:	46bd      	mov	sp, r7
 800320a:	bd80      	pop	{r7, pc}

0800320c <ecAdd>:
 * @return Error code
 **/

error_t ecAdd(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s, const EcPoint *t)
{
 800320c:	b580      	push	{r7, lr}
 800320e:	b09a      	sub	sp, #104	; 0x68
 8003210:	af00      	add	r7, sp, #0
 8003212:	60f8      	str	r0, [r7, #12]
 8003214:	60b9      	str	r1, [r7, #8]
 8003216:	607a      	str	r2, [r7, #4]
 8003218:	603b      	str	r3, [r7, #0]
   Mpi t5;
   Mpi t6;
   Mpi t7;

   //Initialize multiple precision integers
   mpiInit(&t1);
 800321a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800321e:	4618      	mov	r0, r3
 8003220:	f003 fe14 	bl	8006e4c <mpiInit>
   mpiInit(&t2);
 8003224:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8003228:	4618      	mov	r0, r3
 800322a:	f003 fe0f 	bl	8006e4c <mpiInit>
   mpiInit(&t3);
 800322e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8003232:	4618      	mov	r0, r3
 8003234:	f003 fe0a 	bl	8006e4c <mpiInit>
   mpiInit(&t4);
 8003238:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800323c:	4618      	mov	r0, r3
 800323e:	f003 fe05 	bl	8006e4c <mpiInit>
   mpiInit(&t5);
 8003242:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8003246:	4618      	mov	r0, r3
 8003248:	f003 fe00 	bl	8006e4c <mpiInit>
   mpiInit(&t6);
 800324c:	f107 031c 	add.w	r3, r7, #28
 8003250:	4618      	mov	r0, r3
 8003252:	f003 fdfb 	bl	8006e4c <mpiInit>
   mpiInit(&t7);
 8003256:	f107 0310 	add.w	r3, r7, #16
 800325a:	4618      	mov	r0, r3
 800325c:	f003 fdf6 	bl	8006e4c <mpiInit>

   //Set t1 = Sx
   MPI_CHECK(mpiCopy(&t1, &s->x));
 8003260:	687a      	ldr	r2, [r7, #4]
 8003262:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8003266:	4611      	mov	r1, r2
 8003268:	4618      	mov	r0, r3
 800326a:	f004 f83e 	bl	80072ea <mpiCopy>
 800326e:	4603      	mov	r3, r0
 8003270:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003274:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003278:	2b00      	cmp	r3, #0
 800327a:	f040 82df 	bne.w	800383c <ecAdd+0x630>
   //Set t2 = Sy
   MPI_CHECK(mpiCopy(&t2, &s->y));
 800327e:	687b      	ldr	r3, [r7, #4]
 8003280:	f103 020c 	add.w	r2, r3, #12
 8003284:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8003288:	4611      	mov	r1, r2
 800328a:	4618      	mov	r0, r3
 800328c:	f004 f82d 	bl	80072ea <mpiCopy>
 8003290:	4603      	mov	r3, r0
 8003292:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003296:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800329a:	2b00      	cmp	r3, #0
 800329c:	f040 82d0 	bne.w	8003840 <ecAdd+0x634>
   //Set t3 = Sz
   MPI_CHECK(mpiCopy(&t3, &s->z));
 80032a0:	687b      	ldr	r3, [r7, #4]
 80032a2:	f103 0218 	add.w	r2, r3, #24
 80032a6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80032aa:	4611      	mov	r1, r2
 80032ac:	4618      	mov	r0, r3
 80032ae:	f004 f81c 	bl	80072ea <mpiCopy>
 80032b2:	4603      	mov	r3, r0
 80032b4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80032b8:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80032bc:	2b00      	cmp	r3, #0
 80032be:	f040 82c1 	bne.w	8003844 <ecAdd+0x638>
   //Set t4 = Tx
   MPI_CHECK(mpiCopy(&t4, &t->x));
 80032c2:	683a      	ldr	r2, [r7, #0]
 80032c4:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80032c8:	4611      	mov	r1, r2
 80032ca:	4618      	mov	r0, r3
 80032cc:	f004 f80d 	bl	80072ea <mpiCopy>
 80032d0:	4603      	mov	r3, r0
 80032d2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80032d6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80032da:	2b00      	cmp	r3, #0
 80032dc:	f040 82b4 	bne.w	8003848 <ecAdd+0x63c>
   //Set t5 = Ty
   MPI_CHECK(mpiCopy(&t5, &t->y));
 80032e0:	683b      	ldr	r3, [r7, #0]
 80032e2:	f103 020c 	add.w	r2, r3, #12
 80032e6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80032ea:	4611      	mov	r1, r2
 80032ec:	4618      	mov	r0, r3
 80032ee:	f003 fffc 	bl	80072ea <mpiCopy>
 80032f2:	4603      	mov	r3, r0
 80032f4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80032f8:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80032fc:	2b00      	cmp	r3, #0
 80032fe:	f040 82a5 	bne.w	800384c <ecAdd+0x640>

   //Check whether Tz != 1
   if(mpiCompInt(&t->z, 1) != 0)
 8003302:	683b      	ldr	r3, [r7, #0]
 8003304:	3318      	adds	r3, #24
 8003306:	2101      	movs	r1, #1
 8003308:	4618      	mov	r0, r3
 800330a:	f003 ff7f 	bl	800720c <mpiCompInt>
 800330e:	4603      	mov	r3, r0
 8003310:	2b00      	cmp	r3, #0
 8003312:	d053      	beq.n	80033bc <ecAdd+0x1b0>
   {
      //Compute t6 = Tz
      MPI_CHECK(mpiCopy(&t6, &t->z));
 8003314:	683b      	ldr	r3, [r7, #0]
 8003316:	f103 0218 	add.w	r2, r3, #24
 800331a:	f107 031c 	add.w	r3, r7, #28
 800331e:	4611      	mov	r1, r2
 8003320:	4618      	mov	r0, r3
 8003322:	f003 ffe2 	bl	80072ea <mpiCopy>
 8003326:	4603      	mov	r3, r0
 8003328:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800332c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003330:	2b00      	cmp	r3, #0
 8003332:	f040 828d 	bne.w	8003850 <ecAdd+0x644>
      //Compute t7 = t6^2
      EC_CHECK(ecSqrMod(params, &t7, &t6));
 8003336:	f107 021c 	add.w	r2, r7, #28
 800333a:	f107 0310 	add.w	r3, r7, #16
 800333e:	4619      	mov	r1, r3
 8003340:	68f8      	ldr	r0, [r7, #12]
 8003342:	f000 fde0 	bl	8003f06 <ecSqrMod>
 8003346:	4603      	mov	r3, r0
 8003348:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800334c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003350:	2b00      	cmp	r3, #0
 8003352:	f040 827f 	bne.w	8003854 <ecAdd+0x648>
      //Compute t1 = t1 * t7
      EC_CHECK(ecMulMod(params, &t1, &t1, &t7));
 8003356:	f107 0310 	add.w	r3, r7, #16
 800335a:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800335e:	f107 0158 	add.w	r1, r7, #88	; 0x58
 8003362:	68f8      	ldr	r0, [r7, #12]
 8003364:	f000 fd9c 	bl	8003ea0 <ecMulMod>
 8003368:	4603      	mov	r3, r0
 800336a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800336e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003372:	2b00      	cmp	r3, #0
 8003374:	f040 8270 	bne.w	8003858 <ecAdd+0x64c>
      //Compute t7 = t6 * t7
      EC_CHECK(ecMulMod(params, &t7, &t6, &t7));
 8003378:	f107 0310 	add.w	r3, r7, #16
 800337c:	f107 021c 	add.w	r2, r7, #28
 8003380:	f107 0110 	add.w	r1, r7, #16
 8003384:	68f8      	ldr	r0, [r7, #12]
 8003386:	f000 fd8b 	bl	8003ea0 <ecMulMod>
 800338a:	4603      	mov	r3, r0
 800338c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003390:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003394:	2b00      	cmp	r3, #0
 8003396:	f040 8261 	bne.w	800385c <ecAdd+0x650>
      //Compute t2 = t2 * t7
      EC_CHECK(ecMulMod(params, &t2, &t2, &t7));
 800339a:	f107 0310 	add.w	r3, r7, #16
 800339e:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 80033a2:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80033a6:	68f8      	ldr	r0, [r7, #12]
 80033a8:	f000 fd7a 	bl	8003ea0 <ecMulMod>
 80033ac:	4603      	mov	r3, r0
 80033ae:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80033b2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80033b6:	2b00      	cmp	r3, #0
 80033b8:	f040 8252 	bne.w	8003860 <ecAdd+0x654>
   }

   //Compute t7 = t3^2
   EC_CHECK(ecSqrMod(params, &t7, &t3));
 80033bc:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80033c0:	f107 0310 	add.w	r3, r7, #16
 80033c4:	4619      	mov	r1, r3
 80033c6:	68f8      	ldr	r0, [r7, #12]
 80033c8:	f000 fd9d 	bl	8003f06 <ecSqrMod>
 80033cc:	4603      	mov	r3, r0
 80033ce:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80033d2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80033d6:	2b00      	cmp	r3, #0
 80033d8:	f040 8244 	bne.w	8003864 <ecAdd+0x658>
   //Compute t4 = t4 * t7
   EC_CHECK(ecMulMod(params, &t4, &t4, &t7));
 80033dc:	f107 0310 	add.w	r3, r7, #16
 80033e0:	f107 0234 	add.w	r2, r7, #52	; 0x34
 80033e4:	f107 0134 	add.w	r1, r7, #52	; 0x34
 80033e8:	68f8      	ldr	r0, [r7, #12]
 80033ea:	f000 fd59 	bl	8003ea0 <ecMulMod>
 80033ee:	4603      	mov	r3, r0
 80033f0:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80033f4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80033f8:	2b00      	cmp	r3, #0
 80033fa:	f040 8235 	bne.w	8003868 <ecAdd+0x65c>
   //Compute t7 = t3 * t7
   EC_CHECK(ecMulMod(params, &t7, &t3, &t7));
 80033fe:	f107 0310 	add.w	r3, r7, #16
 8003402:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8003406:	f107 0110 	add.w	r1, r7, #16
 800340a:	68f8      	ldr	r0, [r7, #12]
 800340c:	f000 fd48 	bl	8003ea0 <ecMulMod>
 8003410:	4603      	mov	r3, r0
 8003412:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003416:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800341a:	2b00      	cmp	r3, #0
 800341c:	f040 8226 	bne.w	800386c <ecAdd+0x660>
   //Compute t5 = t5 * t7
   EC_CHECK(ecMulMod(params, &t5, &t5, &t7));
 8003420:	f107 0310 	add.w	r3, r7, #16
 8003424:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8003428:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800342c:	68f8      	ldr	r0, [r7, #12]
 800342e:	f000 fd37 	bl	8003ea0 <ecMulMod>
 8003432:	4603      	mov	r3, r0
 8003434:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003438:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800343c:	2b00      	cmp	r3, #0
 800343e:	f040 8217 	bne.w	8003870 <ecAdd+0x664>
   //Compute t4 = t1 - t4
   EC_CHECK(ecSubMod(params, &t4, &t1, &t4));
 8003442:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003446:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800344a:	f107 0134 	add.w	r1, r7, #52	; 0x34
 800344e:	68f8      	ldr	r0, [r7, #12]
 8003450:	f000 fcfa 	bl	8003e48 <ecSubMod>
 8003454:	4603      	mov	r3, r0
 8003456:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800345a:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800345e:	2b00      	cmp	r3, #0
 8003460:	f040 8208 	bne.w	8003874 <ecAdd+0x668>
   //Compute t5 = t2 - t5
   EC_CHECK(ecSubMod(params, &t5, &t2, &t5));
 8003464:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8003468:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800346c:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8003470:	68f8      	ldr	r0, [r7, #12]
 8003472:	f000 fce9 	bl	8003e48 <ecSubMod>
 8003476:	4603      	mov	r3, r0
 8003478:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800347c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003480:	2b00      	cmp	r3, #0
 8003482:	f040 81f9 	bne.w	8003878 <ecAdd+0x66c>

   //Check whether t4 == 0
   if(mpiCompInt(&t4, 0) == 0)
 8003486:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800348a:	2100      	movs	r1, #0
 800348c:	4618      	mov	r0, r3
 800348e:	f003 febd 	bl	800720c <mpiCompInt>
 8003492:	4603      	mov	r3, r0
 8003494:	2b00      	cmp	r3, #0
 8003496:	d158      	bne.n	800354a <ecAdd+0x33e>
   {
      //Check whether t5 == 0
      if(mpiCompInt(&t5, 0) == 0)
 8003498:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800349c:	2100      	movs	r1, #0
 800349e:	4618      	mov	r0, r3
 80034a0:	f003 feb4 	bl	800720c <mpiCompInt>
 80034a4:	4603      	mov	r3, r0
 80034a6:	2b00      	cmp	r3, #0
 80034a8:	d127      	bne.n	80034fa <ecAdd+0x2ee>
      {
         //Set R = (0, 0, 0)
         MPI_CHECK(mpiSetValue(&r->x, 0));
 80034aa:	68bb      	ldr	r3, [r7, #8]
 80034ac:	2100      	movs	r1, #0
 80034ae:	4618      	mov	r0, r3
 80034b0:	f003 ff50 	bl	8007354 <mpiSetValue>
 80034b4:	4603      	mov	r3, r0
 80034b6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80034ba:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80034be:	2b00      	cmp	r3, #0
 80034c0:	f040 81dc 	bne.w	800387c <ecAdd+0x670>
         MPI_CHECK(mpiSetValue(&r->y, 0));
 80034c4:	68bb      	ldr	r3, [r7, #8]
 80034c6:	330c      	adds	r3, #12
 80034c8:	2100      	movs	r1, #0
 80034ca:	4618      	mov	r0, r3
 80034cc:	f003 ff42 	bl	8007354 <mpiSetValue>
 80034d0:	4603      	mov	r3, r0
 80034d2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80034d6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80034da:	2b00      	cmp	r3, #0
 80034dc:	f040 81d0 	bne.w	8003880 <ecAdd+0x674>
         MPI_CHECK(mpiSetValue(&r->z, 0));
 80034e0:	68bb      	ldr	r3, [r7, #8]
 80034e2:	3318      	adds	r3, #24
 80034e4:	2100      	movs	r1, #0
 80034e6:	4618      	mov	r0, r3
 80034e8:	f003 ff34 	bl	8007354 <mpiSetValue>
 80034ec:	4603      	mov	r3, r0
 80034ee:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80034f2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80034f6:	2b00      	cmp	r3, #0
 80034f8:	e1ef      	b.n	80038da <ecAdd+0x6ce>
      }
      else
      {
         //Set R = (1, 1, 0)
         MPI_CHECK(mpiSetValue(&r->x, 1));
 80034fa:	68bb      	ldr	r3, [r7, #8]
 80034fc:	2101      	movs	r1, #1
 80034fe:	4618      	mov	r0, r3
 8003500:	f003 ff28 	bl	8007354 <mpiSetValue>
 8003504:	4603      	mov	r3, r0
 8003506:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800350a:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800350e:	2b00      	cmp	r3, #0
 8003510:	f040 81b8 	bne.w	8003884 <ecAdd+0x678>
         MPI_CHECK(mpiSetValue(&r->y, 1));
 8003514:	68bb      	ldr	r3, [r7, #8]
 8003516:	330c      	adds	r3, #12
 8003518:	2101      	movs	r1, #1
 800351a:	4618      	mov	r0, r3
 800351c:	f003 ff1a 	bl	8007354 <mpiSetValue>
 8003520:	4603      	mov	r3, r0
 8003522:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003526:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800352a:	2b00      	cmp	r3, #0
 800352c:	f040 81ac 	bne.w	8003888 <ecAdd+0x67c>
         MPI_CHECK(mpiSetValue(&r->z, 0));
 8003530:	68bb      	ldr	r3, [r7, #8]
 8003532:	3318      	adds	r3, #24
 8003534:	2100      	movs	r1, #0
 8003536:	4618      	mov	r0, r3
 8003538:	f003 ff0c 	bl	8007354 <mpiSetValue>
 800353c:	4603      	mov	r3, r0
 800353e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003542:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003546:	2b00      	cmp	r3, #0
 8003548:	e1c7      	b.n	80038da <ecAdd+0x6ce>
      }
   }
   else
   {
      //Compute t1 = 2 * t1 - t4
      EC_CHECK(ecAddMod(params, &t1, &t1, &t1));
 800354a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800354e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8003552:	f107 0158 	add.w	r1, r7, #88	; 0x58
 8003556:	68f8      	ldr	r0, [r7, #12]
 8003558:	f000 fc48 	bl	8003dec <ecAddMod>
 800355c:	4603      	mov	r3, r0
 800355e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003562:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003566:	2b00      	cmp	r3, #0
 8003568:	f040 8190 	bne.w	800388c <ecAdd+0x680>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t4));
 800356c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003570:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8003574:	f107 0158 	add.w	r1, r7, #88	; 0x58
 8003578:	68f8      	ldr	r0, [r7, #12]
 800357a:	f000 fc65 	bl	8003e48 <ecSubMod>
 800357e:	4603      	mov	r3, r0
 8003580:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003584:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003588:	2b00      	cmp	r3, #0
 800358a:	f040 8181 	bne.w	8003890 <ecAdd+0x684>
      //Compute t2 = 2 * t2 - t5
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 800358e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8003592:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8003596:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 800359a:	68f8      	ldr	r0, [r7, #12]
 800359c:	f000 fc26 	bl	8003dec <ecAddMod>
 80035a0:	4603      	mov	r3, r0
 80035a2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80035a6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80035aa:	2b00      	cmp	r3, #0
 80035ac:	f040 8172 	bne.w	8003894 <ecAdd+0x688>
      EC_CHECK(ecSubMod(params, &t2, &t2, &t5));
 80035b0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80035b4:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 80035b8:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80035bc:	68f8      	ldr	r0, [r7, #12]
 80035be:	f000 fc43 	bl	8003e48 <ecSubMod>
 80035c2:	4603      	mov	r3, r0
 80035c4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80035c8:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80035cc:	2b00      	cmp	r3, #0
 80035ce:	f040 8163 	bne.w	8003898 <ecAdd+0x68c>

      //Check whether Tz != 1
      if(mpiCompInt(&t->z, 1) != 0)
 80035d2:	683b      	ldr	r3, [r7, #0]
 80035d4:	3318      	adds	r3, #24
 80035d6:	2101      	movs	r1, #1
 80035d8:	4618      	mov	r0, r3
 80035da:	f003 fe17 	bl	800720c <mpiCompInt>
 80035de:	4603      	mov	r3, r0
 80035e0:	2b00      	cmp	r3, #0
 80035e2:	d010      	beq.n	8003606 <ecAdd+0x3fa>
      {
         //Compute t3 = t3 * t6
         EC_CHECK(ecMulMod(params, &t3, &t3, &t6));
 80035e4:	f107 031c 	add.w	r3, r7, #28
 80035e8:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80035ec:	f107 0140 	add.w	r1, r7, #64	; 0x40
 80035f0:	68f8      	ldr	r0, [r7, #12]
 80035f2:	f000 fc55 	bl	8003ea0 <ecMulMod>
 80035f6:	4603      	mov	r3, r0
 80035f8:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80035fc:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003600:	2b00      	cmp	r3, #0
 8003602:	f040 814b 	bne.w	800389c <ecAdd+0x690>
      }

      //Compute t3 = t3 * t4
      EC_CHECK(ecMulMod(params, &t3, &t3, &t4));
 8003606:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800360a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800360e:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8003612:	68f8      	ldr	r0, [r7, #12]
 8003614:	f000 fc44 	bl	8003ea0 <ecMulMod>
 8003618:	4603      	mov	r3, r0
 800361a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800361e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003622:	2b00      	cmp	r3, #0
 8003624:	f040 813c 	bne.w	80038a0 <ecAdd+0x694>
      //Compute t7 = t4^2
      EC_CHECK(ecSqrMod(params, &t7, &t4));
 8003628:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800362c:	f107 0310 	add.w	r3, r7, #16
 8003630:	4619      	mov	r1, r3
 8003632:	68f8      	ldr	r0, [r7, #12]
 8003634:	f000 fc67 	bl	8003f06 <ecSqrMod>
 8003638:	4603      	mov	r3, r0
 800363a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800363e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003642:	2b00      	cmp	r3, #0
 8003644:	f040 812e 	bne.w	80038a4 <ecAdd+0x698>
      //Compute t4 = t4 * t7
      EC_CHECK(ecMulMod(params, &t4, &t4, &t7));
 8003648:	f107 0310 	add.w	r3, r7, #16
 800364c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8003650:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8003654:	68f8      	ldr	r0, [r7, #12]
 8003656:	f000 fc23 	bl	8003ea0 <ecMulMod>
 800365a:	4603      	mov	r3, r0
 800365c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003660:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003664:	2b00      	cmp	r3, #0
 8003666:	f040 811f 	bne.w	80038a8 <ecAdd+0x69c>
      //Compute t7 = t1 * t7
      EC_CHECK(ecMulMod(params, &t7, &t1, &t7));
 800366a:	f107 0310 	add.w	r3, r7, #16
 800366e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8003672:	f107 0110 	add.w	r1, r7, #16
 8003676:	68f8      	ldr	r0, [r7, #12]
 8003678:	f000 fc12 	bl	8003ea0 <ecMulMod>
 800367c:	4603      	mov	r3, r0
 800367e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003682:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003686:	2b00      	cmp	r3, #0
 8003688:	f040 8110 	bne.w	80038ac <ecAdd+0x6a0>
      //Compute t1 = t5^2
      EC_CHECK(ecSqrMod(params, &t1, &t5));
 800368c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8003690:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8003694:	4619      	mov	r1, r3
 8003696:	68f8      	ldr	r0, [r7, #12]
 8003698:	f000 fc35 	bl	8003f06 <ecSqrMod>
 800369c:	4603      	mov	r3, r0
 800369e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80036a2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80036a6:	2b00      	cmp	r3, #0
 80036a8:	f040 8102 	bne.w	80038b0 <ecAdd+0x6a4>
      //Compute t1 = t1 - t7
      EC_CHECK(ecSubMod(params, &t1, &t1, &t7));
 80036ac:	f107 0310 	add.w	r3, r7, #16
 80036b0:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80036b4:	f107 0158 	add.w	r1, r7, #88	; 0x58
 80036b8:	68f8      	ldr	r0, [r7, #12]
 80036ba:	f000 fbc5 	bl	8003e48 <ecSubMod>
 80036be:	4603      	mov	r3, r0
 80036c0:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80036c4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80036c8:	2b00      	cmp	r3, #0
 80036ca:	f040 80f3 	bne.w	80038b4 <ecAdd+0x6a8>
      //Compute t7 = t7 - 2 * t1
      EC_CHECK(ecAddMod(params, &t6, &t1, &t1));
 80036ce:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80036d2:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80036d6:	f107 011c 	add.w	r1, r7, #28
 80036da:	68f8      	ldr	r0, [r7, #12]
 80036dc:	f000 fb86 	bl	8003dec <ecAddMod>
 80036e0:	4603      	mov	r3, r0
 80036e2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80036e6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80036ea:	2b00      	cmp	r3, #0
 80036ec:	f040 80e4 	bne.w	80038b8 <ecAdd+0x6ac>
      EC_CHECK(ecSubMod(params, &t7, &t7, &t6));
 80036f0:	f107 031c 	add.w	r3, r7, #28
 80036f4:	f107 0210 	add.w	r2, r7, #16
 80036f8:	f107 0110 	add.w	r1, r7, #16
 80036fc:	68f8      	ldr	r0, [r7, #12]
 80036fe:	f000 fba3 	bl	8003e48 <ecSubMod>
 8003702:	4603      	mov	r3, r0
 8003704:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003708:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800370c:	2b00      	cmp	r3, #0
 800370e:	f040 80d5 	bne.w	80038bc <ecAdd+0x6b0>
      //Compute t5 = t5 * t7
      EC_CHECK(ecMulMod(params, &t5, &t5, &t7));
 8003712:	f107 0310 	add.w	r3, r7, #16
 8003716:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800371a:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800371e:	68f8      	ldr	r0, [r7, #12]
 8003720:	f000 fbbe 	bl	8003ea0 <ecMulMod>
 8003724:	4603      	mov	r3, r0
 8003726:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800372a:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800372e:	2b00      	cmp	r3, #0
 8003730:	f040 80c6 	bne.w	80038c0 <ecAdd+0x6b4>
      //Compute t4 = t2 * t4
      EC_CHECK(ecMulMod(params, &t4, &t2, &t4));
 8003734:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8003738:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800373c:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8003740:	68f8      	ldr	r0, [r7, #12]
 8003742:	f000 fbad 	bl	8003ea0 <ecMulMod>
 8003746:	4603      	mov	r3, r0
 8003748:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800374c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003750:	2b00      	cmp	r3, #0
 8003752:	f040 80b7 	bne.w	80038c4 <ecAdd+0x6b8>
      //Compute t2 = t5 - t4
      EC_CHECK(ecSubMod(params, &t2, &t5, &t4));
 8003756:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800375a:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800375e:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8003762:	68f8      	ldr	r0, [r7, #12]
 8003764:	f000 fb70 	bl	8003e48 <ecSubMod>
 8003768:	4603      	mov	r3, r0
 800376a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800376e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003772:	2b00      	cmp	r3, #0
 8003774:	f040 80a8 	bne.w	80038c8 <ecAdd+0x6bc>

      //Compute t2 = t2 / 2
      if(mpiIsEven(&t2))
 8003778:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800377c:	2100      	movs	r1, #0
 800377e:	4618      	mov	r0, r3
 8003780:	f003 fcba 	bl	80070f8 <mpiGetBitValue>
 8003784:	4603      	mov	r3, r0
 8003786:	2b00      	cmp	r3, #0
 8003788:	d10d      	bne.n	80037a6 <ecAdd+0x59a>
      {
         MPI_CHECK(mpiShiftRight(&t2, 1));
 800378a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800378e:	2101      	movs	r1, #1
 8003790:	4618      	mov	r0, r3
 8003792:	f004 fa9b 	bl	8007ccc <mpiShiftRight>
 8003796:	4603      	mov	r3, r0
 8003798:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800379c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80037a0:	2b00      	cmp	r3, #0
 80037a2:	d01f      	beq.n	80037e4 <ecAdd+0x5d8>
 80037a4:	e099      	b.n	80038da <ecAdd+0x6ce>
      }
      else
      {
         MPI_CHECK(mpiAdd(&t2, &t2, &params->p));
 80037a6:	68fb      	ldr	r3, [r7, #12]
 80037a8:	f103 0208 	add.w	r2, r3, #8
 80037ac:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 80037b0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80037b4:	4618      	mov	r0, r3
 80037b6:	f003 ffd7 	bl	8007768 <mpiAdd>
 80037ba:	4603      	mov	r3, r0
 80037bc:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80037c0:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80037c4:	2b00      	cmp	r3, #0
 80037c6:	f040 8081 	bne.w	80038cc <ecAdd+0x6c0>
         MPI_CHECK(mpiShiftRight(&t2, 1));
 80037ca:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80037ce:	2101      	movs	r1, #1
 80037d0:	4618      	mov	r0, r3
 80037d2:	f004 fa7b 	bl	8007ccc <mpiShiftRight>
 80037d6:	4603      	mov	r3, r0
 80037d8:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80037dc:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80037e0:	2b00      	cmp	r3, #0
 80037e2:	d175      	bne.n	80038d0 <ecAdd+0x6c4>
      }

      //Set Rx = t1
      MPI_CHECK(mpiCopy(&r->x, &t1));
 80037e4:	68bb      	ldr	r3, [r7, #8]
 80037e6:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80037ea:	4611      	mov	r1, r2
 80037ec:	4618      	mov	r0, r3
 80037ee:	f003 fd7c 	bl	80072ea <mpiCopy>
 80037f2:	4603      	mov	r3, r0
 80037f4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80037f8:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80037fc:	2b00      	cmp	r3, #0
 80037fe:	d169      	bne.n	80038d4 <ecAdd+0x6c8>
      //Set Ry = t2
      MPI_CHECK(mpiCopy(&r->y, &t2));
 8003800:	68bb      	ldr	r3, [r7, #8]
 8003802:	330c      	adds	r3, #12
 8003804:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8003808:	4611      	mov	r1, r2
 800380a:	4618      	mov	r0, r3
 800380c:	f003 fd6d 	bl	80072ea <mpiCopy>
 8003810:	4603      	mov	r3, r0
 8003812:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003816:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800381a:	2b00      	cmp	r3, #0
 800381c:	d15c      	bne.n	80038d8 <ecAdd+0x6cc>
      //Set Rz = t3
      MPI_CHECK(mpiCopy(&r->z, &t3));
 800381e:	68bb      	ldr	r3, [r7, #8]
 8003820:	3318      	adds	r3, #24
 8003822:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8003826:	4611      	mov	r1, r2
 8003828:	4618      	mov	r0, r3
 800382a:	f003 fd5e 	bl	80072ea <mpiCopy>
 800382e:	4603      	mov	r3, r0
 8003830:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8003834:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8003838:	2b00      	cmp	r3, #0
   }

end:
 800383a:	e04e      	b.n	80038da <ecAdd+0x6ce>
   MPI_CHECK(mpiCopy(&t1, &s->x));
 800383c:	bf00      	nop
 800383e:	e04c      	b.n	80038da <ecAdd+0x6ce>
   MPI_CHECK(mpiCopy(&t2, &s->y));
 8003840:	bf00      	nop
 8003842:	e04a      	b.n	80038da <ecAdd+0x6ce>
   MPI_CHECK(mpiCopy(&t3, &s->z));
 8003844:	bf00      	nop
 8003846:	e048      	b.n	80038da <ecAdd+0x6ce>
   MPI_CHECK(mpiCopy(&t4, &t->x));
 8003848:	bf00      	nop
 800384a:	e046      	b.n	80038da <ecAdd+0x6ce>
   MPI_CHECK(mpiCopy(&t5, &t->y));
 800384c:	bf00      	nop
 800384e:	e044      	b.n	80038da <ecAdd+0x6ce>
      MPI_CHECK(mpiCopy(&t6, &t->z));
 8003850:	bf00      	nop
 8003852:	e042      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSqrMod(params, &t7, &t6));
 8003854:	bf00      	nop
 8003856:	e040      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t1, &t1, &t7));
 8003858:	bf00      	nop
 800385a:	e03e      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t7, &t6, &t7));
 800385c:	bf00      	nop
 800385e:	e03c      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t2, &t2, &t7));
 8003860:	bf00      	nop
 8003862:	e03a      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecSqrMod(params, &t7, &t3));
 8003864:	bf00      	nop
 8003866:	e038      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecMulMod(params, &t4, &t4, &t7));
 8003868:	bf00      	nop
 800386a:	e036      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecMulMod(params, &t7, &t3, &t7));
 800386c:	bf00      	nop
 800386e:	e034      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecMulMod(params, &t5, &t5, &t7));
 8003870:	bf00      	nop
 8003872:	e032      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecSubMod(params, &t4, &t1, &t4));
 8003874:	bf00      	nop
 8003876:	e030      	b.n	80038da <ecAdd+0x6ce>
   EC_CHECK(ecSubMod(params, &t5, &t2, &t5));
 8003878:	bf00      	nop
 800387a:	e02e      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiSetValue(&r->x, 0));
 800387c:	bf00      	nop
 800387e:	e02c      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiSetValue(&r->y, 0));
 8003880:	bf00      	nop
 8003882:	e02a      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiSetValue(&r->x, 1));
 8003884:	bf00      	nop
 8003886:	e028      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiSetValue(&r->y, 1));
 8003888:	bf00      	nop
 800388a:	e026      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecAddMod(params, &t1, &t1, &t1));
 800388c:	bf00      	nop
 800388e:	e024      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t4));
 8003890:	bf00      	nop
 8003892:	e022      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecAddMod(params, &t2, &t2, &t2));
 8003894:	bf00      	nop
 8003896:	e020      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSubMod(params, &t2, &t2, &t5));
 8003898:	bf00      	nop
 800389a:	e01e      	b.n	80038da <ecAdd+0x6ce>
         EC_CHECK(ecMulMod(params, &t3, &t3, &t6));
 800389c:	bf00      	nop
 800389e:	e01c      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t3, &t3, &t4));
 80038a0:	bf00      	nop
 80038a2:	e01a      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSqrMod(params, &t7, &t4));
 80038a4:	bf00      	nop
 80038a6:	e018      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t4, &t4, &t7));
 80038a8:	bf00      	nop
 80038aa:	e016      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t7, &t1, &t7));
 80038ac:	bf00      	nop
 80038ae:	e014      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSqrMod(params, &t1, &t5));
 80038b0:	bf00      	nop
 80038b2:	e012      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSubMod(params, &t1, &t1, &t7));
 80038b4:	bf00      	nop
 80038b6:	e010      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecAddMod(params, &t6, &t1, &t1));
 80038b8:	bf00      	nop
 80038ba:	e00e      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSubMod(params, &t7, &t7, &t6));
 80038bc:	bf00      	nop
 80038be:	e00c      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t5, &t5, &t7));
 80038c0:	bf00      	nop
 80038c2:	e00a      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecMulMod(params, &t4, &t2, &t4));
 80038c4:	bf00      	nop
 80038c6:	e008      	b.n	80038da <ecAdd+0x6ce>
      EC_CHECK(ecSubMod(params, &t2, &t5, &t4));
 80038c8:	bf00      	nop
 80038ca:	e006      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiAdd(&t2, &t2, &params->p));
 80038cc:	bf00      	nop
 80038ce:	e004      	b.n	80038da <ecAdd+0x6ce>
         MPI_CHECK(mpiShiftRight(&t2, 1));
 80038d0:	bf00      	nop
 80038d2:	e002      	b.n	80038da <ecAdd+0x6ce>
      MPI_CHECK(mpiCopy(&r->x, &t1));
 80038d4:	bf00      	nop
 80038d6:	e000      	b.n	80038da <ecAdd+0x6ce>
      MPI_CHECK(mpiCopy(&r->y, &t2));
 80038d8:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&t1);
 80038da:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80038de:	4618      	mov	r0, r3
 80038e0:	f003 fac7 	bl	8006e72 <mpiFree>
   mpiFree(&t2);
 80038e4:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80038e8:	4618      	mov	r0, r3
 80038ea:	f003 fac2 	bl	8006e72 <mpiFree>
   mpiFree(&t3);
 80038ee:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80038f2:	4618      	mov	r0, r3
 80038f4:	f003 fabd 	bl	8006e72 <mpiFree>
   mpiFree(&t4);
 80038f8:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80038fc:	4618      	mov	r0, r3
 80038fe:	f003 fab8 	bl	8006e72 <mpiFree>
   mpiFree(&t5);
 8003902:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8003906:	4618      	mov	r0, r3
 8003908:	f003 fab3 	bl	8006e72 <mpiFree>
   mpiFree(&t6);
 800390c:	f107 031c 	add.w	r3, r7, #28
 8003910:	4618      	mov	r0, r3
 8003912:	f003 faae 	bl	8006e72 <mpiFree>
   mpiFree(&t7);
 8003916:	f107 0310 	add.w	r3, r7, #16
 800391a:	4618      	mov	r0, r3
 800391c:	f003 faa9 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8003920:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
}
 8003924:	4618      	mov	r0, r3
 8003926:	3768      	adds	r7, #104	; 0x68
 8003928:	46bd      	mov	sp, r7
 800392a:	bd80      	pop	{r7, pc}

0800392c <ecFullAdd>:
 * @return Error code
 **/

error_t ecFullAdd(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s, const EcPoint *t)
{
 800392c:	b580      	push	{r7, lr}
 800392e:	b086      	sub	sp, #24
 8003930:	af00      	add	r7, sp, #0
 8003932:	60f8      	str	r0, [r7, #12]
 8003934:	60b9      	str	r1, [r7, #8]
 8003936:	607a      	str	r2, [r7, #4]
 8003938:	603b      	str	r3, [r7, #0]
   error_t error;

   //Check whether Sz == 0
   if(mpiCompInt(&s->z, 0) == 0)
 800393a:	687b      	ldr	r3, [r7, #4]
 800393c:	3318      	adds	r3, #24
 800393e:	2100      	movs	r1, #0
 8003940:	4618      	mov	r0, r3
 8003942:	f003 fc63 	bl	800720c <mpiCompInt>
 8003946:	4603      	mov	r3, r0
 8003948:	2b00      	cmp	r3, #0
 800394a:	d126      	bne.n	800399a <ecFullAdd+0x6e>
   {
      //Set R = T
      MPI_CHECK(mpiCopy(&r->x, &t->x));
 800394c:	68bb      	ldr	r3, [r7, #8]
 800394e:	683a      	ldr	r2, [r7, #0]
 8003950:	4611      	mov	r1, r2
 8003952:	4618      	mov	r0, r3
 8003954:	f003 fcc9 	bl	80072ea <mpiCopy>
 8003958:	4603      	mov	r3, r0
 800395a:	82fb      	strh	r3, [r7, #22]
 800395c:	8afb      	ldrh	r3, [r7, #22]
 800395e:	2b00      	cmp	r3, #0
 8003960:	d17a      	bne.n	8003a58 <ecFullAdd+0x12c>
      MPI_CHECK(mpiCopy(&r->y, &t->y));
 8003962:	68bb      	ldr	r3, [r7, #8]
 8003964:	f103 020c 	add.w	r2, r3, #12
 8003968:	683b      	ldr	r3, [r7, #0]
 800396a:	330c      	adds	r3, #12
 800396c:	4619      	mov	r1, r3
 800396e:	4610      	mov	r0, r2
 8003970:	f003 fcbb 	bl	80072ea <mpiCopy>
 8003974:	4603      	mov	r3, r0
 8003976:	82fb      	strh	r3, [r7, #22]
 8003978:	8afb      	ldrh	r3, [r7, #22]
 800397a:	2b00      	cmp	r3, #0
 800397c:	d16e      	bne.n	8003a5c <ecFullAdd+0x130>
      MPI_CHECK(mpiCopy(&r->z, &t->z));
 800397e:	68bb      	ldr	r3, [r7, #8]
 8003980:	f103 0218 	add.w	r2, r3, #24
 8003984:	683b      	ldr	r3, [r7, #0]
 8003986:	3318      	adds	r3, #24
 8003988:	4619      	mov	r1, r3
 800398a:	4610      	mov	r0, r2
 800398c:	f003 fcad 	bl	80072ea <mpiCopy>
 8003990:	4603      	mov	r3, r0
 8003992:	82fb      	strh	r3, [r7, #22]
 8003994:	8afb      	ldrh	r3, [r7, #22]
 8003996:	2b00      	cmp	r3, #0
 8003998:	e069      	b.n	8003a6e <ecFullAdd+0x142>
   }
   //Check whether Tz == 0
   else if(mpiCompInt(&t->z, 0) == 0)
 800399a:	683b      	ldr	r3, [r7, #0]
 800399c:	3318      	adds	r3, #24
 800399e:	2100      	movs	r1, #0
 80039a0:	4618      	mov	r0, r3
 80039a2:	f003 fc33 	bl	800720c <mpiCompInt>
 80039a6:	4603      	mov	r3, r0
 80039a8:	2b00      	cmp	r3, #0
 80039aa:	d126      	bne.n	80039fa <ecFullAdd+0xce>
   {
      //Set R = S
      MPI_CHECK(mpiCopy(&r->x, &s->x));
 80039ac:	68bb      	ldr	r3, [r7, #8]
 80039ae:	687a      	ldr	r2, [r7, #4]
 80039b0:	4611      	mov	r1, r2
 80039b2:	4618      	mov	r0, r3
 80039b4:	f003 fc99 	bl	80072ea <mpiCopy>
 80039b8:	4603      	mov	r3, r0
 80039ba:	82fb      	strh	r3, [r7, #22]
 80039bc:	8afb      	ldrh	r3, [r7, #22]
 80039be:	2b00      	cmp	r3, #0
 80039c0:	d14e      	bne.n	8003a60 <ecFullAdd+0x134>
      MPI_CHECK(mpiCopy(&r->y, &s->y));
 80039c2:	68bb      	ldr	r3, [r7, #8]
 80039c4:	f103 020c 	add.w	r2, r3, #12
 80039c8:	687b      	ldr	r3, [r7, #4]
 80039ca:	330c      	adds	r3, #12
 80039cc:	4619      	mov	r1, r3
 80039ce:	4610      	mov	r0, r2
 80039d0:	f003 fc8b 	bl	80072ea <mpiCopy>
 80039d4:	4603      	mov	r3, r0
 80039d6:	82fb      	strh	r3, [r7, #22]
 80039d8:	8afb      	ldrh	r3, [r7, #22]
 80039da:	2b00      	cmp	r3, #0
 80039dc:	d142      	bne.n	8003a64 <ecFullAdd+0x138>
      MPI_CHECK(mpiCopy(&r->z, &s->z));
 80039de:	68bb      	ldr	r3, [r7, #8]
 80039e0:	f103 0218 	add.w	r2, r3, #24
 80039e4:	687b      	ldr	r3, [r7, #4]
 80039e6:	3318      	adds	r3, #24
 80039e8:	4619      	mov	r1, r3
 80039ea:	4610      	mov	r0, r2
 80039ec:	f003 fc7d 	bl	80072ea <mpiCopy>
 80039f0:	4603      	mov	r3, r0
 80039f2:	82fb      	strh	r3, [r7, #22]
 80039f4:	8afb      	ldrh	r3, [r7, #22]
 80039f6:	2b00      	cmp	r3, #0
 80039f8:	e039      	b.n	8003a6e <ecFullAdd+0x142>
   }
   else
   {
      //Compute R = S + T
      EC_CHECK(ecAdd(params, r, s, t));
 80039fa:	683b      	ldr	r3, [r7, #0]
 80039fc:	687a      	ldr	r2, [r7, #4]
 80039fe:	68b9      	ldr	r1, [r7, #8]
 8003a00:	68f8      	ldr	r0, [r7, #12]
 8003a02:	f7ff fc03 	bl	800320c <ecAdd>
 8003a06:	4603      	mov	r3, r0
 8003a08:	82fb      	strh	r3, [r7, #22]
 8003a0a:	8afb      	ldrh	r3, [r7, #22]
 8003a0c:	2b00      	cmp	r3, #0
 8003a0e:	d12b      	bne.n	8003a68 <ecFullAdd+0x13c>

      //Check whether R == (0, 0, 0)
      if(mpiCompInt(&r->x, 0) == 0 &&
 8003a10:	68bb      	ldr	r3, [r7, #8]
 8003a12:	2100      	movs	r1, #0
 8003a14:	4618      	mov	r0, r3
 8003a16:	f003 fbf9 	bl	800720c <mpiCompInt>
 8003a1a:	4603      	mov	r3, r0
 8003a1c:	2b00      	cmp	r3, #0
 8003a1e:	d125      	bne.n	8003a6c <ecFullAdd+0x140>
         mpiCompInt(&r->y, 0) == 0 &&
 8003a20:	68bb      	ldr	r3, [r7, #8]
 8003a22:	330c      	adds	r3, #12
 8003a24:	2100      	movs	r1, #0
 8003a26:	4618      	mov	r0, r3
 8003a28:	f003 fbf0 	bl	800720c <mpiCompInt>
 8003a2c:	4603      	mov	r3, r0
      if(mpiCompInt(&r->x, 0) == 0 &&
 8003a2e:	2b00      	cmp	r3, #0
 8003a30:	d11c      	bne.n	8003a6c <ecFullAdd+0x140>
         mpiCompInt(&r->z, 0) == 0)
 8003a32:	68bb      	ldr	r3, [r7, #8]
 8003a34:	3318      	adds	r3, #24
 8003a36:	2100      	movs	r1, #0
 8003a38:	4618      	mov	r0, r3
 8003a3a:	f003 fbe7 	bl	800720c <mpiCompInt>
 8003a3e:	4603      	mov	r3, r0
         mpiCompInt(&r->y, 0) == 0 &&
 8003a40:	2b00      	cmp	r3, #0
 8003a42:	d113      	bne.n	8003a6c <ecFullAdd+0x140>
      {
         //Compute R = 2 * S
         EC_CHECK(ecDouble(params, r, s));
 8003a44:	687a      	ldr	r2, [r7, #4]
 8003a46:	68b9      	ldr	r1, [r7, #8]
 8003a48:	68f8      	ldr	r0, [r7, #12]
 8003a4a:	f7ff f8ab 	bl	8002ba4 <ecDouble>
 8003a4e:	4603      	mov	r3, r0
 8003a50:	82fb      	strh	r3, [r7, #22]
 8003a52:	8afb      	ldrh	r3, [r7, #22]
 8003a54:	2b00      	cmp	r3, #0
      }
   }

end:
 8003a56:	e009      	b.n	8003a6c <ecFullAdd+0x140>
      MPI_CHECK(mpiCopy(&r->x, &t->x));
 8003a58:	bf00      	nop
 8003a5a:	e008      	b.n	8003a6e <ecFullAdd+0x142>
      MPI_CHECK(mpiCopy(&r->y, &t->y));
 8003a5c:	bf00      	nop
 8003a5e:	e006      	b.n	8003a6e <ecFullAdd+0x142>
      MPI_CHECK(mpiCopy(&r->x, &s->x));
 8003a60:	bf00      	nop
 8003a62:	e004      	b.n	8003a6e <ecFullAdd+0x142>
      MPI_CHECK(mpiCopy(&r->y, &s->y));
 8003a64:	bf00      	nop
 8003a66:	e002      	b.n	8003a6e <ecFullAdd+0x142>
      EC_CHECK(ecAdd(params, r, s, t));
 8003a68:	bf00      	nop
 8003a6a:	e000      	b.n	8003a6e <ecFullAdd+0x142>
end:
 8003a6c:	bf00      	nop
   //Return status code
   return error;
 8003a6e:	8afb      	ldrh	r3, [r7, #22]
}
 8003a70:	4618      	mov	r0, r3
 8003a72:	3718      	adds	r7, #24
 8003a74:	46bd      	mov	sp, r7
 8003a76:	bd80      	pop	{r7, pc}

08003a78 <ecFullSub>:
 * @return Error code
 **/

error_t ecFullSub(const EcDomainParameters *params, EcPoint *r,
   const EcPoint *s, const EcPoint *t)
{
 8003a78:	b580      	push	{r7, lr}
 8003a7a:	b08e      	sub	sp, #56	; 0x38
 8003a7c:	af00      	add	r7, sp, #0
 8003a7e:	60f8      	str	r0, [r7, #12]
 8003a80:	60b9      	str	r1, [r7, #8]
 8003a82:	607a      	str	r2, [r7, #4]
 8003a84:	603b      	str	r3, [r7, #0]
   error_t error;
   EcPoint u;

   //Initialize EC point
   ecInit(&u);
 8003a86:	f107 0310 	add.w	r3, r7, #16
 8003a8a:	4618      	mov	r0, r3
 8003a8c:	f7fe ff80 	bl	8002990 <ecInit>

   //Set Ux = Tx and Uz = Tz
   MPI_CHECK(mpiCopy(&u.x, &t->x));
 8003a90:	683a      	ldr	r2, [r7, #0]
 8003a92:	f107 0310 	add.w	r3, r7, #16
 8003a96:	4611      	mov	r1, r2
 8003a98:	4618      	mov	r0, r3
 8003a9a:	f003 fc26 	bl	80072ea <mpiCopy>
 8003a9e:	4603      	mov	r3, r0
 8003aa0:	86fb      	strh	r3, [r7, #54]	; 0x36
 8003aa2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8003aa4:	2b00      	cmp	r3, #0
 8003aa6:	d12b      	bne.n	8003b00 <ecFullSub+0x88>
   MPI_CHECK(mpiCopy(&u.z, &t->z));
 8003aa8:	683b      	ldr	r3, [r7, #0]
 8003aaa:	f103 0218 	add.w	r2, r3, #24
 8003aae:	f107 0310 	add.w	r3, r7, #16
 8003ab2:	3318      	adds	r3, #24
 8003ab4:	4611      	mov	r1, r2
 8003ab6:	4618      	mov	r0, r3
 8003ab8:	f003 fc17 	bl	80072ea <mpiCopy>
 8003abc:	4603      	mov	r3, r0
 8003abe:	86fb      	strh	r3, [r7, #54]	; 0x36
 8003ac0:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8003ac2:	2b00      	cmp	r3, #0
 8003ac4:	d11e      	bne.n	8003b04 <ecFullSub+0x8c>
   //Set Uy = p - Ty
   MPI_CHECK(mpiSub(&u.y, &params->p, &t->y));
 8003ac6:	68fb      	ldr	r3, [r7, #12]
 8003ac8:	f103 0108 	add.w	r1, r3, #8
 8003acc:	683b      	ldr	r3, [r7, #0]
 8003ace:	f103 020c 	add.w	r2, r3, #12
 8003ad2:	f107 0310 	add.w	r3, r7, #16
 8003ad6:	330c      	adds	r3, #12
 8003ad8:	4618      	mov	r0, r3
 8003ada:	f003 fea5 	bl	8007828 <mpiSub>
 8003ade:	4603      	mov	r3, r0
 8003ae0:	86fb      	strh	r3, [r7, #54]	; 0x36
 8003ae2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d10f      	bne.n	8003b08 <ecFullSub+0x90>

   //Compute R = S + U
   EC_CHECK(ecFullAdd(params, r, s, &u));
 8003ae8:	f107 0310 	add.w	r3, r7, #16
 8003aec:	687a      	ldr	r2, [r7, #4]
 8003aee:	68b9      	ldr	r1, [r7, #8]
 8003af0:	68f8      	ldr	r0, [r7, #12]
 8003af2:	f7ff ff1b 	bl	800392c <ecFullAdd>
 8003af6:	4603      	mov	r3, r0
 8003af8:	86fb      	strh	r3, [r7, #54]	; 0x36
 8003afa:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8003afc:	2b00      	cmp	r3, #0

end:
 8003afe:	e004      	b.n	8003b0a <ecFullSub+0x92>
   MPI_CHECK(mpiCopy(&u.x, &t->x));
 8003b00:	bf00      	nop
 8003b02:	e002      	b.n	8003b0a <ecFullSub+0x92>
   MPI_CHECK(mpiCopy(&u.z, &t->z));
 8003b04:	bf00      	nop
 8003b06:	e000      	b.n	8003b0a <ecFullSub+0x92>
   MPI_CHECK(mpiSub(&u.y, &params->p, &t->y));
 8003b08:	bf00      	nop
   //Release EC point
   ecFree(&u);
 8003b0a:	f107 0310 	add.w	r3, r7, #16
 8003b0e:	4618      	mov	r0, r3
 8003b10:	f7fe ff54 	bl	80029bc <ecFree>

   //Return status code
   return error;
 8003b14:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
 8003b16:	4618      	mov	r0, r3
 8003b18:	3738      	adds	r7, #56	; 0x38
 8003b1a:	46bd      	mov	sp, r7
 8003b1c:	bd80      	pop	{r7, pc}

08003b1e <ecMult>:
 * @return Error code
 **/

__weak_func error_t ecMult(const EcDomainParameters *params, EcPoint *r, const Mpi *d,
   const EcPoint *s)
{
 8003b1e:	b580      	push	{r7, lr}
 8003b20:	b08a      	sub	sp, #40	; 0x28
 8003b22:	af00      	add	r7, sp, #0
 8003b24:	60f8      	str	r0, [r7, #12]
 8003b26:	60b9      	str	r1, [r7, #8]
 8003b28:	607a      	str	r2, [r7, #4]
 8003b2a:	603b      	str	r3, [r7, #0]
   error_t error;
   uint_t i;
   Mpi h;

   //Initialize multiple precision integer
   mpiInit(&h);
 8003b2c:	f107 0314 	add.w	r3, r7, #20
 8003b30:	4618      	mov	r0, r3
 8003b32:	f003 f98b 	bl	8006e4c <mpiInit>

   //Check whether d == 0
   if(mpiCompInt(d, 0) == 0)
 8003b36:	2100      	movs	r1, #0
 8003b38:	6878      	ldr	r0, [r7, #4]
 8003b3a:	f003 fb67 	bl	800720c <mpiCompInt>
 8003b3e:	4603      	mov	r3, r0
 8003b40:	2b00      	cmp	r3, #0
 8003b42:	d121      	bne.n	8003b88 <ecMult+0x6a>
   {
      //Set R = (1, 1, 0)
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8003b44:	68bb      	ldr	r3, [r7, #8]
 8003b46:	2101      	movs	r1, #1
 8003b48:	4618      	mov	r0, r3
 8003b4a:	f003 fc03 	bl	8007354 <mpiSetValue>
 8003b4e:	4603      	mov	r3, r0
 8003b50:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003b52:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003b54:	2b00      	cmp	r3, #0
 8003b56:	f040 8124 	bne.w	8003da2 <ecMult+0x284>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 8003b5a:	68bb      	ldr	r3, [r7, #8]
 8003b5c:	330c      	adds	r3, #12
 8003b5e:	2101      	movs	r1, #1
 8003b60:	4618      	mov	r0, r3
 8003b62:	f003 fbf7 	bl	8007354 <mpiSetValue>
 8003b66:	4603      	mov	r3, r0
 8003b68:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003b6a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003b6c:	2b00      	cmp	r3, #0
 8003b6e:	f040 811a 	bne.w	8003da6 <ecMult+0x288>
      MPI_CHECK(mpiSetValue(&r->z, 0));
 8003b72:	68bb      	ldr	r3, [r7, #8]
 8003b74:	3318      	adds	r3, #24
 8003b76:	2100      	movs	r1, #0
 8003b78:	4618      	mov	r0, r3
 8003b7a:	f003 fbeb 	bl	8007354 <mpiSetValue>
 8003b7e:	4603      	mov	r3, r0
 8003b80:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003b82:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003b84:	2b00      	cmp	r3, #0
 8003b86:	e127      	b.n	8003dd8 <ecMult+0x2ba>
   }
   //Check whether d == 1
   else if(mpiCompInt(d, 1) == 0)
 8003b88:	2101      	movs	r1, #1
 8003b8a:	6878      	ldr	r0, [r7, #4]
 8003b8c:	f003 fb3e 	bl	800720c <mpiCompInt>
 8003b90:	4603      	mov	r3, r0
 8003b92:	2b00      	cmp	r3, #0
 8003b94:	d128      	bne.n	8003be8 <ecMult+0xca>
   {
      //Set R = S
      MPI_CHECK(mpiCopy(&r->x, &s->x));
 8003b96:	68bb      	ldr	r3, [r7, #8]
 8003b98:	683a      	ldr	r2, [r7, #0]
 8003b9a:	4611      	mov	r1, r2
 8003b9c:	4618      	mov	r0, r3
 8003b9e:	f003 fba4 	bl	80072ea <mpiCopy>
 8003ba2:	4603      	mov	r3, r0
 8003ba4:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003ba6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003ba8:	2b00      	cmp	r3, #0
 8003baa:	f040 80fe 	bne.w	8003daa <ecMult+0x28c>
      MPI_CHECK(mpiCopy(&r->y, &s->y));
 8003bae:	68bb      	ldr	r3, [r7, #8]
 8003bb0:	f103 020c 	add.w	r2, r3, #12
 8003bb4:	683b      	ldr	r3, [r7, #0]
 8003bb6:	330c      	adds	r3, #12
 8003bb8:	4619      	mov	r1, r3
 8003bba:	4610      	mov	r0, r2
 8003bbc:	f003 fb95 	bl	80072ea <mpiCopy>
 8003bc0:	4603      	mov	r3, r0
 8003bc2:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003bc4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003bc6:	2b00      	cmp	r3, #0
 8003bc8:	f040 80f1 	bne.w	8003dae <ecMult+0x290>
      MPI_CHECK(mpiCopy(&r->z, &s->z));
 8003bcc:	68bb      	ldr	r3, [r7, #8]
 8003bce:	f103 0218 	add.w	r2, r3, #24
 8003bd2:	683b      	ldr	r3, [r7, #0]
 8003bd4:	3318      	adds	r3, #24
 8003bd6:	4619      	mov	r1, r3
 8003bd8:	4610      	mov	r0, r2
 8003bda:	f003 fb86 	bl	80072ea <mpiCopy>
 8003bde:	4603      	mov	r3, r0
 8003be0:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003be2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003be4:	2b00      	cmp	r3, #0
 8003be6:	e0f7      	b.n	8003dd8 <ecMult+0x2ba>
   }
   //Check whether Sz == 0
   else if(mpiCompInt(&s->z, 0) == 0)
 8003be8:	683b      	ldr	r3, [r7, #0]
 8003bea:	3318      	adds	r3, #24
 8003bec:	2100      	movs	r1, #0
 8003bee:	4618      	mov	r0, r3
 8003bf0:	f003 fb0c 	bl	800720c <mpiCompInt>
 8003bf4:	4603      	mov	r3, r0
 8003bf6:	2b00      	cmp	r3, #0
 8003bf8:	d121      	bne.n	8003c3e <ecMult+0x120>
   {
      //Set R = (1, 1, 0)
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8003bfa:	68bb      	ldr	r3, [r7, #8]
 8003bfc:	2101      	movs	r1, #1
 8003bfe:	4618      	mov	r0, r3
 8003c00:	f003 fba8 	bl	8007354 <mpiSetValue>
 8003c04:	4603      	mov	r3, r0
 8003c06:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c08:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c0a:	2b00      	cmp	r3, #0
 8003c0c:	f040 80d1 	bne.w	8003db2 <ecMult+0x294>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 8003c10:	68bb      	ldr	r3, [r7, #8]
 8003c12:	330c      	adds	r3, #12
 8003c14:	2101      	movs	r1, #1
 8003c16:	4618      	mov	r0, r3
 8003c18:	f003 fb9c 	bl	8007354 <mpiSetValue>
 8003c1c:	4603      	mov	r3, r0
 8003c1e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c20:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c22:	2b00      	cmp	r3, #0
 8003c24:	f040 80c7 	bne.w	8003db6 <ecMult+0x298>
      MPI_CHECK(mpiSetValue(&r->z, 0));
 8003c28:	68bb      	ldr	r3, [r7, #8]
 8003c2a:	3318      	adds	r3, #24
 8003c2c:	2100      	movs	r1, #0
 8003c2e:	4618      	mov	r0, r3
 8003c30:	f003 fb90 	bl	8007354 <mpiSetValue>
 8003c34:	4603      	mov	r3, r0
 8003c36:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c38:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c3a:	2b00      	cmp	r3, #0
 8003c3c:	e0cc      	b.n	8003dd8 <ecMult+0x2ba>
   }
   else
   {
      //Check whether Sz != 1
      if(mpiCompInt(&s->z, 1) != 0)
 8003c3e:	683b      	ldr	r3, [r7, #0]
 8003c40:	3318      	adds	r3, #24
 8003c42:	2101      	movs	r1, #1
 8003c44:	4618      	mov	r0, r3
 8003c46:	f003 fae1 	bl	800720c <mpiCompInt>
 8003c4a:	4603      	mov	r3, r0
 8003c4c:	2b00      	cmp	r3, #0
 8003c4e:	d015      	beq.n	8003c7c <ecMult+0x15e>
      {
         //Normalize S
         EC_CHECK(ecAffinify(params, r, s));
 8003c50:	683a      	ldr	r2, [r7, #0]
 8003c52:	68b9      	ldr	r1, [r7, #8]
 8003c54:	68f8      	ldr	r0, [r7, #12]
 8003c56:	f7fe ff21 	bl	8002a9c <ecAffinify>
 8003c5a:	4603      	mov	r3, r0
 8003c5c:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c5e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c60:	2b00      	cmp	r3, #0
 8003c62:	f040 80aa 	bne.w	8003dba <ecMult+0x29c>
         EC_CHECK(ecProjectify(params, r, r));
 8003c66:	68ba      	ldr	r2, [r7, #8]
 8003c68:	68b9      	ldr	r1, [r7, #8]
 8003c6a:	68f8      	ldr	r0, [r7, #12]
 8003c6c:	f7fe fef6 	bl	8002a5c <ecProjectify>
 8003c70:	4603      	mov	r3, r0
 8003c72:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c74:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c76:	2b00      	cmp	r3, #0
 8003c78:	d029      	beq.n	8003cce <ecMult+0x1b0>
 8003c7a:	e0ad      	b.n	8003dd8 <ecMult+0x2ba>
      }
      else
      {
         //Set R = S
         MPI_CHECK(mpiCopy(&r->x, &s->x));
 8003c7c:	68bb      	ldr	r3, [r7, #8]
 8003c7e:	683a      	ldr	r2, [r7, #0]
 8003c80:	4611      	mov	r1, r2
 8003c82:	4618      	mov	r0, r3
 8003c84:	f003 fb31 	bl	80072ea <mpiCopy>
 8003c88:	4603      	mov	r3, r0
 8003c8a:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c8c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c8e:	2b00      	cmp	r3, #0
 8003c90:	f040 8095 	bne.w	8003dbe <ecMult+0x2a0>
         MPI_CHECK(mpiCopy(&r->y, &s->y));
 8003c94:	68bb      	ldr	r3, [r7, #8]
 8003c96:	f103 020c 	add.w	r2, r3, #12
 8003c9a:	683b      	ldr	r3, [r7, #0]
 8003c9c:	330c      	adds	r3, #12
 8003c9e:	4619      	mov	r1, r3
 8003ca0:	4610      	mov	r0, r2
 8003ca2:	f003 fb22 	bl	80072ea <mpiCopy>
 8003ca6:	4603      	mov	r3, r0
 8003ca8:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003caa:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003cac:	2b00      	cmp	r3, #0
 8003cae:	f040 8088 	bne.w	8003dc2 <ecMult+0x2a4>
         MPI_CHECK(mpiCopy(&r->z, &s->z));
 8003cb2:	68bb      	ldr	r3, [r7, #8]
 8003cb4:	f103 0218 	add.w	r2, r3, #24
 8003cb8:	683b      	ldr	r3, [r7, #0]
 8003cba:	3318      	adds	r3, #24
 8003cbc:	4619      	mov	r1, r3
 8003cbe:	4610      	mov	r0, r2
 8003cc0:	f003 fb13 	bl	80072ea <mpiCopy>
 8003cc4:	4603      	mov	r3, r0
 8003cc6:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003cc8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003cca:	2b00      	cmp	r3, #0
 8003ccc:	d17b      	bne.n	8003dc6 <ecMult+0x2a8>
         }
      }
//Fast left-to-right binary method
#else
      //Precompute h = 3 * d
      MPI_CHECK(mpiAdd(&h, d, d));
 8003cce:	f107 0314 	add.w	r3, r7, #20
 8003cd2:	687a      	ldr	r2, [r7, #4]
 8003cd4:	6879      	ldr	r1, [r7, #4]
 8003cd6:	4618      	mov	r0, r3
 8003cd8:	f003 fd46 	bl	8007768 <mpiAdd>
 8003cdc:	4603      	mov	r3, r0
 8003cde:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003ce0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d171      	bne.n	8003dca <ecMult+0x2ac>
      MPI_CHECK(mpiAdd(&h, &h, d));
 8003ce6:	f107 0114 	add.w	r1, r7, #20
 8003cea:	f107 0314 	add.w	r3, r7, #20
 8003cee:	687a      	ldr	r2, [r7, #4]
 8003cf0:	4618      	mov	r0, r3
 8003cf2:	f003 fd39 	bl	8007768 <mpiAdd>
 8003cf6:	4603      	mov	r3, r0
 8003cf8:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003cfa:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003cfc:	2b00      	cmp	r3, #0
 8003cfe:	d166      	bne.n	8003dce <ecMult+0x2b0>

      //Scalar multiplication
      for(i = mpiGetBitLength(&h) - 2; i >= 1; i--)
 8003d00:	f107 0314 	add.w	r3, r7, #20
 8003d04:	4618      	mov	r0, r3
 8003d06:	f003 f975 	bl	8006ff4 <mpiGetBitLength>
 8003d0a:	4603      	mov	r3, r0
 8003d0c:	3b02      	subs	r3, #2
 8003d0e:	623b      	str	r3, [r7, #32]
 8003d10:	e043      	b.n	8003d9a <ecMult+0x27c>
      {
         //Point doubling
         EC_CHECK(ecDouble(params, r, r));
 8003d12:	68ba      	ldr	r2, [r7, #8]
 8003d14:	68b9      	ldr	r1, [r7, #8]
 8003d16:	68f8      	ldr	r0, [r7, #12]
 8003d18:	f7fe ff44 	bl	8002ba4 <ecDouble>
 8003d1c:	4603      	mov	r3, r0
 8003d1e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003d20:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d22:	2b00      	cmp	r3, #0
 8003d24:	d155      	bne.n	8003dd2 <ecMult+0x2b4>

         //Check whether h(i) == 1 and k(i) == 0
         if(mpiGetBitValue(&h, i) && !mpiGetBitValue(d, i))
 8003d26:	f107 0314 	add.w	r3, r7, #20
 8003d2a:	6a39      	ldr	r1, [r7, #32]
 8003d2c:	4618      	mov	r0, r3
 8003d2e:	f003 f9e3 	bl	80070f8 <mpiGetBitValue>
 8003d32:	4603      	mov	r3, r0
 8003d34:	2b00      	cmp	r3, #0
 8003d36:	d012      	beq.n	8003d5e <ecMult+0x240>
 8003d38:	6a39      	ldr	r1, [r7, #32]
 8003d3a:	6878      	ldr	r0, [r7, #4]
 8003d3c:	f003 f9dc 	bl	80070f8 <mpiGetBitValue>
 8003d40:	4603      	mov	r3, r0
 8003d42:	2b00      	cmp	r3, #0
 8003d44:	d10b      	bne.n	8003d5e <ecMult+0x240>
         {
            //Compute R = R + S
            EC_CHECK(ecFullAdd(params, r, r, s));
 8003d46:	683b      	ldr	r3, [r7, #0]
 8003d48:	68ba      	ldr	r2, [r7, #8]
 8003d4a:	68b9      	ldr	r1, [r7, #8]
 8003d4c:	68f8      	ldr	r0, [r7, #12]
 8003d4e:	f7ff fded 	bl	800392c <ecFullAdd>
 8003d52:	4603      	mov	r3, r0
 8003d54:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003d56:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d58:	2b00      	cmp	r3, #0
 8003d5a:	d01b      	beq.n	8003d94 <ecMult+0x276>
 8003d5c:	e03c      	b.n	8003dd8 <ecMult+0x2ba>
         }
         //Check whether h(i) == 0 and k(i) == 1
         else if(!mpiGetBitValue(&h, i) && mpiGetBitValue(d, i))
 8003d5e:	f107 0314 	add.w	r3, r7, #20
 8003d62:	6a39      	ldr	r1, [r7, #32]
 8003d64:	4618      	mov	r0, r3
 8003d66:	f003 f9c7 	bl	80070f8 <mpiGetBitValue>
 8003d6a:	4603      	mov	r3, r0
 8003d6c:	2b00      	cmp	r3, #0
 8003d6e:	d111      	bne.n	8003d94 <ecMult+0x276>
 8003d70:	6a39      	ldr	r1, [r7, #32]
 8003d72:	6878      	ldr	r0, [r7, #4]
 8003d74:	f003 f9c0 	bl	80070f8 <mpiGetBitValue>
 8003d78:	4603      	mov	r3, r0
 8003d7a:	2b00      	cmp	r3, #0
 8003d7c:	d00a      	beq.n	8003d94 <ecMult+0x276>
         {
            //Compute R = R - S
            EC_CHECK(ecFullSub(params, r, r, s));
 8003d7e:	683b      	ldr	r3, [r7, #0]
 8003d80:	68ba      	ldr	r2, [r7, #8]
 8003d82:	68b9      	ldr	r1, [r7, #8]
 8003d84:	68f8      	ldr	r0, [r7, #12]
 8003d86:	f7ff fe77 	bl	8003a78 <ecFullSub>
 8003d8a:	4603      	mov	r3, r0
 8003d8c:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003d8e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d90:	2b00      	cmp	r3, #0
 8003d92:	d120      	bne.n	8003dd6 <ecMult+0x2b8>
      for(i = mpiGetBitLength(&h) - 2; i >= 1; i--)
 8003d94:	6a3b      	ldr	r3, [r7, #32]
 8003d96:	3b01      	subs	r3, #1
 8003d98:	623b      	str	r3, [r7, #32]
 8003d9a:	6a3b      	ldr	r3, [r7, #32]
 8003d9c:	2b00      	cmp	r3, #0
 8003d9e:	d1b8      	bne.n	8003d12 <ecMult+0x1f4>
         }
      }
#endif
   }

end:
 8003da0:	e01a      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8003da2:	bf00      	nop
 8003da4:	e018      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 8003da6:	bf00      	nop
 8003da8:	e016      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiCopy(&r->x, &s->x));
 8003daa:	bf00      	nop
 8003dac:	e014      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiCopy(&r->y, &s->y));
 8003dae:	bf00      	nop
 8003db0:	e012      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiSetValue(&r->x, 1));
 8003db2:	bf00      	nop
 8003db4:	e010      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiSetValue(&r->y, 1));
 8003db6:	bf00      	nop
 8003db8:	e00e      	b.n	8003dd8 <ecMult+0x2ba>
         EC_CHECK(ecAffinify(params, r, s));
 8003dba:	bf00      	nop
 8003dbc:	e00c      	b.n	8003dd8 <ecMult+0x2ba>
         MPI_CHECK(mpiCopy(&r->x, &s->x));
 8003dbe:	bf00      	nop
 8003dc0:	e00a      	b.n	8003dd8 <ecMult+0x2ba>
         MPI_CHECK(mpiCopy(&r->y, &s->y));
 8003dc2:	bf00      	nop
 8003dc4:	e008      	b.n	8003dd8 <ecMult+0x2ba>
         MPI_CHECK(mpiCopy(&r->z, &s->z));
 8003dc6:	bf00      	nop
 8003dc8:	e006      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiAdd(&h, d, d));
 8003dca:	bf00      	nop
 8003dcc:	e004      	b.n	8003dd8 <ecMult+0x2ba>
      MPI_CHECK(mpiAdd(&h, &h, d));
 8003dce:	bf00      	nop
 8003dd0:	e002      	b.n	8003dd8 <ecMult+0x2ba>
         EC_CHECK(ecDouble(params, r, r));
 8003dd2:	bf00      	nop
 8003dd4:	e000      	b.n	8003dd8 <ecMult+0x2ba>
            EC_CHECK(ecFullSub(params, r, r, s));
 8003dd6:	bf00      	nop
   //Release multiple precision integer
   mpiFree(&h);
 8003dd8:	f107 0314 	add.w	r3, r7, #20
 8003ddc:	4618      	mov	r0, r3
 8003dde:	f003 f848 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8003de2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 8003de4:	4618      	mov	r0, r3
 8003de6:	3728      	adds	r7, #40	; 0x28
 8003de8:	46bd      	mov	sp, r7
 8003dea:	bd80      	pop	{r7, pc}

08003dec <ecAddMod>:
 * @return Error code
 **/

error_t ecAddMod(const EcDomainParameters *params, Mpi *r, const Mpi *a,
   const Mpi *b)
{
 8003dec:	b580      	push	{r7, lr}
 8003dee:	b086      	sub	sp, #24
 8003df0:	af00      	add	r7, sp, #0
 8003df2:	60f8      	str	r0, [r7, #12]
 8003df4:	60b9      	str	r1, [r7, #8]
 8003df6:	607a      	str	r2, [r7, #4]
 8003df8:	603b      	str	r3, [r7, #0]
   error_t error;

   //Compute R = A + B
   MPI_CHECK(mpiAdd(r, a, b));
 8003dfa:	683a      	ldr	r2, [r7, #0]
 8003dfc:	6879      	ldr	r1, [r7, #4]
 8003dfe:	68b8      	ldr	r0, [r7, #8]
 8003e00:	f003 fcb2 	bl	8007768 <mpiAdd>
 8003e04:	4603      	mov	r3, r0
 8003e06:	82fb      	strh	r3, [r7, #22]
 8003e08:	8afb      	ldrh	r3, [r7, #22]
 8003e0a:	2b00      	cmp	r3, #0
 8003e0c:	d114      	bne.n	8003e38 <ecAddMod+0x4c>

   //Compute R = (A + B) mod p
   if(mpiComp(r, &params->p) >= 0)
 8003e0e:	68fb      	ldr	r3, [r7, #12]
 8003e10:	3308      	adds	r3, #8
 8003e12:	4619      	mov	r1, r3
 8003e14:	68b8      	ldr	r0, [r7, #8]
 8003e16:	f003 f993 	bl	8007140 <mpiComp>
 8003e1a:	4603      	mov	r3, r0
 8003e1c:	2b00      	cmp	r3, #0
 8003e1e:	db0d      	blt.n	8003e3c <ecAddMod+0x50>
   {
      MPI_CHECK(mpiSub(r, r, &params->p));
 8003e20:	68fb      	ldr	r3, [r7, #12]
 8003e22:	3308      	adds	r3, #8
 8003e24:	461a      	mov	r2, r3
 8003e26:	68b9      	ldr	r1, [r7, #8]
 8003e28:	68b8      	ldr	r0, [r7, #8]
 8003e2a:	f003 fcfd 	bl	8007828 <mpiSub>
 8003e2e:	4603      	mov	r3, r0
 8003e30:	82fb      	strh	r3, [r7, #22]
 8003e32:	8afb      	ldrh	r3, [r7, #22]
 8003e34:	2b00      	cmp	r3, #0
   }

end:
 8003e36:	e001      	b.n	8003e3c <ecAddMod+0x50>
   MPI_CHECK(mpiAdd(r, a, b));
 8003e38:	bf00      	nop
 8003e3a:	e000      	b.n	8003e3e <ecAddMod+0x52>
end:
 8003e3c:	bf00      	nop
   //Return status code
   return error;
 8003e3e:	8afb      	ldrh	r3, [r7, #22]
}
 8003e40:	4618      	mov	r0, r3
 8003e42:	3718      	adds	r7, #24
 8003e44:	46bd      	mov	sp, r7
 8003e46:	bd80      	pop	{r7, pc}

08003e48 <ecSubMod>:
 * @return Error code
 **/

error_t ecSubMod(const EcDomainParameters *params, Mpi *r, const Mpi *a,
   const Mpi *b)
{
 8003e48:	b580      	push	{r7, lr}
 8003e4a:	b086      	sub	sp, #24
 8003e4c:	af00      	add	r7, sp, #0
 8003e4e:	60f8      	str	r0, [r7, #12]
 8003e50:	60b9      	str	r1, [r7, #8]
 8003e52:	607a      	str	r2, [r7, #4]
 8003e54:	603b      	str	r3, [r7, #0]
   error_t error;

   //Compute R = A - B
   MPI_CHECK(mpiSub(r, a, b));
 8003e56:	683a      	ldr	r2, [r7, #0]
 8003e58:	6879      	ldr	r1, [r7, #4]
 8003e5a:	68b8      	ldr	r0, [r7, #8]
 8003e5c:	f003 fce4 	bl	8007828 <mpiSub>
 8003e60:	4603      	mov	r3, r0
 8003e62:	82fb      	strh	r3, [r7, #22]
 8003e64:	8afb      	ldrh	r3, [r7, #22]
 8003e66:	2b00      	cmp	r3, #0
 8003e68:	d112      	bne.n	8003e90 <ecSubMod+0x48>

   //Compute R = (A - B) mod p
   if(mpiCompInt(r, 0) < 0)
 8003e6a:	2100      	movs	r1, #0
 8003e6c:	68b8      	ldr	r0, [r7, #8]
 8003e6e:	f003 f9cd 	bl	800720c <mpiCompInt>
 8003e72:	4603      	mov	r3, r0
 8003e74:	2b00      	cmp	r3, #0
 8003e76:	da0d      	bge.n	8003e94 <ecSubMod+0x4c>
   {
      MPI_CHECK(mpiAdd(r, r, &params->p));
 8003e78:	68fb      	ldr	r3, [r7, #12]
 8003e7a:	3308      	adds	r3, #8
 8003e7c:	461a      	mov	r2, r3
 8003e7e:	68b9      	ldr	r1, [r7, #8]
 8003e80:	68b8      	ldr	r0, [r7, #8]
 8003e82:	f003 fc71 	bl	8007768 <mpiAdd>
 8003e86:	4603      	mov	r3, r0
 8003e88:	82fb      	strh	r3, [r7, #22]
 8003e8a:	8afb      	ldrh	r3, [r7, #22]
 8003e8c:	2b00      	cmp	r3, #0
   }

end:
 8003e8e:	e001      	b.n	8003e94 <ecSubMod+0x4c>
   MPI_CHECK(mpiSub(r, a, b));
 8003e90:	bf00      	nop
 8003e92:	e000      	b.n	8003e96 <ecSubMod+0x4e>
end:
 8003e94:	bf00      	nop
   //Return status code
   return error;
 8003e96:	8afb      	ldrh	r3, [r7, #22]
}
 8003e98:	4618      	mov	r0, r3
 8003e9a:	3718      	adds	r7, #24
 8003e9c:	46bd      	mov	sp, r7
 8003e9e:	bd80      	pop	{r7, pc}

08003ea0 <ecMulMod>:
 * @return Error code
 **/

__weak_func error_t ecMulMod(const EcDomainParameters *params, Mpi *r, const Mpi *a,
   const Mpi *b)
{
 8003ea0:	b580      	push	{r7, lr}
 8003ea2:	b086      	sub	sp, #24
 8003ea4:	af00      	add	r7, sp, #0
 8003ea6:	60f8      	str	r0, [r7, #12]
 8003ea8:	60b9      	str	r1, [r7, #8]
 8003eaa:	607a      	str	r2, [r7, #4]
 8003eac:	603b      	str	r3, [r7, #0]
   error_t error;

   //Compute R = A * B
   MPI_CHECK(mpiMul(r, a, b));
 8003eae:	683a      	ldr	r2, [r7, #0]
 8003eb0:	6879      	ldr	r1, [r7, #4]
 8003eb2:	68b8      	ldr	r0, [r7, #8]
 8003eb4:	f003 ff9a 	bl	8007dec <mpiMul>
 8003eb8:	4603      	mov	r3, r0
 8003eba:	82fb      	strh	r3, [r7, #22]
 8003ebc:	8afb      	ldrh	r3, [r7, #22]
 8003ebe:	2b00      	cmp	r3, #0
 8003ec0:	d11b      	bne.n	8003efa <ecMulMod+0x5a>

   //Compute R = (A * B) mod p
   if(params->mod != NULL)
 8003ec2:	68fb      	ldr	r3, [r7, #12]
 8003ec4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003ec6:	2b00      	cmp	r3, #0
 8003ec8:	d00b      	beq.n	8003ee2 <ecMulMod+0x42>
   {
      MPI_CHECK(params->mod(r, &params->p));
 8003eca:	68fb      	ldr	r3, [r7, #12]
 8003ecc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003ece:	68fa      	ldr	r2, [r7, #12]
 8003ed0:	3208      	adds	r2, #8
 8003ed2:	4611      	mov	r1, r2
 8003ed4:	68b8      	ldr	r0, [r7, #8]
 8003ed6:	4798      	blx	r3
 8003ed8:	4603      	mov	r3, r0
 8003eda:	82fb      	strh	r3, [r7, #22]
 8003edc:	8afb      	ldrh	r3, [r7, #22]
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	e00c      	b.n	8003efc <ecMulMod+0x5c>
   }
   else
   {
      MPI_CHECK(mpiMod(r, r, &params->p));
 8003ee2:	68fb      	ldr	r3, [r7, #12]
 8003ee4:	3308      	adds	r3, #8
 8003ee6:	461a      	mov	r2, r3
 8003ee8:	68b9      	ldr	r1, [r7, #8]
 8003eea:	68b8      	ldr	r0, [r7, #8]
 8003eec:	f004 f910 	bl	8008110 <mpiMod>
 8003ef0:	4603      	mov	r3, r0
 8003ef2:	82fb      	strh	r3, [r7, #22]
 8003ef4:	8afb      	ldrh	r3, [r7, #22]
 8003ef6:	2b00      	cmp	r3, #0
   }

end:
 8003ef8:	e000      	b.n	8003efc <ecMulMod+0x5c>
   MPI_CHECK(mpiMul(r, a, b));
 8003efa:	bf00      	nop
   //Return status code
   return error;
 8003efc:	8afb      	ldrh	r3, [r7, #22]
}
 8003efe:	4618      	mov	r0, r3
 8003f00:	3718      	adds	r7, #24
 8003f02:	46bd      	mov	sp, r7
 8003f04:	bd80      	pop	{r7, pc}

08003f06 <ecSqrMod>:
 * @param[in] a An integer such as 0 <= A < p
 * @return Error code
 **/

__weak_func error_t ecSqrMod(const EcDomainParameters *params, Mpi *r, const Mpi *a)
{
 8003f06:	b580      	push	{r7, lr}
 8003f08:	b086      	sub	sp, #24
 8003f0a:	af00      	add	r7, sp, #0
 8003f0c:	60f8      	str	r0, [r7, #12]
 8003f0e:	60b9      	str	r1, [r7, #8]
 8003f10:	607a      	str	r2, [r7, #4]
   error_t error;

   //Compute R = A ^ 2
   MPI_CHECK(mpiMul(r, a, a));
 8003f12:	687a      	ldr	r2, [r7, #4]
 8003f14:	6879      	ldr	r1, [r7, #4]
 8003f16:	68b8      	ldr	r0, [r7, #8]
 8003f18:	f003 ff68 	bl	8007dec <mpiMul>
 8003f1c:	4603      	mov	r3, r0
 8003f1e:	82fb      	strh	r3, [r7, #22]
 8003f20:	8afb      	ldrh	r3, [r7, #22]
 8003f22:	2b00      	cmp	r3, #0
 8003f24:	d11b      	bne.n	8003f5e <ecSqrMod+0x58>

   //Compute R = (A ^ 2) mod p
   if(params->mod != NULL)
 8003f26:	68fb      	ldr	r3, [r7, #12]
 8003f28:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003f2a:	2b00      	cmp	r3, #0
 8003f2c:	d00b      	beq.n	8003f46 <ecSqrMod+0x40>
   {
      MPI_CHECK(params->mod(r, &params->p));
 8003f2e:	68fb      	ldr	r3, [r7, #12]
 8003f30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003f32:	68fa      	ldr	r2, [r7, #12]
 8003f34:	3208      	adds	r2, #8
 8003f36:	4611      	mov	r1, r2
 8003f38:	68b8      	ldr	r0, [r7, #8]
 8003f3a:	4798      	blx	r3
 8003f3c:	4603      	mov	r3, r0
 8003f3e:	82fb      	strh	r3, [r7, #22]
 8003f40:	8afb      	ldrh	r3, [r7, #22]
 8003f42:	2b00      	cmp	r3, #0
 8003f44:	e00c      	b.n	8003f60 <ecSqrMod+0x5a>
   }
   else
   {
      MPI_CHECK(mpiMod(r, r, &params->p));
 8003f46:	68fb      	ldr	r3, [r7, #12]
 8003f48:	3308      	adds	r3, #8
 8003f4a:	461a      	mov	r2, r3
 8003f4c:	68b9      	ldr	r1, [r7, #8]
 8003f4e:	68b8      	ldr	r0, [r7, #8]
 8003f50:	f004 f8de 	bl	8008110 <mpiMod>
 8003f54:	4603      	mov	r3, r0
 8003f56:	82fb      	strh	r3, [r7, #22]
 8003f58:	8afb      	ldrh	r3, [r7, #22]
 8003f5a:	2b00      	cmp	r3, #0
   }

end:
 8003f5c:	e000      	b.n	8003f60 <ecSqrMod+0x5a>
   MPI_CHECK(mpiMul(r, a, a));
 8003f5e:	bf00      	nop
   //Return status code
   return error;
 8003f60:	8afb      	ldrh	r3, [r7, #22]
}
 8003f62:	4618      	mov	r0, r3
 8003f64:	3718      	adds	r7, #24
 8003f66:	46bd      	mov	sp, r7
 8003f68:	bd80      	pop	{r7, pc}

08003f6a <secp256r1Mod>:
 *   input and return (a mod p) as output
 * @param[in] p Prime modulus
 **/

error_t secp256r1Mod(Mpi *a, const Mpi *p)
{
 8003f6a:	b580      	push	{r7, lr}
 8003f6c:	b08c      	sub	sp, #48	; 0x30
 8003f6e:	af00      	add	r7, sp, #0
 8003f70:	6078      	str	r0, [r7, #4]
 8003f72:	6039      	str	r1, [r7, #0]
   Mpi s;
   Mpi t;
   Mpi b;

   //Initialize multiple precision integers
   mpiInit(&s);
 8003f74:	f107 0320 	add.w	r3, r7, #32
 8003f78:	4618      	mov	r0, r3
 8003f7a:	f002 ff67 	bl	8006e4c <mpiInit>
   mpiInit(&t);
 8003f7e:	f107 0314 	add.w	r3, r7, #20
 8003f82:	4618      	mov	r0, r3
 8003f84:	f002 ff62 	bl	8006e4c <mpiInit>
   mpiInit(&b);
 8003f88:	f107 0308 	add.w	r3, r7, #8
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	f002 ff5d 	bl	8006e4c <mpiInit>

   //Ajust the size of the integers
   MPI_CHECK(mpiGrow(a, 64 / MPI_INT_SIZE));
 8003f92:	2110      	movs	r1, #16
 8003f94:	6878      	ldr	r0, [r7, #4]
 8003f96:	f002 ff8c 	bl	8006eb2 <mpiGrow>
 8003f9a:	4603      	mov	r3, r0
 8003f9c:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8003f9e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8003fa0:	2b00      	cmp	r3, #0
 8003fa2:	f040 81ce 	bne.w	8004342 <secp256r1Mod+0x3d8>
   MPI_CHECK(mpiGrow(&s, 32 / MPI_INT_SIZE));
 8003fa6:	f107 0320 	add.w	r3, r7, #32
 8003faa:	2108      	movs	r1, #8
 8003fac:	4618      	mov	r0, r3
 8003fae:	f002 ff80 	bl	8006eb2 <mpiGrow>
 8003fb2:	4603      	mov	r3, r0
 8003fb4:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8003fb6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8003fb8:	2b00      	cmp	r3, #0
 8003fba:	f040 81c4 	bne.w	8004346 <secp256r1Mod+0x3dc>
   MPI_CHECK(mpiGrow(&t, 32 / MPI_INT_SIZE));
 8003fbe:	f107 0314 	add.w	r3, r7, #20
 8003fc2:	2108      	movs	r1, #8
 8003fc4:	4618      	mov	r0, r3
 8003fc6:	f002 ff74 	bl	8006eb2 <mpiGrow>
 8003fca:	4603      	mov	r3, r0
 8003fcc:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8003fce:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8003fd0:	2b00      	cmp	r3, #0
 8003fd2:	f040 81ba 	bne.w	800434a <secp256r1Mod+0x3e0>

   //Compute T = A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0
   COPY_WORD32(&t, 0, a, 0, 8);
 8003fd6:	69f8      	ldr	r0, [r7, #28]
 8003fd8:	687b      	ldr	r3, [r7, #4]
 8003fda:	689b      	ldr	r3, [r3, #8]
 8003fdc:	2220      	movs	r2, #32
 8003fde:	4619      	mov	r1, r3
 8003fe0:	f00a fa72 	bl	800e4c8 <memcpy>

   //Compute S1 = A15 | A14 | A13 | A12 | A11 | 0 | 0 | 0
   CLEAR_WORD32(&s, 0, 3);
 8003fe4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003fe6:	220c      	movs	r2, #12
 8003fe8:	2100      	movs	r1, #0
 8003fea:	4618      	mov	r0, r3
 8003fec:	f00a fa7a 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 11, 5);
 8003ff0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003ff2:	f103 000c 	add.w	r0, r3, #12
 8003ff6:	687b      	ldr	r3, [r7, #4]
 8003ff8:	689b      	ldr	r3, [r3, #8]
 8003ffa:	332c      	adds	r3, #44	; 0x2c
 8003ffc:	2214      	movs	r2, #20
 8003ffe:	4619      	mov	r1, r3
 8004000:	f00a fa62 	bl	800e4c8 <memcpy>
   //Compute T = T + 2 * S1
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004004:	f107 0220 	add.w	r2, r7, #32
 8004008:	f107 0114 	add.w	r1, r7, #20
 800400c:	f107 0314 	add.w	r3, r7, #20
 8004010:	4618      	mov	r0, r3
 8004012:	f003 fba9 	bl	8007768 <mpiAdd>
 8004016:	4603      	mov	r3, r0
 8004018:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800401a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800401c:	2b00      	cmp	r3, #0
 800401e:	f040 8196 	bne.w	800434e <secp256r1Mod+0x3e4>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004022:	f107 0220 	add.w	r2, r7, #32
 8004026:	f107 0114 	add.w	r1, r7, #20
 800402a:	f107 0314 	add.w	r3, r7, #20
 800402e:	4618      	mov	r0, r3
 8004030:	f003 fb9a 	bl	8007768 <mpiAdd>
 8004034:	4603      	mov	r3, r0
 8004036:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004038:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800403a:	2b00      	cmp	r3, #0
 800403c:	f040 8189 	bne.w	8004352 <secp256r1Mod+0x3e8>

   //Compute S2 = 0 | A15 | A14 | A13 | A12 | 0 | 0 | 0
   CLEAR_WORD32(&s, 0, 3);
 8004040:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004042:	220c      	movs	r2, #12
 8004044:	2100      	movs	r1, #0
 8004046:	4618      	mov	r0, r3
 8004048:	f00a fa4c 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 12, 4);
 800404c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800404e:	f103 000c 	add.w	r0, r3, #12
 8004052:	687b      	ldr	r3, [r7, #4]
 8004054:	689b      	ldr	r3, [r3, #8]
 8004056:	3330      	adds	r3, #48	; 0x30
 8004058:	2210      	movs	r2, #16
 800405a:	4619      	mov	r1, r3
 800405c:	f00a fa34 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 7, 1);
 8004060:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004062:	331c      	adds	r3, #28
 8004064:	2204      	movs	r2, #4
 8004066:	2100      	movs	r1, #0
 8004068:	4618      	mov	r0, r3
 800406a:	f00a fa3b 	bl	800e4e4 <memset>
   //Compute T = T + 2 * S2
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800406e:	f107 0220 	add.w	r2, r7, #32
 8004072:	f107 0114 	add.w	r1, r7, #20
 8004076:	f107 0314 	add.w	r3, r7, #20
 800407a:	4618      	mov	r0, r3
 800407c:	f003 fb74 	bl	8007768 <mpiAdd>
 8004080:	4603      	mov	r3, r0
 8004082:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004084:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004086:	2b00      	cmp	r3, #0
 8004088:	f040 8165 	bne.w	8004356 <secp256r1Mod+0x3ec>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800408c:	f107 0220 	add.w	r2, r7, #32
 8004090:	f107 0114 	add.w	r1, r7, #20
 8004094:	f107 0314 	add.w	r3, r7, #20
 8004098:	4618      	mov	r0, r3
 800409a:	f003 fb65 	bl	8007768 <mpiAdd>
 800409e:	4603      	mov	r3, r0
 80040a0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80040a2:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80040a4:	2b00      	cmp	r3, #0
 80040a6:	f040 8158 	bne.w	800435a <secp256r1Mod+0x3f0>

   //Compute S3 = A15 | A14 | 0 | 0 | 0 | A10 | A9 | A8
   COPY_WORD32(&s, 0, a, 8, 3);
 80040aa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80040ac:	687b      	ldr	r3, [r7, #4]
 80040ae:	689b      	ldr	r3, [r3, #8]
 80040b0:	3320      	adds	r3, #32
 80040b2:	220c      	movs	r2, #12
 80040b4:	4619      	mov	r1, r3
 80040b6:	f00a fa07 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 3, 3);
 80040ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80040bc:	330c      	adds	r3, #12
 80040be:	220c      	movs	r2, #12
 80040c0:	2100      	movs	r1, #0
 80040c2:	4618      	mov	r0, r3
 80040c4:	f00a fa0e 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 6, a, 14, 2);
 80040c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80040ca:	f103 0018 	add.w	r0, r3, #24
 80040ce:	687b      	ldr	r3, [r7, #4]
 80040d0:	689b      	ldr	r3, [r3, #8]
 80040d2:	3338      	adds	r3, #56	; 0x38
 80040d4:	2208      	movs	r2, #8
 80040d6:	4619      	mov	r1, r3
 80040d8:	f00a f9f6 	bl	800e4c8 <memcpy>
   //Compute T = T + S3
   MPI_CHECK(mpiAdd(&t, &t, &s));
 80040dc:	f107 0220 	add.w	r2, r7, #32
 80040e0:	f107 0114 	add.w	r1, r7, #20
 80040e4:	f107 0314 	add.w	r3, r7, #20
 80040e8:	4618      	mov	r0, r3
 80040ea:	f003 fb3d 	bl	8007768 <mpiAdd>
 80040ee:	4603      	mov	r3, r0
 80040f0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80040f2:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80040f4:	2b00      	cmp	r3, #0
 80040f6:	f040 8132 	bne.w	800435e <secp256r1Mod+0x3f4>

   //Compute S4 = A8 | A13 | A15 | A14 | A13 | A11 | A10 | A9
   COPY_WORD32(&s, 0, a, 9, 3);
 80040fa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80040fc:	687b      	ldr	r3, [r7, #4]
 80040fe:	689b      	ldr	r3, [r3, #8]
 8004100:	3324      	adds	r3, #36	; 0x24
 8004102:	220c      	movs	r2, #12
 8004104:	4619      	mov	r1, r3
 8004106:	f00a f9df 	bl	800e4c8 <memcpy>
   COPY_WORD32(&s, 3, a, 13, 3);
 800410a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800410c:	f103 000c 	add.w	r0, r3, #12
 8004110:	687b      	ldr	r3, [r7, #4]
 8004112:	689b      	ldr	r3, [r3, #8]
 8004114:	3334      	adds	r3, #52	; 0x34
 8004116:	220c      	movs	r2, #12
 8004118:	4619      	mov	r1, r3
 800411a:	f00a f9d5 	bl	800e4c8 <memcpy>
   COPY_WORD32(&s, 6, a, 13, 1);
 800411e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004120:	3318      	adds	r3, #24
 8004122:	687a      	ldr	r2, [r7, #4]
 8004124:	6892      	ldr	r2, [r2, #8]
 8004126:	3234      	adds	r2, #52	; 0x34
 8004128:	6812      	ldr	r2, [r2, #0]
 800412a:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 7, a, 8, 1);
 800412c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800412e:	331c      	adds	r3, #28
 8004130:	687a      	ldr	r2, [r7, #4]
 8004132:	6892      	ldr	r2, [r2, #8]
 8004134:	3220      	adds	r2, #32
 8004136:	6812      	ldr	r2, [r2, #0]
 8004138:	601a      	str	r2, [r3, #0]
   //Compute T = T + S4
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800413a:	f107 0220 	add.w	r2, r7, #32
 800413e:	f107 0114 	add.w	r1, r7, #20
 8004142:	f107 0314 	add.w	r3, r7, #20
 8004146:	4618      	mov	r0, r3
 8004148:	f003 fb0e 	bl	8007768 <mpiAdd>
 800414c:	4603      	mov	r3, r0
 800414e:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004150:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004152:	2b00      	cmp	r3, #0
 8004154:	f040 8105 	bne.w	8004362 <secp256r1Mod+0x3f8>

   //Compute D1 = A10 | A8 | 0 | 0 | 0 | A13 | A12 | A11
   COPY_WORD32(&s, 0, a, 11, 3);
 8004158:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800415a:	687b      	ldr	r3, [r7, #4]
 800415c:	689b      	ldr	r3, [r3, #8]
 800415e:	332c      	adds	r3, #44	; 0x2c
 8004160:	220c      	movs	r2, #12
 8004162:	4619      	mov	r1, r3
 8004164:	f00a f9b0 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 3, 3);
 8004168:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800416a:	330c      	adds	r3, #12
 800416c:	220c      	movs	r2, #12
 800416e:	2100      	movs	r1, #0
 8004170:	4618      	mov	r0, r3
 8004172:	f00a f9b7 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 6, a, 8, 1);
 8004176:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004178:	3318      	adds	r3, #24
 800417a:	687a      	ldr	r2, [r7, #4]
 800417c:	6892      	ldr	r2, [r2, #8]
 800417e:	3220      	adds	r2, #32
 8004180:	6812      	ldr	r2, [r2, #0]
 8004182:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 7, a, 10, 1);
 8004184:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004186:	331c      	adds	r3, #28
 8004188:	687a      	ldr	r2, [r7, #4]
 800418a:	6892      	ldr	r2, [r2, #8]
 800418c:	3228      	adds	r2, #40	; 0x28
 800418e:	6812      	ldr	r2, [r2, #0]
 8004190:	601a      	str	r2, [r3, #0]
   //Compute T = T - D1
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004192:	f107 0220 	add.w	r2, r7, #32
 8004196:	f107 0114 	add.w	r1, r7, #20
 800419a:	f107 0314 	add.w	r3, r7, #20
 800419e:	4618      	mov	r0, r3
 80041a0:	f003 fb42 	bl	8007828 <mpiSub>
 80041a4:	4603      	mov	r3, r0
 80041a6:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80041a8:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80041aa:	2b00      	cmp	r3, #0
 80041ac:	f040 80db 	bne.w	8004366 <secp256r1Mod+0x3fc>

   //Compute D2 = A11 | A9 | 0 | 0 | A15 | A14 | A13 | A12
   COPY_WORD32(&s, 0, a, 12, 4);
 80041b0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80041b2:	687b      	ldr	r3, [r7, #4]
 80041b4:	689b      	ldr	r3, [r3, #8]
 80041b6:	3330      	adds	r3, #48	; 0x30
 80041b8:	2210      	movs	r2, #16
 80041ba:	4619      	mov	r1, r3
 80041bc:	f00a f984 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 4, 2);
 80041c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80041c2:	3310      	adds	r3, #16
 80041c4:	2208      	movs	r2, #8
 80041c6:	2100      	movs	r1, #0
 80041c8:	4618      	mov	r0, r3
 80041ca:	f00a f98b 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 6, a, 9, 1);
 80041ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80041d0:	3318      	adds	r3, #24
 80041d2:	687a      	ldr	r2, [r7, #4]
 80041d4:	6892      	ldr	r2, [r2, #8]
 80041d6:	3224      	adds	r2, #36	; 0x24
 80041d8:	6812      	ldr	r2, [r2, #0]
 80041da:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 7, a, 11, 1);
 80041dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80041de:	331c      	adds	r3, #28
 80041e0:	687a      	ldr	r2, [r7, #4]
 80041e2:	6892      	ldr	r2, [r2, #8]
 80041e4:	322c      	adds	r2, #44	; 0x2c
 80041e6:	6812      	ldr	r2, [r2, #0]
 80041e8:	601a      	str	r2, [r3, #0]
   //Compute T = T - D2
   MPI_CHECK(mpiSub(&t, &t, &s));
 80041ea:	f107 0220 	add.w	r2, r7, #32
 80041ee:	f107 0114 	add.w	r1, r7, #20
 80041f2:	f107 0314 	add.w	r3, r7, #20
 80041f6:	4618      	mov	r0, r3
 80041f8:	f003 fb16 	bl	8007828 <mpiSub>
 80041fc:	4603      	mov	r3, r0
 80041fe:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004200:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004202:	2b00      	cmp	r3, #0
 8004204:	f040 80b1 	bne.w	800436a <secp256r1Mod+0x400>

   //Compute D3 = A12 | 0 | A10 | A9 | A8 | A15 | A14 | A13
   COPY_WORD32(&s, 0, a, 13, 3);
 8004208:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800420a:	687b      	ldr	r3, [r7, #4]
 800420c:	689b      	ldr	r3, [r3, #8]
 800420e:	3334      	adds	r3, #52	; 0x34
 8004210:	220c      	movs	r2, #12
 8004212:	4619      	mov	r1, r3
 8004214:	f00a f958 	bl	800e4c8 <memcpy>
   COPY_WORD32(&s, 3, a, 8, 3);
 8004218:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800421a:	f103 000c 	add.w	r0, r3, #12
 800421e:	687b      	ldr	r3, [r7, #4]
 8004220:	689b      	ldr	r3, [r3, #8]
 8004222:	3320      	adds	r3, #32
 8004224:	220c      	movs	r2, #12
 8004226:	4619      	mov	r1, r3
 8004228:	f00a f94e 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 6, 1);
 800422c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800422e:	3318      	adds	r3, #24
 8004230:	2204      	movs	r2, #4
 8004232:	2100      	movs	r1, #0
 8004234:	4618      	mov	r0, r3
 8004236:	f00a f955 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 7, a, 12, 1);
 800423a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800423c:	331c      	adds	r3, #28
 800423e:	687a      	ldr	r2, [r7, #4]
 8004240:	6892      	ldr	r2, [r2, #8]
 8004242:	3230      	adds	r2, #48	; 0x30
 8004244:	6812      	ldr	r2, [r2, #0]
 8004246:	601a      	str	r2, [r3, #0]
   //Compute T = T - D3
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004248:	f107 0220 	add.w	r2, r7, #32
 800424c:	f107 0114 	add.w	r1, r7, #20
 8004250:	f107 0314 	add.w	r3, r7, #20
 8004254:	4618      	mov	r0, r3
 8004256:	f003 fae7 	bl	8007828 <mpiSub>
 800425a:	4603      	mov	r3, r0
 800425c:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800425e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004260:	2b00      	cmp	r3, #0
 8004262:	f040 8084 	bne.w	800436e <secp256r1Mod+0x404>

   //Compute D4 = A13 | 0 | A11 | A10 | A9 | 0 | A15 | A14
   COPY_WORD32(&s, 0, a, 14, 2);
 8004266:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8004268:	687b      	ldr	r3, [r7, #4]
 800426a:	689b      	ldr	r3, [r3, #8]
 800426c:	3338      	adds	r3, #56	; 0x38
 800426e:	2208      	movs	r2, #8
 8004270:	4619      	mov	r1, r3
 8004272:	f00a f929 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 2, 1);
 8004276:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004278:	3308      	adds	r3, #8
 800427a:	2204      	movs	r2, #4
 800427c:	2100      	movs	r1, #0
 800427e:	4618      	mov	r0, r3
 8004280:	f00a f930 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 9, 3);
 8004284:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004286:	f103 000c 	add.w	r0, r3, #12
 800428a:	687b      	ldr	r3, [r7, #4]
 800428c:	689b      	ldr	r3, [r3, #8]
 800428e:	3324      	adds	r3, #36	; 0x24
 8004290:	220c      	movs	r2, #12
 8004292:	4619      	mov	r1, r3
 8004294:	f00a f918 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 6, 1);
 8004298:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800429a:	3318      	adds	r3, #24
 800429c:	2204      	movs	r2, #4
 800429e:	2100      	movs	r1, #0
 80042a0:	4618      	mov	r0, r3
 80042a2:	f00a f91f 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 7, a, 13, 1);
 80042a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042a8:	331c      	adds	r3, #28
 80042aa:	687a      	ldr	r2, [r7, #4]
 80042ac:	6892      	ldr	r2, [r2, #8]
 80042ae:	3234      	adds	r2, #52	; 0x34
 80042b0:	6812      	ldr	r2, [r2, #0]
 80042b2:	601a      	str	r2, [r3, #0]
   //Compute T = T - D4
   MPI_CHECK(mpiSub(&t, &t, &s));
 80042b4:	f107 0220 	add.w	r2, r7, #32
 80042b8:	f107 0114 	add.w	r1, r7, #20
 80042bc:	f107 0314 	add.w	r3, r7, #20
 80042c0:	4618      	mov	r0, r3
 80042c2:	f003 fab1 	bl	8007828 <mpiSub>
 80042c6:	4603      	mov	r3, r0
 80042c8:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80042ca:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80042cc:	2b00      	cmp	r3, #0
 80042ce:	d150      	bne.n	8004372 <secp256r1Mod+0x408>

   //Compute (T + 2 * S1 + 2 * S2 + S3 + S4 - D1 - D2 - D3 - D4) mod p
   while(mpiComp(&t, p) >= 0)
 80042d0:	e00c      	b.n	80042ec <secp256r1Mod+0x382>
   {
      MPI_CHECK(mpiSub(&t, &t, p));
 80042d2:	f107 0114 	add.w	r1, r7, #20
 80042d6:	f107 0314 	add.w	r3, r7, #20
 80042da:	683a      	ldr	r2, [r7, #0]
 80042dc:	4618      	mov	r0, r3
 80042de:	f003 faa3 	bl	8007828 <mpiSub>
 80042e2:	4603      	mov	r3, r0
 80042e4:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80042e6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d144      	bne.n	8004376 <secp256r1Mod+0x40c>
   while(mpiComp(&t, p) >= 0)
 80042ec:	f107 0314 	add.w	r3, r7, #20
 80042f0:	6839      	ldr	r1, [r7, #0]
 80042f2:	4618      	mov	r0, r3
 80042f4:	f002 ff24 	bl	8007140 <mpiComp>
 80042f8:	4603      	mov	r3, r0
 80042fa:	2b00      	cmp	r3, #0
 80042fc:	dae9      	bge.n	80042d2 <secp256r1Mod+0x368>
   }

   while(mpiCompInt(&t, 0) < 0)
 80042fe:	e00c      	b.n	800431a <secp256r1Mod+0x3b0>
   {
      MPI_CHECK(mpiAdd(&t, &t, p));
 8004300:	f107 0114 	add.w	r1, r7, #20
 8004304:	f107 0314 	add.w	r3, r7, #20
 8004308:	683a      	ldr	r2, [r7, #0]
 800430a:	4618      	mov	r0, r3
 800430c:	f003 fa2c 	bl	8007768 <mpiAdd>
 8004310:	4603      	mov	r3, r0
 8004312:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004314:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004316:	2b00      	cmp	r3, #0
 8004318:	d12f      	bne.n	800437a <secp256r1Mod+0x410>
   while(mpiCompInt(&t, 0) < 0)
 800431a:	f107 0314 	add.w	r3, r7, #20
 800431e:	2100      	movs	r1, #0
 8004320:	4618      	mov	r0, r3
 8004322:	f002 ff73 	bl	800720c <mpiCompInt>
 8004326:	4603      	mov	r3, r0
 8004328:	2b00      	cmp	r3, #0
 800432a:	dbe9      	blt.n	8004300 <secp256r1Mod+0x396>
   }

   //Save result
   MPI_CHECK(mpiCopy(a, &t));
 800432c:	f107 0314 	add.w	r3, r7, #20
 8004330:	4619      	mov	r1, r3
 8004332:	6878      	ldr	r0, [r7, #4]
 8004334:	f002 ffd9 	bl	80072ea <mpiCopy>
 8004338:	4603      	mov	r3, r0
 800433a:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800433c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800433e:	2b00      	cmp	r3, #0

end:
 8004340:	e01c      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiGrow(a, 64 / MPI_INT_SIZE));
 8004342:	bf00      	nop
 8004344:	e01a      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiGrow(&s, 32 / MPI_INT_SIZE));
 8004346:	bf00      	nop
 8004348:	e018      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiGrow(&t, 32 / MPI_INT_SIZE));
 800434a:	bf00      	nop
 800434c:	e016      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800434e:	bf00      	nop
 8004350:	e014      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004352:	bf00      	nop
 8004354:	e012      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004356:	bf00      	nop
 8004358:	e010      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800435a:	bf00      	nop
 800435c:	e00e      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800435e:	bf00      	nop
 8004360:	e00c      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004362:	bf00      	nop
 8004364:	e00a      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004366:	bf00      	nop
 8004368:	e008      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiSub(&t, &t, &s));
 800436a:	bf00      	nop
 800436c:	e006      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiSub(&t, &t, &s));
 800436e:	bf00      	nop
 8004370:	e004      	b.n	800437c <secp256r1Mod+0x412>
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004372:	bf00      	nop
 8004374:	e002      	b.n	800437c <secp256r1Mod+0x412>
      MPI_CHECK(mpiSub(&t, &t, p));
 8004376:	bf00      	nop
 8004378:	e000      	b.n	800437c <secp256r1Mod+0x412>
      MPI_CHECK(mpiAdd(&t, &t, p));
 800437a:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&s);
 800437c:	f107 0320 	add.w	r3, r7, #32
 8004380:	4618      	mov	r0, r3
 8004382:	f002 fd76 	bl	8006e72 <mpiFree>
   mpiFree(&t);
 8004386:	f107 0314 	add.w	r3, r7, #20
 800438a:	4618      	mov	r0, r3
 800438c:	f002 fd71 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8004390:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
}
 8004392:	4618      	mov	r0, r3
 8004394:	3730      	adds	r7, #48	; 0x30
 8004396:	46bd      	mov	sp, r7
 8004398:	bd80      	pop	{r7, pc}

0800439a <secp384r1Mod>:
 *   input and return (a mod p) as output
 * @param[in] p Prime modulus
 **/

error_t secp384r1Mod(Mpi *a, const Mpi *p)
{
 800439a:	b580      	push	{r7, lr}
 800439c:	b08a      	sub	sp, #40	; 0x28
 800439e:	af00      	add	r7, sp, #0
 80043a0:	6078      	str	r0, [r7, #4]
 80043a2:	6039      	str	r1, [r7, #0]
   error_t error;
   Mpi s;
   Mpi t;

   //Initialize multiple precision integers
   mpiInit(&s);
 80043a4:	f107 0318 	add.w	r3, r7, #24
 80043a8:	4618      	mov	r0, r3
 80043aa:	f002 fd4f 	bl	8006e4c <mpiInit>
   mpiInit(&t);
 80043ae:	f107 030c 	add.w	r3, r7, #12
 80043b2:	4618      	mov	r0, r3
 80043b4:	f002 fd4a 	bl	8006e4c <mpiInit>

   //Ajust the size of the integers
   MPI_CHECK(mpiGrow(a, 96 / MPI_INT_SIZE));
 80043b8:	2118      	movs	r1, #24
 80043ba:	6878      	ldr	r0, [r7, #4]
 80043bc:	f002 fd79 	bl	8006eb2 <mpiGrow>
 80043c0:	4603      	mov	r3, r0
 80043c2:	84fb      	strh	r3, [r7, #38]	; 0x26
 80043c4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80043c6:	2b00      	cmp	r3, #0
 80043c8:	f040 81b7 	bne.w	800473a <secp384r1Mod+0x3a0>
   MPI_CHECK(mpiGrow(&s, 48 / MPI_INT_SIZE));
 80043cc:	f107 0318 	add.w	r3, r7, #24
 80043d0:	210c      	movs	r1, #12
 80043d2:	4618      	mov	r0, r3
 80043d4:	f002 fd6d 	bl	8006eb2 <mpiGrow>
 80043d8:	4603      	mov	r3, r0
 80043da:	84fb      	strh	r3, [r7, #38]	; 0x26
 80043dc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80043de:	2b00      	cmp	r3, #0
 80043e0:	f040 81ad 	bne.w	800473e <secp384r1Mod+0x3a4>
   MPI_CHECK(mpiGrow(&t, 48 / MPI_INT_SIZE));
 80043e4:	f107 030c 	add.w	r3, r7, #12
 80043e8:	210c      	movs	r1, #12
 80043ea:	4618      	mov	r0, r3
 80043ec:	f002 fd61 	bl	8006eb2 <mpiGrow>
 80043f0:	4603      	mov	r3, r0
 80043f2:	84fb      	strh	r3, [r7, #38]	; 0x26
 80043f4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80043f6:	2b00      	cmp	r3, #0
 80043f8:	f040 81a3 	bne.w	8004742 <secp384r1Mod+0x3a8>

   //Compute T = A11 | A10 | A9 | A8 | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0
   COPY_WORD32(&t, 0, a, 0, 12);
 80043fc:	6978      	ldr	r0, [r7, #20]
 80043fe:	687b      	ldr	r3, [r7, #4]
 8004400:	689b      	ldr	r3, [r3, #8]
 8004402:	2230      	movs	r2, #48	; 0x30
 8004404:	4619      	mov	r1, r3
 8004406:	f00a f85f 	bl	800e4c8 <memcpy>

   //Compute S1 = 0 | 0 | 0 | 0 | 0 | A23 | A22 | A21 | 0 | 0 | 0 | 0
   CLEAR_WORD32(&s, 0, 4);
 800440a:	6a3b      	ldr	r3, [r7, #32]
 800440c:	2210      	movs	r2, #16
 800440e:	2100      	movs	r1, #0
 8004410:	4618      	mov	r0, r3
 8004412:	f00a f867 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 4, a, 21, 3);
 8004416:	6a3b      	ldr	r3, [r7, #32]
 8004418:	f103 0010 	add.w	r0, r3, #16
 800441c:	687b      	ldr	r3, [r7, #4]
 800441e:	689b      	ldr	r3, [r3, #8]
 8004420:	3354      	adds	r3, #84	; 0x54
 8004422:	220c      	movs	r2, #12
 8004424:	4619      	mov	r1, r3
 8004426:	f00a f84f 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 7, 5);
 800442a:	6a3b      	ldr	r3, [r7, #32]
 800442c:	331c      	adds	r3, #28
 800442e:	2214      	movs	r2, #20
 8004430:	2100      	movs	r1, #0
 8004432:	4618      	mov	r0, r3
 8004434:	f00a f856 	bl	800e4e4 <memset>
   //Compute T = T + 2 * S1
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004438:	f107 0218 	add.w	r2, r7, #24
 800443c:	f107 010c 	add.w	r1, r7, #12
 8004440:	f107 030c 	add.w	r3, r7, #12
 8004444:	4618      	mov	r0, r3
 8004446:	f003 f98f 	bl	8007768 <mpiAdd>
 800444a:	4603      	mov	r3, r0
 800444c:	84fb      	strh	r3, [r7, #38]	; 0x26
 800444e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004450:	2b00      	cmp	r3, #0
 8004452:	f040 8178 	bne.w	8004746 <secp384r1Mod+0x3ac>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004456:	f107 0218 	add.w	r2, r7, #24
 800445a:	f107 010c 	add.w	r1, r7, #12
 800445e:	f107 030c 	add.w	r3, r7, #12
 8004462:	4618      	mov	r0, r3
 8004464:	f003 f980 	bl	8007768 <mpiAdd>
 8004468:	4603      	mov	r3, r0
 800446a:	84fb      	strh	r3, [r7, #38]	; 0x26
 800446c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800446e:	2b00      	cmp	r3, #0
 8004470:	f040 816b 	bne.w	800474a <secp384r1Mod+0x3b0>

   //Compute S2 = A23 | A22 | A21 | A20 | A19 | A18 | A17 | A16 | A15 | A14 | A13 | A12
   COPY_WORD32(&s, 0, a, 12, 12);
 8004474:	6a38      	ldr	r0, [r7, #32]
 8004476:	687b      	ldr	r3, [r7, #4]
 8004478:	689b      	ldr	r3, [r3, #8]
 800447a:	3330      	adds	r3, #48	; 0x30
 800447c:	2230      	movs	r2, #48	; 0x30
 800447e:	4619      	mov	r1, r3
 8004480:	f00a f822 	bl	800e4c8 <memcpy>
   //Compute T = T + S2
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004484:	f107 0218 	add.w	r2, r7, #24
 8004488:	f107 010c 	add.w	r1, r7, #12
 800448c:	f107 030c 	add.w	r3, r7, #12
 8004490:	4618      	mov	r0, r3
 8004492:	f003 f969 	bl	8007768 <mpiAdd>
 8004496:	4603      	mov	r3, r0
 8004498:	84fb      	strh	r3, [r7, #38]	; 0x26
 800449a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800449c:	2b00      	cmp	r3, #0
 800449e:	f040 8156 	bne.w	800474e <secp384r1Mod+0x3b4>

   //Compute S3 = A20 | A19 | A18 | A17 | A16 | A15 | A14 | A13 | A12 | A23| A22 | A21
   COPY_WORD32(&s, 0, a, 21, 3);
 80044a2:	6a38      	ldr	r0, [r7, #32]
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	689b      	ldr	r3, [r3, #8]
 80044a8:	3354      	adds	r3, #84	; 0x54
 80044aa:	220c      	movs	r2, #12
 80044ac:	4619      	mov	r1, r3
 80044ae:	f00a f80b 	bl	800e4c8 <memcpy>
   COPY_WORD32(&s, 3, a, 12, 9);
 80044b2:	6a3b      	ldr	r3, [r7, #32]
 80044b4:	f103 000c 	add.w	r0, r3, #12
 80044b8:	687b      	ldr	r3, [r7, #4]
 80044ba:	689b      	ldr	r3, [r3, #8]
 80044bc:	3330      	adds	r3, #48	; 0x30
 80044be:	2224      	movs	r2, #36	; 0x24
 80044c0:	4619      	mov	r1, r3
 80044c2:	f00a f801 	bl	800e4c8 <memcpy>
   //Compute T = T + S3
   MPI_CHECK(mpiAdd(&t, &t, &s));
 80044c6:	f107 0218 	add.w	r2, r7, #24
 80044ca:	f107 010c 	add.w	r1, r7, #12
 80044ce:	f107 030c 	add.w	r3, r7, #12
 80044d2:	4618      	mov	r0, r3
 80044d4:	f003 f948 	bl	8007768 <mpiAdd>
 80044d8:	4603      	mov	r3, r0
 80044da:	84fb      	strh	r3, [r7, #38]	; 0x26
 80044dc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80044de:	2b00      	cmp	r3, #0
 80044e0:	f040 8137 	bne.w	8004752 <secp384r1Mod+0x3b8>

   //Compute S4 = A19 | A18 | A17 | A16 | A15 | A14 | A13 | A12 | A20 | 0 | A23 | 0
   CLEAR_WORD32(&s, 0, 1);
 80044e4:	6a3b      	ldr	r3, [r7, #32]
 80044e6:	2204      	movs	r2, #4
 80044e8:	2100      	movs	r1, #0
 80044ea:	4618      	mov	r0, r3
 80044ec:	f009 fffa 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 1, a, 23, 1);
 80044f0:	6a3b      	ldr	r3, [r7, #32]
 80044f2:	3304      	adds	r3, #4
 80044f4:	687a      	ldr	r2, [r7, #4]
 80044f6:	6892      	ldr	r2, [r2, #8]
 80044f8:	325c      	adds	r2, #92	; 0x5c
 80044fa:	6812      	ldr	r2, [r2, #0]
 80044fc:	601a      	str	r2, [r3, #0]
   CLEAR_WORD32(&s, 2, 1);
 80044fe:	6a3b      	ldr	r3, [r7, #32]
 8004500:	3308      	adds	r3, #8
 8004502:	2204      	movs	r2, #4
 8004504:	2100      	movs	r1, #0
 8004506:	4618      	mov	r0, r3
 8004508:	f009 ffec 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 20, 1);
 800450c:	6a3b      	ldr	r3, [r7, #32]
 800450e:	330c      	adds	r3, #12
 8004510:	687a      	ldr	r2, [r7, #4]
 8004512:	6892      	ldr	r2, [r2, #8]
 8004514:	3250      	adds	r2, #80	; 0x50
 8004516:	6812      	ldr	r2, [r2, #0]
 8004518:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 4, a, 12, 8);
 800451a:	6a3b      	ldr	r3, [r7, #32]
 800451c:	f103 0010 	add.w	r0, r3, #16
 8004520:	687b      	ldr	r3, [r7, #4]
 8004522:	689b      	ldr	r3, [r3, #8]
 8004524:	3330      	adds	r3, #48	; 0x30
 8004526:	2220      	movs	r2, #32
 8004528:	4619      	mov	r1, r3
 800452a:	f009 ffcd 	bl	800e4c8 <memcpy>
   //Compute T = T + S4
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800452e:	f107 0218 	add.w	r2, r7, #24
 8004532:	f107 010c 	add.w	r1, r7, #12
 8004536:	f107 030c 	add.w	r3, r7, #12
 800453a:	4618      	mov	r0, r3
 800453c:	f003 f914 	bl	8007768 <mpiAdd>
 8004540:	4603      	mov	r3, r0
 8004542:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004544:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004546:	2b00      	cmp	r3, #0
 8004548:	f040 8105 	bne.w	8004756 <secp384r1Mod+0x3bc>

   //Compute S5 = 0 | 0 | 0 | 0 | A23 | A22 | A21 | A20 | 0 | 0 | 0 | 0
   CLEAR_WORD32(&s, 0, 4);
 800454c:	6a3b      	ldr	r3, [r7, #32]
 800454e:	2210      	movs	r2, #16
 8004550:	2100      	movs	r1, #0
 8004552:	4618      	mov	r0, r3
 8004554:	f009 ffc6 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 4, a, 20, 4);
 8004558:	6a3b      	ldr	r3, [r7, #32]
 800455a:	f103 0010 	add.w	r0, r3, #16
 800455e:	687b      	ldr	r3, [r7, #4]
 8004560:	689b      	ldr	r3, [r3, #8]
 8004562:	3350      	adds	r3, #80	; 0x50
 8004564:	2210      	movs	r2, #16
 8004566:	4619      	mov	r1, r3
 8004568:	f009 ffae 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 8, 4);
 800456c:	6a3b      	ldr	r3, [r7, #32]
 800456e:	3320      	adds	r3, #32
 8004570:	2210      	movs	r2, #16
 8004572:	2100      	movs	r1, #0
 8004574:	4618      	mov	r0, r3
 8004576:	f009 ffb5 	bl	800e4e4 <memset>
   //Compute T = T + S5
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800457a:	f107 0218 	add.w	r2, r7, #24
 800457e:	f107 010c 	add.w	r1, r7, #12
 8004582:	f107 030c 	add.w	r3, r7, #12
 8004586:	4618      	mov	r0, r3
 8004588:	f003 f8ee 	bl	8007768 <mpiAdd>
 800458c:	4603      	mov	r3, r0
 800458e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004590:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004592:	2b00      	cmp	r3, #0
 8004594:	f040 80e1 	bne.w	800475a <secp384r1Mod+0x3c0>

   //Compute S6 = 0 | 0 | 0 | 0 | 0 | 0 | A23 | A22 | A21 | 0 | 0 | A20
   COPY_WORD32(&s, 0, a, 20, 1);
 8004598:	6a3b      	ldr	r3, [r7, #32]
 800459a:	687a      	ldr	r2, [r7, #4]
 800459c:	6892      	ldr	r2, [r2, #8]
 800459e:	3250      	adds	r2, #80	; 0x50
 80045a0:	6812      	ldr	r2, [r2, #0]
 80045a2:	601a      	str	r2, [r3, #0]
   CLEAR_WORD32(&s, 1, 2);
 80045a4:	6a3b      	ldr	r3, [r7, #32]
 80045a6:	3304      	adds	r3, #4
 80045a8:	2208      	movs	r2, #8
 80045aa:	2100      	movs	r1, #0
 80045ac:	4618      	mov	r0, r3
 80045ae:	f009 ff99 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 21, 3);
 80045b2:	6a3b      	ldr	r3, [r7, #32]
 80045b4:	f103 000c 	add.w	r0, r3, #12
 80045b8:	687b      	ldr	r3, [r7, #4]
 80045ba:	689b      	ldr	r3, [r3, #8]
 80045bc:	3354      	adds	r3, #84	; 0x54
 80045be:	220c      	movs	r2, #12
 80045c0:	4619      	mov	r1, r3
 80045c2:	f009 ff81 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 6, 6);
 80045c6:	6a3b      	ldr	r3, [r7, #32]
 80045c8:	3318      	adds	r3, #24
 80045ca:	2218      	movs	r2, #24
 80045cc:	2100      	movs	r1, #0
 80045ce:	4618      	mov	r0, r3
 80045d0:	f009 ff88 	bl	800e4e4 <memset>
   //Compute T = T + S6
   MPI_CHECK(mpiAdd(&t, &t, &s));
 80045d4:	f107 0218 	add.w	r2, r7, #24
 80045d8:	f107 010c 	add.w	r1, r7, #12
 80045dc:	f107 030c 	add.w	r3, r7, #12
 80045e0:	4618      	mov	r0, r3
 80045e2:	f003 f8c1 	bl	8007768 <mpiAdd>
 80045e6:	4603      	mov	r3, r0
 80045e8:	84fb      	strh	r3, [r7, #38]	; 0x26
 80045ea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80045ec:	2b00      	cmp	r3, #0
 80045ee:	f040 80b6 	bne.w	800475e <secp384r1Mod+0x3c4>

   //Compute D1 = A22 | A21 | A20 | A19 | A18 | A17 | A16 | A15 | A14 | A13 | A12 | A23
   COPY_WORD32(&s, 0, a, 23, 1);
 80045f2:	6a3b      	ldr	r3, [r7, #32]
 80045f4:	687a      	ldr	r2, [r7, #4]
 80045f6:	6892      	ldr	r2, [r2, #8]
 80045f8:	325c      	adds	r2, #92	; 0x5c
 80045fa:	6812      	ldr	r2, [r2, #0]
 80045fc:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 1, a, 12, 11);
 80045fe:	6a3b      	ldr	r3, [r7, #32]
 8004600:	1d18      	adds	r0, r3, #4
 8004602:	687b      	ldr	r3, [r7, #4]
 8004604:	689b      	ldr	r3, [r3, #8]
 8004606:	3330      	adds	r3, #48	; 0x30
 8004608:	222c      	movs	r2, #44	; 0x2c
 800460a:	4619      	mov	r1, r3
 800460c:	f009 ff5c 	bl	800e4c8 <memcpy>
   //Compute T = T - D1
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004610:	f107 0218 	add.w	r2, r7, #24
 8004614:	f107 010c 	add.w	r1, r7, #12
 8004618:	f107 030c 	add.w	r3, r7, #12
 800461c:	4618      	mov	r0, r3
 800461e:	f003 f903 	bl	8007828 <mpiSub>
 8004622:	4603      	mov	r3, r0
 8004624:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004626:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004628:	2b00      	cmp	r3, #0
 800462a:	f040 809a 	bne.w	8004762 <secp384r1Mod+0x3c8>

   //Compute D2 = 0 | 0 | 0 | 0 | 0 | 0 | 0 | A23 | A22 | A21 | A20 | 0
   CLEAR_WORD32(&s, 0, 1);
 800462e:	6a3b      	ldr	r3, [r7, #32]
 8004630:	2204      	movs	r2, #4
 8004632:	2100      	movs	r1, #0
 8004634:	4618      	mov	r0, r3
 8004636:	f009 ff55 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 1, a, 20, 4);
 800463a:	6a3b      	ldr	r3, [r7, #32]
 800463c:	1d18      	adds	r0, r3, #4
 800463e:	687b      	ldr	r3, [r7, #4]
 8004640:	689b      	ldr	r3, [r3, #8]
 8004642:	3350      	adds	r3, #80	; 0x50
 8004644:	2210      	movs	r2, #16
 8004646:	4619      	mov	r1, r3
 8004648:	f009 ff3e 	bl	800e4c8 <memcpy>
   CLEAR_WORD32(&s, 5, 7);
 800464c:	6a3b      	ldr	r3, [r7, #32]
 800464e:	3314      	adds	r3, #20
 8004650:	221c      	movs	r2, #28
 8004652:	2100      	movs	r1, #0
 8004654:	4618      	mov	r0, r3
 8004656:	f009 ff45 	bl	800e4e4 <memset>
   //Compute T = T - D2
   MPI_CHECK(mpiSub(&t, &t, &s));
 800465a:	f107 0218 	add.w	r2, r7, #24
 800465e:	f107 010c 	add.w	r1, r7, #12
 8004662:	f107 030c 	add.w	r3, r7, #12
 8004666:	4618      	mov	r0, r3
 8004668:	f003 f8de 	bl	8007828 <mpiSub>
 800466c:	4603      	mov	r3, r0
 800466e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004670:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004672:	2b00      	cmp	r3, #0
 8004674:	d177      	bne.n	8004766 <secp384r1Mod+0x3cc>

   //Compute D3 = 0 | 0 | 0 | 0 | 0 | 0 | 0 | A23 | A23 | 0 | 0 | 0
   CLEAR_WORD32(&s, 0, 3);
 8004676:	6a3b      	ldr	r3, [r7, #32]
 8004678:	220c      	movs	r2, #12
 800467a:	2100      	movs	r1, #0
 800467c:	4618      	mov	r0, r3
 800467e:	f009 ff31 	bl	800e4e4 <memset>
   COPY_WORD32(&s, 3, a, 23, 1);
 8004682:	6a3b      	ldr	r3, [r7, #32]
 8004684:	330c      	adds	r3, #12
 8004686:	687a      	ldr	r2, [r7, #4]
 8004688:	6892      	ldr	r2, [r2, #8]
 800468a:	325c      	adds	r2, #92	; 0x5c
 800468c:	6812      	ldr	r2, [r2, #0]
 800468e:	601a      	str	r2, [r3, #0]
   COPY_WORD32(&s, 4, a, 23, 1);
 8004690:	6a3b      	ldr	r3, [r7, #32]
 8004692:	3310      	adds	r3, #16
 8004694:	687a      	ldr	r2, [r7, #4]
 8004696:	6892      	ldr	r2, [r2, #8]
 8004698:	325c      	adds	r2, #92	; 0x5c
 800469a:	6812      	ldr	r2, [r2, #0]
 800469c:	601a      	str	r2, [r3, #0]
   CLEAR_WORD32(&s, 5, 7);
 800469e:	6a3b      	ldr	r3, [r7, #32]
 80046a0:	3314      	adds	r3, #20
 80046a2:	221c      	movs	r2, #28
 80046a4:	2100      	movs	r1, #0
 80046a6:	4618      	mov	r0, r3
 80046a8:	f009 ff1c 	bl	800e4e4 <memset>
   //Compute T = T - D3
   MPI_CHECK(mpiSub(&t, &t, &s));
 80046ac:	f107 0218 	add.w	r2, r7, #24
 80046b0:	f107 010c 	add.w	r1, r7, #12
 80046b4:	f107 030c 	add.w	r3, r7, #12
 80046b8:	4618      	mov	r0, r3
 80046ba:	f003 f8b5 	bl	8007828 <mpiSub>
 80046be:	4603      	mov	r3, r0
 80046c0:	84fb      	strh	r3, [r7, #38]	; 0x26
 80046c2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80046c4:	2b00      	cmp	r3, #0
 80046c6:	d150      	bne.n	800476a <secp384r1Mod+0x3d0>

   //Compute (T + 2 * S1 + S2 + S3 + S4 + S5 + S6 - D1 - D2 - D3) mod p
   while(mpiComp(&t, p) >= 0)
 80046c8:	e00c      	b.n	80046e4 <secp384r1Mod+0x34a>
   {
      MPI_CHECK(mpiSub(&t, &t, p));
 80046ca:	f107 010c 	add.w	r1, r7, #12
 80046ce:	f107 030c 	add.w	r3, r7, #12
 80046d2:	683a      	ldr	r2, [r7, #0]
 80046d4:	4618      	mov	r0, r3
 80046d6:	f003 f8a7 	bl	8007828 <mpiSub>
 80046da:	4603      	mov	r3, r0
 80046dc:	84fb      	strh	r3, [r7, #38]	; 0x26
 80046de:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80046e0:	2b00      	cmp	r3, #0
 80046e2:	d144      	bne.n	800476e <secp384r1Mod+0x3d4>
   while(mpiComp(&t, p) >= 0)
 80046e4:	f107 030c 	add.w	r3, r7, #12
 80046e8:	6839      	ldr	r1, [r7, #0]
 80046ea:	4618      	mov	r0, r3
 80046ec:	f002 fd28 	bl	8007140 <mpiComp>
 80046f0:	4603      	mov	r3, r0
 80046f2:	2b00      	cmp	r3, #0
 80046f4:	dae9      	bge.n	80046ca <secp384r1Mod+0x330>
   }

   while(mpiCompInt(&t, 0) < 0)
 80046f6:	e00c      	b.n	8004712 <secp384r1Mod+0x378>
   {
      MPI_CHECK(mpiAdd(&t, &t, p));
 80046f8:	f107 010c 	add.w	r1, r7, #12
 80046fc:	f107 030c 	add.w	r3, r7, #12
 8004700:	683a      	ldr	r2, [r7, #0]
 8004702:	4618      	mov	r0, r3
 8004704:	f003 f830 	bl	8007768 <mpiAdd>
 8004708:	4603      	mov	r3, r0
 800470a:	84fb      	strh	r3, [r7, #38]	; 0x26
 800470c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800470e:	2b00      	cmp	r3, #0
 8004710:	d12f      	bne.n	8004772 <secp384r1Mod+0x3d8>
   while(mpiCompInt(&t, 0) < 0)
 8004712:	f107 030c 	add.w	r3, r7, #12
 8004716:	2100      	movs	r1, #0
 8004718:	4618      	mov	r0, r3
 800471a:	f002 fd77 	bl	800720c <mpiCompInt>
 800471e:	4603      	mov	r3, r0
 8004720:	2b00      	cmp	r3, #0
 8004722:	dbe9      	blt.n	80046f8 <secp384r1Mod+0x35e>
   }

   //Save result
   MPI_CHECK(mpiCopy(a, &t));
 8004724:	f107 030c 	add.w	r3, r7, #12
 8004728:	4619      	mov	r1, r3
 800472a:	6878      	ldr	r0, [r7, #4]
 800472c:	f002 fddd 	bl	80072ea <mpiCopy>
 8004730:	4603      	mov	r3, r0
 8004732:	84fb      	strh	r3, [r7, #38]	; 0x26
 8004734:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8004736:	2b00      	cmp	r3, #0

end:
 8004738:	e01c      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiGrow(a, 96 / MPI_INT_SIZE));
 800473a:	bf00      	nop
 800473c:	e01a      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiGrow(&s, 48 / MPI_INT_SIZE));
 800473e:	bf00      	nop
 8004740:	e018      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiGrow(&t, 48 / MPI_INT_SIZE));
 8004742:	bf00      	nop
 8004744:	e016      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004746:	bf00      	nop
 8004748:	e014      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800474a:	bf00      	nop
 800474c:	e012      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800474e:	bf00      	nop
 8004750:	e010      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004752:	bf00      	nop
 8004754:	e00e      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 8004756:	bf00      	nop
 8004758:	e00c      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800475a:	bf00      	nop
 800475c:	e00a      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiAdd(&t, &t, &s));
 800475e:	bf00      	nop
 8004760:	e008      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004762:	bf00      	nop
 8004764:	e006      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiSub(&t, &t, &s));
 8004766:	bf00      	nop
 8004768:	e004      	b.n	8004774 <secp384r1Mod+0x3da>
   MPI_CHECK(mpiSub(&t, &t, &s));
 800476a:	bf00      	nop
 800476c:	e002      	b.n	8004774 <secp384r1Mod+0x3da>
      MPI_CHECK(mpiSub(&t, &t, p));
 800476e:	bf00      	nop
 8004770:	e000      	b.n	8004774 <secp384r1Mod+0x3da>
      MPI_CHECK(mpiAdd(&t, &t, p));
 8004772:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&s);
 8004774:	f107 0318 	add.w	r3, r7, #24
 8004778:	4618      	mov	r0, r3
 800477a:	f002 fb7a 	bl	8006e72 <mpiFree>
   mpiFree(&t);
 800477e:	f107 030c 	add.w	r3, r7, #12
 8004782:	4618      	mov	r0, r3
 8004784:	f002 fb75 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8004788:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 800478a:	4618      	mov	r0, r3
 800478c:	3728      	adds	r7, #40	; 0x28
 800478e:	46bd      	mov	sp, r7
 8004790:	bd80      	pop	{r7, pc}

08004792 <secp521r1Mod>:
 *   input and return (a mod p) as output
 * @param[in] p Prime modulus
 **/

error_t secp521r1Mod(Mpi *a, const Mpi *p)
{
 8004792:	b580      	push	{r7, lr}
 8004794:	b086      	sub	sp, #24
 8004796:	af00      	add	r7, sp, #0
 8004798:	6078      	str	r0, [r7, #4]
 800479a:	6039      	str	r1, [r7, #0]
   error_t error;
   Mpi t;

   //Initialize multiple precision integer
   mpiInit(&t);
 800479c:	f107 0308 	add.w	r3, r7, #8
 80047a0:	4618      	mov	r0, r3
 80047a2:	f002 fb53 	bl	8006e4c <mpiInit>

   //Ajust the size of the integers
   MPI_CHECK(mpiGrow(a, 132 / MPI_INT_SIZE));
 80047a6:	2121      	movs	r1, #33	; 0x21
 80047a8:	6878      	ldr	r0, [r7, #4]
 80047aa:	f002 fb82 	bl	8006eb2 <mpiGrow>
 80047ae:	4603      	mov	r3, r0
 80047b0:	82fb      	strh	r3, [r7, #22]
 80047b2:	8afb      	ldrh	r3, [r7, #22]
 80047b4:	2b00      	cmp	r3, #0
 80047b6:	d142      	bne.n	800483e <secp521r1Mod+0xac>
   MPI_CHECK(mpiGrow(&t, 68 / MPI_INT_SIZE));
 80047b8:	f107 0308 	add.w	r3, r7, #8
 80047bc:	2111      	movs	r1, #17
 80047be:	4618      	mov	r0, r3
 80047c0:	f002 fb77 	bl	8006eb2 <mpiGrow>
 80047c4:	4603      	mov	r3, r0
 80047c6:	82fb      	strh	r3, [r7, #22]
 80047c8:	8afb      	ldrh	r3, [r7, #22]
 80047ca:	2b00      	cmp	r3, #0
 80047cc:	d139      	bne.n	8004842 <secp521r1Mod+0xb0>

   //Compute A0
   COPY_WORD32(&t, 0, a, 0, 17);
 80047ce:	6938      	ldr	r0, [r7, #16]
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	689b      	ldr	r3, [r3, #8]
 80047d4:	2244      	movs	r2, #68	; 0x44
 80047d6:	4619      	mov	r1, r3
 80047d8:	f009 fe76 	bl	800e4c8 <memcpy>
   t.data[16] &= 0x000001FF;
 80047dc:	693b      	ldr	r3, [r7, #16]
 80047de:	3340      	adds	r3, #64	; 0x40
 80047e0:	681a      	ldr	r2, [r3, #0]
 80047e2:	693b      	ldr	r3, [r7, #16]
 80047e4:	3340      	adds	r3, #64	; 0x40
 80047e6:	f3c2 0208 	ubfx	r2, r2, #0, #9
 80047ea:	601a      	str	r2, [r3, #0]

   //Compute A1
   MPI_CHECK(mpiShiftRight(a, 521));
 80047ec:	f240 2109 	movw	r1, #521	; 0x209
 80047f0:	6878      	ldr	r0, [r7, #4]
 80047f2:	f003 fa6b 	bl	8007ccc <mpiShiftRight>
 80047f6:	4603      	mov	r3, r0
 80047f8:	82fb      	strh	r3, [r7, #22]
 80047fa:	8afb      	ldrh	r3, [r7, #22]
 80047fc:	2b00      	cmp	r3, #0
 80047fe:	d122      	bne.n	8004846 <secp521r1Mod+0xb4>

   //Compute A0 + A1
   MPI_CHECK(mpiAdd(a, a, &t));
 8004800:	f107 0308 	add.w	r3, r7, #8
 8004804:	461a      	mov	r2, r3
 8004806:	6879      	ldr	r1, [r7, #4]
 8004808:	6878      	ldr	r0, [r7, #4]
 800480a:	f002 ffad 	bl	8007768 <mpiAdd>
 800480e:	4603      	mov	r3, r0
 8004810:	82fb      	strh	r3, [r7, #22]
 8004812:	8afb      	ldrh	r3, [r7, #22]
 8004814:	2b00      	cmp	r3, #0
 8004816:	d118      	bne.n	800484a <secp521r1Mod+0xb8>

   //Compute (A0 + A1) mod p
   while(mpiComp(a, p) >= 0)
 8004818:	e009      	b.n	800482e <secp521r1Mod+0x9c>
   {
      MPI_CHECK(mpiSub(a, a, p));
 800481a:	683a      	ldr	r2, [r7, #0]
 800481c:	6879      	ldr	r1, [r7, #4]
 800481e:	6878      	ldr	r0, [r7, #4]
 8004820:	f003 f802 	bl	8007828 <mpiSub>
 8004824:	4603      	mov	r3, r0
 8004826:	82fb      	strh	r3, [r7, #22]
 8004828:	8afb      	ldrh	r3, [r7, #22]
 800482a:	2b00      	cmp	r3, #0
 800482c:	d10f      	bne.n	800484e <secp521r1Mod+0xbc>
   while(mpiComp(a, p) >= 0)
 800482e:	6839      	ldr	r1, [r7, #0]
 8004830:	6878      	ldr	r0, [r7, #4]
 8004832:	f002 fc85 	bl	8007140 <mpiComp>
 8004836:	4603      	mov	r3, r0
 8004838:	2b00      	cmp	r3, #0
 800483a:	daee      	bge.n	800481a <secp521r1Mod+0x88>
   }

end:
 800483c:	e008      	b.n	8004850 <secp521r1Mod+0xbe>
   MPI_CHECK(mpiGrow(a, 132 / MPI_INT_SIZE));
 800483e:	bf00      	nop
 8004840:	e006      	b.n	8004850 <secp521r1Mod+0xbe>
   MPI_CHECK(mpiGrow(&t, 68 / MPI_INT_SIZE));
 8004842:	bf00      	nop
 8004844:	e004      	b.n	8004850 <secp521r1Mod+0xbe>
   MPI_CHECK(mpiShiftRight(a, 521));
 8004846:	bf00      	nop
 8004848:	e002      	b.n	8004850 <secp521r1Mod+0xbe>
   MPI_CHECK(mpiAdd(a, a, &t));
 800484a:	bf00      	nop
 800484c:	e000      	b.n	8004850 <secp521r1Mod+0xbe>
      MPI_CHECK(mpiSub(a, a, p));
 800484e:	bf00      	nop
   //Release multiple precision integer
   mpiFree(&t);
 8004850:	f107 0308 	add.w	r3, r7, #8
 8004854:	4618      	mov	r0, r3
 8004856:	f002 fb0c 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 800485a:	8afb      	ldrh	r3, [r7, #22]
}
 800485c:	4618      	mov	r0, r3
 800485e:	3718      	adds	r7, #24
 8004860:	46bd      	mov	sp, r7
 8004862:	bd80      	pop	{r7, pc}

08004864 <ecdsaInitSignature>:
 * @brief Initialize an ECDSA signature
 * @param[in] signature Pointer to the ECDSA signature to initialize
 **/

void ecdsaInitSignature(EcdsaSignature *signature)
{
 8004864:	b580      	push	{r7, lr}
 8004866:	b082      	sub	sp, #8
 8004868:	af00      	add	r7, sp, #0
 800486a:	6078      	str	r0, [r7, #4]
   //Initialize multiple precision integers
   mpiInit(&signature->r);
 800486c:	687b      	ldr	r3, [r7, #4]
 800486e:	4618      	mov	r0, r3
 8004870:	f002 faec 	bl	8006e4c <mpiInit>
   mpiInit(&signature->s);
 8004874:	687b      	ldr	r3, [r7, #4]
 8004876:	330c      	adds	r3, #12
 8004878:	4618      	mov	r0, r3
 800487a:	f002 fae7 	bl	8006e4c <mpiInit>
}
 800487e:	bf00      	nop
 8004880:	3708      	adds	r7, #8
 8004882:	46bd      	mov	sp, r7
 8004884:	bd80      	pop	{r7, pc}

08004886 <ecdsaFreeSignature>:
 * @brief Release an ECDSA signature
 * @param[in] signature Pointer to the ECDSA signature to free
 **/

void ecdsaFreeSignature(EcdsaSignature *signature)
{
 8004886:	b580      	push	{r7, lr}
 8004888:	b082      	sub	sp, #8
 800488a:	af00      	add	r7, sp, #0
 800488c:	6078      	str	r0, [r7, #4]
   //Release multiple precision integers
   mpiFree(&signature->r);
 800488e:	687b      	ldr	r3, [r7, #4]
 8004890:	4618      	mov	r0, r3
 8004892:	f002 faee 	bl	8006e72 <mpiFree>
   mpiFree(&signature->s);
 8004896:	687b      	ldr	r3, [r7, #4]
 8004898:	330c      	adds	r3, #12
 800489a:	4618      	mov	r0, r3
 800489c:	f002 fae9 	bl	8006e72 <mpiFree>
}
 80048a0:	bf00      	nop
 80048a2:	3708      	adds	r7, #8
 80048a4:	46bd      	mov	sp, r7
 80048a6:	bd80      	pop	{r7, pc}

080048a8 <ed25519GeneratePrivateKey>:
 * @return Error code
 **/

error_t ed25519GeneratePrivateKey(const PrngAlgo *prngAlgo, void *prngContext,
   uint8_t *privateKey)
{
 80048a8:	b580      	push	{r7, lr}
 80048aa:	b086      	sub	sp, #24
 80048ac:	af00      	add	r7, sp, #0
 80048ae:	60f8      	str	r0, [r7, #12]
 80048b0:	60b9      	str	r1, [r7, #8]
 80048b2:	607a      	str	r2, [r7, #4]
   error_t error;

   //Check parameters
   if(prngAlgo == NULL || prngContext == NULL || privateKey == NULL)
 80048b4:	68fb      	ldr	r3, [r7, #12]
 80048b6:	2b00      	cmp	r3, #0
 80048b8:	d005      	beq.n	80048c6 <ed25519GeneratePrivateKey+0x1e>
 80048ba:	68bb      	ldr	r3, [r7, #8]
 80048bc:	2b00      	cmp	r3, #0
 80048be:	d002      	beq.n	80048c6 <ed25519GeneratePrivateKey+0x1e>
 80048c0:	687b      	ldr	r3, [r7, #4]
 80048c2:	2b00      	cmp	r3, #0
 80048c4:	d101      	bne.n	80048ca <ed25519GeneratePrivateKey+0x22>
      return ERROR_INVALID_PARAMETER;
 80048c6:	2302      	movs	r3, #2
 80048c8:	e008      	b.n	80048dc <ed25519GeneratePrivateKey+0x34>

   //The private key is 32 octets of cryptographically secure random data
   error = prngAlgo->read(prngContext, privateKey, ED25519_PRIVATE_KEY_LEN);
 80048ca:	68fb      	ldr	r3, [r7, #12]
 80048cc:	695b      	ldr	r3, [r3, #20]
 80048ce:	2220      	movs	r2, #32
 80048d0:	6879      	ldr	r1, [r7, #4]
 80048d2:	68b8      	ldr	r0, [r7, #8]
 80048d4:	4798      	blx	r3
 80048d6:	4603      	mov	r3, r0
 80048d8:	82fb      	strh	r3, [r7, #22]

   //Return status code
   return error;
 80048da:	8afb      	ldrh	r3, [r7, #22]
}
 80048dc:	4618      	mov	r0, r3
 80048de:	3718      	adds	r7, #24
 80048e0:	46bd      	mov	sp, r7
 80048e2:	bd80      	pop	{r7, pc}

080048e4 <ed25519GeneratePublicKey>:
 * @param[out] publicKey EdDSA public key (32 bytes)
 * @return Error code
 **/

error_t ed25519GeneratePublicKey(const uint8_t *privateKey, uint8_t *publicKey)
{
 80048e4:	b580      	push	{r7, lr}
 80048e6:	b084      	sub	sp, #16
 80048e8:	af00      	add	r7, sp, #0
 80048ea:	6078      	str	r0, [r7, #4]
 80048ec:	6039      	str	r1, [r7, #0]
   uint8_t *s;
   Ed25519State *state;

   //Check parameters
   if(privateKey == NULL || publicKey == NULL)
 80048ee:	687b      	ldr	r3, [r7, #4]
 80048f0:	2b00      	cmp	r3, #0
 80048f2:	d002      	beq.n	80048fa <ed25519GeneratePublicKey+0x16>
 80048f4:	683b      	ldr	r3, [r7, #0]
 80048f6:	2b00      	cmp	r3, #0
 80048f8:	d101      	bne.n	80048fe <ed25519GeneratePublicKey+0x1a>
      return ERROR_INVALID_PARAMETER;
 80048fa:	2302      	movs	r3, #2
 80048fc:	e04c      	b.n	8004998 <ed25519GeneratePublicKey+0xb4>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed25519State));
 80048fe:	f44f 609e 	mov.w	r0, #1264	; 0x4f0
 8004902:	f007 f87d 	bl	800ba00 <osAllocMem>
 8004906:	60f8      	str	r0, [r7, #12]
   //Failed to allocate memory?
   if(state == NULL)
 8004908:	68fb      	ldr	r3, [r7, #12]
 800490a:	2b00      	cmp	r3, #0
 800490c:	d101      	bne.n	8004912 <ed25519GeneratePublicKey+0x2e>
      return ERROR_OUT_OF_MEMORY;
 800490e:	2364      	movs	r3, #100	; 0x64
 8004910:	e042      	b.n	8004998 <ed25519GeneratePublicKey+0xb4>

   //Hash the 32-byte private key using SHA-512
   sha512Init(&state->sha512Context);
 8004912:	68fb      	ldr	r3, [r7, #12]
 8004914:	4618      	mov	r0, r3
 8004916:	f005 fdbb 	bl	800a490 <sha512Init>
   sha512Update(&state->sha512Context, privateKey, ED25519_PRIVATE_KEY_LEN);
 800491a:	68fb      	ldr	r3, [r7, #12]
 800491c:	2220      	movs	r2, #32
 800491e:	6879      	ldr	r1, [r7, #4]
 8004920:	4618      	mov	r0, r3
 8004922:	f005 fe1d 	bl	800a560 <sha512Update>
   sha512Final(&state->sha512Context, NULL);
 8004926:	68fb      	ldr	r3, [r7, #12]
 8004928:	2100      	movs	r1, #0
 800492a:	4618      	mov	r0, r3
 800492c:	f005 fe6a 	bl	800a604 <sha512Final>

   //Only the lower 32 bytes are used for generating the public key. Interpret
   //the buffer as the little-endian integer, forming a secret scalar s
   s = state->sha512Context.digest;
 8004930:	68fb      	ldr	r3, [r7, #12]
 8004932:	60bb      	str	r3, [r7, #8]

   //The lowest three bits of the first octet are cleared, the highest bit
   //of the last octet is cleared, and the second highest bit of the last
   //octet is set
   s[0] &= 0xF8;
 8004934:	68bb      	ldr	r3, [r7, #8]
 8004936:	781b      	ldrb	r3, [r3, #0]
 8004938:	f023 0307 	bic.w	r3, r3, #7
 800493c:	b2da      	uxtb	r2, r3
 800493e:	68bb      	ldr	r3, [r7, #8]
 8004940:	701a      	strb	r2, [r3, #0]
   s[31] &= 0x7F;
 8004942:	68bb      	ldr	r3, [r7, #8]
 8004944:	331f      	adds	r3, #31
 8004946:	781a      	ldrb	r2, [r3, #0]
 8004948:	68bb      	ldr	r3, [r7, #8]
 800494a:	331f      	adds	r3, #31
 800494c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8004950:	b2d2      	uxtb	r2, r2
 8004952:	701a      	strb	r2, [r3, #0]
   s[31] |= 0x40;
 8004954:	68bb      	ldr	r3, [r7, #8]
 8004956:	331f      	adds	r3, #31
 8004958:	781a      	ldrb	r2, [r3, #0]
 800495a:	68bb      	ldr	r3, [r7, #8]
 800495c:	331f      	adds	r3, #31
 800495e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004962:	b2d2      	uxtb	r2, r2
 8004964:	701a      	strb	r2, [r3, #0]

   //Perform a fixed-base scalar multiplication s * B
   ed25519Mul(state, &state->sb, s, &ED25519_B);
 8004966:	68fb      	ldr	r3, [r7, #12]
 8004968:	f503 711c 	add.w	r1, r3, #624	; 0x270
 800496c:	4b0c      	ldr	r3, [pc, #48]	; (80049a0 <ed25519GeneratePublicKey+0xbc>)
 800496e:	68ba      	ldr	r2, [r7, #8]
 8004970:	68f8      	ldr	r0, [r7, #12]
 8004972:	f000 fb0d 	bl	8004f90 <ed25519Mul>
   //The public key A is the encoding of the point s * B
   ed25519Encode(&state->sb, publicKey);
 8004976:	68fb      	ldr	r3, [r7, #12]
 8004978:	f503 731c 	add.w	r3, r3, #624	; 0x270
 800497c:	6839      	ldr	r1, [r7, #0]
 800497e:	4618      	mov	r0, r3
 8004980:	f000 fd2d 	bl	80053de <ed25519Encode>

   //Erase working state
   osMemset(state, 0, sizeof(Ed25519State));
 8004984:	f44f 629e 	mov.w	r2, #1264	; 0x4f0
 8004988:	2100      	movs	r1, #0
 800498a:	68f8      	ldr	r0, [r7, #12]
 800498c:	f009 fdaa 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8004990:	68f8      	ldr	r0, [r7, #12]
 8004992:	f007 f843 	bl	800ba1c <osFreeMem>

   //Successful processing
   return NO_ERROR;
 8004996:	2300      	movs	r3, #0
}
 8004998:	4618      	mov	r0, r3
 800499a:	3710      	adds	r7, #16
 800499c:	46bd      	mov	sp, r7
 800499e:	bd80      	pop	{r7, pc}
 80049a0:	0800f178 	.word	0x0800f178

080049a4 <ed25519GenerateSignature>:
 **/

error_t ed25519GenerateSignature(const uint8_t *privateKey,
   const uint8_t *publicKey, const void *message, size_t messageLen,
   const void *context, uint8_t contextLen, uint8_t flag, uint8_t *signature)
{
 80049a4:	b580      	push	{r7, lr}
 80049a6:	b08e      	sub	sp, #56	; 0x38
 80049a8:	af04      	add	r7, sp, #16
 80049aa:	60f8      	str	r0, [r7, #12]
 80049ac:	60b9      	str	r1, [r7, #8]
 80049ae:	607a      	str	r2, [r7, #4]
 80049b0:	603b      	str	r3, [r7, #0]
   error_t error;
   EddsaMessageChunk messageChunks[2];

   //The message fits in a single chunk
   messageChunks[0].buffer = message;
 80049b2:	687b      	ldr	r3, [r7, #4]
 80049b4:	617b      	str	r3, [r7, #20]
   messageChunks[0].length = messageLen;
 80049b6:	683b      	ldr	r3, [r7, #0]
 80049b8:	61bb      	str	r3, [r7, #24]
   messageChunks[1].buffer = NULL;
 80049ba:	2300      	movs	r3, #0
 80049bc:	61fb      	str	r3, [r7, #28]
   messageChunks[1].length = 0;
 80049be:	2300      	movs	r3, #0
 80049c0:	623b      	str	r3, [r7, #32]

   //Ed25519 signature generation
   error = ed25519GenerateSignatureEx(privateKey, publicKey, messageChunks,
 80049c2:	f107 0214 	add.w	r2, r7, #20
 80049c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80049c8:	9302      	str	r3, [sp, #8]
 80049ca:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80049ce:	9301      	str	r3, [sp, #4]
 80049d0:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 80049d4:	9300      	str	r3, [sp, #0]
 80049d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049d8:	68b9      	ldr	r1, [r7, #8]
 80049da:	68f8      	ldr	r0, [r7, #12]
 80049dc:	f000 f808 	bl	80049f0 <ed25519GenerateSignatureEx>
 80049e0:	4603      	mov	r3, r0
 80049e2:	84fb      	strh	r3, [r7, #38]	; 0x26
      context, contextLen, flag, signature);

   //Return status code
   return error;
 80049e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 80049e6:	4618      	mov	r0, r3
 80049e8:	3728      	adds	r7, #40	; 0x28
 80049ea:	46bd      	mov	sp, r7
 80049ec:	bd80      	pop	{r7, pc}
	...

080049f0 <ed25519GenerateSignatureEx>:
 **/

error_t ed25519GenerateSignatureEx(const uint8_t *privateKey,
   const uint8_t *publicKey, const EddsaMessageChunk *messageChunks,
   const void *context, uint8_t contextLen, uint8_t flag, uint8_t *signature)
{
 80049f0:	b590      	push	{r4, r7, lr}
 80049f2:	b08b      	sub	sp, #44	; 0x2c
 80049f4:	af02      	add	r7, sp, #8
 80049f6:	60f8      	str	r0, [r7, #12]
 80049f8:	60b9      	str	r1, [r7, #8]
 80049fa:	607a      	str	r2, [r7, #4]
 80049fc:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint8_t c;
   Ed25519State *state;

   //Check parameters
   if(privateKey == NULL || signature == NULL)
 80049fe:	68fb      	ldr	r3, [r7, #12]
 8004a00:	2b00      	cmp	r3, #0
 8004a02:	d002      	beq.n	8004a0a <ed25519GenerateSignatureEx+0x1a>
 8004a04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004a06:	2b00      	cmp	r3, #0
 8004a08:	d101      	bne.n	8004a0e <ed25519GenerateSignatureEx+0x1e>
      return ERROR_INVALID_PARAMETER;
 8004a0a:	2302      	movs	r3, #2
 8004a0c:	e179      	b.n	8004d02 <ed25519GenerateSignatureEx+0x312>
   if(messageChunks == NULL)
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	2b00      	cmp	r3, #0
 8004a12:	d101      	bne.n	8004a18 <ed25519GenerateSignatureEx+0x28>
      return ERROR_INVALID_PARAMETER;
 8004a14:	2302      	movs	r3, #2
 8004a16:	e174      	b.n	8004d02 <ed25519GenerateSignatureEx+0x312>
   if(context == NULL && contextLen != 0)
 8004a18:	683b      	ldr	r3, [r7, #0]
 8004a1a:	2b00      	cmp	r3, #0
 8004a1c:	d105      	bne.n	8004a2a <ed25519GenerateSignatureEx+0x3a>
 8004a1e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8004a22:	2b00      	cmp	r3, #0
 8004a24:	d001      	beq.n	8004a2a <ed25519GenerateSignatureEx+0x3a>
      return ERROR_INVALID_PARAMETER;
 8004a26:	2302      	movs	r3, #2
 8004a28:	e16b      	b.n	8004d02 <ed25519GenerateSignatureEx+0x312>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed25519State));
 8004a2a:	f44f 609e 	mov.w	r0, #1264	; 0x4f0
 8004a2e:	f006 ffe7 	bl	800ba00 <osAllocMem>
 8004a32:	61b8      	str	r0, [r7, #24]
   //Failed to allocate memory?
   if(state == NULL)
 8004a34:	69bb      	ldr	r3, [r7, #24]
 8004a36:	2b00      	cmp	r3, #0
 8004a38:	d101      	bne.n	8004a3e <ed25519GenerateSignatureEx+0x4e>
      return ERROR_OUT_OF_MEMORY;
 8004a3a:	2364      	movs	r3, #100	; 0x64
 8004a3c:	e161      	b.n	8004d02 <ed25519GenerateSignatureEx+0x312>

   //Hash the private key, 32 octets, using SHA-512. Let h denote the
   //resulting digest
   sha512Init(&state->sha512Context);
 8004a3e:	69bb      	ldr	r3, [r7, #24]
 8004a40:	4618      	mov	r0, r3
 8004a42:	f005 fd25 	bl	800a490 <sha512Init>
   sha512Update(&state->sha512Context, privateKey, ED25519_PRIVATE_KEY_LEN);
 8004a46:	69bb      	ldr	r3, [r7, #24]
 8004a48:	2220      	movs	r2, #32
 8004a4a:	68f9      	ldr	r1, [r7, #12]
 8004a4c:	4618      	mov	r0, r3
 8004a4e:	f005 fd87 	bl	800a560 <sha512Update>
   sha512Final(&state->sha512Context, NULL);
 8004a52:	69bb      	ldr	r3, [r7, #24]
 8004a54:	2100      	movs	r1, #0
 8004a56:	4618      	mov	r0, r3
 8004a58:	f005 fdd4 	bl	800a604 <sha512Final>

   //Construct the secret scalar s from the first half of the digest
   osMemcpy(state->s, state->sha512Context.digest, 32);
 8004a5c:	69bb      	ldr	r3, [r7, #24]
 8004a5e:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8004a62:	69b9      	ldr	r1, [r7, #24]
 8004a64:	2220      	movs	r2, #32
 8004a66:	4618      	mov	r0, r3
 8004a68:	f009 fd2e 	bl	800e4c8 <memcpy>

   //The lowest three bits of the first octet are cleared, the highest bit
   //of the last octet is cleared, and the second highest bit of the last
   //octet is set
   state->s[0] &= 0xF8;
 8004a6c:	69bb      	ldr	r3, [r7, #24]
 8004a6e:	f893 3150 	ldrb.w	r3, [r3, #336]	; 0x150
 8004a72:	f023 0307 	bic.w	r3, r3, #7
 8004a76:	b2da      	uxtb	r2, r3
 8004a78:	69bb      	ldr	r3, [r7, #24]
 8004a7a:	f883 2150 	strb.w	r2, [r3, #336]	; 0x150
   state->s[31] &= 0x7F;
 8004a7e:	69bb      	ldr	r3, [r7, #24]
 8004a80:	f893 316f 	ldrb.w	r3, [r3, #367]	; 0x16f
 8004a84:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004a88:	b2da      	uxtb	r2, r3
 8004a8a:	69bb      	ldr	r3, [r7, #24]
 8004a8c:	f883 216f 	strb.w	r2, [r3, #367]	; 0x16f
   state->s[31] |= 0x40;
 8004a90:	69bb      	ldr	r3, [r7, #24]
 8004a92:	f893 316f 	ldrb.w	r3, [r3, #367]	; 0x16f
 8004a96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004a9a:	b2da      	uxtb	r2, r3
 8004a9c:	69bb      	ldr	r3, [r7, #24]
 8004a9e:	f883 216f 	strb.w	r2, [r3, #367]	; 0x16f

   //The public key is optional
   if(publicKey == NULL)
 8004aa2:	68bb      	ldr	r3, [r7, #8]
 8004aa4:	2b00      	cmp	r3, #0
 8004aa6:	d115      	bne.n	8004ad4 <ed25519GenerateSignatureEx+0xe4>
   {
      //Perform a fixed-base scalar multiplication s * B
      ed25519Mul(state, &state->sb, state->s, &ED25519_B);
 8004aa8:	69bb      	ldr	r3, [r7, #24]
 8004aaa:	f503 711c 	add.w	r1, r3, #624	; 0x270
 8004aae:	69bb      	ldr	r3, [r7, #24]
 8004ab0:	f503 72a8 	add.w	r2, r3, #336	; 0x150
 8004ab4:	4b95      	ldr	r3, [pc, #596]	; (8004d0c <ed25519GenerateSignatureEx+0x31c>)
 8004ab6:	69b8      	ldr	r0, [r7, #24]
 8004ab8:	f000 fa6a 	bl	8004f90 <ed25519Mul>
      //The public key A is the encoding of the point s * B
      ed25519Encode(&state->sb, state->k);
 8004abc:	69bb      	ldr	r3, [r7, #24]
 8004abe:	f503 721c 	add.w	r2, r3, #624	; 0x270
 8004ac2:	69bb      	ldr	r3, [r7, #24]
 8004ac4:	33d0      	adds	r3, #208	; 0xd0
 8004ac6:	4619      	mov	r1, r3
 8004ac8:	4610      	mov	r0, r2
 8004aca:	f000 fc88 	bl	80053de <ed25519Encode>
      //Point to the resulting public key
      publicKey = state->k;
 8004ace:	69bb      	ldr	r3, [r7, #24]
 8004ad0:	33d0      	adds	r3, #208	; 0xd0
 8004ad2:	60bb      	str	r3, [r7, #8]
   }

   //Let prefix denote the second half of the hash digest
   osMemcpy(state->p, state->sha512Context.digest + 32, 32);
 8004ad4:	69bb      	ldr	r3, [r7, #24]
 8004ad6:	f503 7088 	add.w	r0, r3, #272	; 0x110
 8004ada:	69bb      	ldr	r3, [r7, #24]
 8004adc:	3320      	adds	r3, #32
 8004ade:	2220      	movs	r2, #32
 8004ae0:	4619      	mov	r1, r3
 8004ae2:	f009 fcf1 	bl	800e4c8 <memcpy>

   //Initialize SHA-512 context
   sha512Init(&state->sha512Context);
 8004ae6:	69bb      	ldr	r3, [r7, #24]
 8004ae8:	4618      	mov	r0, r3
 8004aea:	f005 fcd1 	bl	800a490 <sha512Init>

   //For Ed25519ctx and Ed25519ph schemes, dom2(x, y) is the octet string
   //"SigEd25519 no Ed25519 collisions" || octet(x) || octet(OLEN(y)) || y,
   //where x is in range 0-255 and y is an octet string of at most 255 octets
   if(context != NULL || flag != 0)
 8004aee:	683b      	ldr	r3, [r7, #0]
 8004af0:	2b00      	cmp	r3, #0
 8004af2:	d103      	bne.n	8004afc <ed25519GenerateSignatureEx+0x10c>
 8004af4:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8004af8:	2b00      	cmp	r3, #0
 8004afa:	d01a      	beq.n	8004b32 <ed25519GenerateSignatureEx+0x142>
   {
      sha512Update(&state->sha512Context, "SigEd25519 no Ed25519 collisions", 32);
 8004afc:	69bb      	ldr	r3, [r7, #24]
 8004afe:	2220      	movs	r2, #32
 8004b00:	4983      	ldr	r1, [pc, #524]	; (8004d10 <ed25519GenerateSignatureEx+0x320>)
 8004b02:	4618      	mov	r0, r3
 8004b04:	f005 fd2c 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &flag, sizeof(uint8_t));
 8004b08:	69bb      	ldr	r3, [r7, #24]
 8004b0a:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8004b0e:	2201      	movs	r2, #1
 8004b10:	4618      	mov	r0, r3
 8004b12:	f005 fd25 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &contextLen, sizeof(uint8_t));
 8004b16:	69bb      	ldr	r3, [r7, #24]
 8004b18:	2201      	movs	r2, #1
 8004b1a:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8004b1e:	4618      	mov	r0, r3
 8004b20:	f005 fd1e 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, context, contextLen);
 8004b24:	69bb      	ldr	r3, [r7, #24]
 8004b26:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8004b2a:	6839      	ldr	r1, [r7, #0]
 8004b2c:	4618      	mov	r0, r3
 8004b2e:	f005 fd17 	bl	800a560 <sha512Update>
   }

   //Digest prefix
   sha512Update(&state->sha512Context, state->p, 32);
 8004b32:	69b8      	ldr	r0, [r7, #24]
 8004b34:	69bb      	ldr	r3, [r7, #24]
 8004b36:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8004b3a:	2220      	movs	r2, #32
 8004b3c:	4619      	mov	r1, r3
 8004b3e:	f005 fd0f 	bl	800a560 <sha512Update>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004b42:	2300      	movs	r3, #0
 8004b44:	61fb      	str	r3, [r7, #28]
 8004b46:	e010      	b.n	8004b6a <ed25519GenerateSignatureEx+0x17a>
   {
      //Digest current chunk
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004b48:	69b8      	ldr	r0, [r7, #24]
 8004b4a:	69fb      	ldr	r3, [r7, #28]
 8004b4c:	00db      	lsls	r3, r3, #3
 8004b4e:	687a      	ldr	r2, [r7, #4]
 8004b50:	4413      	add	r3, r2
 8004b52:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8004b54:	69fb      	ldr	r3, [r7, #28]
 8004b56:	00db      	lsls	r3, r3, #3
 8004b58:	687a      	ldr	r2, [r7, #4]
 8004b5a:	4413      	add	r3, r2
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004b5c:	685b      	ldr	r3, [r3, #4]
 8004b5e:	461a      	mov	r2, r3
 8004b60:	f005 fcfe 	bl	800a560 <sha512Update>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004b64:	69fb      	ldr	r3, [r7, #28]
 8004b66:	3301      	adds	r3, #1
 8004b68:	61fb      	str	r3, [r7, #28]
 8004b6a:	69fb      	ldr	r3, [r7, #28]
 8004b6c:	00db      	lsls	r3, r3, #3
 8004b6e:	687a      	ldr	r2, [r7, #4]
 8004b70:	4413      	add	r3, r2
 8004b72:	681b      	ldr	r3, [r3, #0]
 8004b74:	2b00      	cmp	r3, #0
 8004b76:	d1e7      	bne.n	8004b48 <ed25519GenerateSignatureEx+0x158>
   }

   //Compute SHA-512(dom2(F, C) || prefix || PH(M))
   sha512Final(&state->sha512Context, NULL);
 8004b78:	69bb      	ldr	r3, [r7, #24]
 8004b7a:	2100      	movs	r1, #0
 8004b7c:	4618      	mov	r0, r3
 8004b7e:	f005 fd41 	bl	800a604 <sha512Final>

   //Reduce the 64-octet digest as a little-endian integer r
   ed25519RedInt(state->r, state->sha512Context.digest);
 8004b82:	69bb      	ldr	r3, [r7, #24]
 8004b84:	f503 7398 	add.w	r3, r3, #304	; 0x130
 8004b88:	69ba      	ldr	r2, [r7, #24]
 8004b8a:	4611      	mov	r1, r2
 8004b8c:	4618      	mov	r0, r3
 8004b8e:	f000 fd23 	bl	80055d8 <ed25519RedInt>
   //Compute the point r * B
   ed25519Mul(state, &state->rb, state->r, &ED25519_B);
 8004b92:	69bb      	ldr	r3, [r7, #24]
 8004b94:	f503 71f8 	add.w	r1, r3, #496	; 0x1f0
 8004b98:	69bb      	ldr	r3, [r7, #24]
 8004b9a:	f503 7298 	add.w	r2, r3, #304	; 0x130
 8004b9e:	4b5b      	ldr	r3, [pc, #364]	; (8004d0c <ed25519GenerateSignatureEx+0x31c>)
 8004ba0:	69b8      	ldr	r0, [r7, #24]
 8004ba2:	f000 f9f5 	bl	8004f90 <ed25519Mul>
   //Let the string R be the encoding of this point
   ed25519Encode(&state->rb, signature);
 8004ba6:	69bb      	ldr	r3, [r7, #24]
 8004ba8:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 8004bac:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8004bae:	4618      	mov	r0, r3
 8004bb0:	f000 fc15 	bl	80053de <ed25519Encode>

   //Initialize SHA-512 context
   sha512Init(&state->sha512Context);
 8004bb4:	69bb      	ldr	r3, [r7, #24]
 8004bb6:	4618      	mov	r0, r3
 8004bb8:	f005 fc6a 	bl	800a490 <sha512Init>

   //For Ed25519ctx and Ed25519ph schemes, dom2(x, y) is the octet string
   //"SigEd25519 no Ed25519 collisions" || octet(x) || octet(OLEN(y)) || y,
   //where x is in range 0-255 and y is an octet string of at most 255 octets
   if(context != NULL || flag != 0)
 8004bbc:	683b      	ldr	r3, [r7, #0]
 8004bbe:	2b00      	cmp	r3, #0
 8004bc0:	d103      	bne.n	8004bca <ed25519GenerateSignatureEx+0x1da>
 8004bc2:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8004bc6:	2b00      	cmp	r3, #0
 8004bc8:	d01a      	beq.n	8004c00 <ed25519GenerateSignatureEx+0x210>
   {
      sha512Update(&state->sha512Context, "SigEd25519 no Ed25519 collisions", 32);
 8004bca:	69bb      	ldr	r3, [r7, #24]
 8004bcc:	2220      	movs	r2, #32
 8004bce:	4950      	ldr	r1, [pc, #320]	; (8004d10 <ed25519GenerateSignatureEx+0x320>)
 8004bd0:	4618      	mov	r0, r3
 8004bd2:	f005 fcc5 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &flag, sizeof(uint8_t));
 8004bd6:	69bb      	ldr	r3, [r7, #24]
 8004bd8:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8004bdc:	2201      	movs	r2, #1
 8004bde:	4618      	mov	r0, r3
 8004be0:	f005 fcbe 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &contextLen, sizeof(uint8_t));
 8004be4:	69bb      	ldr	r3, [r7, #24]
 8004be6:	2201      	movs	r2, #1
 8004be8:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8004bec:	4618      	mov	r0, r3
 8004bee:	f005 fcb7 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, context, contextLen);
 8004bf2:	69bb      	ldr	r3, [r7, #24]
 8004bf4:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8004bf8:	6839      	ldr	r1, [r7, #0]
 8004bfa:	4618      	mov	r0, r3
 8004bfc:	f005 fcb0 	bl	800a560 <sha512Update>
   }

   //Digest R || A
   sha512Update(&state->sha512Context, signature, ED25519_SIGNATURE_LEN / 2);
 8004c00:	69bb      	ldr	r3, [r7, #24]
 8004c02:	2220      	movs	r2, #32
 8004c04:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8004c06:	4618      	mov	r0, r3
 8004c08:	f005 fcaa 	bl	800a560 <sha512Update>
   sha512Update(&state->sha512Context, publicKey, ED25519_PUBLIC_KEY_LEN);
 8004c0c:	69bb      	ldr	r3, [r7, #24]
 8004c0e:	2220      	movs	r2, #32
 8004c10:	68b9      	ldr	r1, [r7, #8]
 8004c12:	4618      	mov	r0, r3
 8004c14:	f005 fca4 	bl	800a560 <sha512Update>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004c18:	2300      	movs	r3, #0
 8004c1a:	61fb      	str	r3, [r7, #28]
 8004c1c:	e010      	b.n	8004c40 <ed25519GenerateSignatureEx+0x250>
   {
      //Digest current chunk
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004c1e:	69b8      	ldr	r0, [r7, #24]
 8004c20:	69fb      	ldr	r3, [r7, #28]
 8004c22:	00db      	lsls	r3, r3, #3
 8004c24:	687a      	ldr	r2, [r7, #4]
 8004c26:	4413      	add	r3, r2
 8004c28:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8004c2a:	69fb      	ldr	r3, [r7, #28]
 8004c2c:	00db      	lsls	r3, r3, #3
 8004c2e:	687a      	ldr	r2, [r7, #4]
 8004c30:	4413      	add	r3, r2
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004c32:	685b      	ldr	r3, [r3, #4]
 8004c34:	461a      	mov	r2, r3
 8004c36:	f005 fc93 	bl	800a560 <sha512Update>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004c3a:	69fb      	ldr	r3, [r7, #28]
 8004c3c:	3301      	adds	r3, #1
 8004c3e:	61fb      	str	r3, [r7, #28]
 8004c40:	69fb      	ldr	r3, [r7, #28]
 8004c42:	00db      	lsls	r3, r3, #3
 8004c44:	687a      	ldr	r2, [r7, #4]
 8004c46:	4413      	add	r3, r2
 8004c48:	681b      	ldr	r3, [r3, #0]
 8004c4a:	2b00      	cmp	r3, #0
 8004c4c:	d1e7      	bne.n	8004c1e <ed25519GenerateSignatureEx+0x22e>
   }

   //Compute SHA512(dom2(F, C) || R || A || PH(M)) and interpret the 64-octet
   //digest as a little-endian integer k
   sha512Final(&state->sha512Context, state->k);
 8004c4e:	69ba      	ldr	r2, [r7, #24]
 8004c50:	69bb      	ldr	r3, [r7, #24]
 8004c52:	33d0      	adds	r3, #208	; 0xd0
 8004c54:	4619      	mov	r1, r3
 8004c56:	4610      	mov	r0, r2
 8004c58:	f005 fcd4 	bl	800a604 <sha512Final>

   //Compute S = (r + k * s) mod L. For efficiency, reduce k modulo L first
   ed25519RedInt(state->p, state->k);
 8004c5c:	69bb      	ldr	r3, [r7, #24]
 8004c5e:	f503 7288 	add.w	r2, r3, #272	; 0x110
 8004c62:	69bb      	ldr	r3, [r7, #24]
 8004c64:	33d0      	adds	r3, #208	; 0xd0
 8004c66:	4619      	mov	r1, r3
 8004c68:	4610      	mov	r0, r2
 8004c6a:	f000 fcb5 	bl	80055d8 <ed25519RedInt>
   ed25519MulInt(state->k, state->k + 32, state->p, state->s, 32);
 8004c6e:	69bb      	ldr	r3, [r7, #24]
 8004c70:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
 8004c74:	69bb      	ldr	r3, [r7, #24]
 8004c76:	33d0      	adds	r3, #208	; 0xd0
 8004c78:	f103 0120 	add.w	r1, r3, #32
 8004c7c:	69bb      	ldr	r3, [r7, #24]
 8004c7e:	f503 7288 	add.w	r2, r3, #272	; 0x110
 8004c82:	69bb      	ldr	r3, [r7, #24]
 8004c84:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8004c88:	2420      	movs	r4, #32
 8004c8a:	9400      	str	r4, [sp, #0]
 8004c8c:	f000 fd71 	bl	8005772 <ed25519MulInt>
   ed25519RedInt(state->p, state->k);
 8004c90:	69bb      	ldr	r3, [r7, #24]
 8004c92:	f503 7288 	add.w	r2, r3, #272	; 0x110
 8004c96:	69bb      	ldr	r3, [r7, #24]
 8004c98:	33d0      	adds	r3, #208	; 0xd0
 8004c9a:	4619      	mov	r1, r3
 8004c9c:	4610      	mov	r0, r2
 8004c9e:	f000 fc9b 	bl	80055d8 <ed25519RedInt>
   ed25519AddInt(state->s, state->p, state->r, 32);
 8004ca2:	69bb      	ldr	r3, [r7, #24]
 8004ca4:	f503 70a8 	add.w	r0, r3, #336	; 0x150
 8004ca8:	69bb      	ldr	r3, [r7, #24]
 8004caa:	f503 7188 	add.w	r1, r3, #272	; 0x110
 8004cae:	69bb      	ldr	r3, [r7, #24]
 8004cb0:	f503 7298 	add.w	r2, r3, #304	; 0x130
 8004cb4:	2320      	movs	r3, #32
 8004cb6:	f000 fcef 	bl	8005698 <ed25519AddInt>

   //Perform modular reduction
   c = ed25519SubInt(state->p, state->s, ED25519_L, 32);
 8004cba:	69bb      	ldr	r3, [r7, #24]
 8004cbc:	f503 7088 	add.w	r0, r3, #272	; 0x110
 8004cc0:	69bb      	ldr	r3, [r7, #24]
 8004cc2:	f503 71a8 	add.w	r1, r3, #336	; 0x150
 8004cc6:	2320      	movs	r3, #32
 8004cc8:	4a12      	ldr	r2, [pc, #72]	; (8004d14 <ed25519GenerateSignatureEx+0x324>)
 8004cca:	f000 fd18 	bl	80056fe <ed25519SubInt>
 8004cce:	4603      	mov	r3, r0
 8004cd0:	75fb      	strb	r3, [r7, #23]
   ed25519SelectInt(signature + 32, state->p, state->s, c, 32);
 8004cd2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004cd4:	f103 0020 	add.w	r0, r3, #32
 8004cd8:	69bb      	ldr	r3, [r7, #24]
 8004cda:	f503 7188 	add.w	r1, r3, #272	; 0x110
 8004cde:	69bb      	ldr	r3, [r7, #24]
 8004ce0:	f503 72a8 	add.w	r2, r3, #336	; 0x150
 8004ce4:	7dfb      	ldrb	r3, [r7, #23]
 8004ce6:	2420      	movs	r4, #32
 8004ce8:	9400      	str	r4, [sp, #0]
 8004cea:	f000 fdd8 	bl	800589e <ed25519SelectInt>

   //Erase working state
   osMemset(state, 0, sizeof(Ed25519State));
 8004cee:	f44f 629e 	mov.w	r2, #1264	; 0x4f0
 8004cf2:	2100      	movs	r1, #0
 8004cf4:	69b8      	ldr	r0, [r7, #24]
 8004cf6:	f009 fbf5 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8004cfa:	69b8      	ldr	r0, [r7, #24]
 8004cfc:	f006 fe8e 	bl	800ba1c <osFreeMem>

   //Successful processing
   return NO_ERROR;
 8004d00:	2300      	movs	r3, #0
}
 8004d02:	4618      	mov	r0, r3
 8004d04:	3724      	adds	r7, #36	; 0x24
 8004d06:	46bd      	mov	sp, r7
 8004d08:	bd90      	pop	{r4, r7, pc}
 8004d0a:	bf00      	nop
 8004d0c:	0800f178 	.word	0x0800f178
 8004d10:	0800e81c 	.word	0x0800e81c
 8004d14:	0800f258 	.word	0x0800f258

08004d18 <ed25519VerifySignature>:
 **/

error_t ed25519VerifySignature(const uint8_t *publicKey, const void *message,
   size_t messageLen, const void *context, uint8_t contextLen, uint8_t flag,
   const uint8_t *signature)
{
 8004d18:	b580      	push	{r7, lr}
 8004d1a:	b08c      	sub	sp, #48	; 0x30
 8004d1c:	af02      	add	r7, sp, #8
 8004d1e:	60f8      	str	r0, [r7, #12]
 8004d20:	60b9      	str	r1, [r7, #8]
 8004d22:	607a      	str	r2, [r7, #4]
 8004d24:	603b      	str	r3, [r7, #0]
   error_t error;
   EddsaMessageChunk messageChunks[2];

   //The message fits in a single chunk
   messageChunks[0].buffer = message;
 8004d26:	68bb      	ldr	r3, [r7, #8]
 8004d28:	617b      	str	r3, [r7, #20]
   messageChunks[0].length = messageLen;
 8004d2a:	687b      	ldr	r3, [r7, #4]
 8004d2c:	61bb      	str	r3, [r7, #24]
   messageChunks[1].buffer = NULL;
 8004d2e:	2300      	movs	r3, #0
 8004d30:	61fb      	str	r3, [r7, #28]
   messageChunks[1].length = 0;
 8004d32:	2300      	movs	r3, #0
 8004d34:	623b      	str	r3, [r7, #32]

   //Ed25519 signature verification
   error = ed25519VerifySignatureEx(publicKey, messageChunks, context,
 8004d36:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8004d3a:	f107 0114 	add.w	r1, r7, #20
 8004d3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004d40:	9301      	str	r3, [sp, #4]
 8004d42:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8004d46:	9300      	str	r3, [sp, #0]
 8004d48:	4613      	mov	r3, r2
 8004d4a:	683a      	ldr	r2, [r7, #0]
 8004d4c:	68f8      	ldr	r0, [r7, #12]
 8004d4e:	f000 f807 	bl	8004d60 <ed25519VerifySignatureEx>
 8004d52:	4603      	mov	r3, r0
 8004d54:	84fb      	strh	r3, [r7, #38]	; 0x26
      contextLen, flag, signature);

   //Return status code
   return error;
 8004d56:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 8004d58:	4618      	mov	r0, r3
 8004d5a:	3728      	adds	r7, #40	; 0x28
 8004d5c:	46bd      	mov	sp, r7
 8004d5e:	bd80      	pop	{r7, pc}

08004d60 <ed25519VerifySignatureEx>:
 **/

error_t ed25519VerifySignatureEx(const uint8_t *publicKey,
   const EddsaMessageChunk *messageChunks, const void *context,
   uint8_t contextLen, uint8_t flag, const uint8_t *signature)
{
 8004d60:	b580      	push	{r7, lr}
 8004d62:	b088      	sub	sp, #32
 8004d64:	af00      	add	r7, sp, #0
 8004d66:	60f8      	str	r0, [r7, #12]
 8004d68:	60b9      	str	r1, [r7, #8]
 8004d6a:	607a      	str	r2, [r7, #4]
 8004d6c:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   uint32_t ret;
   Ed25519State *state;

   //Check parameters
   if(publicKey == NULL || signature == NULL)
 8004d6e:	68fb      	ldr	r3, [r7, #12]
 8004d70:	2b00      	cmp	r3, #0
 8004d72:	d002      	beq.n	8004d7a <ed25519VerifySignatureEx+0x1a>
 8004d74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d76:	2b00      	cmp	r3, #0
 8004d78:	d101      	bne.n	8004d7e <ed25519VerifySignatureEx+0x1e>
      return ERROR_INVALID_PARAMETER;
 8004d7a:	2302      	movs	r3, #2
 8004d7c:	e0fb      	b.n	8004f76 <ed25519VerifySignatureEx+0x216>
   if(messageChunks == NULL)
 8004d7e:	68bb      	ldr	r3, [r7, #8]
 8004d80:	2b00      	cmp	r3, #0
 8004d82:	d101      	bne.n	8004d88 <ed25519VerifySignatureEx+0x28>
      return ERROR_INVALID_PARAMETER;
 8004d84:	2302      	movs	r3, #2
 8004d86:	e0f6      	b.n	8004f76 <ed25519VerifySignatureEx+0x216>
   if(context == NULL && contextLen != 0)
 8004d88:	687b      	ldr	r3, [r7, #4]
 8004d8a:	2b00      	cmp	r3, #0
 8004d8c:	d104      	bne.n	8004d98 <ed25519VerifySignatureEx+0x38>
 8004d8e:	78fb      	ldrb	r3, [r7, #3]
 8004d90:	2b00      	cmp	r3, #0
 8004d92:	d001      	beq.n	8004d98 <ed25519VerifySignatureEx+0x38>
      return ERROR_INVALID_PARAMETER;
 8004d94:	2302      	movs	r3, #2
 8004d96:	e0ee      	b.n	8004f76 <ed25519VerifySignatureEx+0x216>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed25519State));
 8004d98:	f44f 609e 	mov.w	r0, #1264	; 0x4f0
 8004d9c:	f006 fe30 	bl	800ba00 <osAllocMem>
 8004da0:	61b8      	str	r0, [r7, #24]
   //Failed to allocate memory?
   if(state == NULL)
 8004da2:	69bb      	ldr	r3, [r7, #24]
 8004da4:	2b00      	cmp	r3, #0
 8004da6:	d101      	bne.n	8004dac <ed25519VerifySignatureEx+0x4c>
      return ERROR_OUT_OF_MEMORY;
 8004da8:	2364      	movs	r3, #100	; 0x64
 8004daa:	e0e4      	b.n	8004f76 <ed25519VerifySignatureEx+0x216>

   //First split the signature into two 32-octet halves. Decode the first
   //half as a point R
   osMemcpy(state->r, signature, ED25519_SIGNATURE_LEN / 2);
 8004dac:	69bb      	ldr	r3, [r7, #24]
 8004dae:	f503 7398 	add.w	r3, r3, #304	; 0x130
 8004db2:	2220      	movs	r2, #32
 8004db4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004db6:	4618      	mov	r0, r3
 8004db8:	f009 fb86 	bl	800e4c8 <memcpy>

   //Decode the second half as an integer S, in the range 0 <= s < L
   osMemcpy(state->s, signature + ED25519_SIGNATURE_LEN / 2,
 8004dbc:	69bb      	ldr	r3, [r7, #24]
 8004dbe:	f503 70a8 	add.w	r0, r3, #336	; 0x150
 8004dc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dc4:	3320      	adds	r3, #32
 8004dc6:	2220      	movs	r2, #32
 8004dc8:	4619      	mov	r1, r3
 8004dca:	f009 fb7d 	bl	800e4c8 <memcpy>
      ED25519_SIGNATURE_LEN / 2);

   //Ed25519 signatures are not malleable due to the verification check that
   //decoded S is smaller than L (refer to RFC 8032, section 8.4)
   ret = 1 ^ ed25519SubInt(state->p, state->s, ED25519_L,
 8004dce:	69bb      	ldr	r3, [r7, #24]
 8004dd0:	f503 7088 	add.w	r0, r3, #272	; 0x110
 8004dd4:	69bb      	ldr	r3, [r7, #24]
 8004dd6:	f503 71a8 	add.w	r1, r3, #336	; 0x150
 8004dda:	2320      	movs	r3, #32
 8004ddc:	4a68      	ldr	r2, [pc, #416]	; (8004f80 <ed25519VerifySignatureEx+0x220>)
 8004dde:	f000 fc8e 	bl	80056fe <ed25519SubInt>
 8004de2:	4603      	mov	r3, r0
 8004de4:	f083 0301 	eor.w	r3, r3, #1
 8004de8:	b2db      	uxtb	r3, r3
 8004dea:	617b      	str	r3, [r7, #20]
      ED25519_SIGNATURE_LEN / 2);

   //Decode the public key A as point A'
   ret |= ed25519Decode(&state->ka, publicKey);
 8004dec:	69bb      	ldr	r3, [r7, #24]
 8004dee:	f503 73b8 	add.w	r3, r3, #368	; 0x170
 8004df2:	68f9      	ldr	r1, [r7, #12]
 8004df4:	4618      	mov	r0, r3
 8004df6:	f000 fb39 	bl	800546c <ed25519Decode>
 8004dfa:	4602      	mov	r2, r0
 8004dfc:	697b      	ldr	r3, [r7, #20]
 8004dfe:	4313      	orrs	r3, r2
 8004e00:	617b      	str	r3, [r7, #20]

   //Initialize SHA-512 context
   sha512Init(&state->sha512Context);
 8004e02:	69bb      	ldr	r3, [r7, #24]
 8004e04:	4618      	mov	r0, r3
 8004e06:	f005 fb43 	bl	800a490 <sha512Init>

   //For Ed25519ctx and Ed25519ph schemes, dom2(x, y) is the octet string
   //"SigEd25519 no Ed25519 collisions" || octet(x) || octet(OLEN(y)) || y,
   //where x is in range 0-255 and y is an octet string of at most 255 octets
   if(context != NULL || flag != 0)
 8004e0a:	687b      	ldr	r3, [r7, #4]
 8004e0c:	2b00      	cmp	r3, #0
 8004e0e:	d103      	bne.n	8004e18 <ed25519VerifySignatureEx+0xb8>
 8004e10:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8004e14:	2b00      	cmp	r3, #0
 8004e16:	d018      	beq.n	8004e4a <ed25519VerifySignatureEx+0xea>
   {
      sha512Update(&state->sha512Context, "SigEd25519 no Ed25519 collisions", 32);
 8004e18:	69bb      	ldr	r3, [r7, #24]
 8004e1a:	2220      	movs	r2, #32
 8004e1c:	4959      	ldr	r1, [pc, #356]	; (8004f84 <ed25519VerifySignatureEx+0x224>)
 8004e1e:	4618      	mov	r0, r3
 8004e20:	f005 fb9e 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &flag, sizeof(uint8_t));
 8004e24:	69bb      	ldr	r3, [r7, #24]
 8004e26:	2201      	movs	r2, #1
 8004e28:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8004e2c:	4618      	mov	r0, r3
 8004e2e:	f005 fb97 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, &contextLen, sizeof(uint8_t));
 8004e32:	69bb      	ldr	r3, [r7, #24]
 8004e34:	1cf9      	adds	r1, r7, #3
 8004e36:	2201      	movs	r2, #1
 8004e38:	4618      	mov	r0, r3
 8004e3a:	f005 fb91 	bl	800a560 <sha512Update>
      sha512Update(&state->sha512Context, context, contextLen);
 8004e3e:	69bb      	ldr	r3, [r7, #24]
 8004e40:	78fa      	ldrb	r2, [r7, #3]
 8004e42:	6879      	ldr	r1, [r7, #4]
 8004e44:	4618      	mov	r0, r3
 8004e46:	f005 fb8b 	bl	800a560 <sha512Update>
   }

   //Digest R || A
   sha512Update(&state->sha512Context, state->r, ED25519_SIGNATURE_LEN / 2);
 8004e4a:	69b8      	ldr	r0, [r7, #24]
 8004e4c:	69bb      	ldr	r3, [r7, #24]
 8004e4e:	f503 7398 	add.w	r3, r3, #304	; 0x130
 8004e52:	2220      	movs	r2, #32
 8004e54:	4619      	mov	r1, r3
 8004e56:	f005 fb83 	bl	800a560 <sha512Update>
   sha512Update(&state->sha512Context, publicKey, ED25519_PUBLIC_KEY_LEN);
 8004e5a:	69bb      	ldr	r3, [r7, #24]
 8004e5c:	2220      	movs	r2, #32
 8004e5e:	68f9      	ldr	r1, [r7, #12]
 8004e60:	4618      	mov	r0, r3
 8004e62:	f005 fb7d 	bl	800a560 <sha512Update>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004e66:	2300      	movs	r3, #0
 8004e68:	61fb      	str	r3, [r7, #28]
 8004e6a:	e010      	b.n	8004e8e <ed25519VerifySignatureEx+0x12e>
   {
      //Digest current chunk
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004e6c:	69b8      	ldr	r0, [r7, #24]
 8004e6e:	69fb      	ldr	r3, [r7, #28]
 8004e70:	00db      	lsls	r3, r3, #3
 8004e72:	68ba      	ldr	r2, [r7, #8]
 8004e74:	4413      	add	r3, r2
 8004e76:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8004e78:	69fb      	ldr	r3, [r7, #28]
 8004e7a:	00db      	lsls	r3, r3, #3
 8004e7c:	68ba      	ldr	r2, [r7, #8]
 8004e7e:	4413      	add	r3, r2
      sha512Update(&state->sha512Context, messageChunks[i].buffer,
 8004e80:	685b      	ldr	r3, [r3, #4]
 8004e82:	461a      	mov	r2, r3
 8004e84:	f005 fb6c 	bl	800a560 <sha512Update>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8004e88:	69fb      	ldr	r3, [r7, #28]
 8004e8a:	3301      	adds	r3, #1
 8004e8c:	61fb      	str	r3, [r7, #28]
 8004e8e:	69fb      	ldr	r3, [r7, #28]
 8004e90:	00db      	lsls	r3, r3, #3
 8004e92:	68ba      	ldr	r2, [r7, #8]
 8004e94:	4413      	add	r3, r2
 8004e96:	681b      	ldr	r3, [r3, #0]
 8004e98:	2b00      	cmp	r3, #0
 8004e9a:	d1e7      	bne.n	8004e6c <ed25519VerifySignatureEx+0x10c>
   }

   //Compute SHA512(dom2(F, C) || R || A || PH(M)) and interpret the 64-octet
   //digest as a little-endian integer k
   sha512Final(&state->sha512Context, state->k);
 8004e9c:	69ba      	ldr	r2, [r7, #24]
 8004e9e:	69bb      	ldr	r3, [r7, #24]
 8004ea0:	33d0      	adds	r3, #208	; 0xd0
 8004ea2:	4619      	mov	r1, r3
 8004ea4:	4610      	mov	r0, r2
 8004ea6:	f005 fbad 	bl	800a604 <sha512Final>

   //For efficiency, reduce k modulo L first
   ed25519RedInt(state->k, state->k);
 8004eaa:	69bb      	ldr	r3, [r7, #24]
 8004eac:	f103 02d0 	add.w	r2, r3, #208	; 0xd0
 8004eb0:	69bb      	ldr	r3, [r7, #24]
 8004eb2:	33d0      	adds	r3, #208	; 0xd0
 8004eb4:	4619      	mov	r1, r3
 8004eb6:	4610      	mov	r0, r2
 8004eb8:	f000 fb8e 	bl	80055d8 <ed25519RedInt>

   //Compute the point P = s * B - k * A'
   curve25519Sub(state->ka.x, ED25519_ZERO, state->ka.x);
 8004ebc:	69bb      	ldr	r3, [r7, #24]
 8004ebe:	f503 70b8 	add.w	r0, r3, #368	; 0x170
 8004ec2:	69bb      	ldr	r3, [r7, #24]
 8004ec4:	f503 73b8 	add.w	r3, r3, #368	; 0x170
 8004ec8:	461a      	mov	r2, r3
 8004eca:	492f      	ldr	r1, [pc, #188]	; (8004f88 <ed25519VerifySignatureEx+0x228>)
 8004ecc:	f7fb fd16 	bl	80008fc <curve25519Sub>
   curve25519Sub(state->ka.t, ED25519_ZERO, state->ka.t);
 8004ed0:	69bb      	ldr	r3, [r7, #24]
 8004ed2:	f503 70e8 	add.w	r0, r3, #464	; 0x1d0
 8004ed6:	69bb      	ldr	r3, [r7, #24]
 8004ed8:	f503 73e8 	add.w	r3, r3, #464	; 0x1d0
 8004edc:	461a      	mov	r2, r3
 8004ede:	492a      	ldr	r1, [pc, #168]	; (8004f88 <ed25519VerifySignatureEx+0x228>)
 8004ee0:	f7fb fd0c 	bl	80008fc <curve25519Sub>
   ed25519Mul(state, &state->sb, state->s, &ED25519_B);
 8004ee4:	69bb      	ldr	r3, [r7, #24]
 8004ee6:	f503 711c 	add.w	r1, r3, #624	; 0x270
 8004eea:	69bb      	ldr	r3, [r7, #24]
 8004eec:	f503 72a8 	add.w	r2, r3, #336	; 0x150
 8004ef0:	4b26      	ldr	r3, [pc, #152]	; (8004f8c <ed25519VerifySignatureEx+0x22c>)
 8004ef2:	69b8      	ldr	r0, [r7, #24]
 8004ef4:	f000 f84c 	bl	8004f90 <ed25519Mul>
   ed25519Mul(state, &state->ka, state->k, &state->ka);
 8004ef8:	69bb      	ldr	r3, [r7, #24]
 8004efa:	f503 71b8 	add.w	r1, r3, #368	; 0x170
 8004efe:	69bb      	ldr	r3, [r7, #24]
 8004f00:	f103 02d0 	add.w	r2, r3, #208	; 0xd0
 8004f04:	69bb      	ldr	r3, [r7, #24]
 8004f06:	f503 73b8 	add.w	r3, r3, #368	; 0x170
 8004f0a:	69b8      	ldr	r0, [r7, #24]
 8004f0c:	f000 f840 	bl	8004f90 <ed25519Mul>
   ed25519Add(state, &state->ka, &state->sb, &state->ka);
 8004f10:	69bb      	ldr	r3, [r7, #24]
 8004f12:	f503 71b8 	add.w	r1, r3, #368	; 0x170
 8004f16:	69bb      	ldr	r3, [r7, #24]
 8004f18:	f503 721c 	add.w	r2, r3, #624	; 0x270
 8004f1c:	69bb      	ldr	r3, [r7, #24]
 8004f1e:	f503 73b8 	add.w	r3, r3, #368	; 0x170
 8004f22:	69b8      	ldr	r0, [r7, #24]
 8004f24:	f000 f8e6 	bl	80050f4 <ed25519Add>

   //Encode of the resulting point P
   ed25519Encode(&state->ka, state->p);
 8004f28:	69bb      	ldr	r3, [r7, #24]
 8004f2a:	f503 72b8 	add.w	r2, r3, #368	; 0x170
 8004f2e:	69bb      	ldr	r3, [r7, #24]
 8004f30:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8004f34:	4619      	mov	r1, r3
 8004f36:	4610      	mov	r0, r2
 8004f38:	f000 fa51 	bl	80053de <ed25519Encode>

   //If P = R, then the signature is verified. If P does not equal R,
   //then the message or the signature may have been modified
   ret |= ed25519CompInt(state->p, signature, ED25519_SIGNATURE_LEN / 2);
 8004f3c:	69bb      	ldr	r3, [r7, #24]
 8004f3e:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8004f42:	2220      	movs	r2, #32
 8004f44:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004f46:	4618      	mov	r0, r3
 8004f48:	f000 fcde 	bl	8005908 <ed25519CompInt>
 8004f4c:	4603      	mov	r3, r0
 8004f4e:	461a      	mov	r2, r3
 8004f50:	697b      	ldr	r3, [r7, #20]
 8004f52:	4313      	orrs	r3, r2
 8004f54:	617b      	str	r3, [r7, #20]

   //Erase working state
   osMemset(state, 0, sizeof(Ed25519State));
 8004f56:	f44f 629e 	mov.w	r2, #1264	; 0x4f0
 8004f5a:	2100      	movs	r1, #0
 8004f5c:	69b8      	ldr	r0, [r7, #24]
 8004f5e:	f009 fac1 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8004f62:	69b8      	ldr	r0, [r7, #24]
 8004f64:	f006 fd5a 	bl	800ba1c <osFreeMem>

   //Return status code
   return (ret == 0) ? NO_ERROR : ERROR_INVALID_SIGNATURE;
 8004f68:	697b      	ldr	r3, [r7, #20]
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	d101      	bne.n	8004f72 <ed25519VerifySignatureEx+0x212>
 8004f6e:	2300      	movs	r3, #0
 8004f70:	e001      	b.n	8004f76 <ed25519VerifySignatureEx+0x216>
 8004f72:	f240 230d 	movw	r3, #525	; 0x20d
}
 8004f76:	4618      	mov	r0, r3
 8004f78:	3720      	adds	r7, #32
 8004f7a:	46bd      	mov	sp, r7
 8004f7c:	bd80      	pop	{r7, pc}
 8004f7e:	bf00      	nop
 8004f80:	0800f258 	.word	0x0800f258
 8004f84:	0800e81c 	.word	0x0800e81c
 8004f88:	0800f1f8 	.word	0x0800f1f8
 8004f8c:	0800f178 	.word	0x0800f178

08004f90 <ed25519Mul>:
 * @param[in] p Input point
 **/

void ed25519Mul(Ed25519State *state, Ed25519Point *r, const uint8_t *k,
   const Ed25519Point *p)
{
 8004f90:	b580      	push	{r7, lr}
 8004f92:	b086      	sub	sp, #24
 8004f94:	af00      	add	r7, sp, #0
 8004f96:	60f8      	str	r0, [r7, #12]
 8004f98:	60b9      	str	r1, [r7, #8]
 8004f9a:	607a      	str	r2, [r7, #4]
 8004f9c:	603b      	str	r3, [r7, #0]
   int_t i;
   uint8_t b;

   //The neutral element is represented by (0, 1, 1, 0)
   curve25519SetInt(state->u.x, 0);
 8004f9e:	68fb      	ldr	r3, [r7, #12]
 8004fa0:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
 8004fa4:	2100      	movs	r1, #0
 8004fa6:	4618      	mov	r0, r3
 8004fa8:	f7fb fbf8 	bl	800079c <curve25519SetInt>
   curve25519SetInt(state->u.y, 1);
 8004fac:	68fb      	ldr	r3, [r7, #12]
 8004fae:	f503 7344 	add.w	r3, r3, #784	; 0x310
 8004fb2:	2101      	movs	r1, #1
 8004fb4:	4618      	mov	r0, r3
 8004fb6:	f7fb fbf1 	bl	800079c <curve25519SetInt>
   curve25519SetInt(state->u.z, 1);
 8004fba:	68fb      	ldr	r3, [r7, #12]
 8004fbc:	f503 734c 	add.w	r3, r3, #816	; 0x330
 8004fc0:	2101      	movs	r1, #1
 8004fc2:	4618      	mov	r0, r3
 8004fc4:	f7fb fbea 	bl	800079c <curve25519SetInt>
   curve25519SetInt(state->u.t, 0);
 8004fc8:	68fb      	ldr	r3, [r7, #12]
 8004fca:	f503 7354 	add.w	r3, r3, #848	; 0x350
 8004fce:	2100      	movs	r1, #0
 8004fd0:	4618      	mov	r0, r3
 8004fd2:	f7fb fbe3 	bl	800079c <curve25519SetInt>

   //Perform scalar multiplication
   for(i = CURVE25519_BIT_LEN - 1; i >= 0; i--)
 8004fd6:	23fe      	movs	r3, #254	; 0xfe
 8004fd8:	617b      	str	r3, [r7, #20]
 8004fda:	e05e      	b.n	800509a <ed25519Mul+0x10a>
   {
      //The scalar is processed in a left-to-right fashion
      b = (k[i / 8] >> (i % 8)) & 1;
 8004fdc:	697b      	ldr	r3, [r7, #20]
 8004fde:	2b00      	cmp	r3, #0
 8004fe0:	da00      	bge.n	8004fe4 <ed25519Mul+0x54>
 8004fe2:	3307      	adds	r3, #7
 8004fe4:	10db      	asrs	r3, r3, #3
 8004fe6:	461a      	mov	r2, r3
 8004fe8:	687b      	ldr	r3, [r7, #4]
 8004fea:	4413      	add	r3, r2
 8004fec:	781b      	ldrb	r3, [r3, #0]
 8004fee:	4619      	mov	r1, r3
 8004ff0:	697b      	ldr	r3, [r7, #20]
 8004ff2:	425a      	negs	r2, r3
 8004ff4:	f003 0307 	and.w	r3, r3, #7
 8004ff8:	f002 0207 	and.w	r2, r2, #7
 8004ffc:	bf58      	it	pl
 8004ffe:	4253      	negpl	r3, r2
 8005000:	fa41 f303 	asr.w	r3, r1, r3
 8005004:	b2db      	uxtb	r3, r3
 8005006:	f003 0301 	and.w	r3, r3, #1
 800500a:	74fb      	strb	r3, [r7, #19]

      //Compute U = 2 * U
      ed25519Double(state, &state->u, &state->u);
 800500c:	68fb      	ldr	r3, [r7, #12]
 800500e:	f503 713c 	add.w	r1, r3, #752	; 0x2f0
 8005012:	68fb      	ldr	r3, [r7, #12]
 8005014:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
 8005018:	461a      	mov	r2, r3
 800501a:	68f8      	ldr	r0, [r7, #12]
 800501c:	f000 f93e 	bl	800529c <ed25519Double>
      //Compute V = U + P
      ed25519Add(state, &state->v, &state->u, p);
 8005020:	68fb      	ldr	r3, [r7, #12]
 8005022:	f503 715c 	add.w	r1, r3, #880	; 0x370
 8005026:	68fb      	ldr	r3, [r7, #12]
 8005028:	f503 723c 	add.w	r2, r3, #752	; 0x2f0
 800502c:	683b      	ldr	r3, [r7, #0]
 800502e:	68f8      	ldr	r0, [r7, #12]
 8005030:	f000 f860 	bl	80050f4 <ed25519Add>

      //If b is set, then U = V
      curve25519Select(state->u.x, state->u.x, state->v.x, b);
 8005034:	68fb      	ldr	r3, [r7, #12]
 8005036:	f503 703c 	add.w	r0, r3, #752	; 0x2f0
 800503a:	68fb      	ldr	r3, [r7, #12]
 800503c:	f503 713c 	add.w	r1, r3, #752	; 0x2f0
 8005040:	68fb      	ldr	r3, [r7, #12]
 8005042:	f503 725c 	add.w	r2, r3, #880	; 0x370
 8005046:	7cfb      	ldrb	r3, [r7, #19]
 8005048:	f7fc fa83 	bl	8001552 <curve25519Select>
      curve25519Select(state->u.y, state->u.y, state->v.y, b);
 800504c:	68fb      	ldr	r3, [r7, #12]
 800504e:	f503 7044 	add.w	r0, r3, #784	; 0x310
 8005052:	68fb      	ldr	r3, [r7, #12]
 8005054:	f503 7144 	add.w	r1, r3, #784	; 0x310
 8005058:	68fb      	ldr	r3, [r7, #12]
 800505a:	f503 7264 	add.w	r2, r3, #912	; 0x390
 800505e:	7cfb      	ldrb	r3, [r7, #19]
 8005060:	f7fc fa77 	bl	8001552 <curve25519Select>
      curve25519Select(state->u.z, state->u.z, state->v.z, b);
 8005064:	68fb      	ldr	r3, [r7, #12]
 8005066:	f503 704c 	add.w	r0, r3, #816	; 0x330
 800506a:	68fb      	ldr	r3, [r7, #12]
 800506c:	f503 714c 	add.w	r1, r3, #816	; 0x330
 8005070:	68fb      	ldr	r3, [r7, #12]
 8005072:	f503 726c 	add.w	r2, r3, #944	; 0x3b0
 8005076:	7cfb      	ldrb	r3, [r7, #19]
 8005078:	f7fc fa6b 	bl	8001552 <curve25519Select>
      curve25519Select(state->u.t, state->u.t, state->v.t, b);
 800507c:	68fb      	ldr	r3, [r7, #12]
 800507e:	f503 7054 	add.w	r0, r3, #848	; 0x350
 8005082:	68fb      	ldr	r3, [r7, #12]
 8005084:	f503 7154 	add.w	r1, r3, #848	; 0x350
 8005088:	68fb      	ldr	r3, [r7, #12]
 800508a:	f503 7274 	add.w	r2, r3, #976	; 0x3d0
 800508e:	7cfb      	ldrb	r3, [r7, #19]
 8005090:	f7fc fa5f 	bl	8001552 <curve25519Select>
   for(i = CURVE25519_BIT_LEN - 1; i >= 0; i--)
 8005094:	697b      	ldr	r3, [r7, #20]
 8005096:	3b01      	subs	r3, #1
 8005098:	617b      	str	r3, [r7, #20]
 800509a:	697b      	ldr	r3, [r7, #20]
 800509c:	2b00      	cmp	r3, #0
 800509e:	da9d      	bge.n	8004fdc <ed25519Mul+0x4c>
   }

   //Copy result
   curve25519Copy(r->x, state->u.x);
 80050a0:	68ba      	ldr	r2, [r7, #8]
 80050a2:	68fb      	ldr	r3, [r7, #12]
 80050a4:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
 80050a8:	4619      	mov	r1, r3
 80050aa:	4610      	mov	r0, r2
 80050ac:	f7fc fa32 	bl	8001514 <curve25519Copy>
   curve25519Copy(r->y, state->u.y);
 80050b0:	68bb      	ldr	r3, [r7, #8]
 80050b2:	f103 0220 	add.w	r2, r3, #32
 80050b6:	68fb      	ldr	r3, [r7, #12]
 80050b8:	f503 7344 	add.w	r3, r3, #784	; 0x310
 80050bc:	4619      	mov	r1, r3
 80050be:	4610      	mov	r0, r2
 80050c0:	f7fc fa28 	bl	8001514 <curve25519Copy>
   curve25519Copy(r->z, state->u.z);
 80050c4:	68bb      	ldr	r3, [r7, #8]
 80050c6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80050ca:	68fb      	ldr	r3, [r7, #12]
 80050cc:	f503 734c 	add.w	r3, r3, #816	; 0x330
 80050d0:	4619      	mov	r1, r3
 80050d2:	4610      	mov	r0, r2
 80050d4:	f7fc fa1e 	bl	8001514 <curve25519Copy>
   curve25519Copy(r->t, state->u.t);
 80050d8:	68bb      	ldr	r3, [r7, #8]
 80050da:	f103 0260 	add.w	r2, r3, #96	; 0x60
 80050de:	68fb      	ldr	r3, [r7, #12]
 80050e0:	f503 7354 	add.w	r3, r3, #848	; 0x350
 80050e4:	4619      	mov	r1, r3
 80050e6:	4610      	mov	r0, r2
 80050e8:	f7fc fa14 	bl	8001514 <curve25519Copy>
}
 80050ec:	bf00      	nop
 80050ee:	3718      	adds	r7, #24
 80050f0:	46bd      	mov	sp, r7
 80050f2:	bd80      	pop	{r7, pc}

080050f4 <ed25519Add>:
 * @param[in] q Second operand
 **/

void ed25519Add(Ed25519State *state, Ed25519Point *r, const Ed25519Point *p,
   const Ed25519Point *q)
{
 80050f4:	b580      	push	{r7, lr}
 80050f6:	b084      	sub	sp, #16
 80050f8:	af00      	add	r7, sp, #0
 80050fa:	60f8      	str	r0, [r7, #12]
 80050fc:	60b9      	str	r1, [r7, #8]
 80050fe:	607a      	str	r2, [r7, #4]
 8005100:	603b      	str	r3, [r7, #0]
   //Compute A = (Y1 + X1) * (Y2 + X2)
   curve25519Add(state->c, p->y, p->x);
 8005102:	68fb      	ldr	r3, [r7, #12]
 8005104:	f503 6086 	add.w	r0, r3, #1072	; 0x430
 8005108:	687b      	ldr	r3, [r7, #4]
 800510a:	3320      	adds	r3, #32
 800510c:	687a      	ldr	r2, [r7, #4]
 800510e:	4619      	mov	r1, r3
 8005110:	f7fb fb62 	bl	80007d8 <curve25519Add>
   curve25519Add(state->d, q->y, q->x);
 8005114:	68fb      	ldr	r3, [r7, #12]
 8005116:	f503 608a 	add.w	r0, r3, #1104	; 0x450
 800511a:	683b      	ldr	r3, [r7, #0]
 800511c:	3320      	adds	r3, #32
 800511e:	683a      	ldr	r2, [r7, #0]
 8005120:	4619      	mov	r1, r3
 8005122:	f7fb fb59 	bl	80007d8 <curve25519Add>
   curve25519Mul(state->a, state->c, state->d);
 8005126:	68fb      	ldr	r3, [r7, #12]
 8005128:	f503 707c 	add.w	r0, r3, #1008	; 0x3f0
 800512c:	68fb      	ldr	r3, [r7, #12]
 800512e:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 8005132:	68fb      	ldr	r3, [r7, #12]
 8005134:	f503 638a 	add.w	r3, r3, #1104	; 0x450
 8005138:	461a      	mov	r2, r3
 800513a:	f7fb fc91 	bl	8000a60 <curve25519Mul>
   //Compute B = (Y1 - X1) * (Y2 - X2)
   curve25519Sub(state->c, p->y, p->x);
 800513e:	68fb      	ldr	r3, [r7, #12]
 8005140:	f503 6086 	add.w	r0, r3, #1072	; 0x430
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	3320      	adds	r3, #32
 8005148:	687a      	ldr	r2, [r7, #4]
 800514a:	4619      	mov	r1, r3
 800514c:	f7fb fbd6 	bl	80008fc <curve25519Sub>
   curve25519Sub(state->d, q->y, q->x);
 8005150:	68fb      	ldr	r3, [r7, #12]
 8005152:	f503 608a 	add.w	r0, r3, #1104	; 0x450
 8005156:	683b      	ldr	r3, [r7, #0]
 8005158:	3320      	adds	r3, #32
 800515a:	683a      	ldr	r2, [r7, #0]
 800515c:	4619      	mov	r1, r3
 800515e:	f7fb fbcd 	bl	80008fc <curve25519Sub>
   curve25519Mul(state->b, state->c, state->d);
 8005162:	68fb      	ldr	r3, [r7, #12]
 8005164:	f503 6082 	add.w	r0, r3, #1040	; 0x410
 8005168:	68fb      	ldr	r3, [r7, #12]
 800516a:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 800516e:	68fb      	ldr	r3, [r7, #12]
 8005170:	f503 638a 	add.w	r3, r3, #1104	; 0x450
 8005174:	461a      	mov	r2, r3
 8005176:	f7fb fc73 	bl	8000a60 <curve25519Mul>
   //Compute C = 2 * Z1 * Z2
   curve25519Mul(state->c, p->z, q->z);
 800517a:	68fb      	ldr	r3, [r7, #12]
 800517c:	f503 6086 	add.w	r0, r3, #1072	; 0x430
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8005186:	683b      	ldr	r3, [r7, #0]
 8005188:	3340      	adds	r3, #64	; 0x40
 800518a:	461a      	mov	r2, r3
 800518c:	f7fb fc68 	bl	8000a60 <curve25519Mul>
   curve25519Add(state->c, state->c, state->c);
 8005190:	68fb      	ldr	r3, [r7, #12]
 8005192:	f503 6086 	add.w	r0, r3, #1072	; 0x430
 8005196:	68fb      	ldr	r3, [r7, #12]
 8005198:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 800519c:	68fb      	ldr	r3, [r7, #12]
 800519e:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 80051a2:	461a      	mov	r2, r3
 80051a4:	f7fb fb18 	bl	80007d8 <curve25519Add>
   //Compute D = (2 * d) * T1 * T2
   curve25519Mul(state->d, p->t, q->t);
 80051a8:	68fb      	ldr	r3, [r7, #12]
 80051aa:	f503 608a 	add.w	r0, r3, #1104	; 0x450
 80051ae:	687b      	ldr	r3, [r7, #4]
 80051b0:	f103 0160 	add.w	r1, r3, #96	; 0x60
 80051b4:	683b      	ldr	r3, [r7, #0]
 80051b6:	3360      	adds	r3, #96	; 0x60
 80051b8:	461a      	mov	r2, r3
 80051ba:	f7fb fc51 	bl	8000a60 <curve25519Mul>
   curve25519Mul(state->d, state->d, ED25519_2D);
 80051be:	68fb      	ldr	r3, [r7, #12]
 80051c0:	f503 608a 	add.w	r0, r3, #1104	; 0x450
 80051c4:	68fb      	ldr	r3, [r7, #12]
 80051c6:	f503 638a 	add.w	r3, r3, #1104	; 0x450
 80051ca:	4a33      	ldr	r2, [pc, #204]	; (8005298 <ed25519Add+0x1a4>)
 80051cc:	4619      	mov	r1, r3
 80051ce:	f7fb fc47 	bl	8000a60 <curve25519Mul>
   //Compute E = A + B
   curve25519Add(state->e, state->a, state->b);
 80051d2:	68fb      	ldr	r3, [r7, #12]
 80051d4:	f503 608e 	add.w	r0, r3, #1136	; 0x470
 80051d8:	68fb      	ldr	r3, [r7, #12]
 80051da:	f503 717c 	add.w	r1, r3, #1008	; 0x3f0
 80051de:	68fb      	ldr	r3, [r7, #12]
 80051e0:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 80051e4:	461a      	mov	r2, r3
 80051e6:	f7fb faf7 	bl	80007d8 <curve25519Add>
   //Compute F = A - B
   curve25519Sub(state->f, state->a, state->b);
 80051ea:	68fb      	ldr	r3, [r7, #12]
 80051ec:	f503 6092 	add.w	r0, r3, #1168	; 0x490
 80051f0:	68fb      	ldr	r3, [r7, #12]
 80051f2:	f503 717c 	add.w	r1, r3, #1008	; 0x3f0
 80051f6:	68fb      	ldr	r3, [r7, #12]
 80051f8:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 80051fc:	461a      	mov	r2, r3
 80051fe:	f7fb fb7d 	bl	80008fc <curve25519Sub>
   //Compute G = C + D
   curve25519Add(state->g, state->c, state->d);
 8005202:	68fb      	ldr	r3, [r7, #12]
 8005204:	f503 6096 	add.w	r0, r3, #1200	; 0x4b0
 8005208:	68fb      	ldr	r3, [r7, #12]
 800520a:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 800520e:	68fb      	ldr	r3, [r7, #12]
 8005210:	f503 638a 	add.w	r3, r3, #1104	; 0x450
 8005214:	461a      	mov	r2, r3
 8005216:	f7fb fadf 	bl	80007d8 <curve25519Add>
   //Compute H = C - D
   curve25519Sub(state->h, state->c, state->d);
 800521a:	68fb      	ldr	r3, [r7, #12]
 800521c:	f503 609a 	add.w	r0, r3, #1232	; 0x4d0
 8005220:	68fb      	ldr	r3, [r7, #12]
 8005222:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 8005226:	68fb      	ldr	r3, [r7, #12]
 8005228:	f503 638a 	add.w	r3, r3, #1104	; 0x450
 800522c:	461a      	mov	r2, r3
 800522e:	f7fb fb65 	bl	80008fc <curve25519Sub>
   //Compute X3 = F * H
   curve25519Mul(r->x, state->f, state->h);
 8005232:	68b8      	ldr	r0, [r7, #8]
 8005234:	68fb      	ldr	r3, [r7, #12]
 8005236:	f503 6192 	add.w	r1, r3, #1168	; 0x490
 800523a:	68fb      	ldr	r3, [r7, #12]
 800523c:	f503 639a 	add.w	r3, r3, #1232	; 0x4d0
 8005240:	461a      	mov	r2, r3
 8005242:	f7fb fc0d 	bl	8000a60 <curve25519Mul>
   //Compute Y3 = E * G
   curve25519Mul(r->y, state->e, state->g);
 8005246:	68bb      	ldr	r3, [r7, #8]
 8005248:	f103 0020 	add.w	r0, r3, #32
 800524c:	68fb      	ldr	r3, [r7, #12]
 800524e:	f503 618e 	add.w	r1, r3, #1136	; 0x470
 8005252:	68fb      	ldr	r3, [r7, #12]
 8005254:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 8005258:	461a      	mov	r2, r3
 800525a:	f7fb fc01 	bl	8000a60 <curve25519Mul>
   //Compute Z3 = G * H
   curve25519Mul(r->z, state->g, state->h);
 800525e:	68bb      	ldr	r3, [r7, #8]
 8005260:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8005264:	68fb      	ldr	r3, [r7, #12]
 8005266:	f503 6196 	add.w	r1, r3, #1200	; 0x4b0
 800526a:	68fb      	ldr	r3, [r7, #12]
 800526c:	f503 639a 	add.w	r3, r3, #1232	; 0x4d0
 8005270:	461a      	mov	r2, r3
 8005272:	f7fb fbf5 	bl	8000a60 <curve25519Mul>
   //Compute T3 = E * F
   curve25519Mul(r->t, state->e, state->f);
 8005276:	68bb      	ldr	r3, [r7, #8]
 8005278:	f103 0060 	add.w	r0, r3, #96	; 0x60
 800527c:	68fb      	ldr	r3, [r7, #12]
 800527e:	f503 618e 	add.w	r1, r3, #1136	; 0x470
 8005282:	68fb      	ldr	r3, [r7, #12]
 8005284:	f503 6392 	add.w	r3, r3, #1168	; 0x490
 8005288:	461a      	mov	r2, r3
 800528a:	f7fb fbe9 	bl	8000a60 <curve25519Mul>
}
 800528e:	bf00      	nop
 8005290:	3710      	adds	r7, #16
 8005292:	46bd      	mov	sp, r7
 8005294:	bd80      	pop	{r7, pc}
 8005296:	bf00      	nop
 8005298:	0800f238 	.word	0x0800f238

0800529c <ed25519Double>:
 * @param[out] r Resulting point R = 2 * P
 * @param[in] p Input point P
 **/

void ed25519Double(Ed25519State *state, Ed25519Point *r, const Ed25519Point *p)
{
 800529c:	b580      	push	{r7, lr}
 800529e:	b084      	sub	sp, #16
 80052a0:	af00      	add	r7, sp, #0
 80052a2:	60f8      	str	r0, [r7, #12]
 80052a4:	60b9      	str	r1, [r7, #8]
 80052a6:	607a      	str	r2, [r7, #4]
   //Compute A = X1^2
   curve25519Sqr(state->a, p->x);
 80052a8:	68fb      	ldr	r3, [r7, #12]
 80052aa:	f503 737c 	add.w	r3, r3, #1008	; 0x3f0
 80052ae:	687a      	ldr	r2, [r7, #4]
 80052b0:	4611      	mov	r1, r2
 80052b2:	4618      	mov	r0, r3
 80052b4:	f7fb fe38 	bl	8000f28 <curve25519Sqr>
   //Compute B = Y1^2
   curve25519Sqr(state->b, p->y);
 80052b8:	68fb      	ldr	r3, [r7, #12]
 80052ba:	f503 6282 	add.w	r2, r3, #1040	; 0x410
 80052be:	687b      	ldr	r3, [r7, #4]
 80052c0:	3320      	adds	r3, #32
 80052c2:	4619      	mov	r1, r3
 80052c4:	4610      	mov	r0, r2
 80052c6:	f7fb fe2f 	bl	8000f28 <curve25519Sqr>
   //Compute C = 2 * Z1^2
   curve25519Sqr(state->c, p->z);
 80052ca:	68fb      	ldr	r3, [r7, #12]
 80052cc:	f503 6286 	add.w	r2, r3, #1072	; 0x430
 80052d0:	687b      	ldr	r3, [r7, #4]
 80052d2:	3340      	adds	r3, #64	; 0x40
 80052d4:	4619      	mov	r1, r3
 80052d6:	4610      	mov	r0, r2
 80052d8:	f7fb fe26 	bl	8000f28 <curve25519Sqr>
   curve25519Add(state->c, state->c, state->c);
 80052dc:	68fb      	ldr	r3, [r7, #12]
 80052de:	f503 6086 	add.w	r0, r3, #1072	; 0x430
 80052e2:	68fb      	ldr	r3, [r7, #12]
 80052e4:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 80052e8:	68fb      	ldr	r3, [r7, #12]
 80052ea:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 80052ee:	461a      	mov	r2, r3
 80052f0:	f7fb fa72 	bl	80007d8 <curve25519Add>
   //Compute E = A + B
   curve25519Add(state->e, state->a, state->b);
 80052f4:	68fb      	ldr	r3, [r7, #12]
 80052f6:	f503 608e 	add.w	r0, r3, #1136	; 0x470
 80052fa:	68fb      	ldr	r3, [r7, #12]
 80052fc:	f503 717c 	add.w	r1, r3, #1008	; 0x3f0
 8005300:	68fb      	ldr	r3, [r7, #12]
 8005302:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 8005306:	461a      	mov	r2, r3
 8005308:	f7fb fa66 	bl	80007d8 <curve25519Add>
   //Compute F = E - (X1 + Y1)^2
   curve25519Add(state->f, p->x, p->y);
 800530c:	68fb      	ldr	r3, [r7, #12]
 800530e:	f503 6092 	add.w	r0, r3, #1168	; 0x490
 8005312:	6879      	ldr	r1, [r7, #4]
 8005314:	687b      	ldr	r3, [r7, #4]
 8005316:	3320      	adds	r3, #32
 8005318:	461a      	mov	r2, r3
 800531a:	f7fb fa5d 	bl	80007d8 <curve25519Add>
   curve25519Sqr(state->f, state->f);
 800531e:	68fb      	ldr	r3, [r7, #12]
 8005320:	f503 6292 	add.w	r2, r3, #1168	; 0x490
 8005324:	68fb      	ldr	r3, [r7, #12]
 8005326:	f503 6392 	add.w	r3, r3, #1168	; 0x490
 800532a:	4619      	mov	r1, r3
 800532c:	4610      	mov	r0, r2
 800532e:	f7fb fdfb 	bl	8000f28 <curve25519Sqr>
   curve25519Sub(state->f, state->e, state->f);
 8005332:	68fb      	ldr	r3, [r7, #12]
 8005334:	f503 6092 	add.w	r0, r3, #1168	; 0x490
 8005338:	68fb      	ldr	r3, [r7, #12]
 800533a:	f503 618e 	add.w	r1, r3, #1136	; 0x470
 800533e:	68fb      	ldr	r3, [r7, #12]
 8005340:	f503 6392 	add.w	r3, r3, #1168	; 0x490
 8005344:	461a      	mov	r2, r3
 8005346:	f7fb fad9 	bl	80008fc <curve25519Sub>
   //Compute G = A - B
   curve25519Sub(state->g, state->a, state->b);
 800534a:	68fb      	ldr	r3, [r7, #12]
 800534c:	f503 6096 	add.w	r0, r3, #1200	; 0x4b0
 8005350:	68fb      	ldr	r3, [r7, #12]
 8005352:	f503 717c 	add.w	r1, r3, #1008	; 0x3f0
 8005356:	68fb      	ldr	r3, [r7, #12]
 8005358:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 800535c:	461a      	mov	r2, r3
 800535e:	f7fb facd 	bl	80008fc <curve25519Sub>
   //Compute H = C + G
   curve25519Add(state->h, state->c, state->g);
 8005362:	68fb      	ldr	r3, [r7, #12]
 8005364:	f503 609a 	add.w	r0, r3, #1232	; 0x4d0
 8005368:	68fb      	ldr	r3, [r7, #12]
 800536a:	f503 6186 	add.w	r1, r3, #1072	; 0x430
 800536e:	68fb      	ldr	r3, [r7, #12]
 8005370:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 8005374:	461a      	mov	r2, r3
 8005376:	f7fb fa2f 	bl	80007d8 <curve25519Add>
   //Compute X3 = F * H
   curve25519Mul(r->x, state->f, state->h);
 800537a:	68b8      	ldr	r0, [r7, #8]
 800537c:	68fb      	ldr	r3, [r7, #12]
 800537e:	f503 6192 	add.w	r1, r3, #1168	; 0x490
 8005382:	68fb      	ldr	r3, [r7, #12]
 8005384:	f503 639a 	add.w	r3, r3, #1232	; 0x4d0
 8005388:	461a      	mov	r2, r3
 800538a:	f7fb fb69 	bl	8000a60 <curve25519Mul>
   //Compute Y3 = E * G
   curve25519Mul(r->y, state->e, state->g);
 800538e:	68bb      	ldr	r3, [r7, #8]
 8005390:	f103 0020 	add.w	r0, r3, #32
 8005394:	68fb      	ldr	r3, [r7, #12]
 8005396:	f503 618e 	add.w	r1, r3, #1136	; 0x470
 800539a:	68fb      	ldr	r3, [r7, #12]
 800539c:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 80053a0:	461a      	mov	r2, r3
 80053a2:	f7fb fb5d 	bl	8000a60 <curve25519Mul>
   //Compute Z3 = G * H
   curve25519Mul(r->z, state->g, state->h);
 80053a6:	68bb      	ldr	r3, [r7, #8]
 80053a8:	f103 0040 	add.w	r0, r3, #64	; 0x40
 80053ac:	68fb      	ldr	r3, [r7, #12]
 80053ae:	f503 6196 	add.w	r1, r3, #1200	; 0x4b0
 80053b2:	68fb      	ldr	r3, [r7, #12]
 80053b4:	f503 639a 	add.w	r3, r3, #1232	; 0x4d0
 80053b8:	461a      	mov	r2, r3
 80053ba:	f7fb fb51 	bl	8000a60 <curve25519Mul>
   //Compute T3 = E * F
   curve25519Mul(r->t, state->e, state->f);
 80053be:	68bb      	ldr	r3, [r7, #8]
 80053c0:	f103 0060 	add.w	r0, r3, #96	; 0x60
 80053c4:	68fb      	ldr	r3, [r7, #12]
 80053c6:	f503 618e 	add.w	r1, r3, #1136	; 0x470
 80053ca:	68fb      	ldr	r3, [r7, #12]
 80053cc:	f503 6392 	add.w	r3, r3, #1168	; 0x490
 80053d0:	461a      	mov	r2, r3
 80053d2:	f7fb fb45 	bl	8000a60 <curve25519Mul>
}
 80053d6:	bf00      	nop
 80053d8:	3710      	adds	r7, #16
 80053da:	46bd      	mov	sp, r7
 80053dc:	bd80      	pop	{r7, pc}

080053de <ed25519Encode>:
 * @param[in] p Point representation
 * @param[out] data Octet string resulting from the conversion
 **/

void ed25519Encode(Ed25519Point *p, uint8_t *data)
{
 80053de:	b580      	push	{r7, lr}
 80053e0:	b082      	sub	sp, #8
 80053e2:	af00      	add	r7, sp, #0
 80053e4:	6078      	str	r0, [r7, #4]
 80053e6:	6039      	str	r1, [r7, #0]
   //Retrieve affine representation
   curve25519Inv(p->z, p->z);
 80053e8:	687b      	ldr	r3, [r7, #4]
 80053ea:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80053ee:	687b      	ldr	r3, [r7, #4]
 80053f0:	3340      	adds	r3, #64	; 0x40
 80053f2:	4619      	mov	r1, r3
 80053f4:	4610      	mov	r0, r2
 80053f6:	f7fb fe09 	bl	800100c <curve25519Inv>
   curve25519Mul(p->x, p->x, p->z);
 80053fa:	6878      	ldr	r0, [r7, #4]
 80053fc:	6879      	ldr	r1, [r7, #4]
 80053fe:	687b      	ldr	r3, [r7, #4]
 8005400:	3340      	adds	r3, #64	; 0x40
 8005402:	461a      	mov	r2, r3
 8005404:	f7fb fb2c 	bl	8000a60 <curve25519Mul>
   curve25519Mul(p->y, p->y, p->z);
 8005408:	687b      	ldr	r3, [r7, #4]
 800540a:	f103 0020 	add.w	r0, r3, #32
 800540e:	687b      	ldr	r3, [r7, #4]
 8005410:	f103 0120 	add.w	r1, r3, #32
 8005414:	687b      	ldr	r3, [r7, #4]
 8005416:	3340      	adds	r3, #64	; 0x40
 8005418:	461a      	mov	r2, r3
 800541a:	f7fb fb21 	bl	8000a60 <curve25519Mul>
   curve25519SetInt(p->z, 1);
 800541e:	687b      	ldr	r3, [r7, #4]
 8005420:	3340      	adds	r3, #64	; 0x40
 8005422:	2101      	movs	r1, #1
 8005424:	4618      	mov	r0, r3
 8005426:	f7fb f9b9 	bl	800079c <curve25519SetInt>
   curve25519Mul(p->t, p->x, p->y);
 800542a:	687b      	ldr	r3, [r7, #4]
 800542c:	f103 0060 	add.w	r0, r3, #96	; 0x60
 8005430:	6879      	ldr	r1, [r7, #4]
 8005432:	687b      	ldr	r3, [r7, #4]
 8005434:	3320      	adds	r3, #32
 8005436:	461a      	mov	r2, r3
 8005438:	f7fb fb12 	bl	8000a60 <curve25519Mul>

   //Encode the y-coordinate as a little-endian string of 32 octets. The most
   //significant bit of the final octet is always zero
   curve25519Export(p->y, data);
 800543c:	687b      	ldr	r3, [r7, #4]
 800543e:	3320      	adds	r3, #32
 8005440:	6839      	ldr	r1, [r7, #0]
 8005442:	4618      	mov	r0, r3
 8005444:	f7fc f900 	bl	8001648 <curve25519Export>

   //Copy the least significant bit of the x-coordinate to the most significant
   //bit of the final octet
   data[31] |= (p->x[0] & 1) << 7;
 8005448:	683b      	ldr	r3, [r7, #0]
 800544a:	331f      	adds	r3, #31
 800544c:	7819      	ldrb	r1, [r3, #0]
 800544e:	687b      	ldr	r3, [r7, #4]
 8005450:	681b      	ldr	r3, [r3, #0]
 8005452:	b2db      	uxtb	r3, r3
 8005454:	01db      	lsls	r3, r3, #7
 8005456:	b2da      	uxtb	r2, r3
 8005458:	683b      	ldr	r3, [r7, #0]
 800545a:	331f      	adds	r3, #31
 800545c:	430a      	orrs	r2, r1
 800545e:	b2d2      	uxtb	r2, r2
 8005460:	701a      	strb	r2, [r3, #0]
}
 8005462:	bf00      	nop
 8005464:	3708      	adds	r7, #8
 8005466:	46bd      	mov	sp, r7
 8005468:	bd80      	pop	{r7, pc}
	...

0800546c <ed25519Decode>:
 * @param[in] p Point representation
 * @param[out] data Octet string to be converted
 **/

uint32_t ed25519Decode(Ed25519Point *p, const uint8_t *data)
{
 800546c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8005470:	b098      	sub	sp, #96	; 0x60
 8005472:	af00      	add	r7, sp, #0
 8005474:	6078      	str	r0, [r7, #4]
 8005476:	6039      	str	r1, [r7, #0]
   uint32_t v[8];

   //First, interpret the string as an integer in little-endian representation.
   //Bit 255 of this number is the least significant bit of the x-coordinate
   //and denote this value x_0
   x0 = data[31] >> 7;
 8005478:	683b      	ldr	r3, [r7, #0]
 800547a:	331f      	adds	r3, #31
 800547c:	781b      	ldrb	r3, [r3, #0]
 800547e:	09db      	lsrs	r3, r3, #7
 8005480:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

   //The y-coordinate is recovered simply by clearing this bit
   curve25519Import(p->y, data);
 8005484:	687b      	ldr	r3, [r7, #4]
 8005486:	3320      	adds	r3, #32
 8005488:	6839      	ldr	r1, [r7, #0]
 800548a:	4618      	mov	r0, r3
 800548c:	f7fc f8ba 	bl	8001604 <curve25519Import>
   p->y[7] &= 0x7FFFFFFF;
 8005490:	687b      	ldr	r3, [r7, #4]
 8005492:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005494:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8005498:	687b      	ldr	r3, [r7, #4]
 800549a:	63da      	str	r2, [r3, #60]	; 0x3c

   //Compute u = y + 19
   for(temp = 19, i = 0; i < 8; i++)
 800549c:	f04f 0213 	mov.w	r2, #19
 80054a0:	f04f 0300 	mov.w	r3, #0
 80054a4:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
 80054a8:	2300      	movs	r3, #0
 80054aa:	65fb      	str	r3, [r7, #92]	; 0x5c
 80054ac:	e023      	b.n	80054f6 <ed25519Decode+0x8a>
   {
      temp += p->y[i];
 80054ae:	687b      	ldr	r3, [r7, #4]
 80054b0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80054b2:	3208      	adds	r2, #8
 80054b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80054b8:	2200      	movs	r2, #0
 80054ba:	461c      	mov	r4, r3
 80054bc:	4615      	mov	r5, r2
 80054be:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 80054c2:	eb12 0804 	adds.w	r8, r2, r4
 80054c6:	eb43 0905 	adc.w	r9, r3, r5
 80054ca:	e9c7 8914 	strd	r8, r9, [r7, #80]	; 0x50
      u[i] = temp & 0xFFFFFFFF;
 80054ce:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80054d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80054d2:	009b      	lsls	r3, r3, #2
 80054d4:	3360      	adds	r3, #96	; 0x60
 80054d6:	443b      	add	r3, r7
 80054d8:	f843 2c38 	str.w	r2, [r3, #-56]
      temp >>= 32;
 80054dc:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 80054e0:	f04f 0200 	mov.w	r2, #0
 80054e4:	f04f 0300 	mov.w	r3, #0
 80054e8:	000a      	movs	r2, r1
 80054ea:	2300      	movs	r3, #0
 80054ec:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
   for(temp = 19, i = 0; i < 8; i++)
 80054f0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80054f2:	3301      	adds	r3, #1
 80054f4:	65fb      	str	r3, [r7, #92]	; 0x5c
 80054f6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80054f8:	2b07      	cmp	r3, #7
 80054fa:	d9d8      	bls.n	80054ae <ed25519Decode+0x42>
   }

   //If the y-coordinate is >= p, decoding fails
   ret = (u[7] >> 31) & 1;
 80054fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80054fe:	0fdb      	lsrs	r3, r3, #31
 8005500:	64bb      	str	r3, [r7, #72]	; 0x48

   //The curve equation implies x^2 = (y^2 - 1) / (d * y^2 + 1) mod p
   //Let u = y^2 - 1 and v = d * y^2 + 1
   curve25519Sqr(v, p->y);
 8005502:	687b      	ldr	r3, [r7, #4]
 8005504:	f103 0220 	add.w	r2, r3, #32
 8005508:	f107 0308 	add.w	r3, r7, #8
 800550c:	4611      	mov	r1, r2
 800550e:	4618      	mov	r0, r3
 8005510:	f7fb fd0a 	bl	8000f28 <curve25519Sqr>
   curve25519SubInt(u, v, 1);
 8005514:	f107 0108 	add.w	r1, r7, #8
 8005518:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800551c:	2201      	movs	r2, #1
 800551e:	4618      	mov	r0, r3
 8005520:	f7fb fa47 	bl	80009b2 <curve25519SubInt>
   curve25519Mul(v, v, ED25519_D);
 8005524:	f107 0108 	add.w	r1, r7, #8
 8005528:	f107 0308 	add.w	r3, r7, #8
 800552c:	4a28      	ldr	r2, [pc, #160]	; (80055d0 <ed25519Decode+0x164>)
 800552e:	4618      	mov	r0, r3
 8005530:	f7fb fa96 	bl	8000a60 <curve25519Mul>
   curve25519AddInt(v, v, 1);
 8005534:	f107 0108 	add.w	r1, r7, #8
 8005538:	f107 0308 	add.w	r3, r7, #8
 800553c:	2201      	movs	r2, #1
 800553e:	4618      	mov	r0, r3
 8005540:	f7fb f99d 	bl	800087e <curve25519AddInt>

   //Compute u = sqrt(u / v)
   ret |= curve25519Sqrt(u, u, v);
 8005544:	f107 0208 	add.w	r2, r7, #8
 8005548:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800554c:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005550:	4618      	mov	r0, r3
 8005552:	f7fb fe67 	bl	8001224 <curve25519Sqrt>
 8005556:	4602      	mov	r2, r0
 8005558:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800555a:	4313      	orrs	r3, r2
 800555c:	64bb      	str	r3, [r7, #72]	; 0x48

   //If x = 0, and x_0 = 1, decoding fails
   ret |= (curve25519Comp(u, ED25519_ZERO) ^ 1) & x0;
 800555e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005562:	491c      	ldr	r1, [pc, #112]	; (80055d4 <ed25519Decode+0x168>)
 8005564:	4618      	mov	r0, r3
 8005566:	f7fc f824 	bl	80015b2 <curve25519Comp>
 800556a:	4603      	mov	r3, r0
 800556c:	f083 0201 	eor.w	r2, r3, #1
 8005570:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8005574:	4013      	ands	r3, r2
 8005576:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8005578:	4313      	orrs	r3, r2
 800557a:	64bb      	str	r3, [r7, #72]	; 0x48

   //Compute v = p - u
   curve25519Sub(v, ED25519_ZERO, u);
 800557c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8005580:	f107 0308 	add.w	r3, r7, #8
 8005584:	4913      	ldr	r1, [pc, #76]	; (80055d4 <ed25519Decode+0x168>)
 8005586:	4618      	mov	r0, r3
 8005588:	f7fb f9b8 	bl	80008fc <curve25519Sub>

   //Finally, use the x_0 bit to select the right square root
   curve25519Select(p->x, u, v, (x0 ^ u[0]) & 1);
 800558c:	6878      	ldr	r0, [r7, #4]
 800558e:	f897 204f 	ldrb.w	r2, [r7, #79]	; 0x4f
 8005592:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005594:	4053      	eors	r3, r2
 8005596:	f003 0301 	and.w	r3, r3, #1
 800559a:	f107 0208 	add.w	r2, r7, #8
 800559e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80055a2:	f7fb ffd6 	bl	8001552 <curve25519Select>

   //Calculate extended point representation
   curve25519SetInt(p->z, 1);
 80055a6:	687b      	ldr	r3, [r7, #4]
 80055a8:	3340      	adds	r3, #64	; 0x40
 80055aa:	2101      	movs	r1, #1
 80055ac:	4618      	mov	r0, r3
 80055ae:	f7fb f8f5 	bl	800079c <curve25519SetInt>
   curve25519Mul(p->t, p->x, p->y);
 80055b2:	687b      	ldr	r3, [r7, #4]
 80055b4:	f103 0060 	add.w	r0, r3, #96	; 0x60
 80055b8:	6879      	ldr	r1, [r7, #4]
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	3320      	adds	r3, #32
 80055be:	461a      	mov	r2, r3
 80055c0:	f7fb fa4e 	bl	8000a60 <curve25519Mul>

   //Return 0 if the point has been successfully decoded, else 1
   return ret;
 80055c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 80055c6:	4618      	mov	r0, r3
 80055c8:	3760      	adds	r7, #96	; 0x60
 80055ca:	46bd      	mov	sp, r7
 80055cc:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 80055d0:	0800f218 	.word	0x0800f218
 80055d4:	0800f1f8 	.word	0x0800f1f8

080055d8 <ed25519RedInt>:
 * @param[out] r Resulting integer R = A mod L
 * @param[in] a An integer such as 0 <= A < b^(2 * k)
 **/

void ed25519RedInt(uint8_t *r, const uint8_t *a)
{
 80055d8:	b590      	push	{r4, r7, lr}
 80055da:	b097      	sub	sp, #92	; 0x5c
 80055dc:	af02      	add	r7, sp, #8
 80055de:	6078      	str	r0, [r7, #4]
 80055e0:	6039      	str	r1, [r7, #0]
   uint8_t c;
   uint8_t u[33];
   uint8_t v[33];

   //Compute the estimate of the quotient u = ((a / b^(k - 1)) * mu) / b^(k + 1)
   ed25519MulInt(NULL, u, a + 31, ED25519_MU, 33);
 80055e2:	683b      	ldr	r3, [r7, #0]
 80055e4:	f103 021f 	add.w	r2, r3, #31
 80055e8:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 80055ec:	2321      	movs	r3, #33	; 0x21
 80055ee:	9300      	str	r3, [sp, #0]
 80055f0:	4b27      	ldr	r3, [pc, #156]	; (8005690 <ed25519RedInt+0xb8>)
 80055f2:	2000      	movs	r0, #0
 80055f4:	f000 f8bd 	bl	8005772 <ed25519MulInt>
   //Compute v = u * L mod b^(k + 1)
   ed25519MulInt(v, NULL, u, ED25519_L, 33);
 80055f8:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80055fc:	f107 0008 	add.w	r0, r7, #8
 8005600:	2321      	movs	r3, #33	; 0x21
 8005602:	9300      	str	r3, [sp, #0]
 8005604:	4b23      	ldr	r3, [pc, #140]	; (8005694 <ed25519RedInt+0xbc>)
 8005606:	2100      	movs	r1, #0
 8005608:	f000 f8b3 	bl	8005772 <ed25519MulInt>

   //Compute the estimate of the remainder u = a mod b^(k + 1) - v
   //If u < 0, then u = u + b^(k + 1)
   ed25519SubInt(u, a, v, 33);
 800560c:	f107 0208 	add.w	r2, r7, #8
 8005610:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8005614:	2321      	movs	r3, #33	; 0x21
 8005616:	6839      	ldr	r1, [r7, #0]
 8005618:	f000 f871 	bl	80056fe <ed25519SubInt>

   //This estimation implies that at most two subtractions of L are required to
   //obtain the correct remainder r
   c = ed25519SubInt(v, u, ED25519_L, 33);
 800561c:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 8005620:	f107 0008 	add.w	r0, r7, #8
 8005624:	2321      	movs	r3, #33	; 0x21
 8005626:	4a1b      	ldr	r2, [pc, #108]	; (8005694 <ed25519RedInt+0xbc>)
 8005628:	f000 f869 	bl	80056fe <ed25519SubInt>
 800562c:	4603      	mov	r3, r0
 800562e:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
   ed25519SelectInt(u, v, u, c, 33);
 8005632:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8005636:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800563a:	f107 0108 	add.w	r1, r7, #8
 800563e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8005642:	2421      	movs	r4, #33	; 0x21
 8005644:	9400      	str	r4, [sp, #0]
 8005646:	f000 f92a 	bl	800589e <ed25519SelectInt>
   c = ed25519SubInt(v, u, ED25519_L, 33);
 800564a:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 800564e:	f107 0008 	add.w	r0, r7, #8
 8005652:	2321      	movs	r3, #33	; 0x21
 8005654:	4a0f      	ldr	r2, [pc, #60]	; (8005694 <ed25519RedInt+0xbc>)
 8005656:	f000 f852 	bl	80056fe <ed25519SubInt>
 800565a:	4603      	mov	r3, r0
 800565c:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
   ed25519SelectInt(u, v, u, c, 33);
 8005660:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8005664:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8005668:	f107 0108 	add.w	r1, r7, #8
 800566c:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8005670:	2421      	movs	r4, #33	; 0x21
 8005672:	9400      	str	r4, [sp, #0]
 8005674:	f000 f913 	bl	800589e <ed25519SelectInt>

   //Copy the resulting remainder
   ed25519CopyInt(r, u, 32);
 8005678:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800567c:	2220      	movs	r2, #32
 800567e:	4619      	mov	r1, r3
 8005680:	6878      	ldr	r0, [r7, #4]
 8005682:	f000 f8ed 	bl	8005860 <ed25519CopyInt>
}
 8005686:	bf00      	nop
 8005688:	3754      	adds	r7, #84	; 0x54
 800568a:	46bd      	mov	sp, r7
 800568c:	bd90      	pop	{r4, r7, pc}
 800568e:	bf00      	nop
 8005690:	0800f27c 	.word	0x0800f27c
 8005694:	0800f258 	.word	0x0800f258

08005698 <ed25519AddInt>:
 * @param[in] b An integer such as 0 <= B < (2^8)^n
 * @param[in] n Size of the operands, in bytes
 **/

void ed25519AddInt(uint8_t *r, const uint8_t *a, const uint8_t *b, uint_t n)
{
 8005698:	b480      	push	{r7}
 800569a:	b087      	sub	sp, #28
 800569c:	af00      	add	r7, sp, #0
 800569e:	60f8      	str	r0, [r7, #12]
 80056a0:	60b9      	str	r1, [r7, #8]
 80056a2:	607a      	str	r2, [r7, #4]
 80056a4:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint16_t temp;

   //Compute R = A + B
   for(temp = 0, i = 0; i < n; i++)
 80056a6:	2300      	movs	r3, #0
 80056a8:	827b      	strh	r3, [r7, #18]
 80056aa:	2300      	movs	r3, #0
 80056ac:	617b      	str	r3, [r7, #20]
 80056ae:	e01b      	b.n	80056e8 <ed25519AddInt+0x50>
   {
      temp += a[i];
 80056b0:	68ba      	ldr	r2, [r7, #8]
 80056b2:	697b      	ldr	r3, [r7, #20]
 80056b4:	4413      	add	r3, r2
 80056b6:	781b      	ldrb	r3, [r3, #0]
 80056b8:	b29a      	uxth	r2, r3
 80056ba:	8a7b      	ldrh	r3, [r7, #18]
 80056bc:	4413      	add	r3, r2
 80056be:	827b      	strh	r3, [r7, #18]
      temp += b[i];
 80056c0:	687a      	ldr	r2, [r7, #4]
 80056c2:	697b      	ldr	r3, [r7, #20]
 80056c4:	4413      	add	r3, r2
 80056c6:	781b      	ldrb	r3, [r3, #0]
 80056c8:	b29a      	uxth	r2, r3
 80056ca:	8a7b      	ldrh	r3, [r7, #18]
 80056cc:	4413      	add	r3, r2
 80056ce:	827b      	strh	r3, [r7, #18]
      r[i] = temp & 0xFF;
 80056d0:	68fa      	ldr	r2, [r7, #12]
 80056d2:	697b      	ldr	r3, [r7, #20]
 80056d4:	4413      	add	r3, r2
 80056d6:	8a7a      	ldrh	r2, [r7, #18]
 80056d8:	b2d2      	uxtb	r2, r2
 80056da:	701a      	strb	r2, [r3, #0]
      temp >>= 8;
 80056dc:	8a7b      	ldrh	r3, [r7, #18]
 80056de:	0a1b      	lsrs	r3, r3, #8
 80056e0:	827b      	strh	r3, [r7, #18]
   for(temp = 0, i = 0; i < n; i++)
 80056e2:	697b      	ldr	r3, [r7, #20]
 80056e4:	3301      	adds	r3, #1
 80056e6:	617b      	str	r3, [r7, #20]
 80056e8:	697a      	ldr	r2, [r7, #20]
 80056ea:	683b      	ldr	r3, [r7, #0]
 80056ec:	429a      	cmp	r2, r3
 80056ee:	d3df      	bcc.n	80056b0 <ed25519AddInt+0x18>
   }
}
 80056f0:	bf00      	nop
 80056f2:	bf00      	nop
 80056f4:	371c      	adds	r7, #28
 80056f6:	46bd      	mov	sp, r7
 80056f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056fc:	4770      	bx	lr

080056fe <ed25519SubInt>:
 * @param[in] n Size of the operands, in bytes
 * @return 1 if the result is negative, else 0
 **/

uint8_t ed25519SubInt(uint8_t *r, const uint8_t *a, const uint8_t *b, uint_t n)
{
 80056fe:	b480      	push	{r7}
 8005700:	b087      	sub	sp, #28
 8005702:	af00      	add	r7, sp, #0
 8005704:	60f8      	str	r0, [r7, #12]
 8005706:	60b9      	str	r1, [r7, #8]
 8005708:	607a      	str	r2, [r7, #4]
 800570a:	603b      	str	r3, [r7, #0]
   uint_t i;
   int16_t temp;

   //Compute R = A - B
   for(temp = 0, i = 0; i < n; i++)
 800570c:	2300      	movs	r3, #0
 800570e:	827b      	strh	r3, [r7, #18]
 8005710:	2300      	movs	r3, #0
 8005712:	617b      	str	r3, [r7, #20]
 8005714:	e01e      	b.n	8005754 <ed25519SubInt+0x56>
   {
      temp += a[i];
 8005716:	68ba      	ldr	r2, [r7, #8]
 8005718:	697b      	ldr	r3, [r7, #20]
 800571a:	4413      	add	r3, r2
 800571c:	781b      	ldrb	r3, [r3, #0]
 800571e:	b29a      	uxth	r2, r3
 8005720:	8a7b      	ldrh	r3, [r7, #18]
 8005722:	4413      	add	r3, r2
 8005724:	b29b      	uxth	r3, r3
 8005726:	827b      	strh	r3, [r7, #18]
      temp -= b[i];
 8005728:	8a7a      	ldrh	r2, [r7, #18]
 800572a:	6879      	ldr	r1, [r7, #4]
 800572c:	697b      	ldr	r3, [r7, #20]
 800572e:	440b      	add	r3, r1
 8005730:	781b      	ldrb	r3, [r3, #0]
 8005732:	b29b      	uxth	r3, r3
 8005734:	1ad3      	subs	r3, r2, r3
 8005736:	b29b      	uxth	r3, r3
 8005738:	827b      	strh	r3, [r7, #18]
      r[i] = temp & 0xFF;
 800573a:	68fa      	ldr	r2, [r7, #12]
 800573c:	697b      	ldr	r3, [r7, #20]
 800573e:	4413      	add	r3, r2
 8005740:	8a7a      	ldrh	r2, [r7, #18]
 8005742:	b2d2      	uxtb	r2, r2
 8005744:	701a      	strb	r2, [r3, #0]
      temp >>= 8;
 8005746:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800574a:	121b      	asrs	r3, r3, #8
 800574c:	827b      	strh	r3, [r7, #18]
   for(temp = 0, i = 0; i < n; i++)
 800574e:	697b      	ldr	r3, [r7, #20]
 8005750:	3301      	adds	r3, #1
 8005752:	617b      	str	r3, [r7, #20]
 8005754:	697a      	ldr	r2, [r7, #20]
 8005756:	683b      	ldr	r3, [r7, #0]
 8005758:	429a      	cmp	r2, r3
 800575a:	d3dc      	bcc.n	8005716 <ed25519SubInt+0x18>
   }

   //Return 1 if the result of the subtraction is negative
   return temp & 1;
 800575c:	8a7b      	ldrh	r3, [r7, #18]
 800575e:	b2db      	uxtb	r3, r3
 8005760:	f003 0301 	and.w	r3, r3, #1
 8005764:	b2db      	uxtb	r3, r3
}
 8005766:	4618      	mov	r0, r3
 8005768:	371c      	adds	r7, #28
 800576a:	46bd      	mov	sp, r7
 800576c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005770:	4770      	bx	lr

08005772 <ed25519MulInt>:
 * @param[in] n Size of the operands, in bytes
 **/

void ed25519MulInt(uint8_t *rl, uint8_t *rh, const uint8_t *a,
   const uint8_t *b, uint_t n)
{
 8005772:	b480      	push	{r7}
 8005774:	b089      	sub	sp, #36	; 0x24
 8005776:	af00      	add	r7, sp, #0
 8005778:	60f8      	str	r0, [r7, #12]
 800577a:	60b9      	str	r1, [r7, #8]
 800577c:	607a      	str	r2, [r7, #4]
 800577e:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint_t j;
   uint32_t temp;

   //Compute the low part of the multiplication
   for(temp = 0, i = 0; i < n; i++)
 8005780:	2300      	movs	r3, #0
 8005782:	617b      	str	r3, [r7, #20]
 8005784:	2300      	movs	r3, #0
 8005786:	61fb      	str	r3, [r7, #28]
 8005788:	e029      	b.n	80057de <ed25519MulInt+0x6c>
   {
      //The Comba's algorithm computes the products, column by column
      for(j = 0; j <= i; j++)
 800578a:	2300      	movs	r3, #0
 800578c:	61bb      	str	r3, [r7, #24]
 800578e:	e013      	b.n	80057b8 <ed25519MulInt+0x46>
      {
         temp += (uint16_t) a[j] * b[i - j];
 8005790:	687a      	ldr	r2, [r7, #4]
 8005792:	69bb      	ldr	r3, [r7, #24]
 8005794:	4413      	add	r3, r2
 8005796:	781b      	ldrb	r3, [r3, #0]
 8005798:	4619      	mov	r1, r3
 800579a:	69fa      	ldr	r2, [r7, #28]
 800579c:	69bb      	ldr	r3, [r7, #24]
 800579e:	1ad3      	subs	r3, r2, r3
 80057a0:	683a      	ldr	r2, [r7, #0]
 80057a2:	4413      	add	r3, r2
 80057a4:	781b      	ldrb	r3, [r3, #0]
 80057a6:	fb01 f303 	mul.w	r3, r1, r3
 80057aa:	461a      	mov	r2, r3
 80057ac:	697b      	ldr	r3, [r7, #20]
 80057ae:	4413      	add	r3, r2
 80057b0:	617b      	str	r3, [r7, #20]
      for(j = 0; j <= i; j++)
 80057b2:	69bb      	ldr	r3, [r7, #24]
 80057b4:	3301      	adds	r3, #1
 80057b6:	61bb      	str	r3, [r7, #24]
 80057b8:	69ba      	ldr	r2, [r7, #24]
 80057ba:	69fb      	ldr	r3, [r7, #28]
 80057bc:	429a      	cmp	r2, r3
 80057be:	d9e7      	bls.n	8005790 <ed25519MulInt+0x1e>
      }

      //At the bottom of each column, the final result is written to memory
      if(rl != NULL)
 80057c0:	68fb      	ldr	r3, [r7, #12]
 80057c2:	2b00      	cmp	r3, #0
 80057c4:	d005      	beq.n	80057d2 <ed25519MulInt+0x60>
      {
         rl[i] = temp & 0xFF;
 80057c6:	68fa      	ldr	r2, [r7, #12]
 80057c8:	69fb      	ldr	r3, [r7, #28]
 80057ca:	4413      	add	r3, r2
 80057cc:	697a      	ldr	r2, [r7, #20]
 80057ce:	b2d2      	uxtb	r2, r2
 80057d0:	701a      	strb	r2, [r3, #0]
      }

      //Propagate the carry upwards
      temp >>= 8;
 80057d2:	697b      	ldr	r3, [r7, #20]
 80057d4:	0a1b      	lsrs	r3, r3, #8
 80057d6:	617b      	str	r3, [r7, #20]
   for(temp = 0, i = 0; i < n; i++)
 80057d8:	69fb      	ldr	r3, [r7, #28]
 80057da:	3301      	adds	r3, #1
 80057dc:	61fb      	str	r3, [r7, #28]
 80057de:	69fa      	ldr	r2, [r7, #28]
 80057e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80057e2:	429a      	cmp	r2, r3
 80057e4:	d3d1      	bcc.n	800578a <ed25519MulInt+0x18>
   }

   //Check whether the high part of the multiplication should be calculated
   if(rh != NULL)
 80057e6:	68bb      	ldr	r3, [r7, #8]
 80057e8:	2b00      	cmp	r3, #0
 80057ea:	d033      	beq.n	8005854 <ed25519MulInt+0xe2>
   {
      //Compute the high part of the multiplication
      for(i = n; i < (2 * n); i++)
 80057ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80057ee:	61fb      	str	r3, [r7, #28]
 80057f0:	e02b      	b.n	800584a <ed25519MulInt+0xd8>
      {
         //The Comba's algorithm computes the products, column by column
         for(j = i + 1 - n; j < n; j++)
 80057f2:	69fa      	ldr	r2, [r7, #28]
 80057f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80057f6:	1ad3      	subs	r3, r2, r3
 80057f8:	3301      	adds	r3, #1
 80057fa:	61bb      	str	r3, [r7, #24]
 80057fc:	e013      	b.n	8005826 <ed25519MulInt+0xb4>
         {
            temp += (uint16_t) a[j] * b[i - j];
 80057fe:	687a      	ldr	r2, [r7, #4]
 8005800:	69bb      	ldr	r3, [r7, #24]
 8005802:	4413      	add	r3, r2
 8005804:	781b      	ldrb	r3, [r3, #0]
 8005806:	4619      	mov	r1, r3
 8005808:	69fa      	ldr	r2, [r7, #28]
 800580a:	69bb      	ldr	r3, [r7, #24]
 800580c:	1ad3      	subs	r3, r2, r3
 800580e:	683a      	ldr	r2, [r7, #0]
 8005810:	4413      	add	r3, r2
 8005812:	781b      	ldrb	r3, [r3, #0]
 8005814:	fb01 f303 	mul.w	r3, r1, r3
 8005818:	461a      	mov	r2, r3
 800581a:	697b      	ldr	r3, [r7, #20]
 800581c:	4413      	add	r3, r2
 800581e:	617b      	str	r3, [r7, #20]
         for(j = i + 1 - n; j < n; j++)
 8005820:	69bb      	ldr	r3, [r7, #24]
 8005822:	3301      	adds	r3, #1
 8005824:	61bb      	str	r3, [r7, #24]
 8005826:	69ba      	ldr	r2, [r7, #24]
 8005828:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800582a:	429a      	cmp	r2, r3
 800582c:	d3e7      	bcc.n	80057fe <ed25519MulInt+0x8c>
         }

         //At the bottom of each column, the final result is written to memory
         rh[i - n] = temp & 0xFF;
 800582e:	69fa      	ldr	r2, [r7, #28]
 8005830:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005832:	1ad3      	subs	r3, r2, r3
 8005834:	68ba      	ldr	r2, [r7, #8]
 8005836:	4413      	add	r3, r2
 8005838:	697a      	ldr	r2, [r7, #20]
 800583a:	b2d2      	uxtb	r2, r2
 800583c:	701a      	strb	r2, [r3, #0]

         //Propagate the carry upwards
         temp >>= 8;
 800583e:	697b      	ldr	r3, [r7, #20]
 8005840:	0a1b      	lsrs	r3, r3, #8
 8005842:	617b      	str	r3, [r7, #20]
      for(i = n; i < (2 * n); i++)
 8005844:	69fb      	ldr	r3, [r7, #28]
 8005846:	3301      	adds	r3, #1
 8005848:	61fb      	str	r3, [r7, #28]
 800584a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800584c:	005b      	lsls	r3, r3, #1
 800584e:	69fa      	ldr	r2, [r7, #28]
 8005850:	429a      	cmp	r2, r3
 8005852:	d3ce      	bcc.n	80057f2 <ed25519MulInt+0x80>
      }
   }
}
 8005854:	bf00      	nop
 8005856:	3724      	adds	r7, #36	; 0x24
 8005858:	46bd      	mov	sp, r7
 800585a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800585e:	4770      	bx	lr

08005860 <ed25519CopyInt>:
 * @param[in] b Pointer to the source integer
 * @param[in] n Size of the integers, in bytes
 **/

void ed25519CopyInt(uint8_t *a, const uint8_t *b, uint_t n)
{
 8005860:	b480      	push	{r7}
 8005862:	b087      	sub	sp, #28
 8005864:	af00      	add	r7, sp, #0
 8005866:	60f8      	str	r0, [r7, #12]
 8005868:	60b9      	str	r1, [r7, #8]
 800586a:	607a      	str	r2, [r7, #4]
   uint_t i;

   //Copy the value of the integer
   for(i = 0; i < n; i++)
 800586c:	2300      	movs	r3, #0
 800586e:	617b      	str	r3, [r7, #20]
 8005870:	e00a      	b.n	8005888 <ed25519CopyInt+0x28>
   {
      a[i] = b[i];
 8005872:	68ba      	ldr	r2, [r7, #8]
 8005874:	697b      	ldr	r3, [r7, #20]
 8005876:	441a      	add	r2, r3
 8005878:	68f9      	ldr	r1, [r7, #12]
 800587a:	697b      	ldr	r3, [r7, #20]
 800587c:	440b      	add	r3, r1
 800587e:	7812      	ldrb	r2, [r2, #0]
 8005880:	701a      	strb	r2, [r3, #0]
   for(i = 0; i < n; i++)
 8005882:	697b      	ldr	r3, [r7, #20]
 8005884:	3301      	adds	r3, #1
 8005886:	617b      	str	r3, [r7, #20]
 8005888:	697a      	ldr	r2, [r7, #20]
 800588a:	687b      	ldr	r3, [r7, #4]
 800588c:	429a      	cmp	r2, r3
 800588e:	d3f0      	bcc.n	8005872 <ed25519CopyInt+0x12>
   }
}
 8005890:	bf00      	nop
 8005892:	bf00      	nop
 8005894:	371c      	adds	r7, #28
 8005896:	46bd      	mov	sp, r7
 8005898:	f85d 7b04 	ldr.w	r7, [sp], #4
 800589c:	4770      	bx	lr

0800589e <ed25519SelectInt>:
 * @param[in] n Size of the integers, in bytes
 **/

void ed25519SelectInt(uint8_t *r, const uint8_t *a, const uint8_t *b,
   uint8_t c, uint_t n)
{
 800589e:	b480      	push	{r7}
 80058a0:	b087      	sub	sp, #28
 80058a2:	af00      	add	r7, sp, #0
 80058a4:	60f8      	str	r0, [r7, #12]
 80058a6:	60b9      	str	r1, [r7, #8]
 80058a8:	607a      	str	r2, [r7, #4]
 80058aa:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   uint8_t mask;

   //The mask is the all-1 or all-0 word
   mask = c - 1;
 80058ac:	78fb      	ldrb	r3, [r7, #3]
 80058ae:	3b01      	subs	r3, #1
 80058b0:	74fb      	strb	r3, [r7, #19]

   //Select between A and B
   for(i = 0; i < n; i++)
 80058b2:	2300      	movs	r3, #0
 80058b4:	617b      	str	r3, [r7, #20]
 80058b6:	e01c      	b.n	80058f2 <ed25519SelectInt+0x54>
   {
      //Constant time implementation
      r[i] = (a[i] & mask) | (b[i] & ~mask);
 80058b8:	68ba      	ldr	r2, [r7, #8]
 80058ba:	697b      	ldr	r3, [r7, #20]
 80058bc:	4413      	add	r3, r2
 80058be:	781a      	ldrb	r2, [r3, #0]
 80058c0:	7cfb      	ldrb	r3, [r7, #19]
 80058c2:	4013      	ands	r3, r2
 80058c4:	b2db      	uxtb	r3, r3
 80058c6:	b25a      	sxtb	r2, r3
 80058c8:	6879      	ldr	r1, [r7, #4]
 80058ca:	697b      	ldr	r3, [r7, #20]
 80058cc:	440b      	add	r3, r1
 80058ce:	781b      	ldrb	r3, [r3, #0]
 80058d0:	b259      	sxtb	r1, r3
 80058d2:	f997 3013 	ldrsb.w	r3, [r7, #19]
 80058d6:	43db      	mvns	r3, r3
 80058d8:	b25b      	sxtb	r3, r3
 80058da:	400b      	ands	r3, r1
 80058dc:	b25b      	sxtb	r3, r3
 80058de:	4313      	orrs	r3, r2
 80058e0:	b259      	sxtb	r1, r3
 80058e2:	68fa      	ldr	r2, [r7, #12]
 80058e4:	697b      	ldr	r3, [r7, #20]
 80058e6:	4413      	add	r3, r2
 80058e8:	b2ca      	uxtb	r2, r1
 80058ea:	701a      	strb	r2, [r3, #0]
   for(i = 0; i < n; i++)
 80058ec:	697b      	ldr	r3, [r7, #20]
 80058ee:	3301      	adds	r3, #1
 80058f0:	617b      	str	r3, [r7, #20]
 80058f2:	697a      	ldr	r2, [r7, #20]
 80058f4:	6a3b      	ldr	r3, [r7, #32]
 80058f6:	429a      	cmp	r2, r3
 80058f8:	d3de      	bcc.n	80058b8 <ed25519SelectInt+0x1a>
   }
}
 80058fa:	bf00      	nop
 80058fc:	bf00      	nop
 80058fe:	371c      	adds	r7, #28
 8005900:	46bd      	mov	sp, r7
 8005902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005906:	4770      	bx	lr

08005908 <ed25519CompInt>:
 * @param[in] n Size of the integers, in bytes
 * @return The function returns 0 if the A = B, else 1
 **/

uint8_t ed25519CompInt(const uint8_t *a, const uint8_t *b, uint_t n)
{
 8005908:	b480      	push	{r7}
 800590a:	b087      	sub	sp, #28
 800590c:	af00      	add	r7, sp, #0
 800590e:	60f8      	str	r0, [r7, #12]
 8005910:	60b9      	str	r1, [r7, #8]
 8005912:	607a      	str	r2, [r7, #4]
   uint_t i;
   uint8_t mask;

   //Initialize mask
   mask = 0;
 8005914:	2300      	movs	r3, #0
 8005916:	74fb      	strb	r3, [r7, #19]

   //Compare A and B
   for(i = 0; i < n; i++)
 8005918:	2300      	movs	r3, #0
 800591a:	617b      	str	r3, [r7, #20]
 800591c:	e00f      	b.n	800593e <ed25519CompInt+0x36>
   {
      //Constant time implementation
      mask |= a[i] ^ b[i];
 800591e:	68fa      	ldr	r2, [r7, #12]
 8005920:	697b      	ldr	r3, [r7, #20]
 8005922:	4413      	add	r3, r2
 8005924:	781a      	ldrb	r2, [r3, #0]
 8005926:	68b9      	ldr	r1, [r7, #8]
 8005928:	697b      	ldr	r3, [r7, #20]
 800592a:	440b      	add	r3, r1
 800592c:	781b      	ldrb	r3, [r3, #0]
 800592e:	4053      	eors	r3, r2
 8005930:	b2da      	uxtb	r2, r3
 8005932:	7cfb      	ldrb	r3, [r7, #19]
 8005934:	4313      	orrs	r3, r2
 8005936:	74fb      	strb	r3, [r7, #19]
   for(i = 0; i < n; i++)
 8005938:	697b      	ldr	r3, [r7, #20]
 800593a:	3301      	adds	r3, #1
 800593c:	617b      	str	r3, [r7, #20]
 800593e:	697a      	ldr	r2, [r7, #20]
 8005940:	687b      	ldr	r3, [r7, #4]
 8005942:	429a      	cmp	r2, r3
 8005944:	d3eb      	bcc.n	800591e <ed25519CompInt+0x16>
   }

   //Return 0 if A = B, else 1
   return ((uint8_t) (mask | (~mask + 1))) >> 7;
 8005946:	7cfb      	ldrb	r3, [r7, #19]
 8005948:	425b      	negs	r3, r3
 800594a:	b2db      	uxtb	r3, r3
 800594c:	b25a      	sxtb	r2, r3
 800594e:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8005952:	4313      	orrs	r3, r2
 8005954:	b25b      	sxtb	r3, r3
 8005956:	b2db      	uxtb	r3, r3
 8005958:	09db      	lsrs	r3, r3, #7
 800595a:	b2db      	uxtb	r3, r3
}
 800595c:	4618      	mov	r0, r3
 800595e:	371c      	adds	r7, #28
 8005960:	46bd      	mov	sp, r7
 8005962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005966:	4770      	bx	lr

08005968 <ed448GeneratePrivateKey>:
 * @return Error code
 **/

error_t ed448GeneratePrivateKey(const PrngAlgo *prngAlgo, void *prngContext,
   uint8_t *privateKey)
{
 8005968:	b580      	push	{r7, lr}
 800596a:	b086      	sub	sp, #24
 800596c:	af00      	add	r7, sp, #0
 800596e:	60f8      	str	r0, [r7, #12]
 8005970:	60b9      	str	r1, [r7, #8]
 8005972:	607a      	str	r2, [r7, #4]
   error_t error;

   //Check parameters
   if(prngAlgo == NULL || prngContext == NULL || privateKey == NULL )
 8005974:	68fb      	ldr	r3, [r7, #12]
 8005976:	2b00      	cmp	r3, #0
 8005978:	d005      	beq.n	8005986 <ed448GeneratePrivateKey+0x1e>
 800597a:	68bb      	ldr	r3, [r7, #8]
 800597c:	2b00      	cmp	r3, #0
 800597e:	d002      	beq.n	8005986 <ed448GeneratePrivateKey+0x1e>
 8005980:	687b      	ldr	r3, [r7, #4]
 8005982:	2b00      	cmp	r3, #0
 8005984:	d101      	bne.n	800598a <ed448GeneratePrivateKey+0x22>
      return ERROR_INVALID_PARAMETER;
 8005986:	2302      	movs	r3, #2
 8005988:	e008      	b.n	800599c <ed448GeneratePrivateKey+0x34>

   //The private key is 57 octets of cryptographically secure random data
   error = prngAlgo->read(prngContext, privateKey, ED448_PRIVATE_KEY_LEN);
 800598a:	68fb      	ldr	r3, [r7, #12]
 800598c:	695b      	ldr	r3, [r3, #20]
 800598e:	2239      	movs	r2, #57	; 0x39
 8005990:	6879      	ldr	r1, [r7, #4]
 8005992:	68b8      	ldr	r0, [r7, #8]
 8005994:	4798      	blx	r3
 8005996:	4603      	mov	r3, r0
 8005998:	82fb      	strh	r3, [r7, #22]

   //Return status code
   return error;
 800599a:	8afb      	ldrh	r3, [r7, #22]
}
 800599c:	4618      	mov	r0, r3
 800599e:	3718      	adds	r7, #24
 80059a0:	46bd      	mov	sp, r7
 80059a2:	bd80      	pop	{r7, pc}

080059a4 <ed448GeneratePublicKey>:
 * @param[out] publicKey EdDSA public key (57 bytes)
 * @return Error code
 **/

error_t ed448GeneratePublicKey(const uint8_t *privateKey, uint8_t *publicKey)
{
 80059a4:	b580      	push	{r7, lr}
 80059a6:	b092      	sub	sp, #72	; 0x48
 80059a8:	af00      	add	r7, sp, #0
 80059aa:	6078      	str	r0, [r7, #4]
 80059ac:	6039      	str	r1, [r7, #0]
   uint8_t s[57];
   Ed448State *state;

   //Check parameters
   if(privateKey == NULL || publicKey == NULL)
 80059ae:	687b      	ldr	r3, [r7, #4]
 80059b0:	2b00      	cmp	r3, #0
 80059b2:	d002      	beq.n	80059ba <ed448GeneratePublicKey+0x16>
 80059b4:	683b      	ldr	r3, [r7, #0]
 80059b6:	2b00      	cmp	r3, #0
 80059b8:	d101      	bne.n	80059be <ed448GeneratePublicKey+0x1a>
      return ERROR_INVALID_PARAMETER;
 80059ba:	2302      	movs	r3, #2
 80059bc:	e049      	b.n	8005a52 <ed448GeneratePublicKey+0xae>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed448State));
 80059be:	f44f 60f7 	mov.w	r0, #1976	; 0x7b8
 80059c2:	f006 f81d 	bl	800ba00 <osAllocMem>
 80059c6:	6478      	str	r0, [r7, #68]	; 0x44
   //Failed to allocate memory?
   if(state == NULL)
 80059c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059ca:	2b00      	cmp	r3, #0
 80059cc:	d101      	bne.n	80059d2 <ed448GeneratePublicKey+0x2e>
      return ERROR_OUT_OF_MEMORY;
 80059ce:	2364      	movs	r3, #100	; 0x64
 80059d0:	e03f      	b.n	8005a52 <ed448GeneratePublicKey+0xae>

   //Hash the 57-byte private key using SHAKE256(x, 57)
   shakeInit(&state->shakeContext, 256);
 80059d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059d4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80059d8:	4618      	mov	r0, r3
 80059da:	f002 fdfb 	bl	80085d4 <shakeInit>
   shakeAbsorb(&state->shakeContext, privateKey, ED448_PRIVATE_KEY_LEN);
 80059de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059e0:	2239      	movs	r2, #57	; 0x39
 80059e2:	6879      	ldr	r1, [r7, #4]
 80059e4:	4618      	mov	r0, r3
 80059e6:	f002 fe12 	bl	800860e <shakeAbsorb>
   shakeFinal(&state->shakeContext);
 80059ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059ec:	4618      	mov	r0, r3
 80059ee:	f002 fe1e 	bl	800862e <shakeFinal>

   //Only the lower 57 bytes are used for generating the public key. Interpret
   //the buffer as the little-endian integer, forming a secret scalar s
   shakeSqueeze(&state->shakeContext, s, 57);
 80059f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059f4:	f107 0108 	add.w	r1, r7, #8
 80059f8:	2239      	movs	r2, #57	; 0x39
 80059fa:	4618      	mov	r0, r3
 80059fc:	f002 fe24 	bl	8008648 <shakeSqueeze>

   //The two least significant bits of the first octet are cleared, all eight
   //bits the last octet are cleared, and the highest bit of the second to
   //last octet is set
   s[0] &= 0xFC;
 8005a00:	7a3b      	ldrb	r3, [r7, #8]
 8005a02:	f023 0303 	bic.w	r3, r3, #3
 8005a06:	b2db      	uxtb	r3, r3
 8005a08:	723b      	strb	r3, [r7, #8]
   s[56] = 0x00;
 8005a0a:	2300      	movs	r3, #0
 8005a0c:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
   s[55] |= 0x80;
 8005a10:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8005a14:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005a18:	b2db      	uxtb	r3, r3
 8005a1a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

   //Perform a fixed-base scalar multiplication s * B
   ed448Mul(state, &state->sb, s, &ED448_B);
 8005a1e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005a20:	f503 6187 	add.w	r1, r3, #1080	; 0x438
 8005a24:	f107 0208 	add.w	r2, r7, #8
 8005a28:	4b0c      	ldr	r3, [pc, #48]	; (8005a5c <ed448GeneratePublicKey+0xb8>)
 8005a2a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005a2c:	f000 fb08 	bl	8006040 <ed448Mul>
   //The public key A is the encoding of the point s * B
   ed448Encode(&state->sb, publicKey);
 8005a30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005a32:	f503 6387 	add.w	r3, r3, #1080	; 0x438
 8005a36:	6839      	ldr	r1, [r7, #0]
 8005a38:	4618      	mov	r0, r3
 8005a3a:	f000 fd10 	bl	800645e <ed448Encode>

   //Erase working state
   osMemset(state, 0, sizeof(Ed448State));
 8005a3e:	f44f 62f7 	mov.w	r2, #1976	; 0x7b8
 8005a42:	2100      	movs	r1, #0
 8005a44:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005a46:	f008 fd4d 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8005a4a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005a4c:	f005 ffe6 	bl	800ba1c <osFreeMem>

   //Successful processing
   return NO_ERROR;
 8005a50:	2300      	movs	r3, #0
}
 8005a52:	4618      	mov	r0, r3
 8005a54:	3748      	adds	r7, #72	; 0x48
 8005a56:	46bd      	mov	sp, r7
 8005a58:	bd80      	pop	{r7, pc}
 8005a5a:	bf00      	nop
 8005a5c:	0800f2a0 	.word	0x0800f2a0

08005a60 <ed448GenerateSignature>:
 **/

error_t ed448GenerateSignature(const uint8_t *privateKey,
   const uint8_t *publicKey, const void *message, size_t messageLen,
   const void *context, uint8_t contextLen, uint8_t flag, uint8_t *signature)
{
 8005a60:	b580      	push	{r7, lr}
 8005a62:	b08e      	sub	sp, #56	; 0x38
 8005a64:	af04      	add	r7, sp, #16
 8005a66:	60f8      	str	r0, [r7, #12]
 8005a68:	60b9      	str	r1, [r7, #8]
 8005a6a:	607a      	str	r2, [r7, #4]
 8005a6c:	603b      	str	r3, [r7, #0]
   error_t error;
   EddsaMessageChunk messageChunks[2];

   //The message fits in a single chunk
   messageChunks[0].buffer = message;
 8005a6e:	687b      	ldr	r3, [r7, #4]
 8005a70:	617b      	str	r3, [r7, #20]
   messageChunks[0].length = messageLen;
 8005a72:	683b      	ldr	r3, [r7, #0]
 8005a74:	61bb      	str	r3, [r7, #24]
   messageChunks[1].buffer = NULL;
 8005a76:	2300      	movs	r3, #0
 8005a78:	61fb      	str	r3, [r7, #28]
   messageChunks[1].length = 0;
 8005a7a:	2300      	movs	r3, #0
 8005a7c:	623b      	str	r3, [r7, #32]

   //Ed448 signature generation
   error = ed448GenerateSignatureEx(privateKey, publicKey, messageChunks,
 8005a7e:	f107 0214 	add.w	r2, r7, #20
 8005a82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005a84:	9302      	str	r3, [sp, #8]
 8005a86:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8005a8a:	9301      	str	r3, [sp, #4]
 8005a8c:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8005a90:	9300      	str	r3, [sp, #0]
 8005a92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005a94:	68b9      	ldr	r1, [r7, #8]
 8005a96:	68f8      	ldr	r0, [r7, #12]
 8005a98:	f000 f808 	bl	8005aac <ed448GenerateSignatureEx>
 8005a9c:	4603      	mov	r3, r0
 8005a9e:	84fb      	strh	r3, [r7, #38]	; 0x26
      context, contextLen, flag, signature);

   //Return status code
   return error;
 8005aa0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 8005aa2:	4618      	mov	r0, r3
 8005aa4:	3728      	adds	r7, #40	; 0x28
 8005aa6:	46bd      	mov	sp, r7
 8005aa8:	bd80      	pop	{r7, pc}
	...

08005aac <ed448GenerateSignatureEx>:
 **/

error_t ed448GenerateSignatureEx(const uint8_t *privateKey,
   const uint8_t *publicKey, const EddsaMessageChunk *messageChunks,
   const void *context, uint8_t contextLen, uint8_t flag, uint8_t *signature)
{
 8005aac:	b590      	push	{r4, r7, lr}
 8005aae:	b08b      	sub	sp, #44	; 0x2c
 8005ab0:	af02      	add	r7, sp, #8
 8005ab2:	60f8      	str	r0, [r7, #12]
 8005ab4:	60b9      	str	r1, [r7, #8]
 8005ab6:	607a      	str	r2, [r7, #4]
 8005ab8:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint8_t c;
   Ed448State *state;

   //Check parameters
   if(privateKey == NULL || signature == NULL)
 8005aba:	68fb      	ldr	r3, [r7, #12]
 8005abc:	2b00      	cmp	r3, #0
 8005abe:	d002      	beq.n	8005ac6 <ed448GenerateSignatureEx+0x1a>
 8005ac0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005ac2:	2b00      	cmp	r3, #0
 8005ac4:	d101      	bne.n	8005aca <ed448GenerateSignatureEx+0x1e>
      return ERROR_INVALID_PARAMETER;
 8005ac6:	2302      	movs	r3, #2
 8005ac8:	e17d      	b.n	8005dc6 <ed448GenerateSignatureEx+0x31a>
   if(messageChunks == NULL)
 8005aca:	687b      	ldr	r3, [r7, #4]
 8005acc:	2b00      	cmp	r3, #0
 8005ace:	d101      	bne.n	8005ad4 <ed448GenerateSignatureEx+0x28>
      return ERROR_INVALID_PARAMETER;
 8005ad0:	2302      	movs	r3, #2
 8005ad2:	e178      	b.n	8005dc6 <ed448GenerateSignatureEx+0x31a>
   if(context == NULL && contextLen != 0)
 8005ad4:	683b      	ldr	r3, [r7, #0]
 8005ad6:	2b00      	cmp	r3, #0
 8005ad8:	d105      	bne.n	8005ae6 <ed448GenerateSignatureEx+0x3a>
 8005ada:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8005ade:	2b00      	cmp	r3, #0
 8005ae0:	d001      	beq.n	8005ae6 <ed448GenerateSignatureEx+0x3a>
      return ERROR_INVALID_PARAMETER;
 8005ae2:	2302      	movs	r3, #2
 8005ae4:	e16f      	b.n	8005dc6 <ed448GenerateSignatureEx+0x31a>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed448State));
 8005ae6:	f44f 60f7 	mov.w	r0, #1976	; 0x7b8
 8005aea:	f005 ff89 	bl	800ba00 <osAllocMem>
 8005aee:	61b8      	str	r0, [r7, #24]
   //Failed to allocate memory?
   if(state == NULL)
 8005af0:	69bb      	ldr	r3, [r7, #24]
 8005af2:	2b00      	cmp	r3, #0
 8005af4:	d101      	bne.n	8005afa <ed448GenerateSignatureEx+0x4e>
      return ERROR_OUT_OF_MEMORY;
 8005af6:	2364      	movs	r3, #100	; 0x64
 8005af8:	e165      	b.n	8005dc6 <ed448GenerateSignatureEx+0x31a>

   //Hash the private key, 57 octets, using SHAKE256(x, 114). Let h denote
   //the resulting digest
   shakeInit(&state->shakeContext, 256);
 8005afa:	69bb      	ldr	r3, [r7, #24]
 8005afc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8005b00:	4618      	mov	r0, r3
 8005b02:	f002 fd67 	bl	80085d4 <shakeInit>
   shakeAbsorb(&state->shakeContext, privateKey, ED448_PRIVATE_KEY_LEN);
 8005b06:	69bb      	ldr	r3, [r7, #24]
 8005b08:	2239      	movs	r2, #57	; 0x39
 8005b0a:	68f9      	ldr	r1, [r7, #12]
 8005b0c:	4618      	mov	r0, r3
 8005b0e:	f002 fd7e 	bl	800860e <shakeAbsorb>
   shakeFinal(&state->shakeContext);
 8005b12:	69bb      	ldr	r3, [r7, #24]
 8005b14:	4618      	mov	r0, r3
 8005b16:	f002 fd8a 	bl	800862e <shakeFinal>

   //Construct the secret scalar s from the first half of the digest
   shakeSqueeze(&state->shakeContext, state->s, 57);
 8005b1a:	69b8      	ldr	r0, [r7, #24]
 8005b1c:	69bb      	ldr	r3, [r7, #24]
 8005b1e:	f503 731d 	add.w	r3, r3, #628	; 0x274
 8005b22:	2239      	movs	r2, #57	; 0x39
 8005b24:	4619      	mov	r1, r3
 8005b26:	f002 fd8f 	bl	8008648 <shakeSqueeze>

   //The two least significant bits of the first octet are cleared, all eight
   //bits the last octet are cleared, and the highest bit of the second to
   //last octet is set
   state->s[0] &= 0xFC;
 8005b2a:	69bb      	ldr	r3, [r7, #24]
 8005b2c:	f893 3274 	ldrb.w	r3, [r3, #628]	; 0x274
 8005b30:	f023 0303 	bic.w	r3, r3, #3
 8005b34:	b2da      	uxtb	r2, r3
 8005b36:	69bb      	ldr	r3, [r7, #24]
 8005b38:	f883 2274 	strb.w	r2, [r3, #628]	; 0x274
   state->s[56] = 0x00;
 8005b3c:	69bb      	ldr	r3, [r7, #24]
 8005b3e:	2200      	movs	r2, #0
 8005b40:	f883 22ac 	strb.w	r2, [r3, #684]	; 0x2ac
   state->s[55] |= 0x80;
 8005b44:	69bb      	ldr	r3, [r7, #24]
 8005b46:	f893 32ab 	ldrb.w	r3, [r3, #683]	; 0x2ab
 8005b4a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005b4e:	b2da      	uxtb	r2, r3
 8005b50:	69bb      	ldr	r3, [r7, #24]
 8005b52:	f883 22ab 	strb.w	r2, [r3, #683]	; 0x2ab

   //The public key is optional
   if(publicKey == NULL)
 8005b56:	68bb      	ldr	r3, [r7, #8]
 8005b58:	2b00      	cmp	r3, #0
 8005b5a:	d117      	bne.n	8005b8c <ed448GenerateSignatureEx+0xe0>
   {
      //Perform a fixed-base scalar multiplication s * B
      ed448Mul(state, &state->sb, state->s, &ED448_B);
 8005b5c:	69bb      	ldr	r3, [r7, #24]
 8005b5e:	f503 6187 	add.w	r1, r3, #1080	; 0x438
 8005b62:	69bb      	ldr	r3, [r7, #24]
 8005b64:	f503 721d 	add.w	r2, r3, #628	; 0x274
 8005b68:	4b99      	ldr	r3, [pc, #612]	; (8005dd0 <ed448GenerateSignatureEx+0x324>)
 8005b6a:	69b8      	ldr	r0, [r7, #24]
 8005b6c:	f000 fa68 	bl	8006040 <ed448Mul>
      //The public key A is the encoding of the point s * B
      ed448Encode(&state->sb, state->t);
 8005b70:	69bb      	ldr	r3, [r7, #24]
 8005b72:	f503 6287 	add.w	r2, r3, #1080	; 0x438
 8005b76:	69bb      	ldr	r3, [r7, #24]
 8005b78:	f203 23ad 	addw	r3, r3, #685	; 0x2ad
 8005b7c:	4619      	mov	r1, r3
 8005b7e:	4610      	mov	r0, r2
 8005b80:	f000 fc6d 	bl	800645e <ed448Encode>
      //Point to the resulting public key
      publicKey = state->t;
 8005b84:	69bb      	ldr	r3, [r7, #24]
 8005b86:	f203 23ad 	addw	r3, r3, #685	; 0x2ad
 8005b8a:	60bb      	str	r3, [r7, #8]
   }

   //Let prefix denote the second half of the hash digest
   shakeSqueeze(&state->shakeContext, state->p, 57);
 8005b8c:	69b8      	ldr	r0, [r7, #24]
 8005b8e:	69bb      	ldr	r3, [r7, #24]
 8005b90:	f203 2302 	addw	r3, r3, #514	; 0x202
 8005b94:	2239      	movs	r2, #57	; 0x39
 8005b96:	4619      	mov	r1, r3
 8005b98:	f002 fd56 	bl	8008648 <shakeSqueeze>

   //Initialize SHAKE256 context
   shakeInit(&state->shakeContext, 256);
 8005b9c:	69bb      	ldr	r3, [r7, #24]
 8005b9e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8005ba2:	4618      	mov	r0, r3
 8005ba4:	f002 fd16 	bl	80085d4 <shakeInit>

   //Absorb dom4(F, C) || prefix
   shakeAbsorb(&state->shakeContext, "SigEd448", 8);
 8005ba8:	69bb      	ldr	r3, [r7, #24]
 8005baa:	2208      	movs	r2, #8
 8005bac:	4989      	ldr	r1, [pc, #548]	; (8005dd4 <ed448GenerateSignatureEx+0x328>)
 8005bae:	4618      	mov	r0, r3
 8005bb0:	f002 fd2d 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &flag, sizeof(uint8_t));
 8005bb4:	69bb      	ldr	r3, [r7, #24]
 8005bb6:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8005bba:	2201      	movs	r2, #1
 8005bbc:	4618      	mov	r0, r3
 8005bbe:	f002 fd26 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &contextLen, sizeof(uint8_t));
 8005bc2:	69bb      	ldr	r3, [r7, #24]
 8005bc4:	2201      	movs	r2, #1
 8005bc6:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8005bca:	4618      	mov	r0, r3
 8005bcc:	f002 fd1f 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, context, contextLen);
 8005bd0:	69bb      	ldr	r3, [r7, #24]
 8005bd2:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8005bd6:	6839      	ldr	r1, [r7, #0]
 8005bd8:	4618      	mov	r0, r3
 8005bda:	f002 fd18 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, state->p, 57);
 8005bde:	69b8      	ldr	r0, [r7, #24]
 8005be0:	69bb      	ldr	r3, [r7, #24]
 8005be2:	f203 2302 	addw	r3, r3, #514	; 0x202
 8005be6:	2239      	movs	r2, #57	; 0x39
 8005be8:	4619      	mov	r1, r3
 8005bea:	f002 fd10 	bl	800860e <shakeAbsorb>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005bee:	2300      	movs	r3, #0
 8005bf0:	61fb      	str	r3, [r7, #28]
 8005bf2:	e010      	b.n	8005c16 <ed448GenerateSignatureEx+0x16a>
   {
      //Absorb current chunk
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005bf4:	69b8      	ldr	r0, [r7, #24]
 8005bf6:	69fb      	ldr	r3, [r7, #28]
 8005bf8:	00db      	lsls	r3, r3, #3
 8005bfa:	687a      	ldr	r2, [r7, #4]
 8005bfc:	4413      	add	r3, r2
 8005bfe:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8005c00:	69fb      	ldr	r3, [r7, #28]
 8005c02:	00db      	lsls	r3, r3, #3
 8005c04:	687a      	ldr	r2, [r7, #4]
 8005c06:	4413      	add	r3, r2
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005c08:	685b      	ldr	r3, [r3, #4]
 8005c0a:	461a      	mov	r2, r3
 8005c0c:	f002 fcff 	bl	800860e <shakeAbsorb>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005c10:	69fb      	ldr	r3, [r7, #28]
 8005c12:	3301      	adds	r3, #1
 8005c14:	61fb      	str	r3, [r7, #28]
 8005c16:	69fb      	ldr	r3, [r7, #28]
 8005c18:	00db      	lsls	r3, r3, #3
 8005c1a:	687a      	ldr	r2, [r7, #4]
 8005c1c:	4413      	add	r3, r2
 8005c1e:	681b      	ldr	r3, [r3, #0]
 8005c20:	2b00      	cmp	r3, #0
 8005c22:	d1e7      	bne.n	8005bf4 <ed448GenerateSignatureEx+0x148>
   }

   //Compute SHAKE256(dom4(F, C) || prefix || PH(M), 114)
   shakeFinal(&state->shakeContext);
 8005c24:	69bb      	ldr	r3, [r7, #24]
 8005c26:	4618      	mov	r0, r3
 8005c28:	f002 fd01 	bl	800862e <shakeFinal>
   shakeSqueeze(&state->shakeContext, state->k, 114);
 8005c2c:	69b8      	ldr	r0, [r7, #24]
 8005c2e:	69bb      	ldr	r3, [r7, #24]
 8005c30:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005c34:	2272      	movs	r2, #114	; 0x72
 8005c36:	4619      	mov	r1, r3
 8005c38:	f002 fd06 	bl	8008648 <shakeSqueeze>

   //Reduce the 114-octet digest as a little-endian integer r
   ed448RedInt(state->r, state->k);
 8005c3c:	69bb      	ldr	r3, [r7, #24]
 8005c3e:	f203 223b 	addw	r2, r3, #571	; 0x23b
 8005c42:	69bb      	ldr	r3, [r7, #24]
 8005c44:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005c48:	4619      	mov	r1, r3
 8005c4a:	4610      	mov	r0, r2
 8005c4c:	f000 fd60 	bl	8006710 <ed448RedInt>
   //Compute the point r * B
   ed448Mul(state, &state->rb, state->r, &ED448_B);
 8005c50:	69bb      	ldr	r3, [r7, #24]
 8005c52:	f503 7164 	add.w	r1, r3, #912	; 0x390
 8005c56:	69bb      	ldr	r3, [r7, #24]
 8005c58:	f203 223b 	addw	r2, r3, #571	; 0x23b
 8005c5c:	4b5c      	ldr	r3, [pc, #368]	; (8005dd0 <ed448GenerateSignatureEx+0x324>)
 8005c5e:	69b8      	ldr	r0, [r7, #24]
 8005c60:	f000 f9ee 	bl	8006040 <ed448Mul>
   //Let the string R be the encoding of this point
   ed448Encode(&state->rb, signature);
 8005c64:	69bb      	ldr	r3, [r7, #24]
 8005c66:	f503 7364 	add.w	r3, r3, #912	; 0x390
 8005c6a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8005c6c:	4618      	mov	r0, r3
 8005c6e:	f000 fbf6 	bl	800645e <ed448Encode>

   //Initialize SHAKE256 context
   shakeInit(&state->shakeContext, 256);
 8005c72:	69bb      	ldr	r3, [r7, #24]
 8005c74:	f44f 7180 	mov.w	r1, #256	; 0x100
 8005c78:	4618      	mov	r0, r3
 8005c7a:	f002 fcab 	bl	80085d4 <shakeInit>

   //Absorb dom4(F, C) || R || A
   shakeAbsorb(&state->shakeContext, "SigEd448", 8);
 8005c7e:	69bb      	ldr	r3, [r7, #24]
 8005c80:	2208      	movs	r2, #8
 8005c82:	4954      	ldr	r1, [pc, #336]	; (8005dd4 <ed448GenerateSignatureEx+0x328>)
 8005c84:	4618      	mov	r0, r3
 8005c86:	f002 fcc2 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &flag, sizeof(uint8_t));
 8005c8a:	69bb      	ldr	r3, [r7, #24]
 8005c8c:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8005c90:	2201      	movs	r2, #1
 8005c92:	4618      	mov	r0, r3
 8005c94:	f002 fcbb 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &contextLen, sizeof(uint8_t));
 8005c98:	69bb      	ldr	r3, [r7, #24]
 8005c9a:	2201      	movs	r2, #1
 8005c9c:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8005ca0:	4618      	mov	r0, r3
 8005ca2:	f002 fcb4 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, context, contextLen);
 8005ca6:	69bb      	ldr	r3, [r7, #24]
 8005ca8:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8005cac:	6839      	ldr	r1, [r7, #0]
 8005cae:	4618      	mov	r0, r3
 8005cb0:	f002 fcad 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, signature, ED448_SIGNATURE_LEN / 2);
 8005cb4:	69bb      	ldr	r3, [r7, #24]
 8005cb6:	2239      	movs	r2, #57	; 0x39
 8005cb8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8005cba:	4618      	mov	r0, r3
 8005cbc:	f002 fca7 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, publicKey, ED448_PUBLIC_KEY_LEN);
 8005cc0:	69bb      	ldr	r3, [r7, #24]
 8005cc2:	2239      	movs	r2, #57	; 0x39
 8005cc4:	68b9      	ldr	r1, [r7, #8]
 8005cc6:	4618      	mov	r0, r3
 8005cc8:	f002 fca1 	bl	800860e <shakeAbsorb>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005ccc:	2300      	movs	r3, #0
 8005cce:	61fb      	str	r3, [r7, #28]
 8005cd0:	e010      	b.n	8005cf4 <ed448GenerateSignatureEx+0x248>
   {
      //Absorb current chunk
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005cd2:	69b8      	ldr	r0, [r7, #24]
 8005cd4:	69fb      	ldr	r3, [r7, #28]
 8005cd6:	00db      	lsls	r3, r3, #3
 8005cd8:	687a      	ldr	r2, [r7, #4]
 8005cda:	4413      	add	r3, r2
 8005cdc:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8005cde:	69fb      	ldr	r3, [r7, #28]
 8005ce0:	00db      	lsls	r3, r3, #3
 8005ce2:	687a      	ldr	r2, [r7, #4]
 8005ce4:	4413      	add	r3, r2
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005ce6:	685b      	ldr	r3, [r3, #4]
 8005ce8:	461a      	mov	r2, r3
 8005cea:	f002 fc90 	bl	800860e <shakeAbsorb>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005cee:	69fb      	ldr	r3, [r7, #28]
 8005cf0:	3301      	adds	r3, #1
 8005cf2:	61fb      	str	r3, [r7, #28]
 8005cf4:	69fb      	ldr	r3, [r7, #28]
 8005cf6:	00db      	lsls	r3, r3, #3
 8005cf8:	687a      	ldr	r2, [r7, #4]
 8005cfa:	4413      	add	r3, r2
 8005cfc:	681b      	ldr	r3, [r3, #0]
 8005cfe:	2b00      	cmp	r3, #0
 8005d00:	d1e7      	bne.n	8005cd2 <ed448GenerateSignatureEx+0x226>
   }

   //Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114) and interpret the
   //114-octet digest as a little-endian integer k
   shakeFinal(&state->shakeContext);
 8005d02:	69bb      	ldr	r3, [r7, #24]
 8005d04:	4618      	mov	r0, r3
 8005d06:	f002 fc92 	bl	800862e <shakeFinal>
   shakeSqueeze(&state->shakeContext, state->k, 114);
 8005d0a:	69b8      	ldr	r0, [r7, #24]
 8005d0c:	69bb      	ldr	r3, [r7, #24]
 8005d0e:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005d12:	2272      	movs	r2, #114	; 0x72
 8005d14:	4619      	mov	r1, r3
 8005d16:	f002 fc97 	bl	8008648 <shakeSqueeze>

   //Compute S = (r + k * s) mod L. For efficiency, reduce k modulo L first
   ed448RedInt(state->p, state->k);
 8005d1a:	69bb      	ldr	r3, [r7, #24]
 8005d1c:	f203 2202 	addw	r2, r3, #514	; 0x202
 8005d20:	69bb      	ldr	r3, [r7, #24]
 8005d22:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005d26:	4619      	mov	r1, r3
 8005d28:	4610      	mov	r0, r2
 8005d2a:	f000 fcf1 	bl	8006710 <ed448RedInt>
   ed448MulInt(state->k, state->k + 57, state->p, state->s, 57);
 8005d2e:	69bb      	ldr	r3, [r7, #24]
 8005d30:	f503 70c8 	add.w	r0, r3, #400	; 0x190
 8005d34:	69bb      	ldr	r3, [r7, #24]
 8005d36:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005d3a:	f103 0139 	add.w	r1, r3, #57	; 0x39
 8005d3e:	69bb      	ldr	r3, [r7, #24]
 8005d40:	f203 2202 	addw	r2, r3, #514	; 0x202
 8005d44:	69bb      	ldr	r3, [r7, #24]
 8005d46:	f503 731d 	add.w	r3, r3, #628	; 0x274
 8005d4a:	2439      	movs	r4, #57	; 0x39
 8005d4c:	9400      	str	r4, [sp, #0]
 8005d4e:	f000 fdad 	bl	80068ac <ed448MulInt>
   ed448RedInt(state->p, state->k);
 8005d52:	69bb      	ldr	r3, [r7, #24]
 8005d54:	f203 2202 	addw	r2, r3, #514	; 0x202
 8005d58:	69bb      	ldr	r3, [r7, #24]
 8005d5a:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005d5e:	4619      	mov	r1, r3
 8005d60:	4610      	mov	r0, r2
 8005d62:	f000 fcd5 	bl	8006710 <ed448RedInt>
   ed448AddInt(state->s, state->p, state->r, 57);
 8005d66:	69bb      	ldr	r3, [r7, #24]
 8005d68:	f503 701d 	add.w	r0, r3, #628	; 0x274
 8005d6c:	69bb      	ldr	r3, [r7, #24]
 8005d6e:	f203 2102 	addw	r1, r3, #514	; 0x202
 8005d72:	69bb      	ldr	r3, [r7, #24]
 8005d74:	f203 223b 	addw	r2, r3, #571	; 0x23b
 8005d78:	2339      	movs	r3, #57	; 0x39
 8005d7a:	f000 fd29 	bl	80067d0 <ed448AddInt>

   //Perform modular reduction
   c = ed448SubInt(state->p, state->s, ED448_L, 57);
 8005d7e:	69bb      	ldr	r3, [r7, #24]
 8005d80:	f203 2002 	addw	r0, r3, #514	; 0x202
 8005d84:	69bb      	ldr	r3, [r7, #24]
 8005d86:	f503 711d 	add.w	r1, r3, #628	; 0x274
 8005d8a:	2339      	movs	r3, #57	; 0x39
 8005d8c:	4a12      	ldr	r2, [pc, #72]	; (8005dd8 <ed448GenerateSignatureEx+0x32c>)
 8005d8e:	f000 fd52 	bl	8006836 <ed448SubInt>
 8005d92:	4603      	mov	r3, r0
 8005d94:	75fb      	strb	r3, [r7, #23]
   ed448SelectInt(signature + 57, state->p, state->s, c, 57);
 8005d96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005d98:	f103 0039 	add.w	r0, r3, #57	; 0x39
 8005d9c:	69bb      	ldr	r3, [r7, #24]
 8005d9e:	f203 2102 	addw	r1, r3, #514	; 0x202
 8005da2:	69bb      	ldr	r3, [r7, #24]
 8005da4:	f503 721d 	add.w	r2, r3, #628	; 0x274
 8005da8:	7dfb      	ldrb	r3, [r7, #23]
 8005daa:	2439      	movs	r4, #57	; 0x39
 8005dac:	9400      	str	r4, [sp, #0]
 8005dae:	f000 ff10 	bl	8006bd2 <ed448SelectInt>

   //Erase working state
   osMemset(state, 0, sizeof(Ed448State));
 8005db2:	f44f 62f7 	mov.w	r2, #1976	; 0x7b8
 8005db6:	2100      	movs	r1, #0
 8005db8:	69b8      	ldr	r0, [r7, #24]
 8005dba:	f008 fb93 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8005dbe:	69b8      	ldr	r0, [r7, #24]
 8005dc0:	f005 fe2c 	bl	800ba1c <osFreeMem>

   //Successful processing
   return NO_ERROR;
 8005dc4:	2300      	movs	r3, #0
}
 8005dc6:	4618      	mov	r0, r3
 8005dc8:	3724      	adds	r7, #36	; 0x24
 8005dca:	46bd      	mov	sp, r7
 8005dcc:	bd90      	pop	{r4, r7, pc}
 8005dce:	bf00      	nop
 8005dd0:	0800f2a0 	.word	0x0800f2a0
 8005dd4:	0800e840 	.word	0x0800e840
 8005dd8:	0800f3b8 	.word	0x0800f3b8

08005ddc <ed448VerifySignature>:
 **/

error_t ed448VerifySignature(const uint8_t *publicKey, const void *message,
   size_t messageLen, const void *context, uint8_t contextLen, uint8_t flag,
   const uint8_t *signature)
{
 8005ddc:	b580      	push	{r7, lr}
 8005dde:	b08c      	sub	sp, #48	; 0x30
 8005de0:	af02      	add	r7, sp, #8
 8005de2:	60f8      	str	r0, [r7, #12]
 8005de4:	60b9      	str	r1, [r7, #8]
 8005de6:	607a      	str	r2, [r7, #4]
 8005de8:	603b      	str	r3, [r7, #0]
   error_t error;
   EddsaMessageChunk messageChunks[2];

   //The message fits in a single chunk
   messageChunks[0].buffer = message;
 8005dea:	68bb      	ldr	r3, [r7, #8]
 8005dec:	617b      	str	r3, [r7, #20]
   messageChunks[0].length = messageLen;
 8005dee:	687b      	ldr	r3, [r7, #4]
 8005df0:	61bb      	str	r3, [r7, #24]
   messageChunks[1].buffer = NULL;
 8005df2:	2300      	movs	r3, #0
 8005df4:	61fb      	str	r3, [r7, #28]
   messageChunks[1].length = 0;
 8005df6:	2300      	movs	r3, #0
 8005df8:	623b      	str	r3, [r7, #32]

   //Ed448 signature verification
   error = ed448VerifySignatureEx(publicKey, messageChunks, context,
 8005dfa:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8005dfe:	f107 0114 	add.w	r1, r7, #20
 8005e02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005e04:	9301      	str	r3, [sp, #4]
 8005e06:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8005e0a:	9300      	str	r3, [sp, #0]
 8005e0c:	4613      	mov	r3, r2
 8005e0e:	683a      	ldr	r2, [r7, #0]
 8005e10:	68f8      	ldr	r0, [r7, #12]
 8005e12:	f000 f807 	bl	8005e24 <ed448VerifySignatureEx>
 8005e16:	4603      	mov	r3, r0
 8005e18:	84fb      	strh	r3, [r7, #38]	; 0x26
      contextLen, flag, signature);

   //Return status code
   return error;
 8005e1a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 8005e1c:	4618      	mov	r0, r3
 8005e1e:	3728      	adds	r7, #40	; 0x28
 8005e20:	46bd      	mov	sp, r7
 8005e22:	bd80      	pop	{r7, pc}

08005e24 <ed448VerifySignatureEx>:
 **/

error_t ed448VerifySignatureEx(const uint8_t *publicKey,
   const EddsaMessageChunk *messageChunks, const void *context,
   uint8_t contextLen, uint8_t flag, const uint8_t *signature)
{
 8005e24:	b580      	push	{r7, lr}
 8005e26:	b088      	sub	sp, #32
 8005e28:	af00      	add	r7, sp, #0
 8005e2a:	60f8      	str	r0, [r7, #12]
 8005e2c:	60b9      	str	r1, [r7, #8]
 8005e2e:	607a      	str	r2, [r7, #4]
 8005e30:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   uint32_t ret;
   Ed448State *state;

   //Check parameters
   if(publicKey == NULL || signature == NULL)
 8005e32:	68fb      	ldr	r3, [r7, #12]
 8005e34:	2b00      	cmp	r3, #0
 8005e36:	d002      	beq.n	8005e3e <ed448VerifySignatureEx+0x1a>
 8005e38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e3a:	2b00      	cmp	r3, #0
 8005e3c:	d101      	bne.n	8005e42 <ed448VerifySignatureEx+0x1e>
      return ERROR_INVALID_PARAMETER;
 8005e3e:	2302      	movs	r3, #2
 8005e40:	e0f2      	b.n	8006028 <ed448VerifySignatureEx+0x204>
   if(messageChunks == NULL)
 8005e42:	68bb      	ldr	r3, [r7, #8]
 8005e44:	2b00      	cmp	r3, #0
 8005e46:	d101      	bne.n	8005e4c <ed448VerifySignatureEx+0x28>
      return ERROR_INVALID_PARAMETER;
 8005e48:	2302      	movs	r3, #2
 8005e4a:	e0ed      	b.n	8006028 <ed448VerifySignatureEx+0x204>
   if(context == NULL && contextLen != 0)
 8005e4c:	687b      	ldr	r3, [r7, #4]
 8005e4e:	2b00      	cmp	r3, #0
 8005e50:	d104      	bne.n	8005e5c <ed448VerifySignatureEx+0x38>
 8005e52:	78fb      	ldrb	r3, [r7, #3]
 8005e54:	2b00      	cmp	r3, #0
 8005e56:	d001      	beq.n	8005e5c <ed448VerifySignatureEx+0x38>
      return ERROR_INVALID_PARAMETER;
 8005e58:	2302      	movs	r3, #2
 8005e5a:	e0e5      	b.n	8006028 <ed448VerifySignatureEx+0x204>

   //Allocate working state
   state = cryptoAllocMem(sizeof(Ed448State));
 8005e5c:	f44f 60f7 	mov.w	r0, #1976	; 0x7b8
 8005e60:	f005 fdce 	bl	800ba00 <osAllocMem>
 8005e64:	61b8      	str	r0, [r7, #24]
   //Failed to allocate memory?
   if(state == NULL)
 8005e66:	69bb      	ldr	r3, [r7, #24]
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d101      	bne.n	8005e70 <ed448VerifySignatureEx+0x4c>
      return ERROR_OUT_OF_MEMORY;
 8005e6c:	2364      	movs	r3, #100	; 0x64
 8005e6e:	e0db      	b.n	8006028 <ed448VerifySignatureEx+0x204>

   //First split the signature into two 32-octet halves. Decode the first
   //half as a point R
   osMemcpy(state->r, signature, ED448_SIGNATURE_LEN / 2);
 8005e70:	69bb      	ldr	r3, [r7, #24]
 8005e72:	f203 233b 	addw	r3, r3, #571	; 0x23b
 8005e76:	2239      	movs	r2, #57	; 0x39
 8005e78:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005e7a:	4618      	mov	r0, r3
 8005e7c:	f008 fb24 	bl	800e4c8 <memcpy>

   //Decode the second half as an integer S, in the range 0 <= s < L
   osMemcpy(state->s, signature + ED448_SIGNATURE_LEN / 2,
 8005e80:	69bb      	ldr	r3, [r7, #24]
 8005e82:	f503 701d 	add.w	r0, r3, #628	; 0x274
 8005e86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e88:	3339      	adds	r3, #57	; 0x39
 8005e8a:	2239      	movs	r2, #57	; 0x39
 8005e8c:	4619      	mov	r1, r3
 8005e8e:	f008 fb1b 	bl	800e4c8 <memcpy>
      ED448_SIGNATURE_LEN / 2);

   //Ed448 signatures are not malleable due to the verification check that
   //decoded S is smaller than L (refer to RFC 8032, section 8.4)
   ret = 1 ^ ed448SubInt(state->p, state->s, ED448_L, ED448_SIGNATURE_LEN / 2);
 8005e92:	69bb      	ldr	r3, [r7, #24]
 8005e94:	f203 2002 	addw	r0, r3, #514	; 0x202
 8005e98:	69bb      	ldr	r3, [r7, #24]
 8005e9a:	f503 711d 	add.w	r1, r3, #628	; 0x274
 8005e9e:	2339      	movs	r3, #57	; 0x39
 8005ea0:	4a63      	ldr	r2, [pc, #396]	; (8006030 <ed448VerifySignatureEx+0x20c>)
 8005ea2:	f000 fcc8 	bl	8006836 <ed448SubInt>
 8005ea6:	4603      	mov	r3, r0
 8005ea8:	f083 0301 	eor.w	r3, r3, #1
 8005eac:	b2db      	uxtb	r3, r3
 8005eae:	617b      	str	r3, [r7, #20]

   //Decode the public key A as point A'
   ret |= ed448Decode(&state->ka, publicKey);
 8005eb0:	69bb      	ldr	r3, [r7, #24]
 8005eb2:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
 8005eb6:	68f9      	ldr	r1, [r7, #12]
 8005eb8:	4618      	mov	r0, r3
 8005eba:	f000 fb11 	bl	80064e0 <ed448Decode>
 8005ebe:	4602      	mov	r2, r0
 8005ec0:	697b      	ldr	r3, [r7, #20]
 8005ec2:	4313      	orrs	r3, r2
 8005ec4:	617b      	str	r3, [r7, #20]

   //Initialize SHAKE256 context
   shakeInit(&state->shakeContext, 256);
 8005ec6:	69bb      	ldr	r3, [r7, #24]
 8005ec8:	f44f 7180 	mov.w	r1, #256	; 0x100
 8005ecc:	4618      	mov	r0, r3
 8005ece:	f002 fb81 	bl	80085d4 <shakeInit>

   //Absorb dom4(F, C) || R || A
   shakeAbsorb(&state->shakeContext, "SigEd448", 8);
 8005ed2:	69bb      	ldr	r3, [r7, #24]
 8005ed4:	2208      	movs	r2, #8
 8005ed6:	4957      	ldr	r1, [pc, #348]	; (8006034 <ed448VerifySignatureEx+0x210>)
 8005ed8:	4618      	mov	r0, r3
 8005eda:	f002 fb98 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &flag, sizeof(uint8_t));
 8005ede:	69bb      	ldr	r3, [r7, #24]
 8005ee0:	2201      	movs	r2, #1
 8005ee2:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8005ee6:	4618      	mov	r0, r3
 8005ee8:	f002 fb91 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, &contextLen, sizeof(uint8_t));
 8005eec:	69bb      	ldr	r3, [r7, #24]
 8005eee:	1cf9      	adds	r1, r7, #3
 8005ef0:	2201      	movs	r2, #1
 8005ef2:	4618      	mov	r0, r3
 8005ef4:	f002 fb8b 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, context, contextLen);
 8005ef8:	69bb      	ldr	r3, [r7, #24]
 8005efa:	78fa      	ldrb	r2, [r7, #3]
 8005efc:	6879      	ldr	r1, [r7, #4]
 8005efe:	4618      	mov	r0, r3
 8005f00:	f002 fb85 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, state->r, ED448_SIGNATURE_LEN / 2);
 8005f04:	69b8      	ldr	r0, [r7, #24]
 8005f06:	69bb      	ldr	r3, [r7, #24]
 8005f08:	f203 233b 	addw	r3, r3, #571	; 0x23b
 8005f0c:	2239      	movs	r2, #57	; 0x39
 8005f0e:	4619      	mov	r1, r3
 8005f10:	f002 fb7d 	bl	800860e <shakeAbsorb>
   shakeAbsorb(&state->shakeContext, publicKey, ED448_PUBLIC_KEY_LEN);
 8005f14:	69bb      	ldr	r3, [r7, #24]
 8005f16:	2239      	movs	r2, #57	; 0x39
 8005f18:	68f9      	ldr	r1, [r7, #12]
 8005f1a:	4618      	mov	r0, r3
 8005f1c:	f002 fb77 	bl	800860e <shakeAbsorb>

   //The message is split over multiple chunks
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005f20:	2300      	movs	r3, #0
 8005f22:	61fb      	str	r3, [r7, #28]
 8005f24:	e010      	b.n	8005f48 <ed448VerifySignatureEx+0x124>
   {
      //Absorb current chunk
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005f26:	69b8      	ldr	r0, [r7, #24]
 8005f28:	69fb      	ldr	r3, [r7, #28]
 8005f2a:	00db      	lsls	r3, r3, #3
 8005f2c:	68ba      	ldr	r2, [r7, #8]
 8005f2e:	4413      	add	r3, r2
 8005f30:	6819      	ldr	r1, [r3, #0]
         messageChunks[i].length);
 8005f32:	69fb      	ldr	r3, [r7, #28]
 8005f34:	00db      	lsls	r3, r3, #3
 8005f36:	68ba      	ldr	r2, [r7, #8]
 8005f38:	4413      	add	r3, r2
      shakeAbsorb(&state->shakeContext, messageChunks[i].buffer,
 8005f3a:	685b      	ldr	r3, [r3, #4]
 8005f3c:	461a      	mov	r2, r3
 8005f3e:	f002 fb66 	bl	800860e <shakeAbsorb>
   for(i = 0; messageChunks[i].buffer != NULL; i++)
 8005f42:	69fb      	ldr	r3, [r7, #28]
 8005f44:	3301      	adds	r3, #1
 8005f46:	61fb      	str	r3, [r7, #28]
 8005f48:	69fb      	ldr	r3, [r7, #28]
 8005f4a:	00db      	lsls	r3, r3, #3
 8005f4c:	68ba      	ldr	r2, [r7, #8]
 8005f4e:	4413      	add	r3, r2
 8005f50:	681b      	ldr	r3, [r3, #0]
 8005f52:	2b00      	cmp	r3, #0
 8005f54:	d1e7      	bne.n	8005f26 <ed448VerifySignatureEx+0x102>
   }

   //Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114) and interpret the
   //114-octet digest as a little-endian integer k
   shakeFinal(&state->shakeContext);
 8005f56:	69bb      	ldr	r3, [r7, #24]
 8005f58:	4618      	mov	r0, r3
 8005f5a:	f002 fb68 	bl	800862e <shakeFinal>
   shakeSqueeze(&state->shakeContext, state->k, 114);
 8005f5e:	69b8      	ldr	r0, [r7, #24]
 8005f60:	69bb      	ldr	r3, [r7, #24]
 8005f62:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005f66:	2272      	movs	r2, #114	; 0x72
 8005f68:	4619      	mov	r1, r3
 8005f6a:	f002 fb6d 	bl	8008648 <shakeSqueeze>

   //For efficiency, reduce k modulo L first
   ed448RedInt(state->k, state->k);
 8005f6e:	69bb      	ldr	r3, [r7, #24]
 8005f70:	f503 72c8 	add.w	r2, r3, #400	; 0x190
 8005f74:	69bb      	ldr	r3, [r7, #24]
 8005f76:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8005f7a:	4619      	mov	r1, r3
 8005f7c:	4610      	mov	r0, r2
 8005f7e:	f000 fbc7 	bl	8006710 <ed448RedInt>

   //Compute the point P = s * B - k * A'
   curve448Sub(state->ka.x, ED448_ZERO, state->ka.x);
 8005f82:	69bb      	ldr	r3, [r7, #24]
 8005f84:	f503 703a 	add.w	r0, r3, #744	; 0x2e8
 8005f88:	69bb      	ldr	r3, [r7, #24]
 8005f8a:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
 8005f8e:	461a      	mov	r2, r3
 8005f90:	4929      	ldr	r1, [pc, #164]	; (8006038 <ed448VerifySignatureEx+0x214>)
 8005f92:	f7fb fbed 	bl	8001770 <curve448Sub>
   ed448Mul(state, &state->sb, state->s, &ED448_B);
 8005f96:	69bb      	ldr	r3, [r7, #24]
 8005f98:	f503 6187 	add.w	r1, r3, #1080	; 0x438
 8005f9c:	69bb      	ldr	r3, [r7, #24]
 8005f9e:	f503 721d 	add.w	r2, r3, #628	; 0x274
 8005fa2:	4b26      	ldr	r3, [pc, #152]	; (800603c <ed448VerifySignatureEx+0x218>)
 8005fa4:	69b8      	ldr	r0, [r7, #24]
 8005fa6:	f000 f84b 	bl	8006040 <ed448Mul>
   ed448Mul(state, &state->ka, state->k, &state->ka);
 8005faa:	69bb      	ldr	r3, [r7, #24]
 8005fac:	f503 713a 	add.w	r1, r3, #744	; 0x2e8
 8005fb0:	69bb      	ldr	r3, [r7, #24]
 8005fb2:	f503 72c8 	add.w	r2, r3, #400	; 0x190
 8005fb6:	69bb      	ldr	r3, [r7, #24]
 8005fb8:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
 8005fbc:	69b8      	ldr	r0, [r7, #24]
 8005fbe:	f000 f83f 	bl	8006040 <ed448Mul>
   ed448Add(state, &state->ka, &state->sb, &state->ka);
 8005fc2:	69bb      	ldr	r3, [r7, #24]
 8005fc4:	f503 713a 	add.w	r1, r3, #744	; 0x2e8
 8005fc8:	69bb      	ldr	r3, [r7, #24]
 8005fca:	f503 6287 	add.w	r2, r3, #1080	; 0x438
 8005fce:	69bb      	ldr	r3, [r7, #24]
 8005fd0:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
 8005fd4:	69b8      	ldr	r0, [r7, #24]
 8005fd6:	f000 f8c9 	bl	800616c <ed448Add>

   //Encode of the resulting point P
   ed448Encode(&state->ka, state->p);
 8005fda:	69bb      	ldr	r3, [r7, #24]
 8005fdc:	f503 723a 	add.w	r2, r3, #744	; 0x2e8
 8005fe0:	69bb      	ldr	r3, [r7, #24]
 8005fe2:	f203 2302 	addw	r3, r3, #514	; 0x202
 8005fe6:	4619      	mov	r1, r3
 8005fe8:	4610      	mov	r0, r2
 8005fea:	f000 fa38 	bl	800645e <ed448Encode>

   //If P = R, then the signature is verified. If P does not equal R,
   //then the message or the signature may have been modified
   ret |= ed448CompInt(state->p, signature, ED448_SIGNATURE_LEN / 2);
 8005fee:	69bb      	ldr	r3, [r7, #24]
 8005ff0:	f203 2302 	addw	r3, r3, #514	; 0x202
 8005ff4:	2239      	movs	r2, #57	; 0x39
 8005ff6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005ff8:	4618      	mov	r0, r3
 8005ffa:	f000 fe1f 	bl	8006c3c <ed448CompInt>
 8005ffe:	4603      	mov	r3, r0
 8006000:	461a      	mov	r2, r3
 8006002:	697b      	ldr	r3, [r7, #20]
 8006004:	4313      	orrs	r3, r2
 8006006:	617b      	str	r3, [r7, #20]

   //Erase working state
   osMemset(state, 0, sizeof(Ed448State));
 8006008:	f44f 62f7 	mov.w	r2, #1976	; 0x7b8
 800600c:	2100      	movs	r1, #0
 800600e:	69b8      	ldr	r0, [r7, #24]
 8006010:	f008 fa68 	bl	800e4e4 <memset>
   //Release working state
   cryptoFreeMem(state);
 8006014:	69b8      	ldr	r0, [r7, #24]
 8006016:	f005 fd01 	bl	800ba1c <osFreeMem>

   //Return status code
   return (ret == 0) ? NO_ERROR : ERROR_INVALID_SIGNATURE;
 800601a:	697b      	ldr	r3, [r7, #20]
 800601c:	2b00      	cmp	r3, #0
 800601e:	d101      	bne.n	8006024 <ed448VerifySignatureEx+0x200>
 8006020:	2300      	movs	r3, #0
 8006022:	e001      	b.n	8006028 <ed448VerifySignatureEx+0x204>
 8006024:	f240 230d 	movw	r3, #525	; 0x20d
}
 8006028:	4618      	mov	r0, r3
 800602a:	3720      	adds	r7, #32
 800602c:	46bd      	mov	sp, r7
 800602e:	bd80      	pop	{r7, pc}
 8006030:	0800f3b8 	.word	0x0800f3b8
 8006034:	0800e840 	.word	0x0800e840
 8006038:	0800f348 	.word	0x0800f348
 800603c:	0800f2a0 	.word	0x0800f2a0

08006040 <ed448Mul>:
 * @param[in] p Input point
 **/

void ed448Mul(Ed448State *state, Ed448Point *r, const uint8_t *k,
   const Ed448Point *p)
{
 8006040:	b580      	push	{r7, lr}
 8006042:	b086      	sub	sp, #24
 8006044:	af00      	add	r7, sp, #0
 8006046:	60f8      	str	r0, [r7, #12]
 8006048:	60b9      	str	r1, [r7, #8]
 800604a:	607a      	str	r2, [r7, #4]
 800604c:	603b      	str	r3, [r7, #0]
   int_t i;
   uint8_t b;

   //The neutral element is represented by (0, 1, 1)
   curve448SetInt(state->u.x, 0);
 800604e:	68fb      	ldr	r3, [r7, #12]
 8006050:	f503 639c 	add.w	r3, r3, #1248	; 0x4e0
 8006054:	2100      	movs	r1, #0
 8006056:	4618      	mov	r0, r3
 8006058:	f7fb fb17 	bl	800168a <curve448SetInt>
   curve448SetInt(state->u.y, 1);
 800605c:	68fb      	ldr	r3, [r7, #12]
 800605e:	f503 63a3 	add.w	r3, r3, #1304	; 0x518
 8006062:	2101      	movs	r1, #1
 8006064:	4618      	mov	r0, r3
 8006066:	f7fb fb10 	bl	800168a <curve448SetInt>
   curve448SetInt(state->u.z, 1);
 800606a:	68fb      	ldr	r3, [r7, #12]
 800606c:	f503 63aa 	add.w	r3, r3, #1360	; 0x550
 8006070:	2101      	movs	r1, #1
 8006072:	4618      	mov	r0, r3
 8006074:	f7fb fb09 	bl	800168a <curve448SetInt>

   //Perform scalar multiplication
   for(i = CURVE448_BIT_LEN - 1; i >= 0; i--)
 8006078:	f240 13bf 	movw	r3, #447	; 0x1bf
 800607c:	617b      	str	r3, [r7, #20]
 800607e:	e052      	b.n	8006126 <ed448Mul+0xe6>
   {
      //The scalar is processed in a left-to-right fashion
      b = (k[i / 8] >> (i % 8)) & 1;
 8006080:	697b      	ldr	r3, [r7, #20]
 8006082:	2b00      	cmp	r3, #0
 8006084:	da00      	bge.n	8006088 <ed448Mul+0x48>
 8006086:	3307      	adds	r3, #7
 8006088:	10db      	asrs	r3, r3, #3
 800608a:	461a      	mov	r2, r3
 800608c:	687b      	ldr	r3, [r7, #4]
 800608e:	4413      	add	r3, r2
 8006090:	781b      	ldrb	r3, [r3, #0]
 8006092:	4619      	mov	r1, r3
 8006094:	697b      	ldr	r3, [r7, #20]
 8006096:	425a      	negs	r2, r3
 8006098:	f003 0307 	and.w	r3, r3, #7
 800609c:	f002 0207 	and.w	r2, r2, #7
 80060a0:	bf58      	it	pl
 80060a2:	4253      	negpl	r3, r2
 80060a4:	fa41 f303 	asr.w	r3, r1, r3
 80060a8:	b2db      	uxtb	r3, r3
 80060aa:	f003 0301 	and.w	r3, r3, #1
 80060ae:	74fb      	strb	r3, [r7, #19]

      //Compute U = 2 * U
      ed448Double(state, &state->u, &state->u);
 80060b0:	68fb      	ldr	r3, [r7, #12]
 80060b2:	f503 619c 	add.w	r1, r3, #1248	; 0x4e0
 80060b6:	68fb      	ldr	r3, [r7, #12]
 80060b8:	f503 639c 	add.w	r3, r3, #1248	; 0x4e0
 80060bc:	461a      	mov	r2, r3
 80060be:	68f8      	ldr	r0, [r7, #12]
 80060c0:	f000 f934 	bl	800632c <ed448Double>
      //Compute V = U + P
      ed448Add(state, &state->v, &state->u, p);
 80060c4:	68fb      	ldr	r3, [r7, #12]
 80060c6:	f503 61b1 	add.w	r1, r3, #1416	; 0x588
 80060ca:	68fb      	ldr	r3, [r7, #12]
 80060cc:	f503 629c 	add.w	r2, r3, #1248	; 0x4e0
 80060d0:	683b      	ldr	r3, [r7, #0]
 80060d2:	68f8      	ldr	r0, [r7, #12]
 80060d4:	f000 f84a 	bl	800616c <ed448Add>

      //If b is set, then U = V
      curve448Select(state->u.x, state->u.x, state->v.x, b);
 80060d8:	68fb      	ldr	r3, [r7, #12]
 80060da:	f503 609c 	add.w	r0, r3, #1248	; 0x4e0
 80060de:	68fb      	ldr	r3, [r7, #12]
 80060e0:	f503 619c 	add.w	r1, r3, #1248	; 0x4e0
 80060e4:	68fb      	ldr	r3, [r7, #12]
 80060e6:	f503 62b1 	add.w	r2, r3, #1416	; 0x588
 80060ea:	7cfb      	ldrb	r3, [r7, #19]
 80060ec:	f7fc fa78 	bl	80025e0 <curve448Select>
      curve448Select(state->u.y, state->u.y, state->v.y, b);
 80060f0:	68fb      	ldr	r3, [r7, #12]
 80060f2:	f503 60a3 	add.w	r0, r3, #1304	; 0x518
 80060f6:	68fb      	ldr	r3, [r7, #12]
 80060f8:	f503 61a3 	add.w	r1, r3, #1304	; 0x518
 80060fc:	68fb      	ldr	r3, [r7, #12]
 80060fe:	f503 62b8 	add.w	r2, r3, #1472	; 0x5c0
 8006102:	7cfb      	ldrb	r3, [r7, #19]
 8006104:	f7fc fa6c 	bl	80025e0 <curve448Select>
      curve448Select(state->u.z, state->u.z, state->v.z, b);
 8006108:	68fb      	ldr	r3, [r7, #12]
 800610a:	f503 60aa 	add.w	r0, r3, #1360	; 0x550
 800610e:	68fb      	ldr	r3, [r7, #12]
 8006110:	f503 61aa 	add.w	r1, r3, #1360	; 0x550
 8006114:	68fb      	ldr	r3, [r7, #12]
 8006116:	f503 62bf 	add.w	r2, r3, #1528	; 0x5f8
 800611a:	7cfb      	ldrb	r3, [r7, #19]
 800611c:	f7fc fa60 	bl	80025e0 <curve448Select>
   for(i = CURVE448_BIT_LEN - 1; i >= 0; i--)
 8006120:	697b      	ldr	r3, [r7, #20]
 8006122:	3b01      	subs	r3, #1
 8006124:	617b      	str	r3, [r7, #20]
 8006126:	697b      	ldr	r3, [r7, #20]
 8006128:	2b00      	cmp	r3, #0
 800612a:	daa9      	bge.n	8006080 <ed448Mul+0x40>
   }

   //Copy result
   curve448Copy(r->x, state->u.x);
 800612c:	68ba      	ldr	r2, [r7, #8]
 800612e:	68fb      	ldr	r3, [r7, #12]
 8006130:	f503 639c 	add.w	r3, r3, #1248	; 0x4e0
 8006134:	4619      	mov	r1, r3
 8006136:	4610      	mov	r0, r2
 8006138:	f7fc fa33 	bl	80025a2 <curve448Copy>
   curve448Copy(r->y, state->u.y);
 800613c:	68bb      	ldr	r3, [r7, #8]
 800613e:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8006142:	68fb      	ldr	r3, [r7, #12]
 8006144:	f503 63a3 	add.w	r3, r3, #1304	; 0x518
 8006148:	4619      	mov	r1, r3
 800614a:	4610      	mov	r0, r2
 800614c:	f7fc fa29 	bl	80025a2 <curve448Copy>
   curve448Copy(r->z, state->u.z);
 8006150:	68bb      	ldr	r3, [r7, #8]
 8006152:	f103 0270 	add.w	r2, r3, #112	; 0x70
 8006156:	68fb      	ldr	r3, [r7, #12]
 8006158:	f503 63aa 	add.w	r3, r3, #1360	; 0x550
 800615c:	4619      	mov	r1, r3
 800615e:	4610      	mov	r0, r2
 8006160:	f7fc fa1f 	bl	80025a2 <curve448Copy>
}
 8006164:	bf00      	nop
 8006166:	3718      	adds	r7, #24
 8006168:	46bd      	mov	sp, r7
 800616a:	bd80      	pop	{r7, pc}

0800616c <ed448Add>:
 * @param[in] q Second operand
 **/

void ed448Add(Ed448State *state, Ed448Point *r, const Ed448Point *p,
   const Ed448Point *q)
{
 800616c:	b580      	push	{r7, lr}
 800616e:	b084      	sub	sp, #16
 8006170:	af00      	add	r7, sp, #0
 8006172:	60f8      	str	r0, [r7, #12]
 8006174:	60b9      	str	r1, [r7, #8]
 8006176:	607a      	str	r2, [r7, #4]
 8006178:	603b      	str	r3, [r7, #0]
   //Compute A = X1 * X2
   curve448Mul(state->a, p->x, q->x);
 800617a:	68fb      	ldr	r3, [r7, #12]
 800617c:	f503 63c6 	add.w	r3, r3, #1584	; 0x630
 8006180:	6879      	ldr	r1, [r7, #4]
 8006182:	683a      	ldr	r2, [r7, #0]
 8006184:	4618      	mov	r0, r3
 8006186:	f7fb fc35 	bl	80019f4 <curve448Mul>
   //Compute B = Y1 * Y2
   curve448Mul(state->b, p->y, q->y);
 800618a:	68fb      	ldr	r3, [r7, #12]
 800618c:	f503 60cd 	add.w	r0, r3, #1640	; 0x668
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	f103 0138 	add.w	r1, r3, #56	; 0x38
 8006196:	683b      	ldr	r3, [r7, #0]
 8006198:	3338      	adds	r3, #56	; 0x38
 800619a:	461a      	mov	r2, r3
 800619c:	f7fb fc2a 	bl	80019f4 <curve448Mul>
   //Compute C = Z1 * Z2
   curve448Mul(state->c, p->z, q->z);
 80061a0:	68fb      	ldr	r3, [r7, #12]
 80061a2:	f503 60d4 	add.w	r0, r3, #1696	; 0x6a0
 80061a6:	687b      	ldr	r3, [r7, #4]
 80061a8:	f103 0170 	add.w	r1, r3, #112	; 0x70
 80061ac:	683b      	ldr	r3, [r7, #0]
 80061ae:	3370      	adds	r3, #112	; 0x70
 80061b0:	461a      	mov	r2, r3
 80061b2:	f7fb fc1f 	bl	80019f4 <curve448Mul>
   //Compute D = C^2
   curve448Sqr(state->d, state->c);
 80061b6:	68fb      	ldr	r3, [r7, #12]
 80061b8:	f503 62db 	add.w	r2, r3, #1752	; 0x6d8
 80061bc:	68fb      	ldr	r3, [r7, #12]
 80061be:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 80061c2:	4619      	mov	r1, r3
 80061c4:	4610      	mov	r0, r2
 80061c6:	f7fb fed1 	bl	8001f6c <curve448Sqr>
   //Compute E = d * A * B
   curve448Mul(state->e, state->a, state->b);
 80061ca:	68fb      	ldr	r3, [r7, #12]
 80061cc:	f503 60e2 	add.w	r0, r3, #1808	; 0x710
 80061d0:	68fb      	ldr	r3, [r7, #12]
 80061d2:	f503 61c6 	add.w	r1, r3, #1584	; 0x630
 80061d6:	68fb      	ldr	r3, [r7, #12]
 80061d8:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 80061dc:	461a      	mov	r2, r3
 80061de:	f7fb fc09 	bl	80019f4 <curve448Mul>
   curve448Mul(state->e, state->e, ED448_D);
 80061e2:	68fb      	ldr	r3, [r7, #12]
 80061e4:	f503 60e2 	add.w	r0, r3, #1808	; 0x710
 80061e8:	68fb      	ldr	r3, [r7, #12]
 80061ea:	f503 63e2 	add.w	r3, r3, #1808	; 0x710
 80061ee:	4a4e      	ldr	r2, [pc, #312]	; (8006328 <ed448Add+0x1bc>)
 80061f0:	4619      	mov	r1, r3
 80061f2:	f7fb fbff 	bl	80019f4 <curve448Mul>
   //Compute F = D + E
   curve448Add(state->f, state->d, state->e);
 80061f6:	68fb      	ldr	r3, [r7, #12]
 80061f8:	f503 60e9 	add.w	r0, r3, #1864	; 0x748
 80061fc:	68fb      	ldr	r3, [r7, #12]
 80061fe:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 8006202:	68fb      	ldr	r3, [r7, #12]
 8006204:	f503 63e2 	add.w	r3, r3, #1808	; 0x710
 8006208:	461a      	mov	r2, r3
 800620a:	f7fb fa5c 	bl	80016c6 <curve448Add>
   //Compute G = D - E
   curve448Sub(state->g, state->d, state->e);
 800620e:	68fb      	ldr	r3, [r7, #12]
 8006210:	f503 60f0 	add.w	r0, r3, #1920	; 0x780
 8006214:	68fb      	ldr	r3, [r7, #12]
 8006216:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 800621a:	68fb      	ldr	r3, [r7, #12]
 800621c:	f503 63e2 	add.w	r3, r3, #1808	; 0x710
 8006220:	461a      	mov	r2, r3
 8006222:	f7fb faa5 	bl	8001770 <curve448Sub>
   //Compute D = (X1 + Y1) * (X2 + Y2)
   curve448Add(state->d, p->x, p->y);
 8006226:	68fb      	ldr	r3, [r7, #12]
 8006228:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 800622c:	6879      	ldr	r1, [r7, #4]
 800622e:	687b      	ldr	r3, [r7, #4]
 8006230:	3338      	adds	r3, #56	; 0x38
 8006232:	461a      	mov	r2, r3
 8006234:	f7fb fa47 	bl	80016c6 <curve448Add>
   curve448Add(state->e, q->x, q->y);
 8006238:	68fb      	ldr	r3, [r7, #12]
 800623a:	f503 60e2 	add.w	r0, r3, #1808	; 0x710
 800623e:	6839      	ldr	r1, [r7, #0]
 8006240:	683b      	ldr	r3, [r7, #0]
 8006242:	3338      	adds	r3, #56	; 0x38
 8006244:	461a      	mov	r2, r3
 8006246:	f7fb fa3e 	bl	80016c6 <curve448Add>
   curve448Mul(state->d, state->d, state->e);
 800624a:	68fb      	ldr	r3, [r7, #12]
 800624c:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 8006250:	68fb      	ldr	r3, [r7, #12]
 8006252:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 8006256:	68fb      	ldr	r3, [r7, #12]
 8006258:	f503 63e2 	add.w	r3, r3, #1808	; 0x710
 800625c:	461a      	mov	r2, r3
 800625e:	f7fb fbc9 	bl	80019f4 <curve448Mul>
   //Compute X3 = C * G * (D - A - B)
   curve448Sub(state->d, state->d, state->a);
 8006262:	68fb      	ldr	r3, [r7, #12]
 8006264:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 8006268:	68fb      	ldr	r3, [r7, #12]
 800626a:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 800626e:	68fb      	ldr	r3, [r7, #12]
 8006270:	f503 63c6 	add.w	r3, r3, #1584	; 0x630
 8006274:	461a      	mov	r2, r3
 8006276:	f7fb fa7b 	bl	8001770 <curve448Sub>
   curve448Sub(state->d, state->d, state->b);
 800627a:	68fb      	ldr	r3, [r7, #12]
 800627c:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 8006280:	68fb      	ldr	r3, [r7, #12]
 8006282:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 8006286:	68fb      	ldr	r3, [r7, #12]
 8006288:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 800628c:	461a      	mov	r2, r3
 800628e:	f7fb fa6f 	bl	8001770 <curve448Sub>
   curve448Mul(state->d, state->d, state->c);
 8006292:	68fb      	ldr	r3, [r7, #12]
 8006294:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 8006298:	68fb      	ldr	r3, [r7, #12]
 800629a:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 800629e:	68fb      	ldr	r3, [r7, #12]
 80062a0:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 80062a4:	461a      	mov	r2, r3
 80062a6:	f7fb fba5 	bl	80019f4 <curve448Mul>
   curve448Mul(r->x, state->d, state->g);
 80062aa:	68b8      	ldr	r0, [r7, #8]
 80062ac:	68fb      	ldr	r3, [r7, #12]
 80062ae:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 80062b2:	68fb      	ldr	r3, [r7, #12]
 80062b4:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
 80062b8:	461a      	mov	r2, r3
 80062ba:	f7fb fb9b 	bl	80019f4 <curve448Mul>
   //Compute Y3 = C * F * (B - A)
   curve448Sub(state->b, state->b, state->a);
 80062be:	68fb      	ldr	r3, [r7, #12]
 80062c0:	f503 60cd 	add.w	r0, r3, #1640	; 0x668
 80062c4:	68fb      	ldr	r3, [r7, #12]
 80062c6:	f503 61cd 	add.w	r1, r3, #1640	; 0x668
 80062ca:	68fb      	ldr	r3, [r7, #12]
 80062cc:	f503 63c6 	add.w	r3, r3, #1584	; 0x630
 80062d0:	461a      	mov	r2, r3
 80062d2:	f7fb fa4d 	bl	8001770 <curve448Sub>
   curve448Mul(state->b, state->b, state->c);
 80062d6:	68fb      	ldr	r3, [r7, #12]
 80062d8:	f503 60cd 	add.w	r0, r3, #1640	; 0x668
 80062dc:	68fb      	ldr	r3, [r7, #12]
 80062de:	f503 61cd 	add.w	r1, r3, #1640	; 0x668
 80062e2:	68fb      	ldr	r3, [r7, #12]
 80062e4:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 80062e8:	461a      	mov	r2, r3
 80062ea:	f7fb fb83 	bl	80019f4 <curve448Mul>
   curve448Mul(r->y, state->b, state->f);
 80062ee:	68bb      	ldr	r3, [r7, #8]
 80062f0:	f103 0038 	add.w	r0, r3, #56	; 0x38
 80062f4:	68fb      	ldr	r3, [r7, #12]
 80062f6:	f503 61cd 	add.w	r1, r3, #1640	; 0x668
 80062fa:	68fb      	ldr	r3, [r7, #12]
 80062fc:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 8006300:	461a      	mov	r2, r3
 8006302:	f7fb fb77 	bl	80019f4 <curve448Mul>
   //Compute Z3 = F * G
   curve448Mul(r->z, state->f, state->g);
 8006306:	68bb      	ldr	r3, [r7, #8]
 8006308:	f103 0070 	add.w	r0, r3, #112	; 0x70
 800630c:	68fb      	ldr	r3, [r7, #12]
 800630e:	f503 61e9 	add.w	r1, r3, #1864	; 0x748
 8006312:	68fb      	ldr	r3, [r7, #12]
 8006314:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
 8006318:	461a      	mov	r2, r3
 800631a:	f7fb fb6b 	bl	80019f4 <curve448Mul>
}
 800631e:	bf00      	nop
 8006320:	3710      	adds	r7, #16
 8006322:	46bd      	mov	sp, r7
 8006324:	bd80      	pop	{r7, pc}
 8006326:	bf00      	nop
 8006328:	0800f380 	.word	0x0800f380

0800632c <ed448Double>:
 * @param[out] r Resulting point R = 2 * P
 * @param[in] p Input point P
 **/

void ed448Double(Ed448State *state, Ed448Point *r, const Ed448Point *p)
{
 800632c:	b580      	push	{r7, lr}
 800632e:	b084      	sub	sp, #16
 8006330:	af00      	add	r7, sp, #0
 8006332:	60f8      	str	r0, [r7, #12]
 8006334:	60b9      	str	r1, [r7, #8]
 8006336:	607a      	str	r2, [r7, #4]
   //Compute A = X1 * X2
   curve448Mul(state->a, p->x, p->x);
 8006338:	68fb      	ldr	r3, [r7, #12]
 800633a:	f503 63c6 	add.w	r3, r3, #1584	; 0x630
 800633e:	6879      	ldr	r1, [r7, #4]
 8006340:	687a      	ldr	r2, [r7, #4]
 8006342:	4618      	mov	r0, r3
 8006344:	f7fb fb56 	bl	80019f4 <curve448Mul>
   //Compute B = Y1 * Y2
   curve448Mul(state->b, p->y, p->y);
 8006348:	68fb      	ldr	r3, [r7, #12]
 800634a:	f503 60cd 	add.w	r0, r3, #1640	; 0x668
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	f103 0138 	add.w	r1, r3, #56	; 0x38
 8006354:	687b      	ldr	r3, [r7, #4]
 8006356:	3338      	adds	r3, #56	; 0x38
 8006358:	461a      	mov	r2, r3
 800635a:	f7fb fb4b 	bl	80019f4 <curve448Mul>
   //Compute C = Z1 * Z2
   curve448Mul(state->c, p->z, p->z);
 800635e:	68fb      	ldr	r3, [r7, #12]
 8006360:	f503 60d4 	add.w	r0, r3, #1696	; 0x6a0
 8006364:	687b      	ldr	r3, [r7, #4]
 8006366:	f103 0170 	add.w	r1, r3, #112	; 0x70
 800636a:	687b      	ldr	r3, [r7, #4]
 800636c:	3370      	adds	r3, #112	; 0x70
 800636e:	461a      	mov	r2, r3
 8006370:	f7fb fb40 	bl	80019f4 <curve448Mul>
   //Compute F = A + B
   curve448Add(state->f, state->a, state->b);
 8006374:	68fb      	ldr	r3, [r7, #12]
 8006376:	f503 60e9 	add.w	r0, r3, #1864	; 0x748
 800637a:	68fb      	ldr	r3, [r7, #12]
 800637c:	f503 61c6 	add.w	r1, r3, #1584	; 0x630
 8006380:	68fb      	ldr	r3, [r7, #12]
 8006382:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 8006386:	461a      	mov	r2, r3
 8006388:	f7fb f99d 	bl	80016c6 <curve448Add>
   //Compute G = F - 2 * C
   curve448Add(state->c, state->c, state->c);
 800638c:	68fb      	ldr	r3, [r7, #12]
 800638e:	f503 60d4 	add.w	r0, r3, #1696	; 0x6a0
 8006392:	68fb      	ldr	r3, [r7, #12]
 8006394:	f503 61d4 	add.w	r1, r3, #1696	; 0x6a0
 8006398:	68fb      	ldr	r3, [r7, #12]
 800639a:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 800639e:	461a      	mov	r2, r3
 80063a0:	f7fb f991 	bl	80016c6 <curve448Add>
   curve448Sub(state->g, state->f, state->c);
 80063a4:	68fb      	ldr	r3, [r7, #12]
 80063a6:	f503 60f0 	add.w	r0, r3, #1920	; 0x780
 80063aa:	68fb      	ldr	r3, [r7, #12]
 80063ac:	f503 61e9 	add.w	r1, r3, #1864	; 0x748
 80063b0:	68fb      	ldr	r3, [r7, #12]
 80063b2:	f503 63d4 	add.w	r3, r3, #1696	; 0x6a0
 80063b6:	461a      	mov	r2, r3
 80063b8:	f7fb f9da 	bl	8001770 <curve448Sub>
   //Compute D = (X1 + Y1)^2
   curve448Add(state->d, p->x, p->y);
 80063bc:	68fb      	ldr	r3, [r7, #12]
 80063be:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 80063c2:	6879      	ldr	r1, [r7, #4]
 80063c4:	687b      	ldr	r3, [r7, #4]
 80063c6:	3338      	adds	r3, #56	; 0x38
 80063c8:	461a      	mov	r2, r3
 80063ca:	f7fb f97c 	bl	80016c6 <curve448Add>
   curve448Sqr(state->d, state->d);
 80063ce:	68fb      	ldr	r3, [r7, #12]
 80063d0:	f503 62db 	add.w	r2, r3, #1752	; 0x6d8
 80063d4:	68fb      	ldr	r3, [r7, #12]
 80063d6:	f503 63db 	add.w	r3, r3, #1752	; 0x6d8
 80063da:	4619      	mov	r1, r3
 80063dc:	4610      	mov	r0, r2
 80063de:	f7fb fdc5 	bl	8001f6c <curve448Sqr>
   //Compute X3 = G * (D - F)
   curve448Sub(state->d, state->d, state->f);
 80063e2:	68fb      	ldr	r3, [r7, #12]
 80063e4:	f503 60db 	add.w	r0, r3, #1752	; 0x6d8
 80063e8:	68fb      	ldr	r3, [r7, #12]
 80063ea:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 80063ee:	68fb      	ldr	r3, [r7, #12]
 80063f0:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 80063f4:	461a      	mov	r2, r3
 80063f6:	f7fb f9bb 	bl	8001770 <curve448Sub>
   curve448Mul(r->x, state->d, state->g);
 80063fa:	68b8      	ldr	r0, [r7, #8]
 80063fc:	68fb      	ldr	r3, [r7, #12]
 80063fe:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
 8006402:	68fb      	ldr	r3, [r7, #12]
 8006404:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
 8006408:	461a      	mov	r2, r3
 800640a:	f7fb faf3 	bl	80019f4 <curve448Mul>
   //Compute Y3 = F * (A - B)
   curve448Sub(state->a, state->a, state->b);
 800640e:	68fb      	ldr	r3, [r7, #12]
 8006410:	f503 60c6 	add.w	r0, r3, #1584	; 0x630
 8006414:	68fb      	ldr	r3, [r7, #12]
 8006416:	f503 61c6 	add.w	r1, r3, #1584	; 0x630
 800641a:	68fb      	ldr	r3, [r7, #12]
 800641c:	f503 63cd 	add.w	r3, r3, #1640	; 0x668
 8006420:	461a      	mov	r2, r3
 8006422:	f7fb f9a5 	bl	8001770 <curve448Sub>
   curve448Mul(r->y, state->a, state->f);
 8006426:	68bb      	ldr	r3, [r7, #8]
 8006428:	f103 0038 	add.w	r0, r3, #56	; 0x38
 800642c:	68fb      	ldr	r3, [r7, #12]
 800642e:	f503 61c6 	add.w	r1, r3, #1584	; 0x630
 8006432:	68fb      	ldr	r3, [r7, #12]
 8006434:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
 8006438:	461a      	mov	r2, r3
 800643a:	f7fb fadb 	bl	80019f4 <curve448Mul>
   //Compute Z3 = F * G
   curve448Mul(r->z, state->f, state->g);
 800643e:	68bb      	ldr	r3, [r7, #8]
 8006440:	f103 0070 	add.w	r0, r3, #112	; 0x70
 8006444:	68fb      	ldr	r3, [r7, #12]
 8006446:	f503 61e9 	add.w	r1, r3, #1864	; 0x748
 800644a:	68fb      	ldr	r3, [r7, #12]
 800644c:	f503 63f0 	add.w	r3, r3, #1920	; 0x780
 8006450:	461a      	mov	r2, r3
 8006452:	f7fb facf 	bl	80019f4 <curve448Mul>
}
 8006456:	bf00      	nop
 8006458:	3710      	adds	r7, #16
 800645a:	46bd      	mov	sp, r7
 800645c:	bd80      	pop	{r7, pc}

0800645e <ed448Encode>:
 * @param[in] p Point representation
 * @param[out] data Octet string resulting from the conversion
 **/

void ed448Encode(Ed448Point *p, uint8_t *data)
{
 800645e:	b580      	push	{r7, lr}
 8006460:	b082      	sub	sp, #8
 8006462:	af00      	add	r7, sp, #0
 8006464:	6078      	str	r0, [r7, #4]
 8006466:	6039      	str	r1, [r7, #0]
   //Retrieve affine representation
   curve448Inv(p->z, p->z);
 8006468:	687b      	ldr	r3, [r7, #4]
 800646a:	f103 0270 	add.w	r2, r3, #112	; 0x70
 800646e:	687b      	ldr	r3, [r7, #4]
 8006470:	3370      	adds	r3, #112	; 0x70
 8006472:	4619      	mov	r1, r3
 8006474:	4610      	mov	r0, r2
 8006476:	f7fb fe2b 	bl	80020d0 <curve448Inv>
   curve448Mul(p->x, p->x, p->z);
 800647a:	6878      	ldr	r0, [r7, #4]
 800647c:	6879      	ldr	r1, [r7, #4]
 800647e:	687b      	ldr	r3, [r7, #4]
 8006480:	3370      	adds	r3, #112	; 0x70
 8006482:	461a      	mov	r2, r3
 8006484:	f7fb fab6 	bl	80019f4 <curve448Mul>
   curve448Mul(p->y, p->y, p->z);
 8006488:	687b      	ldr	r3, [r7, #4]
 800648a:	f103 0038 	add.w	r0, r3, #56	; 0x38
 800648e:	687b      	ldr	r3, [r7, #4]
 8006490:	f103 0138 	add.w	r1, r3, #56	; 0x38
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	3370      	adds	r3, #112	; 0x70
 8006498:	461a      	mov	r2, r3
 800649a:	f7fb faab 	bl	80019f4 <curve448Mul>
   curve448SetInt(p->z, 1);
 800649e:	687b      	ldr	r3, [r7, #4]
 80064a0:	3370      	adds	r3, #112	; 0x70
 80064a2:	2101      	movs	r1, #1
 80064a4:	4618      	mov	r0, r3
 80064a6:	f7fb f8f0 	bl	800168a <curve448SetInt>

   //Encode the y-coordinate as a little-endian string of 57 octets. The final
   //octet is always zero
   curve448Export(p->y, data);
 80064aa:	687b      	ldr	r3, [r7, #4]
 80064ac:	3338      	adds	r3, #56	; 0x38
 80064ae:	6839      	ldr	r1, [r7, #0]
 80064b0:	4618      	mov	r0, r3
 80064b2:	f7fc f910 	bl	80026d6 <curve448Export>
   data[56] = 0;
 80064b6:	683b      	ldr	r3, [r7, #0]
 80064b8:	3338      	adds	r3, #56	; 0x38
 80064ba:	2200      	movs	r2, #0
 80064bc:	701a      	strb	r2, [r3, #0]

   //Copy the least significant bit of the x-coordinate to the most significant
   //bit of the final octet
   data[56] |= (p->x[0] & 1) << 7;
 80064be:	683b      	ldr	r3, [r7, #0]
 80064c0:	3338      	adds	r3, #56	; 0x38
 80064c2:	7819      	ldrb	r1, [r3, #0]
 80064c4:	687b      	ldr	r3, [r7, #4]
 80064c6:	681b      	ldr	r3, [r3, #0]
 80064c8:	b2db      	uxtb	r3, r3
 80064ca:	01db      	lsls	r3, r3, #7
 80064cc:	b2da      	uxtb	r2, r3
 80064ce:	683b      	ldr	r3, [r7, #0]
 80064d0:	3338      	adds	r3, #56	; 0x38
 80064d2:	430a      	orrs	r2, r1
 80064d4:	b2d2      	uxtb	r2, r2
 80064d6:	701a      	strb	r2, [r3, #0]
}
 80064d8:	bf00      	nop
 80064da:	3708      	adds	r7, #8
 80064dc:	46bd      	mov	sp, r7
 80064de:	bd80      	pop	{r7, pc}

080064e0 <ed448Decode>:
 * @param[in] p Point representation
 * @param[out] data Octet string to be converted
 **/

uint32_t ed448Decode(Ed448Point *p, const uint8_t *data)
{
 80064e0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80064e4:	b0ae      	sub	sp, #184	; 0xb8
 80064e6:	af00      	add	r7, sp, #0
 80064e8:	62f8      	str	r0, [r7, #44]	; 0x2c
 80064ea:	62b9      	str	r1, [r7, #40]	; 0x28
   uint32_t v[14];

   //First, interpret the string as an integer in little-endian representation.
   //Bit 455 of this number is the least significant bit of the x-coordinate
   //and denote this value x_0
   x0 = data[56] >> 7;
 80064ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064ee:	3338      	adds	r3, #56	; 0x38
 80064f0:	781b      	ldrb	r3, [r3, #0]
 80064f2:	09db      	lsrs	r3, r3, #7
 80064f4:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7

   //The y-coordinate is recovered simply by clearing this bit
   curve448Import(p->y, data);
 80064f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80064fa:	3338      	adds	r3, #56	; 0x38
 80064fc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80064fe:	4618      	mov	r0, r3
 8006500:	f7fc f8c7 	bl	8002692 <curve448Import>

   //Compute u = y + 2^224 + 1
   for(temp = 1, i = 0; i < 7; i++)
 8006504:	f04f 0201 	mov.w	r2, #1
 8006508:	f04f 0300 	mov.w	r3, #0
 800650c:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
 8006510:	2300      	movs	r3, #0
 8006512:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8006516:	e02e      	b.n	8006576 <ed448Decode+0x96>
   {
      temp += p->y[i];
 8006518:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800651a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800651e:	330e      	adds	r3, #14
 8006520:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8006524:	2200      	movs	r2, #0
 8006526:	623b      	str	r3, [r7, #32]
 8006528:	627a      	str	r2, [r7, #36]	; 0x24
 800652a:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	; 0xa8
 800652e:	6a39      	ldr	r1, [r7, #32]
 8006530:	1851      	adds	r1, r2, r1
 8006532:	6139      	str	r1, [r7, #16]
 8006534:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8006536:	414b      	adcs	r3, r1
 8006538:	617b      	str	r3, [r7, #20]
 800653a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800653e:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
      u[i] = temp & 0xFFFFFFFF;
 8006542:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8006546:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800654a:	009b      	lsls	r3, r3, #2
 800654c:	3390      	adds	r3, #144	; 0x90
 800654e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8006552:	440b      	add	r3, r1
 8006554:	f843 2c50 	str.w	r2, [r3, #-80]
      temp >>= 32;
 8006558:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	; 0xa8
 800655c:	f04f 0000 	mov.w	r0, #0
 8006560:	f04f 0100 	mov.w	r1, #0
 8006564:	0018      	movs	r0, r3
 8006566:	2100      	movs	r1, #0
 8006568:	e9c7 012a 	strd	r0, r1, [r7, #168]	; 0xa8
   for(temp = 1, i = 0; i < 7; i++)
 800656c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8006570:	3301      	adds	r3, #1
 8006572:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8006576:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800657a:	2b06      	cmp	r3, #6
 800657c:	d9cc      	bls.n	8006518 <ed448Decode+0x38>
   }

   for(temp += 1, i = 7; i < 14; i++)
 800657e:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	; 0xa8
 8006582:	1c51      	adds	r1, r2, #1
 8006584:	60b9      	str	r1, [r7, #8]
 8006586:	f143 0300 	adc.w	r3, r3, #0
 800658a:	60fb      	str	r3, [r7, #12]
 800658c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8006590:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
 8006594:	2307      	movs	r3, #7
 8006596:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800659a:	e02e      	b.n	80065fa <ed448Decode+0x11a>
   {
      temp += p->y[i];
 800659c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800659e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80065a2:	320e      	adds	r2, #14
 80065a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80065a8:	2200      	movs	r2, #0
 80065aa:	4698      	mov	r8, r3
 80065ac:	4691      	mov	r9, r2
 80065ae:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	; 0xa8
 80065b2:	eb12 0108 	adds.w	r1, r2, r8
 80065b6:	6039      	str	r1, [r7, #0]
 80065b8:	eb43 0309 	adc.w	r3, r3, r9
 80065bc:	607b      	str	r3, [r7, #4]
 80065be:	e9d7 2300 	ldrd	r2, r3, [r7]
 80065c2:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
      u[i] = temp & 0xFFFFFFFF;
 80065c6:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80065ca:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80065ce:	009b      	lsls	r3, r3, #2
 80065d0:	3390      	adds	r3, #144	; 0x90
 80065d2:	f107 0128 	add.w	r1, r7, #40	; 0x28
 80065d6:	440b      	add	r3, r1
 80065d8:	f843 2c50 	str.w	r2, [r3, #-80]
      temp >>= 32;
 80065dc:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	; 0xa8
 80065e0:	f04f 0200 	mov.w	r2, #0
 80065e4:	f04f 0300 	mov.w	r3, #0
 80065e8:	000a      	movs	r2, r1
 80065ea:	2300      	movs	r3, #0
 80065ec:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
   for(temp += 1, i = 7; i < 14; i++)
 80065f0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80065f4:	3301      	adds	r3, #1
 80065f6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80065fa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80065fe:	2b0d      	cmp	r3, #13
 8006600:	d9cc      	bls.n	800659c <ed448Decode+0xbc>
   }

   temp += data[56] & 0x7F;
 8006602:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006604:	3338      	adds	r3, #56	; 0x38
 8006606:	781b      	ldrb	r3, [r3, #0]
 8006608:	b2db      	uxtb	r3, r3
 800660a:	2200      	movs	r2, #0
 800660c:	61bb      	str	r3, [r7, #24]
 800660e:	61fa      	str	r2, [r7, #28]
 8006610:	69bb      	ldr	r3, [r7, #24]
 8006612:	f003 047f 	and.w	r4, r3, #127	; 0x7f
 8006616:	2500      	movs	r5, #0
 8006618:	e9d7 232a 	ldrd	r2, r3, [r7, #168]	; 0xa8
 800661c:	eb12 0a04 	adds.w	sl, r2, r4
 8006620:	eb43 0b05 	adc.w	fp, r3, r5
 8006624:	e9c7 ab2a 	strd	sl, fp, [r7, #168]	; 0xa8
   ret = temp & 0xFFFFFFFF;
 8006628:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800662c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   //If the y-coordinate is >= p, decoding fails
   ret = (ret | (~ret + 1)) >> 31;
 8006630:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8006634:	425a      	negs	r2, r3
 8006636:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800663a:	4313      	orrs	r3, r2
 800663c:	0fdb      	lsrs	r3, r3, #31
 800663e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   //The curve equation implies x^2 = (y^2 - 1) / (d * y^2 - 1) mod p
   //Let u = y^2 - 1 and v = d * y^2 - 1
   curve448Sqr(v, p->y);
 8006642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006644:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8006648:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800664c:	4611      	mov	r1, r2
 800664e:	4618      	mov	r0, r3
 8006650:	f7fb fc8c 	bl	8001f6c <curve448Sqr>
   curve448SubInt(u, v, 1);
 8006654:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8006658:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800665c:	2201      	movs	r2, #1
 800665e:	4618      	mov	r0, r3
 8006660:	f7fb f932 	bl	80018c8 <curve448SubInt>
   curve448Mul(v, v, ED448_D);
 8006664:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8006668:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800666c:	4a26      	ldr	r2, [pc, #152]	; (8006708 <ed448Decode+0x228>)
 800666e:	4618      	mov	r0, r3
 8006670:	f7fb f9c0 	bl	80019f4 <curve448Mul>
   curve448SubInt(v, v, 1);
 8006674:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8006678:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800667c:	2201      	movs	r2, #1
 800667e:	4618      	mov	r0, r3
 8006680:	f7fb f922 	bl	80018c8 <curve448SubInt>

   //Compute u = sqrt(u / v)
   ret |= curve448Sqrt(u, u, v);
 8006684:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8006688:	f107 0168 	add.w	r1, r7, #104	; 0x68
 800668c:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8006690:	4618      	mov	r0, r3
 8006692:	f7fb fe22 	bl	80022da <curve448Sqrt>
 8006696:	4602      	mov	r2, r0
 8006698:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800669c:	4313      	orrs	r3, r2
 800669e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   //If x = 0, and x_0 = 1, decoding fails
   ret |= (curve448Comp(u, ED448_ZERO) ^ 1) & x0;
 80066a2:	f107 0368 	add.w	r3, r7, #104	; 0x68
 80066a6:	4919      	ldr	r1, [pc, #100]	; (800670c <ed448Decode+0x22c>)
 80066a8:	4618      	mov	r0, r3
 80066aa:	f7fb ffc9 	bl	8002640 <curve448Comp>
 80066ae:	4603      	mov	r3, r0
 80066b0:	f083 0201 	eor.w	r2, r3, #1
 80066b4:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 80066b8:	4013      	ands	r3, r2
 80066ba:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 80066be:	4313      	orrs	r3, r2
 80066c0:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   //Compute v = p - u
   curve448Sub(v, ED448_ZERO, u);
 80066c4:	f107 0268 	add.w	r2, r7, #104	; 0x68
 80066c8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80066cc:	490f      	ldr	r1, [pc, #60]	; (800670c <ed448Decode+0x22c>)
 80066ce:	4618      	mov	r0, r3
 80066d0:	f7fb f84e 	bl	8001770 <curve448Sub>

   //Finally, use the x_0 bit to select the right square root
   curve448Select(p->x, u, v, (x0 ^ u[0]) & 1);
 80066d4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80066d6:	f897 20a7 	ldrb.w	r2, [r7, #167]	; 0xa7
 80066da:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80066dc:	4053      	eors	r3, r2
 80066de:	f003 0301 	and.w	r3, r3, #1
 80066e2:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80066e6:	f107 0168 	add.w	r1, r7, #104	; 0x68
 80066ea:	f7fb ff79 	bl	80025e0 <curve448Select>

   //Initialize z-coordinate (projective representation)
   curve448SetInt(p->z, 1);
 80066ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80066f0:	3370      	adds	r3, #112	; 0x70
 80066f2:	2101      	movs	r1, #1
 80066f4:	4618      	mov	r0, r3
 80066f6:	f7fa ffc8 	bl	800168a <curve448SetInt>

   //Return 0 if the point has been successfully decoded, else 1
   return ret;
 80066fa:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
}
 80066fe:	4618      	mov	r0, r3
 8006700:	37b8      	adds	r7, #184	; 0xb8
 8006702:	46bd      	mov	sp, r7
 8006704:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006708:	0800f380 	.word	0x0800f380
 800670c:	0800f348 	.word	0x0800f348

08006710 <ed448RedInt>:
 * @param[out] r Resulting integer R = A mod L
 * @param[in] a An integer such as 0 <= A < b^(2 * k)
 **/

void ed448RedInt(uint8_t *r, const uint8_t *a)
{
 8006710:	b590      	push	{r4, r7, lr}
 8006712:	b0a5      	sub	sp, #148	; 0x94
 8006714:	af02      	add	r7, sp, #8
 8006716:	6078      	str	r0, [r7, #4]
 8006718:	6039      	str	r1, [r7, #0]
   uint8_t c;
   uint8_t u[60];
   uint8_t v[60];

   //Compute the estimate of the quotient u = ((a / b^(k - 1)) * mu) / b^(k + 1)
   ed448MulInt(NULL, u, a + 54, ED448_MU, 60);
 800671a:	683b      	ldr	r3, [r7, #0]
 800671c:	f103 0236 	add.w	r2, r3, #54	; 0x36
 8006720:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8006724:	233c      	movs	r3, #60	; 0x3c
 8006726:	9300      	str	r3, [sp, #0]
 8006728:	4b27      	ldr	r3, [pc, #156]	; (80067c8 <ed448RedInt+0xb8>)
 800672a:	2000      	movs	r0, #0
 800672c:	f000 f8be 	bl	80068ac <ed448MulInt>
   //Compute v = u * L mod b^(k + 1)
   ed448MulInt(v, NULL, u, ED448_L, 60);
 8006730:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8006734:	f107 000c 	add.w	r0, r7, #12
 8006738:	233c      	movs	r3, #60	; 0x3c
 800673a:	9300      	str	r3, [sp, #0]
 800673c:	4b23      	ldr	r3, [pc, #140]	; (80067cc <ed448RedInt+0xbc>)
 800673e:	2100      	movs	r1, #0
 8006740:	f000 f8b4 	bl	80068ac <ed448MulInt>

   //Compute the estimate of the remainder u = a mod b^(k + 1) - v
   //If u < 0, then u = u + b^(k + 1)
   ed448SubInt(u, a, v, 60);
 8006744:	f107 020c 	add.w	r2, r7, #12
 8006748:	f107 0048 	add.w	r0, r7, #72	; 0x48
 800674c:	233c      	movs	r3, #60	; 0x3c
 800674e:	6839      	ldr	r1, [r7, #0]
 8006750:	f000 f871 	bl	8006836 <ed448SubInt>

   //This estimation implies that at most two subtractions of L are required to
   //obtain the correct remainder r
   c = ed448SubInt(v, u, ED448_L, 60);
 8006754:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8006758:	f107 000c 	add.w	r0, r7, #12
 800675c:	233c      	movs	r3, #60	; 0x3c
 800675e:	4a1b      	ldr	r2, [pc, #108]	; (80067cc <ed448RedInt+0xbc>)
 8006760:	f000 f869 	bl	8006836 <ed448SubInt>
 8006764:	4603      	mov	r3, r0
 8006766:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
   ed448SelectInt(u, v, u, c, 60);
 800676a:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 800676e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8006772:	f107 010c 	add.w	r1, r7, #12
 8006776:	f107 0048 	add.w	r0, r7, #72	; 0x48
 800677a:	243c      	movs	r4, #60	; 0x3c
 800677c:	9400      	str	r4, [sp, #0]
 800677e:	f000 fa28 	bl	8006bd2 <ed448SelectInt>
   c = ed448SubInt(v, u, ED448_L, 60);
 8006782:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8006786:	f107 000c 	add.w	r0, r7, #12
 800678a:	233c      	movs	r3, #60	; 0x3c
 800678c:	4a0f      	ldr	r2, [pc, #60]	; (80067cc <ed448RedInt+0xbc>)
 800678e:	f000 f852 	bl	8006836 <ed448SubInt>
 8006792:	4603      	mov	r3, r0
 8006794:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
   ed448SelectInt(u, v, u, c, 60);
 8006798:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 800679c:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80067a0:	f107 010c 	add.w	r1, r7, #12
 80067a4:	f107 0048 	add.w	r0, r7, #72	; 0x48
 80067a8:	243c      	movs	r4, #60	; 0x3c
 80067aa:	9400      	str	r4, [sp, #0]
 80067ac:	f000 fa11 	bl	8006bd2 <ed448SelectInt>

   //Copy the resulting remainder
   ed448CopyInt(r, u, 57);
 80067b0:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80067b4:	2239      	movs	r2, #57	; 0x39
 80067b6:	4619      	mov	r1, r3
 80067b8:	6878      	ldr	r0, [r7, #4]
 80067ba:	f000 f9eb 	bl	8006b94 <ed448CopyInt>
}
 80067be:	bf00      	nop
 80067c0:	378c      	adds	r7, #140	; 0x8c
 80067c2:	46bd      	mov	sp, r7
 80067c4:	bd90      	pop	{r4, r7, pc}
 80067c6:	bf00      	nop
 80067c8:	0800f3f4 	.word	0x0800f3f4
 80067cc:	0800f3b8 	.word	0x0800f3b8

080067d0 <ed448AddInt>:
 * @param[in] b An integer such as 0 <= B < (2^8)^n
 * @param[in] n Size of the operands, in bytes
 **/

void ed448AddInt(uint8_t *r, const uint8_t *a, const uint8_t *b, uint_t n)
{
 80067d0:	b480      	push	{r7}
 80067d2:	b087      	sub	sp, #28
 80067d4:	af00      	add	r7, sp, #0
 80067d6:	60f8      	str	r0, [r7, #12]
 80067d8:	60b9      	str	r1, [r7, #8]
 80067da:	607a      	str	r2, [r7, #4]
 80067dc:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint16_t temp;

   //Compute R = A + B
   for(temp = 0, i = 0; i < n; i++)
 80067de:	2300      	movs	r3, #0
 80067e0:	827b      	strh	r3, [r7, #18]
 80067e2:	2300      	movs	r3, #0
 80067e4:	617b      	str	r3, [r7, #20]
 80067e6:	e01b      	b.n	8006820 <ed448AddInt+0x50>
   {
      temp += a[i];
 80067e8:	68ba      	ldr	r2, [r7, #8]
 80067ea:	697b      	ldr	r3, [r7, #20]
 80067ec:	4413      	add	r3, r2
 80067ee:	781b      	ldrb	r3, [r3, #0]
 80067f0:	b29a      	uxth	r2, r3
 80067f2:	8a7b      	ldrh	r3, [r7, #18]
 80067f4:	4413      	add	r3, r2
 80067f6:	827b      	strh	r3, [r7, #18]
      temp += b[i];
 80067f8:	687a      	ldr	r2, [r7, #4]
 80067fa:	697b      	ldr	r3, [r7, #20]
 80067fc:	4413      	add	r3, r2
 80067fe:	781b      	ldrb	r3, [r3, #0]
 8006800:	b29a      	uxth	r2, r3
 8006802:	8a7b      	ldrh	r3, [r7, #18]
 8006804:	4413      	add	r3, r2
 8006806:	827b      	strh	r3, [r7, #18]
      r[i] = temp & 0xFF;
 8006808:	68fa      	ldr	r2, [r7, #12]
 800680a:	697b      	ldr	r3, [r7, #20]
 800680c:	4413      	add	r3, r2
 800680e:	8a7a      	ldrh	r2, [r7, #18]
 8006810:	b2d2      	uxtb	r2, r2
 8006812:	701a      	strb	r2, [r3, #0]
      temp >>= 8;
 8006814:	8a7b      	ldrh	r3, [r7, #18]
 8006816:	0a1b      	lsrs	r3, r3, #8
 8006818:	827b      	strh	r3, [r7, #18]
   for(temp = 0, i = 0; i < n; i++)
 800681a:	697b      	ldr	r3, [r7, #20]
 800681c:	3301      	adds	r3, #1
 800681e:	617b      	str	r3, [r7, #20]
 8006820:	697a      	ldr	r2, [r7, #20]
 8006822:	683b      	ldr	r3, [r7, #0]
 8006824:	429a      	cmp	r2, r3
 8006826:	d3df      	bcc.n	80067e8 <ed448AddInt+0x18>
   }
}
 8006828:	bf00      	nop
 800682a:	bf00      	nop
 800682c:	371c      	adds	r7, #28
 800682e:	46bd      	mov	sp, r7
 8006830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006834:	4770      	bx	lr

08006836 <ed448SubInt>:
 * @param[in] n Size of the operands, in bytes
 * @return 1 if the result is negative, else 0
 **/

uint8_t ed448SubInt(uint8_t *r, const uint8_t *a, const uint8_t *b, uint_t n)
{
 8006836:	b480      	push	{r7}
 8006838:	b087      	sub	sp, #28
 800683a:	af00      	add	r7, sp, #0
 800683c:	60f8      	str	r0, [r7, #12]
 800683e:	60b9      	str	r1, [r7, #8]
 8006840:	607a      	str	r2, [r7, #4]
 8006842:	603b      	str	r3, [r7, #0]
   uint_t i;
   int16_t temp;

   //Compute R = A - B
   for(temp = 0, i = 0; i < n; i++)
 8006844:	2300      	movs	r3, #0
 8006846:	827b      	strh	r3, [r7, #18]
 8006848:	2300      	movs	r3, #0
 800684a:	617b      	str	r3, [r7, #20]
 800684c:	e01e      	b.n	800688c <ed448SubInt+0x56>
   {
      temp += a[i];
 800684e:	68ba      	ldr	r2, [r7, #8]
 8006850:	697b      	ldr	r3, [r7, #20]
 8006852:	4413      	add	r3, r2
 8006854:	781b      	ldrb	r3, [r3, #0]
 8006856:	b29a      	uxth	r2, r3
 8006858:	8a7b      	ldrh	r3, [r7, #18]
 800685a:	4413      	add	r3, r2
 800685c:	b29b      	uxth	r3, r3
 800685e:	827b      	strh	r3, [r7, #18]
      temp -= b[i];
 8006860:	8a7a      	ldrh	r2, [r7, #18]
 8006862:	6879      	ldr	r1, [r7, #4]
 8006864:	697b      	ldr	r3, [r7, #20]
 8006866:	440b      	add	r3, r1
 8006868:	781b      	ldrb	r3, [r3, #0]
 800686a:	b29b      	uxth	r3, r3
 800686c:	1ad3      	subs	r3, r2, r3
 800686e:	b29b      	uxth	r3, r3
 8006870:	827b      	strh	r3, [r7, #18]
      r[i] = temp & 0xFF;
 8006872:	68fa      	ldr	r2, [r7, #12]
 8006874:	697b      	ldr	r3, [r7, #20]
 8006876:	4413      	add	r3, r2
 8006878:	8a7a      	ldrh	r2, [r7, #18]
 800687a:	b2d2      	uxtb	r2, r2
 800687c:	701a      	strb	r2, [r3, #0]
      temp >>= 8;
 800687e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8006882:	121b      	asrs	r3, r3, #8
 8006884:	827b      	strh	r3, [r7, #18]
   for(temp = 0, i = 0; i < n; i++)
 8006886:	697b      	ldr	r3, [r7, #20]
 8006888:	3301      	adds	r3, #1
 800688a:	617b      	str	r3, [r7, #20]
 800688c:	697a      	ldr	r2, [r7, #20]
 800688e:	683b      	ldr	r3, [r7, #0]
 8006890:	429a      	cmp	r2, r3
 8006892:	d3dc      	bcc.n	800684e <ed448SubInt+0x18>
   }

   //Return 1 if the result of the subtraction is negative
   return temp & 1;
 8006894:	8a7b      	ldrh	r3, [r7, #18]
 8006896:	b2db      	uxtb	r3, r3
 8006898:	f003 0301 	and.w	r3, r3, #1
 800689c:	b2db      	uxtb	r3, r3
}
 800689e:	4618      	mov	r0, r3
 80068a0:	371c      	adds	r7, #28
 80068a2:	46bd      	mov	sp, r7
 80068a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068a8:	4770      	bx	lr
	...

080068ac <ed448MulInt>:
 * @param[in] n Size of the operands, in bytes
 **/

void ed448MulInt(uint8_t *rl, uint8_t *rh, const uint8_t *a,
   const uint8_t *b, uint_t n)
{
 80068ac:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80068b0:	b095      	sub	sp, #84	; 0x54
 80068b2:	af00      	add	r7, sp, #0
 80068b4:	6378      	str	r0, [r7, #52]	; 0x34
 80068b6:	6339      	str	r1, [r7, #48]	; 0x30
 80068b8:	62fa      	str	r2, [r7, #44]	; 0x2c
 80068ba:	62bb      	str	r3, [r7, #40]	; 0x28
   uint32_t c;
   uint32_t d;
   uint64_t temp;

   //Perform multiplication in base b = 2^24
   n /= 3;
 80068bc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80068be:	4bb4      	ldr	r3, [pc, #720]	; (8006b90 <ed448MulInt+0x2e4>)
 80068c0:	fba3 2302 	umull	r2, r3, r3, r2
 80068c4:	085b      	lsrs	r3, r3, #1
 80068c6:	673b      	str	r3, [r7, #112]	; 0x70

   //Compute the low part of the multiplication
   for(temp = 0, i = 0; i < n; i++)
 80068c8:	f04f 0200 	mov.w	r2, #0
 80068cc:	f04f 0300 	mov.w	r3, #0
 80068d0:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
 80068d4:	2300      	movs	r3, #0
 80068d6:	64fb      	str	r3, [r7, #76]	; 0x4c
 80068d8:	e0a1      	b.n	8006a1e <ed448MulInt+0x172>
   {
      //The Comba's algorithm computes the products, column by column
      for(j = 0; j <= i; j++)
 80068da:	2300      	movs	r3, #0
 80068dc:	64bb      	str	r3, [r7, #72]	; 0x48
 80068de:	e069      	b.n	80069b4 <ed448MulInt+0x108>
      {
         c = LOAD24LE(a + 3 * j);
 80068e0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80068e2:	4613      	mov	r3, r2
 80068e4:	005b      	lsls	r3, r3, #1
 80068e6:	441a      	add	r2, r3
 80068e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80068ea:	4413      	add	r3, r2
 80068ec:	781b      	ldrb	r3, [r3, #0]
 80068ee:	4619      	mov	r1, r3
 80068f0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80068f2:	4613      	mov	r3, r2
 80068f4:	005b      	lsls	r3, r3, #1
 80068f6:	441a      	add	r2, r3
 80068f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80068fa:	4413      	add	r3, r2
 80068fc:	3301      	adds	r3, #1
 80068fe:	781b      	ldrb	r3, [r3, #0]
 8006900:	021b      	lsls	r3, r3, #8
 8006902:	4319      	orrs	r1, r3
 8006904:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006906:	4613      	mov	r3, r2
 8006908:	005b      	lsls	r3, r3, #1
 800690a:	441a      	add	r2, r3
 800690c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800690e:	4413      	add	r3, r2
 8006910:	3302      	adds	r3, #2
 8006912:	781b      	ldrb	r3, [r3, #0]
 8006914:	041b      	lsls	r3, r3, #16
 8006916:	430b      	orrs	r3, r1
 8006918:	63fb      	str	r3, [r7, #60]	; 0x3c
         d = LOAD24LE(b + 3 * (i - j));
 800691a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800691c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800691e:	1ad2      	subs	r2, r2, r3
 8006920:	4613      	mov	r3, r2
 8006922:	005b      	lsls	r3, r3, #1
 8006924:	441a      	add	r2, r3
 8006926:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006928:	4413      	add	r3, r2
 800692a:	781b      	ldrb	r3, [r3, #0]
 800692c:	4619      	mov	r1, r3
 800692e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006930:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006932:	1ad2      	subs	r2, r2, r3
 8006934:	4613      	mov	r3, r2
 8006936:	005b      	lsls	r3, r3, #1
 8006938:	441a      	add	r2, r3
 800693a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800693c:	4413      	add	r3, r2
 800693e:	3301      	adds	r3, #1
 8006940:	781b      	ldrb	r3, [r3, #0]
 8006942:	021b      	lsls	r3, r3, #8
 8006944:	4319      	orrs	r1, r3
 8006946:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006948:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800694a:	1ad2      	subs	r2, r2, r3
 800694c:	4613      	mov	r3, r2
 800694e:	005b      	lsls	r3, r3, #1
 8006950:	441a      	add	r2, r3
 8006952:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006954:	4413      	add	r3, r2
 8006956:	3302      	adds	r3, #2
 8006958:	781b      	ldrb	r3, [r3, #0]
 800695a:	041b      	lsls	r3, r3, #16
 800695c:	430b      	orrs	r3, r1
 800695e:	63bb      	str	r3, [r7, #56]	; 0x38
         temp += (uint64_t) c * d;
 8006960:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006962:	2200      	movs	r2, #0
 8006964:	623b      	str	r3, [r7, #32]
 8006966:	627a      	str	r2, [r7, #36]	; 0x24
 8006968:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800696a:	2200      	movs	r2, #0
 800696c:	61bb      	str	r3, [r7, #24]
 800696e:	61fa      	str	r2, [r7, #28]
 8006970:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8006974:	460b      	mov	r3, r1
 8006976:	69ba      	ldr	r2, [r7, #24]
 8006978:	fb02 f203 	mul.w	r2, r2, r3
 800697c:	69fb      	ldr	r3, [r7, #28]
 800697e:	e9c7 0108 	strd	r0, r1, [r7, #32]
 8006982:	4601      	mov	r1, r0
 8006984:	fb01 f303 	mul.w	r3, r1, r3
 8006988:	4413      	add	r3, r2
 800698a:	6a3a      	ldr	r2, [r7, #32]
 800698c:	69b9      	ldr	r1, [r7, #24]
 800698e:	fba2 8901 	umull	r8, r9, r2, r1
 8006992:	444b      	add	r3, r9
 8006994:	4699      	mov	r9, r3
 8006996:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800699a:	eb12 0108 	adds.w	r1, r2, r8
 800699e:	60b9      	str	r1, [r7, #8]
 80069a0:	eb43 0309 	adc.w	r3, r3, r9
 80069a4:	60fb      	str	r3, [r7, #12]
 80069a6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80069aa:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
      for(j = 0; j <= i; j++)
 80069ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80069b0:	3301      	adds	r3, #1
 80069b2:	64bb      	str	r3, [r7, #72]	; 0x48
 80069b4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80069b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80069b8:	429a      	cmp	r2, r3
 80069ba:	d991      	bls.n	80068e0 <ed448MulInt+0x34>
      }

      //At the bottom of each column, the final result is written to memory
      if(rl != NULL)
 80069bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069be:	2b00      	cmp	r3, #0
 80069c0:	d01e      	beq.n	8006a00 <ed448MulInt+0x154>
      {
         STORE24LE(temp & 0xFFFFFF, rl + 3 * i);
 80069c2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80069c4:	4613      	mov	r3, r2
 80069c6:	005b      	lsls	r3, r3, #1
 80069c8:	441a      	add	r2, r3
 80069ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069cc:	441a      	add	r2, r3
 80069ce:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80069d2:	7013      	strb	r3, [r2, #0]
 80069d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80069d6:	0a19      	lsrs	r1, r3, #8
 80069d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80069da:	4613      	mov	r3, r2
 80069dc:	005b      	lsls	r3, r3, #1
 80069de:	4413      	add	r3, r2
 80069e0:	1c5a      	adds	r2, r3, #1
 80069e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069e4:	441a      	add	r2, r3
 80069e6:	b2cb      	uxtb	r3, r1
 80069e8:	7013      	strb	r3, [r2, #0]
 80069ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80069ec:	0c19      	lsrs	r1, r3, #16
 80069ee:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80069f0:	4613      	mov	r3, r2
 80069f2:	005b      	lsls	r3, r3, #1
 80069f4:	4413      	add	r3, r2
 80069f6:	1c9a      	adds	r2, r3, #2
 80069f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069fa:	441a      	add	r2, r3
 80069fc:	b2cb      	uxtb	r3, r1
 80069fe:	7013      	strb	r3, [r2, #0]
      }

      //Propagate the carry upwards
      temp >>= 24;
 8006a00:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8006a04:	f04f 0000 	mov.w	r0, #0
 8006a08:	f04f 0100 	mov.w	r1, #0
 8006a0c:	0e10      	lsrs	r0, r2, #24
 8006a0e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8006a12:	0e19      	lsrs	r1, r3, #24
 8006a14:	e9c7 0110 	strd	r0, r1, [r7, #64]	; 0x40
   for(temp = 0, i = 0; i < n; i++)
 8006a18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006a1a:	3301      	adds	r3, #1
 8006a1c:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006a1e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006a20:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006a22:	429a      	cmp	r2, r3
 8006a24:	f4ff af59 	bcc.w	80068da <ed448MulInt+0x2e>
   }

   //Check whether the high part of the multiplication should be calculated
   if(rh != NULL)
 8006a28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006a2a:	2b00      	cmp	r3, #0
 8006a2c:	f000 80aa 	beq.w	8006b84 <ed448MulInt+0x2d8>
   {
      //Compute the high part of the multiplication
      for(i = n; i < (2 * n); i++)
 8006a30:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006a32:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006a34:	e0a0      	b.n	8006b78 <ed448MulInt+0x2cc>
      {
         //The Comba's algorithm computes the products, column by column
         for(j = i + 1 - n; j < n; j++)
 8006a36:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006a38:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006a3a:	1ad3      	subs	r3, r2, r3
 8006a3c:	3301      	adds	r3, #1
 8006a3e:	64bb      	str	r3, [r7, #72]	; 0x48
 8006a40:	e062      	b.n	8006b08 <ed448MulInt+0x25c>
         {
            c = LOAD24LE(a + 3 * j);
 8006a42:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006a44:	4613      	mov	r3, r2
 8006a46:	005b      	lsls	r3, r3, #1
 8006a48:	4413      	add	r3, r2
 8006a4a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006a4c:	4413      	add	r3, r2
 8006a4e:	781b      	ldrb	r3, [r3, #0]
 8006a50:	4619      	mov	r1, r3
 8006a52:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006a54:	4613      	mov	r3, r2
 8006a56:	005b      	lsls	r3, r3, #1
 8006a58:	4413      	add	r3, r2
 8006a5a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006a5c:	4413      	add	r3, r2
 8006a5e:	3301      	adds	r3, #1
 8006a60:	781b      	ldrb	r3, [r3, #0]
 8006a62:	021b      	lsls	r3, r3, #8
 8006a64:	4319      	orrs	r1, r3
 8006a66:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006a68:	4613      	mov	r3, r2
 8006a6a:	005b      	lsls	r3, r3, #1
 8006a6c:	4413      	add	r3, r2
 8006a6e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006a70:	4413      	add	r3, r2
 8006a72:	3302      	adds	r3, #2
 8006a74:	781b      	ldrb	r3, [r3, #0]
 8006a76:	041b      	lsls	r3, r3, #16
 8006a78:	430b      	orrs	r3, r1
 8006a7a:	63fb      	str	r3, [r7, #60]	; 0x3c
            d = LOAD24LE(b + 3 * (i - j));
 8006a7c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006a7e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006a80:	1ad2      	subs	r2, r2, r3
 8006a82:	4613      	mov	r3, r2
 8006a84:	005b      	lsls	r3, r3, #1
 8006a86:	4413      	add	r3, r2
 8006a88:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006a8a:	4413      	add	r3, r2
 8006a8c:	781b      	ldrb	r3, [r3, #0]
 8006a8e:	4619      	mov	r1, r3
 8006a90:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006a92:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006a94:	1ad2      	subs	r2, r2, r3
 8006a96:	4613      	mov	r3, r2
 8006a98:	005b      	lsls	r3, r3, #1
 8006a9a:	4413      	add	r3, r2
 8006a9c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006a9e:	4413      	add	r3, r2
 8006aa0:	3301      	adds	r3, #1
 8006aa2:	781b      	ldrb	r3, [r3, #0]
 8006aa4:	021b      	lsls	r3, r3, #8
 8006aa6:	4319      	orrs	r1, r3
 8006aa8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006aaa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006aac:	1ad2      	subs	r2, r2, r3
 8006aae:	4613      	mov	r3, r2
 8006ab0:	005b      	lsls	r3, r3, #1
 8006ab2:	4413      	add	r3, r2
 8006ab4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006ab6:	4413      	add	r3, r2
 8006ab8:	3302      	adds	r3, #2
 8006aba:	781b      	ldrb	r3, [r3, #0]
 8006abc:	041b      	lsls	r3, r3, #16
 8006abe:	430b      	orrs	r3, r1
 8006ac0:	63bb      	str	r3, [r7, #56]	; 0x38
            temp += (uint64_t) c * d;
 8006ac2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006ac4:	2200      	movs	r2, #0
 8006ac6:	469a      	mov	sl, r3
 8006ac8:	4693      	mov	fp, r2
 8006aca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006acc:	2200      	movs	r2, #0
 8006ace:	613b      	str	r3, [r7, #16]
 8006ad0:	617a      	str	r2, [r7, #20]
 8006ad2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8006ad6:	4603      	mov	r3, r0
 8006ad8:	fb03 f20b 	mul.w	r2, r3, fp
 8006adc:	460b      	mov	r3, r1
 8006ade:	fb0a f303 	mul.w	r3, sl, r3
 8006ae2:	4413      	add	r3, r2
 8006ae4:	4602      	mov	r2, r0
 8006ae6:	fbaa 4502 	umull	r4, r5, sl, r2
 8006aea:	442b      	add	r3, r5
 8006aec:	461d      	mov	r5, r3
 8006aee:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8006af2:	1911      	adds	r1, r2, r4
 8006af4:	6039      	str	r1, [r7, #0]
 8006af6:	416b      	adcs	r3, r5
 8006af8:	607b      	str	r3, [r7, #4]
 8006afa:	e9d7 2300 	ldrd	r2, r3, [r7]
 8006afe:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
         for(j = i + 1 - n; j < n; j++)
 8006b02:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006b04:	3301      	adds	r3, #1
 8006b06:	64bb      	str	r3, [r7, #72]	; 0x48
 8006b08:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006b0a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006b0c:	429a      	cmp	r2, r3
 8006b0e:	d398      	bcc.n	8006a42 <ed448MulInt+0x196>
         }

         //At the bottom of each column, the final result is written to memory
         STORE24LE(temp & 0xFFFFFF, rh + 3 * (i - n));
 8006b10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006b12:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006b14:	1ad2      	subs	r2, r2, r3
 8006b16:	4613      	mov	r3, r2
 8006b18:	005b      	lsls	r3, r3, #1
 8006b1a:	4413      	add	r3, r2
 8006b1c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006b1e:	4413      	add	r3, r2
 8006b20:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8006b24:	701a      	strb	r2, [r3, #0]
 8006b26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006b28:	0a19      	lsrs	r1, r3, #8
 8006b2a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006b2c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006b2e:	1ad2      	subs	r2, r2, r3
 8006b30:	4613      	mov	r3, r2
 8006b32:	005b      	lsls	r3, r3, #1
 8006b34:	4413      	add	r3, r2
 8006b36:	3301      	adds	r3, #1
 8006b38:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006b3a:	4413      	add	r3, r2
 8006b3c:	b2ca      	uxtb	r2, r1
 8006b3e:	701a      	strb	r2, [r3, #0]
 8006b40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006b42:	0c19      	lsrs	r1, r3, #16
 8006b44:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006b46:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006b48:	1ad2      	subs	r2, r2, r3
 8006b4a:	4613      	mov	r3, r2
 8006b4c:	005b      	lsls	r3, r3, #1
 8006b4e:	4413      	add	r3, r2
 8006b50:	3302      	adds	r3, #2
 8006b52:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006b54:	4413      	add	r3, r2
 8006b56:	b2ca      	uxtb	r2, r1
 8006b58:	701a      	strb	r2, [r3, #0]

         //Propagate the carry upwards
         temp >>= 24;
 8006b5a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 8006b5e:	f04f 0200 	mov.w	r2, #0
 8006b62:	f04f 0300 	mov.w	r3, #0
 8006b66:	0e02      	lsrs	r2, r0, #24
 8006b68:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006b6c:	0e0b      	lsrs	r3, r1, #24
 8006b6e:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
      for(i = n; i < (2 * n); i++)
 8006b72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006b74:	3301      	adds	r3, #1
 8006b76:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006b78:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006b7a:	005b      	lsls	r3, r3, #1
 8006b7c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006b7e:	429a      	cmp	r2, r3
 8006b80:	f4ff af59 	bcc.w	8006a36 <ed448MulInt+0x18a>
      }
   }
}
 8006b84:	bf00      	nop
 8006b86:	3754      	adds	r7, #84	; 0x54
 8006b88:	46bd      	mov	sp, r7
 8006b8a:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8006b8e:	4770      	bx	lr
 8006b90:	aaaaaaab 	.word	0xaaaaaaab

08006b94 <ed448CopyInt>:
 * @param[in] b Pointer to the source integer
 * @param[in] n Size of the integers, in bytes
 **/

void ed448CopyInt(uint8_t *a, const uint8_t *b, uint_t n)
{
 8006b94:	b480      	push	{r7}
 8006b96:	b087      	sub	sp, #28
 8006b98:	af00      	add	r7, sp, #0
 8006b9a:	60f8      	str	r0, [r7, #12]
 8006b9c:	60b9      	str	r1, [r7, #8]
 8006b9e:	607a      	str	r2, [r7, #4]
   uint_t i;

   //Copy the value of the integer
   for(i = 0; i < n; i++)
 8006ba0:	2300      	movs	r3, #0
 8006ba2:	617b      	str	r3, [r7, #20]
 8006ba4:	e00a      	b.n	8006bbc <ed448CopyInt+0x28>
   {
      a[i] = b[i];
 8006ba6:	68ba      	ldr	r2, [r7, #8]
 8006ba8:	697b      	ldr	r3, [r7, #20]
 8006baa:	441a      	add	r2, r3
 8006bac:	68f9      	ldr	r1, [r7, #12]
 8006bae:	697b      	ldr	r3, [r7, #20]
 8006bb0:	440b      	add	r3, r1
 8006bb2:	7812      	ldrb	r2, [r2, #0]
 8006bb4:	701a      	strb	r2, [r3, #0]
   for(i = 0; i < n; i++)
 8006bb6:	697b      	ldr	r3, [r7, #20]
 8006bb8:	3301      	adds	r3, #1
 8006bba:	617b      	str	r3, [r7, #20]
 8006bbc:	697a      	ldr	r2, [r7, #20]
 8006bbe:	687b      	ldr	r3, [r7, #4]
 8006bc0:	429a      	cmp	r2, r3
 8006bc2:	d3f0      	bcc.n	8006ba6 <ed448CopyInt+0x12>
   }
}
 8006bc4:	bf00      	nop
 8006bc6:	bf00      	nop
 8006bc8:	371c      	adds	r7, #28
 8006bca:	46bd      	mov	sp, r7
 8006bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bd0:	4770      	bx	lr

08006bd2 <ed448SelectInt>:
 * @param[in] n Size of the integers, in bytes
 **/

void ed448SelectInt(uint8_t *r, const uint8_t *a, const uint8_t *b,
   uint8_t c, uint_t n)
{
 8006bd2:	b480      	push	{r7}
 8006bd4:	b087      	sub	sp, #28
 8006bd6:	af00      	add	r7, sp, #0
 8006bd8:	60f8      	str	r0, [r7, #12]
 8006bda:	60b9      	str	r1, [r7, #8]
 8006bdc:	607a      	str	r2, [r7, #4]
 8006bde:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   uint8_t mask;

   //The mask is the all-1 or all-0 word
   mask = c - 1;
 8006be0:	78fb      	ldrb	r3, [r7, #3]
 8006be2:	3b01      	subs	r3, #1
 8006be4:	74fb      	strb	r3, [r7, #19]

   //Select between A and B
   for(i = 0; i < n; i++)
 8006be6:	2300      	movs	r3, #0
 8006be8:	617b      	str	r3, [r7, #20]
 8006bea:	e01c      	b.n	8006c26 <ed448SelectInt+0x54>
   {
      //Constant time implementation
      r[i] = (a[i] & mask) | (b[i] & ~mask);
 8006bec:	68ba      	ldr	r2, [r7, #8]
 8006bee:	697b      	ldr	r3, [r7, #20]
 8006bf0:	4413      	add	r3, r2
 8006bf2:	781a      	ldrb	r2, [r3, #0]
 8006bf4:	7cfb      	ldrb	r3, [r7, #19]
 8006bf6:	4013      	ands	r3, r2
 8006bf8:	b2db      	uxtb	r3, r3
 8006bfa:	b25a      	sxtb	r2, r3
 8006bfc:	6879      	ldr	r1, [r7, #4]
 8006bfe:	697b      	ldr	r3, [r7, #20]
 8006c00:	440b      	add	r3, r1
 8006c02:	781b      	ldrb	r3, [r3, #0]
 8006c04:	b259      	sxtb	r1, r3
 8006c06:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8006c0a:	43db      	mvns	r3, r3
 8006c0c:	b25b      	sxtb	r3, r3
 8006c0e:	400b      	ands	r3, r1
 8006c10:	b25b      	sxtb	r3, r3
 8006c12:	4313      	orrs	r3, r2
 8006c14:	b259      	sxtb	r1, r3
 8006c16:	68fa      	ldr	r2, [r7, #12]
 8006c18:	697b      	ldr	r3, [r7, #20]
 8006c1a:	4413      	add	r3, r2
 8006c1c:	b2ca      	uxtb	r2, r1
 8006c1e:	701a      	strb	r2, [r3, #0]
   for(i = 0; i < n; i++)
 8006c20:	697b      	ldr	r3, [r7, #20]
 8006c22:	3301      	adds	r3, #1
 8006c24:	617b      	str	r3, [r7, #20]
 8006c26:	697a      	ldr	r2, [r7, #20]
 8006c28:	6a3b      	ldr	r3, [r7, #32]
 8006c2a:	429a      	cmp	r2, r3
 8006c2c:	d3de      	bcc.n	8006bec <ed448SelectInt+0x1a>
   }
}
 8006c2e:	bf00      	nop
 8006c30:	bf00      	nop
 8006c32:	371c      	adds	r7, #28
 8006c34:	46bd      	mov	sp, r7
 8006c36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c3a:	4770      	bx	lr

08006c3c <ed448CompInt>:
 * @param[in] n Size of the integers, in bytes
 * @return The function returns 0 if the A = B, else 1
 **/

uint8_t ed448CompInt(const uint8_t *a, const uint8_t *b, uint_t n)
{
 8006c3c:	b480      	push	{r7}
 8006c3e:	b087      	sub	sp, #28
 8006c40:	af00      	add	r7, sp, #0
 8006c42:	60f8      	str	r0, [r7, #12]
 8006c44:	60b9      	str	r1, [r7, #8]
 8006c46:	607a      	str	r2, [r7, #4]
   uint_t i;
   uint8_t mask;

   //Initialize mask
   mask = 0;
 8006c48:	2300      	movs	r3, #0
 8006c4a:	74fb      	strb	r3, [r7, #19]

   //Compare A and B
   for(i = 0; i < n; i++)
 8006c4c:	2300      	movs	r3, #0
 8006c4e:	617b      	str	r3, [r7, #20]
 8006c50:	e00f      	b.n	8006c72 <ed448CompInt+0x36>
   {
      //Constant time implementation
      mask |= a[i] ^ b[i];
 8006c52:	68fa      	ldr	r2, [r7, #12]
 8006c54:	697b      	ldr	r3, [r7, #20]
 8006c56:	4413      	add	r3, r2
 8006c58:	781a      	ldrb	r2, [r3, #0]
 8006c5a:	68b9      	ldr	r1, [r7, #8]
 8006c5c:	697b      	ldr	r3, [r7, #20]
 8006c5e:	440b      	add	r3, r1
 8006c60:	781b      	ldrb	r3, [r3, #0]
 8006c62:	4053      	eors	r3, r2
 8006c64:	b2da      	uxtb	r2, r3
 8006c66:	7cfb      	ldrb	r3, [r7, #19]
 8006c68:	4313      	orrs	r3, r2
 8006c6a:	74fb      	strb	r3, [r7, #19]
   for(i = 0; i < n; i++)
 8006c6c:	697b      	ldr	r3, [r7, #20]
 8006c6e:	3301      	adds	r3, #1
 8006c70:	617b      	str	r3, [r7, #20]
 8006c72:	697a      	ldr	r2, [r7, #20]
 8006c74:	687b      	ldr	r3, [r7, #4]
 8006c76:	429a      	cmp	r2, r3
 8006c78:	d3eb      	bcc.n	8006c52 <ed448CompInt+0x16>
   }

   //Return 0 if A = B, else 1
   return ((uint8_t) (mask | (~mask + 1))) >> 7;
 8006c7a:	7cfb      	ldrb	r3, [r7, #19]
 8006c7c:	425b      	negs	r3, r3
 8006c7e:	b2db      	uxtb	r3, r3
 8006c80:	b25a      	sxtb	r2, r3
 8006c82:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8006c86:	4313      	orrs	r3, r2
 8006c88:	b25b      	sxtb	r3, r3
 8006c8a:	b2db      	uxtb	r3, r3
 8006c8c:	09db      	lsrs	r3, r3, #7
 8006c8e:	b2db      	uxtb	r3, r3
}
 8006c90:	4618      	mov	r0, r3
 8006c92:	371c      	adds	r7, #28
 8006c94:	46bd      	mov	sp, r7
 8006c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c9a:	4770      	bx	lr

08006c9c <eddsaGenerateKeyPair>:
 **/

error_t eddsaGenerateKeyPair(const PrngAlgo *prngAlgo, void *prngContext,
   const EcCurveInfo *curveInfo, EddsaPrivateKey *privateKey,
   EddsaPublicKey *publicKey)
{
 8006c9c:	b580      	push	{r7, lr}
 8006c9e:	b086      	sub	sp, #24
 8006ca0:	af00      	add	r7, sp, #0
 8006ca2:	60f8      	str	r0, [r7, #12]
 8006ca4:	60b9      	str	r1, [r7, #8]
 8006ca6:	607a      	str	r2, [r7, #4]
 8006ca8:	603b      	str	r3, [r7, #0]
   error_t error;

   //Generate a private key
   error = eddsaGeneratePrivateKey(prngAlgo, prngContext, curveInfo,
 8006caa:	683b      	ldr	r3, [r7, #0]
 8006cac:	687a      	ldr	r2, [r7, #4]
 8006cae:	68b9      	ldr	r1, [r7, #8]
 8006cb0:	68f8      	ldr	r0, [r7, #12]
 8006cb2:	f000 f811 	bl	8006cd8 <eddsaGeneratePrivateKey>
 8006cb6:	4603      	mov	r3, r0
 8006cb8:	82fb      	strh	r3, [r7, #22]
      privateKey);

   //Check status code
   if(!error)
 8006cba:	8afb      	ldrh	r3, [r7, #22]
 8006cbc:	2b00      	cmp	r3, #0
 8006cbe:	d106      	bne.n	8006cce <eddsaGenerateKeyPair+0x32>
   {
      //Derive the public key from the private key
      error = eddsaGeneratePublicKey(curveInfo, privateKey, publicKey);
 8006cc0:	6a3a      	ldr	r2, [r7, #32]
 8006cc2:	6839      	ldr	r1, [r7, #0]
 8006cc4:	6878      	ldr	r0, [r7, #4]
 8006cc6:	f000 f855 	bl	8006d74 <eddsaGeneratePublicKey>
 8006cca:	4603      	mov	r3, r0
 8006ccc:	82fb      	strh	r3, [r7, #22]
   }

   //Return status code
   return error;
 8006cce:	8afb      	ldrh	r3, [r7, #22]
}
 8006cd0:	4618      	mov	r0, r3
 8006cd2:	3718      	adds	r7, #24
 8006cd4:	46bd      	mov	sp, r7
 8006cd6:	bd80      	pop	{r7, pc}

08006cd8 <eddsaGeneratePrivateKey>:
 * @return Error code
 **/

error_t eddsaGeneratePrivateKey(const PrngAlgo *prngAlgo, void *prngContext,
   const EcCurveInfo *curveInfo, EddsaPrivateKey *privateKey)
{
 8006cd8:	b580      	push	{r7, lr}
 8006cda:	b094      	sub	sp, #80	; 0x50
 8006cdc:	af00      	add	r7, sp, #0
 8006cde:	60f8      	str	r0, [r7, #12]
 8006ce0:	60b9      	str	r1, [r7, #8]
 8006ce2:	607a      	str	r2, [r7, #4]
 8006ce4:	603b      	str	r3, [r7, #0]
   error_t error;

#if (ED25519_SUPPORT == ENABLED)
   //Ed25519 algorithm?
   if(curveInfo == ED25519_CURVE)
 8006ce6:	687b      	ldr	r3, [r7, #4]
 8006ce8:	4a20      	ldr	r2, [pc, #128]	; (8006d6c <eddsaGeneratePrivateKey+0x94>)
 8006cea:	4293      	cmp	r3, r2
 8006cec:	d118      	bne.n	8006d20 <eddsaGeneratePrivateKey+0x48>
   {
      uint8_t rawPrivateKey[ED25519_PRIVATE_KEY_LEN];

      //Generate an Ed25519 private key
      error = ed25519GeneratePrivateKey(prngAlgo, prngContext, rawPrivateKey);
 8006cee:	f107 0314 	add.w	r3, r7, #20
 8006cf2:	461a      	mov	r2, r3
 8006cf4:	68b9      	ldr	r1, [r7, #8]
 8006cf6:	68f8      	ldr	r0, [r7, #12]
 8006cf8:	f7fd fdd6 	bl	80048a8 <ed25519GeneratePrivateKey>
 8006cfc:	4603      	mov	r3, r0
 8006cfe:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

      //Check status code
      if(!error)
 8006d02:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	d12a      	bne.n	8006d60 <eddsaGeneratePrivateKey+0x88>
      {
         //Import the Ed25519 private key
         error = mpiImport(&privateKey->d, rawPrivateKey, ED25519_PRIVATE_KEY_LEN,
 8006d0a:	6838      	ldr	r0, [r7, #0]
 8006d0c:	f107 0114 	add.w	r1, r7, #20
 8006d10:	2300      	movs	r3, #0
 8006d12:	2220      	movs	r2, #32
 8006d14:	f000 fbfd 	bl	8007512 <mpiImport>
 8006d18:	4603      	mov	r3, r0
 8006d1a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8006d1e:	e01f      	b.n	8006d60 <eddsaGeneratePrivateKey+0x88>
   }
   else
#endif
#if (ED448_SUPPORT == ENABLED)
   //Ed448 algorithm?
   if(curveInfo == ED448_CURVE)
 8006d20:	687b      	ldr	r3, [r7, #4]
 8006d22:	4a13      	ldr	r2, [pc, #76]	; (8006d70 <eddsaGeneratePrivateKey+0x98>)
 8006d24:	4293      	cmp	r3, r2
 8006d26:	d118      	bne.n	8006d5a <eddsaGeneratePrivateKey+0x82>
   {
      uint8_t rawPrivateKey[ED448_PRIVATE_KEY_LEN];

      //Generate an Ed448 private key
      error = ed448GeneratePrivateKey(prngAlgo, prngContext, rawPrivateKey);
 8006d28:	f107 0314 	add.w	r3, r7, #20
 8006d2c:	461a      	mov	r2, r3
 8006d2e:	68b9      	ldr	r1, [r7, #8]
 8006d30:	68f8      	ldr	r0, [r7, #12]
 8006d32:	f7fe fe19 	bl	8005968 <ed448GeneratePrivateKey>
 8006d36:	4603      	mov	r3, r0
 8006d38:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

      //Check status code
      if(!error)
 8006d3c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8006d40:	2b00      	cmp	r3, #0
 8006d42:	d10d      	bne.n	8006d60 <eddsaGeneratePrivateKey+0x88>
      {
         //Import the Ed448 private key
         error = mpiImport(&privateKey->d, rawPrivateKey, ED448_PRIVATE_KEY_LEN,
 8006d44:	6838      	ldr	r0, [r7, #0]
 8006d46:	f107 0114 	add.w	r1, r7, #20
 8006d4a:	2300      	movs	r3, #0
 8006d4c:	2239      	movs	r2, #57	; 0x39
 8006d4e:	f000 fbe0 	bl	8007512 <mpiImport>
 8006d52:	4603      	mov	r3, r0
 8006d54:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 8006d58:	e002      	b.n	8006d60 <eddsaGeneratePrivateKey+0x88>
   else
#endif
   //Unknown algorithm?
   {
      //Report an error
      error = ERROR_INVALID_PARAMETER;
 8006d5a:	2302      	movs	r3, #2
 8006d5c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
   }

   //Return status code
   return error;
 8006d60:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
}
 8006d64:	4618      	mov	r0, r3
 8006d66:	3750      	adds	r7, #80	; 0x50
 8006d68:	46bd      	mov	sp, r7
 8006d6a:	bd80      	pop	{r7, pc}
 8006d6c:	0800edf0 	.word	0x0800edf0
 8006d70:	0800efb4 	.word	0x0800efb4

08006d74 <eddsaGeneratePublicKey>:
 * @return Error code
 **/

error_t eddsaGeneratePublicKey(const EcCurveInfo *curveInfo,
   const EddsaPrivateKey *privateKey, EddsaPublicKey *publicKey)
{
 8006d74:	b580      	push	{r7, lr}
 8006d76:	b0a2      	sub	sp, #136	; 0x88
 8006d78:	af00      	add	r7, sp, #0
 8006d7a:	60f8      	str	r0, [r7, #12]
 8006d7c:	60b9      	str	r1, [r7, #8]
 8006d7e:	607a      	str	r2, [r7, #4]
   error_t error;

#if (ED25519_SUPPORT == ENABLED)
   //Ed25519 algorithm?
   if(curveInfo == ED25519_CURVE)
 8006d80:	68fb      	ldr	r3, [r7, #12]
 8006d82:	4a30      	ldr	r2, [pc, #192]	; (8006e44 <eddsaGeneratePublicKey+0xd0>)
 8006d84:	4293      	cmp	r3, r2
 8006d86:	d127      	bne.n	8006dd8 <eddsaGeneratePublicKey+0x64>
   {
      uint8_t rawPrivateKey[ED25519_PRIVATE_KEY_LEN];
      uint8_t rawPublicKey[ED25519_PUBLIC_KEY_LEN];

      //Export the Ed25519 private key
      error = mpiExport(&privateKey->d, rawPrivateKey, ED25519_PRIVATE_KEY_LEN,
 8006d88:	68b8      	ldr	r0, [r7, #8]
 8006d8a:	f107 0110 	add.w	r1, r7, #16
 8006d8e:	2300      	movs	r3, #0
 8006d90:	2220      	movs	r2, #32
 8006d92:	f000 fc72 	bl	800767a <mpiExport>
 8006d96:	4603      	mov	r3, r0
 8006d98:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
         MPI_FORMAT_LITTLE_ENDIAN);

      //Check status code
      if(!error)
 8006d9c:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006da0:	2b00      	cmp	r3, #0
 8006da2:	d10a      	bne.n	8006dba <eddsaGeneratePublicKey+0x46>
      {
         //Derive the public key from the private key
         error = ed25519GeneratePublicKey(rawPrivateKey, rawPublicKey);
 8006da4:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8006da8:	f107 0310 	add.w	r3, r7, #16
 8006dac:	4611      	mov	r1, r2
 8006dae:	4618      	mov	r0, r3
 8006db0:	f7fd fd98 	bl	80048e4 <ed25519GeneratePublicKey>
 8006db4:	4603      	mov	r3, r0
 8006db6:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
      }

      //Check status code
      if(!error)
 8006dba:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006dbe:	2b00      	cmp	r3, #0
 8006dc0:	d139      	bne.n	8006e36 <eddsaGeneratePublicKey+0xc2>
      {
         //Import the Ed25519 public key
         error = mpiImport(&publicKey->q, rawPublicKey, ED25519_PUBLIC_KEY_LEN,
 8006dc2:	6878      	ldr	r0, [r7, #4]
 8006dc4:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8006dc8:	2300      	movs	r3, #0
 8006dca:	2220      	movs	r2, #32
 8006dcc:	f000 fba1 	bl	8007512 <mpiImport>
 8006dd0:	4603      	mov	r3, r0
 8006dd2:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
 8006dd6:	e02e      	b.n	8006e36 <eddsaGeneratePublicKey+0xc2>
   }
   else
#endif
#if (ED448_SUPPORT == ENABLED)
   //Ed448 algorithm?
   if(curveInfo == ED448_CURVE)
 8006dd8:	68fb      	ldr	r3, [r7, #12]
 8006dda:	4a1b      	ldr	r2, [pc, #108]	; (8006e48 <eddsaGeneratePublicKey+0xd4>)
 8006ddc:	4293      	cmp	r3, r2
 8006dde:	d127      	bne.n	8006e30 <eddsaGeneratePublicKey+0xbc>
   {
      uint8_t rawPrivateKey[ED448_PRIVATE_KEY_LEN];
      uint8_t rawPublicKey[ED448_PUBLIC_KEY_LEN];

      //Export the Ed448 private key
      error = mpiExport(&privateKey->d, rawPrivateKey, ED448_PRIVATE_KEY_LEN,
 8006de0:	68b8      	ldr	r0, [r7, #8]
 8006de2:	f107 0110 	add.w	r1, r7, #16
 8006de6:	2300      	movs	r3, #0
 8006de8:	2239      	movs	r2, #57	; 0x39
 8006dea:	f000 fc46 	bl	800767a <mpiExport>
 8006dee:	4603      	mov	r3, r0
 8006df0:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
         MPI_FORMAT_LITTLE_ENDIAN);

      //Check status code
      if(!error)
 8006df4:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006df8:	2b00      	cmp	r3, #0
 8006dfa:	d10a      	bne.n	8006e12 <eddsaGeneratePublicKey+0x9e>
      {
         //Derive the public key from the private key
         error = ed448GeneratePublicKey(rawPrivateKey, rawPublicKey);
 8006dfc:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 8006e00:	f107 0310 	add.w	r3, r7, #16
 8006e04:	4611      	mov	r1, r2
 8006e06:	4618      	mov	r0, r3
 8006e08:	f7fe fdcc 	bl	80059a4 <ed448GeneratePublicKey>
 8006e0c:	4603      	mov	r3, r0
 8006e0e:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
      }

      //Check status code
      if(!error)
 8006e12:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8006e16:	2b00      	cmp	r3, #0
 8006e18:	d10d      	bne.n	8006e36 <eddsaGeneratePublicKey+0xc2>
      {
         //Import the Ed448 public key
         error = mpiImport(&publicKey->q, rawPublicKey, ED448_PUBLIC_KEY_LEN,
 8006e1a:	6878      	ldr	r0, [r7, #4]
 8006e1c:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8006e20:	2300      	movs	r3, #0
 8006e22:	2239      	movs	r2, #57	; 0x39
 8006e24:	f000 fb75 	bl	8007512 <mpiImport>
 8006e28:	4603      	mov	r3, r0
 8006e2a:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
 8006e2e:	e002      	b.n	8006e36 <eddsaGeneratePublicKey+0xc2>
   else
#endif
   //Unknown algorithm?
   {
      //Report an error
      error = ERROR_INVALID_PARAMETER;
 8006e30:	2302      	movs	r3, #2
 8006e32:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
   }

   //Return status code
   return error;
 8006e36:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
}
 8006e3a:	4618      	mov	r0, r3
 8006e3c:	3788      	adds	r7, #136	; 0x88
 8006e3e:	46bd      	mov	sp, r7
 8006e40:	bd80      	pop	{r7, pc}
 8006e42:	bf00      	nop
 8006e44:	0800edf0 	.word	0x0800edf0
 8006e48:	0800efb4 	.word	0x0800efb4

08006e4c <mpiInit>:
 * @brief Initialize a multiple precision integer
 * @param[in,out] r Pointer to the multiple precision integer to be initialized
 **/

void mpiInit(Mpi *r)
{
 8006e4c:	b480      	push	{r7}
 8006e4e:	b083      	sub	sp, #12
 8006e50:	af00      	add	r7, sp, #0
 8006e52:	6078      	str	r0, [r7, #4]
   //Initialize structure
   r->sign = 1;
 8006e54:	687b      	ldr	r3, [r7, #4]
 8006e56:	2201      	movs	r2, #1
 8006e58:	601a      	str	r2, [r3, #0]
   r->size = 0;
 8006e5a:	687b      	ldr	r3, [r7, #4]
 8006e5c:	2200      	movs	r2, #0
 8006e5e:	605a      	str	r2, [r3, #4]
   r->data = NULL;
 8006e60:	687b      	ldr	r3, [r7, #4]
 8006e62:	2200      	movs	r2, #0
 8006e64:	609a      	str	r2, [r3, #8]
}
 8006e66:	bf00      	nop
 8006e68:	370c      	adds	r7, #12
 8006e6a:	46bd      	mov	sp, r7
 8006e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e70:	4770      	bx	lr

08006e72 <mpiFree>:
 * @brief Release a multiple precision integer
 * @param[in,out] r Pointer to the multiple precision integer to be freed
 **/

void mpiFree(Mpi *r)
{
 8006e72:	b580      	push	{r7, lr}
 8006e74:	b082      	sub	sp, #8
 8006e76:	af00      	add	r7, sp, #0
 8006e78:	6078      	str	r0, [r7, #4]
   //Any memory previously allocated?
   if(r->data != NULL)
 8006e7a:	687b      	ldr	r3, [r7, #4]
 8006e7c:	689b      	ldr	r3, [r3, #8]
 8006e7e:	2b00      	cmp	r3, #0
 8006e80:	d00d      	beq.n	8006e9e <mpiFree+0x2c>
   {
      //Erase contents before releasing memory
      osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 8006e82:	687b      	ldr	r3, [r7, #4]
 8006e84:	6898      	ldr	r0, [r3, #8]
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	685b      	ldr	r3, [r3, #4]
 8006e8a:	009b      	lsls	r3, r3, #2
 8006e8c:	461a      	mov	r2, r3
 8006e8e:	2100      	movs	r1, #0
 8006e90:	f007 fb28 	bl	800e4e4 <memset>
      cryptoFreeMem(r->data);
 8006e94:	687b      	ldr	r3, [r7, #4]
 8006e96:	689b      	ldr	r3, [r3, #8]
 8006e98:	4618      	mov	r0, r3
 8006e9a:	f004 fdbf 	bl	800ba1c <osFreeMem>
   }

   //Set size to zero
   r->size = 0;
 8006e9e:	687b      	ldr	r3, [r7, #4]
 8006ea0:	2200      	movs	r2, #0
 8006ea2:	605a      	str	r2, [r3, #4]
   r->data = NULL;
 8006ea4:	687b      	ldr	r3, [r7, #4]
 8006ea6:	2200      	movs	r2, #0
 8006ea8:	609a      	str	r2, [r3, #8]
}
 8006eaa:	bf00      	nop
 8006eac:	3708      	adds	r7, #8
 8006eae:	46bd      	mov	sp, r7
 8006eb0:	bd80      	pop	{r7, pc}

08006eb2 <mpiGrow>:
 * @param[in] size Desired size in words
 * @return Error code
 **/

error_t mpiGrow(Mpi *r, uint_t size)
{
 8006eb2:	b580      	push	{r7, lr}
 8006eb4:	b084      	sub	sp, #16
 8006eb6:	af00      	add	r7, sp, #0
 8006eb8:	6078      	str	r0, [r7, #4]
 8006eba:	6039      	str	r1, [r7, #0]
   uint_t *data;

   //Ensure the parameter is valid
   size = MAX(size, 1);
 8006ebc:	683b      	ldr	r3, [r7, #0]
 8006ebe:	2b01      	cmp	r3, #1
 8006ec0:	bf38      	it	cc
 8006ec2:	2301      	movcc	r3, #1
 8006ec4:	603b      	str	r3, [r7, #0]

   //Check the current size
   if(r->size >= size)
 8006ec6:	687b      	ldr	r3, [r7, #4]
 8006ec8:	685b      	ldr	r3, [r3, #4]
 8006eca:	683a      	ldr	r2, [r7, #0]
 8006ecc:	429a      	cmp	r2, r3
 8006ece:	d801      	bhi.n	8006ed4 <mpiGrow+0x22>
      return NO_ERROR;
 8006ed0:	2300      	movs	r3, #0
 8006ed2:	e02a      	b.n	8006f2a <mpiGrow+0x78>

   //Allocate a memory buffer
   data = cryptoAllocMem(size * MPI_INT_SIZE);
 8006ed4:	683b      	ldr	r3, [r7, #0]
 8006ed6:	009b      	lsls	r3, r3, #2
 8006ed8:	4618      	mov	r0, r3
 8006eda:	f004 fd91 	bl	800ba00 <osAllocMem>
 8006ede:	60f8      	str	r0, [r7, #12]
   //Failed to allocate memory?
   if(data == NULL)
 8006ee0:	68fb      	ldr	r3, [r7, #12]
 8006ee2:	2b00      	cmp	r3, #0
 8006ee4:	d101      	bne.n	8006eea <mpiGrow+0x38>
      return ERROR_OUT_OF_MEMORY;
 8006ee6:	2364      	movs	r3, #100	; 0x64
 8006ee8:	e01f      	b.n	8006f2a <mpiGrow+0x78>

   //Clear buffer contents
   osMemset(data, 0, size * MPI_INT_SIZE);
 8006eea:	683b      	ldr	r3, [r7, #0]
 8006eec:	009b      	lsls	r3, r3, #2
 8006eee:	461a      	mov	r2, r3
 8006ef0:	2100      	movs	r1, #0
 8006ef2:	68f8      	ldr	r0, [r7, #12]
 8006ef4:	f007 faf6 	bl	800e4e4 <memset>

   //Any data to copy?
   if(r->size > 0)
 8006ef8:	687b      	ldr	r3, [r7, #4]
 8006efa:	685b      	ldr	r3, [r3, #4]
 8006efc:	2b00      	cmp	r3, #0
 8006efe:	d00d      	beq.n	8006f1c <mpiGrow+0x6a>
   {
      //Copy original data
      osMemcpy(data, r->data, r->size * MPI_INT_SIZE);
 8006f00:	687b      	ldr	r3, [r7, #4]
 8006f02:	6899      	ldr	r1, [r3, #8]
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	685b      	ldr	r3, [r3, #4]
 8006f08:	009b      	lsls	r3, r3, #2
 8006f0a:	461a      	mov	r2, r3
 8006f0c:	68f8      	ldr	r0, [r7, #12]
 8006f0e:	f007 fadb 	bl	800e4c8 <memcpy>
      //Free previously allocated memory
      cryptoFreeMem(r->data);
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	689b      	ldr	r3, [r3, #8]
 8006f16:	4618      	mov	r0, r3
 8006f18:	f004 fd80 	bl	800ba1c <osFreeMem>
   }

   //Update the size of the multiple precision integer
   r->size = size;
 8006f1c:	687b      	ldr	r3, [r7, #4]
 8006f1e:	683a      	ldr	r2, [r7, #0]
 8006f20:	605a      	str	r2, [r3, #4]
   r->data = data;
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	68fa      	ldr	r2, [r7, #12]
 8006f26:	609a      	str	r2, [r3, #8]

   //Successful operation
   return NO_ERROR;
 8006f28:	2300      	movs	r3, #0
}
 8006f2a:	4618      	mov	r0, r3
 8006f2c:	3710      	adds	r7, #16
 8006f2e:	46bd      	mov	sp, r7
 8006f30:	bd80      	pop	{r7, pc}

08006f32 <mpiGetLength>:
 * @param[in] a Pointer to a multiple precision integer
 * @return The actual length in words
 **/

uint_t mpiGetLength(const Mpi *a)
{
 8006f32:	b480      	push	{r7}
 8006f34:	b085      	sub	sp, #20
 8006f36:	af00      	add	r7, sp, #0
 8006f38:	6078      	str	r0, [r7, #4]
   int_t i;

   //Check whether the specified multiple precision integer is empty
   if(a->size == 0)
 8006f3a:	687b      	ldr	r3, [r7, #4]
 8006f3c:	685b      	ldr	r3, [r3, #4]
 8006f3e:	2b00      	cmp	r3, #0
 8006f40:	d101      	bne.n	8006f46 <mpiGetLength+0x14>
      return 0;
 8006f42:	2300      	movs	r3, #0
 8006f44:	e016      	b.n	8006f74 <mpiGetLength+0x42>

   //Start from the most significant word
   for(i = a->size - 1; i >= 0; i--)
 8006f46:	687b      	ldr	r3, [r7, #4]
 8006f48:	685b      	ldr	r3, [r3, #4]
 8006f4a:	3b01      	subs	r3, #1
 8006f4c:	60fb      	str	r3, [r7, #12]
 8006f4e:	e00a      	b.n	8006f66 <mpiGetLength+0x34>
   {
      //Loop as long as the current word is zero
      if(a->data[i] != 0)
 8006f50:	687b      	ldr	r3, [r7, #4]
 8006f52:	689a      	ldr	r2, [r3, #8]
 8006f54:	68fb      	ldr	r3, [r7, #12]
 8006f56:	009b      	lsls	r3, r3, #2
 8006f58:	4413      	add	r3, r2
 8006f5a:	681b      	ldr	r3, [r3, #0]
 8006f5c:	2b00      	cmp	r3, #0
 8006f5e:	d106      	bne.n	8006f6e <mpiGetLength+0x3c>
   for(i = a->size - 1; i >= 0; i--)
 8006f60:	68fb      	ldr	r3, [r7, #12]
 8006f62:	3b01      	subs	r3, #1
 8006f64:	60fb      	str	r3, [r7, #12]
 8006f66:	68fb      	ldr	r3, [r7, #12]
 8006f68:	2b00      	cmp	r3, #0
 8006f6a:	daf1      	bge.n	8006f50 <mpiGetLength+0x1e>
 8006f6c:	e000      	b.n	8006f70 <mpiGetLength+0x3e>
         break;
 8006f6e:	bf00      	nop
   }

   //Return the actual length
   return i + 1;
 8006f70:	68fb      	ldr	r3, [r7, #12]
 8006f72:	3301      	adds	r3, #1
}
 8006f74:	4618      	mov	r0, r3
 8006f76:	3714      	adds	r7, #20
 8006f78:	46bd      	mov	sp, r7
 8006f7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f7e:	4770      	bx	lr

08006f80 <mpiGetByteLength>:
 * @param[in] a Pointer to a multiple precision integer
 * @return The actual byte count
 **/

uint_t mpiGetByteLength(const Mpi *a)
{
 8006f80:	b480      	push	{r7}
 8006f82:	b085      	sub	sp, #20
 8006f84:	af00      	add	r7, sp, #0
 8006f86:	6078      	str	r0, [r7, #4]
   uint_t n;
   uint32_t m;

   //Check whether the specified multiple precision integer is empty
   if(a->size == 0)
 8006f88:	687b      	ldr	r3, [r7, #4]
 8006f8a:	685b      	ldr	r3, [r3, #4]
 8006f8c:	2b00      	cmp	r3, #0
 8006f8e:	d101      	bne.n	8006f94 <mpiGetByteLength+0x14>
      return 0;
 8006f90:	2300      	movs	r3, #0
 8006f92:	e029      	b.n	8006fe8 <mpiGetByteLength+0x68>

   //Start from the most significant word
   for(n = a->size - 1; n > 0; n--)
 8006f94:	687b      	ldr	r3, [r7, #4]
 8006f96:	685b      	ldr	r3, [r3, #4]
 8006f98:	3b01      	subs	r3, #1
 8006f9a:	60fb      	str	r3, [r7, #12]
 8006f9c:	e00a      	b.n	8006fb4 <mpiGetByteLength+0x34>
   {
      //Loop as long as the current word is zero
      if(a->data[n] != 0)
 8006f9e:	687b      	ldr	r3, [r7, #4]
 8006fa0:	689a      	ldr	r2, [r3, #8]
 8006fa2:	68fb      	ldr	r3, [r7, #12]
 8006fa4:	009b      	lsls	r3, r3, #2
 8006fa6:	4413      	add	r3, r2
 8006fa8:	681b      	ldr	r3, [r3, #0]
 8006faa:	2b00      	cmp	r3, #0
 8006fac:	d106      	bne.n	8006fbc <mpiGetByteLength+0x3c>
   for(n = a->size - 1; n > 0; n--)
 8006fae:	68fb      	ldr	r3, [r7, #12]
 8006fb0:	3b01      	subs	r3, #1
 8006fb2:	60fb      	str	r3, [r7, #12]
 8006fb4:	68fb      	ldr	r3, [r7, #12]
 8006fb6:	2b00      	cmp	r3, #0
 8006fb8:	d1f1      	bne.n	8006f9e <mpiGetByteLength+0x1e>
 8006fba:	e000      	b.n	8006fbe <mpiGetByteLength+0x3e>
         break;
 8006fbc:	bf00      	nop
   }

   //Get the current word
   m = a->data[n];
 8006fbe:	687b      	ldr	r3, [r7, #4]
 8006fc0:	689a      	ldr	r2, [r3, #8]
 8006fc2:	68fb      	ldr	r3, [r7, #12]
 8006fc4:	009b      	lsls	r3, r3, #2
 8006fc6:	4413      	add	r3, r2
 8006fc8:	681b      	ldr	r3, [r3, #0]
 8006fca:	60bb      	str	r3, [r7, #8]
   //Convert the length to a byte count
   n *= MPI_INT_SIZE;
 8006fcc:	68fb      	ldr	r3, [r7, #12]
 8006fce:	009b      	lsls	r3, r3, #2
 8006fd0:	60fb      	str	r3, [r7, #12]

   //Adjust the byte count
   for(; m != 0; m >>= 8)
 8006fd2:	e005      	b.n	8006fe0 <mpiGetByteLength+0x60>
   {
      n++;
 8006fd4:	68fb      	ldr	r3, [r7, #12]
 8006fd6:	3301      	adds	r3, #1
 8006fd8:	60fb      	str	r3, [r7, #12]
   for(; m != 0; m >>= 8)
 8006fda:	68bb      	ldr	r3, [r7, #8]
 8006fdc:	0a1b      	lsrs	r3, r3, #8
 8006fde:	60bb      	str	r3, [r7, #8]
 8006fe0:	68bb      	ldr	r3, [r7, #8]
 8006fe2:	2b00      	cmp	r3, #0
 8006fe4:	d1f6      	bne.n	8006fd4 <mpiGetByteLength+0x54>
   }

   //Return the actual length in bytes
   return n;
 8006fe6:	68fb      	ldr	r3, [r7, #12]
}
 8006fe8:	4618      	mov	r0, r3
 8006fea:	3714      	adds	r7, #20
 8006fec:	46bd      	mov	sp, r7
 8006fee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ff2:	4770      	bx	lr

08006ff4 <mpiGetBitLength>:
 * @param[in] a Pointer to a multiple precision integer
 * @return The actual bit count
 **/

uint_t mpiGetBitLength(const Mpi *a)
{
 8006ff4:	b480      	push	{r7}
 8006ff6:	b085      	sub	sp, #20
 8006ff8:	af00      	add	r7, sp, #0
 8006ffa:	6078      	str	r0, [r7, #4]
   uint_t n;
   uint32_t m;

   //Check whether the specified multiple precision integer is empty
   if(a->size == 0)
 8006ffc:	687b      	ldr	r3, [r7, #4]
 8006ffe:	685b      	ldr	r3, [r3, #4]
 8007000:	2b00      	cmp	r3, #0
 8007002:	d101      	bne.n	8007008 <mpiGetBitLength+0x14>
      return 0;
 8007004:	2300      	movs	r3, #0
 8007006:	e029      	b.n	800705c <mpiGetBitLength+0x68>

   //Start from the most significant word
   for(n = a->size - 1; n > 0; n--)
 8007008:	687b      	ldr	r3, [r7, #4]
 800700a:	685b      	ldr	r3, [r3, #4]
 800700c:	3b01      	subs	r3, #1
 800700e:	60fb      	str	r3, [r7, #12]
 8007010:	e00a      	b.n	8007028 <mpiGetBitLength+0x34>
   {
      //Loop as long as the current word is zero
      if(a->data[n] != 0)
 8007012:	687b      	ldr	r3, [r7, #4]
 8007014:	689a      	ldr	r2, [r3, #8]
 8007016:	68fb      	ldr	r3, [r7, #12]
 8007018:	009b      	lsls	r3, r3, #2
 800701a:	4413      	add	r3, r2
 800701c:	681b      	ldr	r3, [r3, #0]
 800701e:	2b00      	cmp	r3, #0
 8007020:	d106      	bne.n	8007030 <mpiGetBitLength+0x3c>
   for(n = a->size - 1; n > 0; n--)
 8007022:	68fb      	ldr	r3, [r7, #12]
 8007024:	3b01      	subs	r3, #1
 8007026:	60fb      	str	r3, [r7, #12]
 8007028:	68fb      	ldr	r3, [r7, #12]
 800702a:	2b00      	cmp	r3, #0
 800702c:	d1f1      	bne.n	8007012 <mpiGetBitLength+0x1e>
 800702e:	e000      	b.n	8007032 <mpiGetBitLength+0x3e>
         break;
 8007030:	bf00      	nop
   }

   //Get the current word
   m = a->data[n];
 8007032:	687b      	ldr	r3, [r7, #4]
 8007034:	689a      	ldr	r2, [r3, #8]
 8007036:	68fb      	ldr	r3, [r7, #12]
 8007038:	009b      	lsls	r3, r3, #2
 800703a:	4413      	add	r3, r2
 800703c:	681b      	ldr	r3, [r3, #0]
 800703e:	60bb      	str	r3, [r7, #8]
   //Convert the length to a bit count
   n *= MPI_INT_SIZE * 8;
 8007040:	68fb      	ldr	r3, [r7, #12]
 8007042:	015b      	lsls	r3, r3, #5
 8007044:	60fb      	str	r3, [r7, #12]

   //Adjust the bit count
   for(; m != 0; m >>= 1)
 8007046:	e005      	b.n	8007054 <mpiGetBitLength+0x60>
   {
      n++;
 8007048:	68fb      	ldr	r3, [r7, #12]
 800704a:	3301      	adds	r3, #1
 800704c:	60fb      	str	r3, [r7, #12]
   for(; m != 0; m >>= 1)
 800704e:	68bb      	ldr	r3, [r7, #8]
 8007050:	085b      	lsrs	r3, r3, #1
 8007052:	60bb      	str	r3, [r7, #8]
 8007054:	68bb      	ldr	r3, [r7, #8]
 8007056:	2b00      	cmp	r3, #0
 8007058:	d1f6      	bne.n	8007048 <mpiGetBitLength+0x54>
   }

   //Return the actual length in bits
   return n;
 800705a:	68fb      	ldr	r3, [r7, #12]
}
 800705c:	4618      	mov	r0, r3
 800705e:	3714      	adds	r7, #20
 8007060:	46bd      	mov	sp, r7
 8007062:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007066:	4770      	bx	lr

08007068 <mpiSetBitValue>:
 * @param[in] value Bit value
 * @return Error code
 **/

error_t mpiSetBitValue(Mpi *r, uint_t index, uint_t value)
{
 8007068:	b580      	push	{r7, lr}
 800706a:	b088      	sub	sp, #32
 800706c:	af00      	add	r7, sp, #0
 800706e:	60f8      	str	r0, [r7, #12]
 8007070:	60b9      	str	r1, [r7, #8]
 8007072:	607a      	str	r2, [r7, #4]
   error_t error;
   uint_t n1;
   uint_t n2;

   //Retrieve the position of the bit to be written
   n1 = index / (MPI_INT_SIZE * 8);
 8007074:	68bb      	ldr	r3, [r7, #8]
 8007076:	095b      	lsrs	r3, r3, #5
 8007078:	61fb      	str	r3, [r7, #28]
   n2 = index % (MPI_INT_SIZE * 8);
 800707a:	68bb      	ldr	r3, [r7, #8]
 800707c:	f003 031f 	and.w	r3, r3, #31
 8007080:	61bb      	str	r3, [r7, #24]

   //Ajust the size of the multiple precision integer if necessary
   error = mpiGrow(r, n1 + 1);
 8007082:	69fb      	ldr	r3, [r7, #28]
 8007084:	3301      	adds	r3, #1
 8007086:	4619      	mov	r1, r3
 8007088:	68f8      	ldr	r0, [r7, #12]
 800708a:	f7ff ff12 	bl	8006eb2 <mpiGrow>
 800708e:	4603      	mov	r3, r0
 8007090:	82fb      	strh	r3, [r7, #22]
   //Failed to adjust the size?
   if(error)
 8007092:	8afb      	ldrh	r3, [r7, #22]
 8007094:	2b00      	cmp	r3, #0
 8007096:	d001      	beq.n	800709c <mpiSetBitValue+0x34>
      return error;
 8007098:	8afb      	ldrh	r3, [r7, #22]
 800709a:	e029      	b.n	80070f0 <mpiSetBitValue+0x88>

   //Set bit value
   if(value)
 800709c:	687b      	ldr	r3, [r7, #4]
 800709e:	2b00      	cmp	r3, #0
 80070a0:	d012      	beq.n	80070c8 <mpiSetBitValue+0x60>
      r->data[n1] |= (1 << n2);
 80070a2:	68fb      	ldr	r3, [r7, #12]
 80070a4:	689a      	ldr	r2, [r3, #8]
 80070a6:	69fb      	ldr	r3, [r7, #28]
 80070a8:	009b      	lsls	r3, r3, #2
 80070aa:	4413      	add	r3, r2
 80070ac:	681a      	ldr	r2, [r3, #0]
 80070ae:	2101      	movs	r1, #1
 80070b0:	69bb      	ldr	r3, [r7, #24]
 80070b2:	fa01 f303 	lsl.w	r3, r1, r3
 80070b6:	4618      	mov	r0, r3
 80070b8:	68fb      	ldr	r3, [r7, #12]
 80070ba:	6899      	ldr	r1, [r3, #8]
 80070bc:	69fb      	ldr	r3, [r7, #28]
 80070be:	009b      	lsls	r3, r3, #2
 80070c0:	440b      	add	r3, r1
 80070c2:	4302      	orrs	r2, r0
 80070c4:	601a      	str	r2, [r3, #0]
 80070c6:	e012      	b.n	80070ee <mpiSetBitValue+0x86>
   else
      r->data[n1] &= ~(1 << n2);
 80070c8:	68fb      	ldr	r3, [r7, #12]
 80070ca:	689a      	ldr	r2, [r3, #8]
 80070cc:	69fb      	ldr	r3, [r7, #28]
 80070ce:	009b      	lsls	r3, r3, #2
 80070d0:	4413      	add	r3, r2
 80070d2:	681a      	ldr	r2, [r3, #0]
 80070d4:	2101      	movs	r1, #1
 80070d6:	69bb      	ldr	r3, [r7, #24]
 80070d8:	fa01 f303 	lsl.w	r3, r1, r3
 80070dc:	43db      	mvns	r3, r3
 80070de:	4618      	mov	r0, r3
 80070e0:	68fb      	ldr	r3, [r7, #12]
 80070e2:	6899      	ldr	r1, [r3, #8]
 80070e4:	69fb      	ldr	r3, [r7, #28]
 80070e6:	009b      	lsls	r3, r3, #2
 80070e8:	440b      	add	r3, r1
 80070ea:	4002      	ands	r2, r0
 80070ec:	601a      	str	r2, [r3, #0]

   //No error to report
   return NO_ERROR;
 80070ee:	2300      	movs	r3, #0
}
 80070f0:	4618      	mov	r0, r3
 80070f2:	3720      	adds	r7, #32
 80070f4:	46bd      	mov	sp, r7
 80070f6:	bd80      	pop	{r7, pc}

080070f8 <mpiGetBitValue>:
 * @param[in] index Position where to read the bit
 * @return The actual bit value
 **/

uint_t mpiGetBitValue(const Mpi *a, uint_t index)
{
 80070f8:	b480      	push	{r7}
 80070fa:	b085      	sub	sp, #20
 80070fc:	af00      	add	r7, sp, #0
 80070fe:	6078      	str	r0, [r7, #4]
 8007100:	6039      	str	r1, [r7, #0]
   uint_t n1;
   uint_t n2;

   //Retrieve the position of the bit to be read
   n1 = index / (MPI_INT_SIZE * 8);
 8007102:	683b      	ldr	r3, [r7, #0]
 8007104:	095b      	lsrs	r3, r3, #5
 8007106:	60fb      	str	r3, [r7, #12]
   n2 = index % (MPI_INT_SIZE * 8);
 8007108:	683b      	ldr	r3, [r7, #0]
 800710a:	f003 031f 	and.w	r3, r3, #31
 800710e:	60bb      	str	r3, [r7, #8]

   //Index out of range?
   if(n1 >= a->size)
 8007110:	687b      	ldr	r3, [r7, #4]
 8007112:	685b      	ldr	r3, [r3, #4]
 8007114:	68fa      	ldr	r2, [r7, #12]
 8007116:	429a      	cmp	r2, r3
 8007118:	d301      	bcc.n	800711e <mpiGetBitValue+0x26>
      return 0;
 800711a:	2300      	movs	r3, #0
 800711c:	e00a      	b.n	8007134 <mpiGetBitValue+0x3c>

   //Return the actual bit value
   return (a->data[n1] >> n2) & 0x01;
 800711e:	687b      	ldr	r3, [r7, #4]
 8007120:	689a      	ldr	r2, [r3, #8]
 8007122:	68fb      	ldr	r3, [r7, #12]
 8007124:	009b      	lsls	r3, r3, #2
 8007126:	4413      	add	r3, r2
 8007128:	681a      	ldr	r2, [r3, #0]
 800712a:	68bb      	ldr	r3, [r7, #8]
 800712c:	fa22 f303 	lsr.w	r3, r2, r3
 8007130:	f003 0301 	and.w	r3, r3, #1
}
 8007134:	4618      	mov	r0, r3
 8007136:	3714      	adds	r7, #20
 8007138:	46bd      	mov	sp, r7
 800713a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800713e:	4770      	bx	lr

08007140 <mpiComp>:
 * @param[in] b The second multiple precision integer to be compared
 * @return Comparison result
 **/

int_t mpiComp(const Mpi *a, const Mpi *b)
{
 8007140:	b580      	push	{r7, lr}
 8007142:	b084      	sub	sp, #16
 8007144:	af00      	add	r7, sp, #0
 8007146:	6078      	str	r0, [r7, #4]
 8007148:	6039      	str	r1, [r7, #0]
   uint_t m;
   uint_t n;

   //Determine the actual length of A and B
   m = mpiGetLength(a);
 800714a:	6878      	ldr	r0, [r7, #4]
 800714c:	f7ff fef1 	bl	8006f32 <mpiGetLength>
 8007150:	60b8      	str	r0, [r7, #8]
   n = mpiGetLength(b);
 8007152:	6838      	ldr	r0, [r7, #0]
 8007154:	f7ff feed 	bl	8006f32 <mpiGetLength>
 8007158:	60f8      	str	r0, [r7, #12]

   //Compare lengths
   if(!m && !n)
 800715a:	68bb      	ldr	r3, [r7, #8]
 800715c:	2b00      	cmp	r3, #0
 800715e:	d104      	bne.n	800716a <mpiComp+0x2a>
 8007160:	68fb      	ldr	r3, [r7, #12]
 8007162:	2b00      	cmp	r3, #0
 8007164:	d101      	bne.n	800716a <mpiComp+0x2a>
      return 0;
 8007166:	2300      	movs	r3, #0
 8007168:	e04c      	b.n	8007204 <mpiComp+0xc4>
   else if(m > n)
 800716a:	68ba      	ldr	r2, [r7, #8]
 800716c:	68fb      	ldr	r3, [r7, #12]
 800716e:	429a      	cmp	r2, r3
 8007170:	d902      	bls.n	8007178 <mpiComp+0x38>
      return a->sign;
 8007172:	687b      	ldr	r3, [r7, #4]
 8007174:	681b      	ldr	r3, [r3, #0]
 8007176:	e045      	b.n	8007204 <mpiComp+0xc4>
   else if(m < n)
 8007178:	68ba      	ldr	r2, [r7, #8]
 800717a:	68fb      	ldr	r3, [r7, #12]
 800717c:	429a      	cmp	r2, r3
 800717e:	d203      	bcs.n	8007188 <mpiComp+0x48>
      return -b->sign;
 8007180:	683b      	ldr	r3, [r7, #0]
 8007182:	681b      	ldr	r3, [r3, #0]
 8007184:	425b      	negs	r3, r3
 8007186:	e03d      	b.n	8007204 <mpiComp+0xc4>

   //Compare signs
   if(a->sign > 0 && b->sign < 0)
 8007188:	687b      	ldr	r3, [r7, #4]
 800718a:	681b      	ldr	r3, [r3, #0]
 800718c:	2b00      	cmp	r3, #0
 800718e:	dd05      	ble.n	800719c <mpiComp+0x5c>
 8007190:	683b      	ldr	r3, [r7, #0]
 8007192:	681b      	ldr	r3, [r3, #0]
 8007194:	2b00      	cmp	r3, #0
 8007196:	da01      	bge.n	800719c <mpiComp+0x5c>
      return 1;
 8007198:	2301      	movs	r3, #1
 800719a:	e033      	b.n	8007204 <mpiComp+0xc4>
   else if(a->sign < 0 && b->sign > 0)
 800719c:	687b      	ldr	r3, [r7, #4]
 800719e:	681b      	ldr	r3, [r3, #0]
 80071a0:	2b00      	cmp	r3, #0
 80071a2:	da29      	bge.n	80071f8 <mpiComp+0xb8>
 80071a4:	683b      	ldr	r3, [r7, #0]
 80071a6:	681b      	ldr	r3, [r3, #0]
 80071a8:	2b00      	cmp	r3, #0
 80071aa:	dd25      	ble.n	80071f8 <mpiComp+0xb8>
      return -1;
 80071ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80071b0:	e028      	b.n	8007204 <mpiComp+0xc4>

   //Then compare values
   while(n--)
   {
      if(a->data[n] > b->data[n])
 80071b2:	687b      	ldr	r3, [r7, #4]
 80071b4:	689a      	ldr	r2, [r3, #8]
 80071b6:	68fb      	ldr	r3, [r7, #12]
 80071b8:	009b      	lsls	r3, r3, #2
 80071ba:	4413      	add	r3, r2
 80071bc:	681a      	ldr	r2, [r3, #0]
 80071be:	683b      	ldr	r3, [r7, #0]
 80071c0:	6899      	ldr	r1, [r3, #8]
 80071c2:	68fb      	ldr	r3, [r7, #12]
 80071c4:	009b      	lsls	r3, r3, #2
 80071c6:	440b      	add	r3, r1
 80071c8:	681b      	ldr	r3, [r3, #0]
 80071ca:	429a      	cmp	r2, r3
 80071cc:	d902      	bls.n	80071d4 <mpiComp+0x94>
         return a->sign;
 80071ce:	687b      	ldr	r3, [r7, #4]
 80071d0:	681b      	ldr	r3, [r3, #0]
 80071d2:	e017      	b.n	8007204 <mpiComp+0xc4>
      else if(a->data[n] < b->data[n])
 80071d4:	687b      	ldr	r3, [r7, #4]
 80071d6:	689a      	ldr	r2, [r3, #8]
 80071d8:	68fb      	ldr	r3, [r7, #12]
 80071da:	009b      	lsls	r3, r3, #2
 80071dc:	4413      	add	r3, r2
 80071de:	681a      	ldr	r2, [r3, #0]
 80071e0:	683b      	ldr	r3, [r7, #0]
 80071e2:	6899      	ldr	r1, [r3, #8]
 80071e4:	68fb      	ldr	r3, [r7, #12]
 80071e6:	009b      	lsls	r3, r3, #2
 80071e8:	440b      	add	r3, r1
 80071ea:	681b      	ldr	r3, [r3, #0]
 80071ec:	429a      	cmp	r2, r3
 80071ee:	d203      	bcs.n	80071f8 <mpiComp+0xb8>
         return -a->sign;
 80071f0:	687b      	ldr	r3, [r7, #4]
 80071f2:	681b      	ldr	r3, [r3, #0]
 80071f4:	425b      	negs	r3, r3
 80071f6:	e005      	b.n	8007204 <mpiComp+0xc4>
   while(n--)
 80071f8:	68fb      	ldr	r3, [r7, #12]
 80071fa:	1e5a      	subs	r2, r3, #1
 80071fc:	60fa      	str	r2, [r7, #12]
 80071fe:	2b00      	cmp	r3, #0
 8007200:	d1d7      	bne.n	80071b2 <mpiComp+0x72>
   }

   //Multiple precision integers are equals
   return 0;
 8007202:	2300      	movs	r3, #0
}
 8007204:	4618      	mov	r0, r3
 8007206:	3710      	adds	r7, #16
 8007208:	46bd      	mov	sp, r7
 800720a:	bd80      	pop	{r7, pc}

0800720c <mpiCompInt>:
 * @param[in] b Integer to be compared
 * @return Comparison result
 **/

int_t mpiCompInt(const Mpi *a, int_t b)
{
 800720c:	b580      	push	{r7, lr}
 800720e:	b086      	sub	sp, #24
 8007210:	af00      	add	r7, sp, #0
 8007212:	6078      	str	r0, [r7, #4]
 8007214:	6039      	str	r1, [r7, #0]
   uint_t value;
   Mpi t;

   //Initialize a temporary multiple precision integer
   value = (b >= 0) ? b : -b;
 8007216:	683b      	ldr	r3, [r7, #0]
 8007218:	2b00      	cmp	r3, #0
 800721a:	bfb8      	it	lt
 800721c:	425b      	neglt	r3, r3
 800721e:	617b      	str	r3, [r7, #20]
   t.sign = (b >= 0) ? 1 : -1;
 8007220:	683b      	ldr	r3, [r7, #0]
 8007222:	2b00      	cmp	r3, #0
 8007224:	db01      	blt.n	800722a <mpiCompInt+0x1e>
 8007226:	2301      	movs	r3, #1
 8007228:	e001      	b.n	800722e <mpiCompInt+0x22>
 800722a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800722e:	60bb      	str	r3, [r7, #8]
   t.size = 1;
 8007230:	2301      	movs	r3, #1
 8007232:	60fb      	str	r3, [r7, #12]
   t.data = &value;
 8007234:	f107 0314 	add.w	r3, r7, #20
 8007238:	613b      	str	r3, [r7, #16]

   //Return comparison result
   return mpiComp(a, &t);
 800723a:	f107 0308 	add.w	r3, r7, #8
 800723e:	4619      	mov	r1, r3
 8007240:	6878      	ldr	r0, [r7, #4]
 8007242:	f7ff ff7d 	bl	8007140 <mpiComp>
 8007246:	4603      	mov	r3, r0
}
 8007248:	4618      	mov	r0, r3
 800724a:	3718      	adds	r7, #24
 800724c:	46bd      	mov	sp, r7
 800724e:	bd80      	pop	{r7, pc}

08007250 <mpiCompAbs>:
 * @param[in] b The second multiple precision integer to be compared
 * @return Comparison result
 **/

int_t mpiCompAbs(const Mpi *a, const Mpi *b)
{
 8007250:	b580      	push	{r7, lr}
 8007252:	b084      	sub	sp, #16
 8007254:	af00      	add	r7, sp, #0
 8007256:	6078      	str	r0, [r7, #4]
 8007258:	6039      	str	r1, [r7, #0]
   uint_t m;
   uint_t n;

   //Determine the actual length of A and B
   m = mpiGetLength(a);
 800725a:	6878      	ldr	r0, [r7, #4]
 800725c:	f7ff fe69 	bl	8006f32 <mpiGetLength>
 8007260:	60b8      	str	r0, [r7, #8]
   n = mpiGetLength(b);
 8007262:	6838      	ldr	r0, [r7, #0]
 8007264:	f7ff fe65 	bl	8006f32 <mpiGetLength>
 8007268:	60f8      	str	r0, [r7, #12]

   //Compare lengths
   if(!m && !n)
 800726a:	68bb      	ldr	r3, [r7, #8]
 800726c:	2b00      	cmp	r3, #0
 800726e:	d104      	bne.n	800727a <mpiCompAbs+0x2a>
 8007270:	68fb      	ldr	r3, [r7, #12]
 8007272:	2b00      	cmp	r3, #0
 8007274:	d101      	bne.n	800727a <mpiCompAbs+0x2a>
      return 0;
 8007276:	2300      	movs	r3, #0
 8007278:	e033      	b.n	80072e2 <mpiCompAbs+0x92>
   else if(m > n)
 800727a:	68ba      	ldr	r2, [r7, #8]
 800727c:	68fb      	ldr	r3, [r7, #12]
 800727e:	429a      	cmp	r2, r3
 8007280:	d901      	bls.n	8007286 <mpiCompAbs+0x36>
      return 1;
 8007282:	2301      	movs	r3, #1
 8007284:	e02d      	b.n	80072e2 <mpiCompAbs+0x92>
   else if(m < n)
 8007286:	68ba      	ldr	r2, [r7, #8]
 8007288:	68fb      	ldr	r3, [r7, #12]
 800728a:	429a      	cmp	r2, r3
 800728c:	d223      	bcs.n	80072d6 <mpiCompAbs+0x86>
      return -1;
 800728e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007292:	e026      	b.n	80072e2 <mpiCompAbs+0x92>

   //Then compare values
   while(n--)
   {
      if(a->data[n] > b->data[n])
 8007294:	687b      	ldr	r3, [r7, #4]
 8007296:	689a      	ldr	r2, [r3, #8]
 8007298:	68fb      	ldr	r3, [r7, #12]
 800729a:	009b      	lsls	r3, r3, #2
 800729c:	4413      	add	r3, r2
 800729e:	681a      	ldr	r2, [r3, #0]
 80072a0:	683b      	ldr	r3, [r7, #0]
 80072a2:	6899      	ldr	r1, [r3, #8]
 80072a4:	68fb      	ldr	r3, [r7, #12]
 80072a6:	009b      	lsls	r3, r3, #2
 80072a8:	440b      	add	r3, r1
 80072aa:	681b      	ldr	r3, [r3, #0]
 80072ac:	429a      	cmp	r2, r3
 80072ae:	d901      	bls.n	80072b4 <mpiCompAbs+0x64>
         return 1;
 80072b0:	2301      	movs	r3, #1
 80072b2:	e016      	b.n	80072e2 <mpiCompAbs+0x92>
      else if(a->data[n] < b->data[n])
 80072b4:	687b      	ldr	r3, [r7, #4]
 80072b6:	689a      	ldr	r2, [r3, #8]
 80072b8:	68fb      	ldr	r3, [r7, #12]
 80072ba:	009b      	lsls	r3, r3, #2
 80072bc:	4413      	add	r3, r2
 80072be:	681a      	ldr	r2, [r3, #0]
 80072c0:	683b      	ldr	r3, [r7, #0]
 80072c2:	6899      	ldr	r1, [r3, #8]
 80072c4:	68fb      	ldr	r3, [r7, #12]
 80072c6:	009b      	lsls	r3, r3, #2
 80072c8:	440b      	add	r3, r1
 80072ca:	681b      	ldr	r3, [r3, #0]
 80072cc:	429a      	cmp	r2, r3
 80072ce:	d202      	bcs.n	80072d6 <mpiCompAbs+0x86>
         return -1;
 80072d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80072d4:	e005      	b.n	80072e2 <mpiCompAbs+0x92>
   while(n--)
 80072d6:	68fb      	ldr	r3, [r7, #12]
 80072d8:	1e5a      	subs	r2, r3, #1
 80072da:	60fa      	str	r2, [r7, #12]
 80072dc:	2b00      	cmp	r3, #0
 80072de:	d1d9      	bne.n	8007294 <mpiCompAbs+0x44>
   }

   //Operands are equals
   return 0;
 80072e0:	2300      	movs	r3, #0
}
 80072e2:	4618      	mov	r0, r3
 80072e4:	3710      	adds	r7, #16
 80072e6:	46bd      	mov	sp, r7
 80072e8:	bd80      	pop	{r7, pc}

080072ea <mpiCopy>:
 * @param[in] a Pointer to a multiple precision integer (source)
 * @return Error code
 **/

error_t mpiCopy(Mpi *r, const Mpi *a)
{
 80072ea:	b580      	push	{r7, lr}
 80072ec:	b084      	sub	sp, #16
 80072ee:	af00      	add	r7, sp, #0
 80072f0:	6078      	str	r0, [r7, #4]
 80072f2:	6039      	str	r1, [r7, #0]
   error_t error;
   uint_t n;

   //R and A are the same instance?
   if(r == a)
 80072f4:	687a      	ldr	r2, [r7, #4]
 80072f6:	683b      	ldr	r3, [r7, #0]
 80072f8:	429a      	cmp	r2, r3
 80072fa:	d101      	bne.n	8007300 <mpiCopy+0x16>
      return NO_ERROR;
 80072fc:	2300      	movs	r3, #0
 80072fe:	e025      	b.n	800734c <mpiCopy+0x62>

   //Determine the actual length of A
   n = mpiGetLength(a);
 8007300:	6838      	ldr	r0, [r7, #0]
 8007302:	f7ff fe16 	bl	8006f32 <mpiGetLength>
 8007306:	60f8      	str	r0, [r7, #12]

   //Ajust the size of the destination operand
   error = mpiGrow(r, n);
 8007308:	68f9      	ldr	r1, [r7, #12]
 800730a:	6878      	ldr	r0, [r7, #4]
 800730c:	f7ff fdd1 	bl	8006eb2 <mpiGrow>
 8007310:	4603      	mov	r3, r0
 8007312:	817b      	strh	r3, [r7, #10]
   //Any error to report?
   if(error)
 8007314:	897b      	ldrh	r3, [r7, #10]
 8007316:	2b00      	cmp	r3, #0
 8007318:	d001      	beq.n	800731e <mpiCopy+0x34>
      return error;
 800731a:	897b      	ldrh	r3, [r7, #10]
 800731c:	e016      	b.n	800734c <mpiCopy+0x62>

   //Clear the contents of the multiple precision integer
   osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 800731e:	687b      	ldr	r3, [r7, #4]
 8007320:	6898      	ldr	r0, [r3, #8]
 8007322:	687b      	ldr	r3, [r7, #4]
 8007324:	685b      	ldr	r3, [r3, #4]
 8007326:	009b      	lsls	r3, r3, #2
 8007328:	461a      	mov	r2, r3
 800732a:	2100      	movs	r1, #0
 800732c:	f007 f8da 	bl	800e4e4 <memset>
   //Let R = A
   osMemcpy(r->data, a->data, n * MPI_INT_SIZE);
 8007330:	687b      	ldr	r3, [r7, #4]
 8007332:	6898      	ldr	r0, [r3, #8]
 8007334:	683b      	ldr	r3, [r7, #0]
 8007336:	6899      	ldr	r1, [r3, #8]
 8007338:	68fb      	ldr	r3, [r7, #12]
 800733a:	009b      	lsls	r3, r3, #2
 800733c:	461a      	mov	r2, r3
 800733e:	f007 f8c3 	bl	800e4c8 <memcpy>
   //Set the sign of R
   r->sign = a->sign;
 8007342:	683b      	ldr	r3, [r7, #0]
 8007344:	681a      	ldr	r2, [r3, #0]
 8007346:	687b      	ldr	r3, [r7, #4]
 8007348:	601a      	str	r2, [r3, #0]

   //Successful operation
   return NO_ERROR;
 800734a:	2300      	movs	r3, #0
}
 800734c:	4618      	mov	r0, r3
 800734e:	3710      	adds	r7, #16
 8007350:	46bd      	mov	sp, r7
 8007352:	bd80      	pop	{r7, pc}

08007354 <mpiSetValue>:
 * @param[in] a Value to be assigned to the multiple precision integer
 * @return Error code
 **/

error_t mpiSetValue(Mpi *r, int_t a)
{
 8007354:	b580      	push	{r7, lr}
 8007356:	b084      	sub	sp, #16
 8007358:	af00      	add	r7, sp, #0
 800735a:	6078      	str	r0, [r7, #4]
 800735c:	6039      	str	r1, [r7, #0]
   error_t error;

   //Ajust the size of the destination operand
   error = mpiGrow(r, 1);
 800735e:	2101      	movs	r1, #1
 8007360:	6878      	ldr	r0, [r7, #4]
 8007362:	f7ff fda6 	bl	8006eb2 <mpiGrow>
 8007366:	4603      	mov	r3, r0
 8007368:	81fb      	strh	r3, [r7, #14]
   //Failed to adjust the size?
   if(error)
 800736a:	89fb      	ldrh	r3, [r7, #14]
 800736c:	2b00      	cmp	r3, #0
 800736e:	d001      	beq.n	8007374 <mpiSetValue+0x20>
      return error;
 8007370:	89fb      	ldrh	r3, [r7, #14]
 8007372:	e01a      	b.n	80073aa <mpiSetValue+0x56>

   //Clear the contents of the multiple precision integer
   osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 8007374:	687b      	ldr	r3, [r7, #4]
 8007376:	6898      	ldr	r0, [r3, #8]
 8007378:	687b      	ldr	r3, [r7, #4]
 800737a:	685b      	ldr	r3, [r3, #4]
 800737c:	009b      	lsls	r3, r3, #2
 800737e:	461a      	mov	r2, r3
 8007380:	2100      	movs	r1, #0
 8007382:	f007 f8af 	bl	800e4e4 <memset>
   //Set the value or R
   r->data[0] = (a >= 0) ? a : -a;
 8007386:	683b      	ldr	r3, [r7, #0]
 8007388:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 800738c:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8007390:	687b      	ldr	r3, [r7, #4]
 8007392:	689b      	ldr	r3, [r3, #8]
 8007394:	601a      	str	r2, [r3, #0]
   //Set the sign of R
   r->sign = (a >= 0) ? 1 : -1;
 8007396:	683b      	ldr	r3, [r7, #0]
 8007398:	2b00      	cmp	r3, #0
 800739a:	db01      	blt.n	80073a0 <mpiSetValue+0x4c>
 800739c:	2201      	movs	r2, #1
 800739e:	e001      	b.n	80073a4 <mpiSetValue+0x50>
 80073a0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80073a4:	687b      	ldr	r3, [r7, #4]
 80073a6:	601a      	str	r2, [r3, #0]

   //Successful operation
   return NO_ERROR;
 80073a8:	2300      	movs	r3, #0
}
 80073aa:	4618      	mov	r0, r3
 80073ac:	3710      	adds	r7, #16
 80073ae:	46bd      	mov	sp, r7
 80073b0:	bd80      	pop	{r7, pc}

080073b2 <mpiRand>:
 * @return Error code
 **/

error_t mpiRand(Mpi *r, uint_t length, const PrngAlgo *prngAlgo,
   void *prngContext)
{
 80073b2:	b580      	push	{r7, lr}
 80073b4:	b088      	sub	sp, #32
 80073b6:	af00      	add	r7, sp, #0
 80073b8:	60f8      	str	r0, [r7, #12]
 80073ba:	60b9      	str	r1, [r7, #8]
 80073bc:	607a      	str	r2, [r7, #4]
 80073be:	603b      	str	r3, [r7, #0]
   error_t error;
   uint_t m;
   uint_t n;

   //Compute the required length, in words
   n = (length + (MPI_INT_SIZE * 8) - 1) / (MPI_INT_SIZE * 8);
 80073c0:	68bb      	ldr	r3, [r7, #8]
 80073c2:	331f      	adds	r3, #31
 80073c4:	095b      	lsrs	r3, r3, #5
 80073c6:	61fb      	str	r3, [r7, #28]
   //Number of bits in the most significant word
   m = length % (MPI_INT_SIZE * 8);
 80073c8:	68bb      	ldr	r3, [r7, #8]
 80073ca:	f003 031f 	and.w	r3, r3, #31
 80073ce:	61bb      	str	r3, [r7, #24]

   //Ajust the size of the multiple precision integer if necessary
   error = mpiGrow(r, n);
 80073d0:	69f9      	ldr	r1, [r7, #28]
 80073d2:	68f8      	ldr	r0, [r7, #12]
 80073d4:	f7ff fd6d 	bl	8006eb2 <mpiGrow>
 80073d8:	4603      	mov	r3, r0
 80073da:	82fb      	strh	r3, [r7, #22]
   //Failed to adjust the size?
   if(error)
 80073dc:	8afb      	ldrh	r3, [r7, #22]
 80073de:	2b00      	cmp	r3, #0
 80073e0:	d001      	beq.n	80073e6 <mpiRand+0x34>
      return error;
 80073e2:	8afb      	ldrh	r3, [r7, #22]
 80073e4:	e03a      	b.n	800745c <mpiRand+0xaa>

   //Clear the contents of the multiple precision integer
   osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 80073e6:	68fb      	ldr	r3, [r7, #12]
 80073e8:	6898      	ldr	r0, [r3, #8]
 80073ea:	68fb      	ldr	r3, [r7, #12]
 80073ec:	685b      	ldr	r3, [r3, #4]
 80073ee:	009b      	lsls	r3, r3, #2
 80073f0:	461a      	mov	r2, r3
 80073f2:	2100      	movs	r1, #0
 80073f4:	f007 f876 	bl	800e4e4 <memset>
   //Set the sign of R
   r->sign = 1;
 80073f8:	68fb      	ldr	r3, [r7, #12]
 80073fa:	2201      	movs	r2, #1
 80073fc:	601a      	str	r2, [r3, #0]

   //Generate a random pattern
   error = prngAlgo->read(prngContext, (uint8_t *) r->data, n * MPI_INT_SIZE);
 80073fe:	687b      	ldr	r3, [r7, #4]
 8007400:	695b      	ldr	r3, [r3, #20]
 8007402:	68fa      	ldr	r2, [r7, #12]
 8007404:	6891      	ldr	r1, [r2, #8]
 8007406:	69fa      	ldr	r2, [r7, #28]
 8007408:	0092      	lsls	r2, r2, #2
 800740a:	6838      	ldr	r0, [r7, #0]
 800740c:	4798      	blx	r3
 800740e:	4603      	mov	r3, r0
 8007410:	82fb      	strh	r3, [r7, #22]
   //Any error to report?
   if(error)
 8007412:	8afb      	ldrh	r3, [r7, #22]
 8007414:	2b00      	cmp	r3, #0
 8007416:	d001      	beq.n	800741c <mpiRand+0x6a>
      return error;
 8007418:	8afb      	ldrh	r3, [r7, #22]
 800741a:	e01f      	b.n	800745c <mpiRand+0xaa>

   //Remove the meaningless bits in the most significant word
   if(n > 0 && m > 0)
 800741c:	69fb      	ldr	r3, [r7, #28]
 800741e:	2b00      	cmp	r3, #0
 8007420:	d01b      	beq.n	800745a <mpiRand+0xa8>
 8007422:	69bb      	ldr	r3, [r7, #24]
 8007424:	2b00      	cmp	r3, #0
 8007426:	d018      	beq.n	800745a <mpiRand+0xa8>
   {
      r->data[n - 1] &= (1 << m) - 1;
 8007428:	68fb      	ldr	r3, [r7, #12]
 800742a:	689a      	ldr	r2, [r3, #8]
 800742c:	69fb      	ldr	r3, [r7, #28]
 800742e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007432:	3b01      	subs	r3, #1
 8007434:	009b      	lsls	r3, r3, #2
 8007436:	4413      	add	r3, r2
 8007438:	681a      	ldr	r2, [r3, #0]
 800743a:	2101      	movs	r1, #1
 800743c:	69bb      	ldr	r3, [r7, #24]
 800743e:	fa01 f303 	lsl.w	r3, r1, r3
 8007442:	3b01      	subs	r3, #1
 8007444:	4618      	mov	r0, r3
 8007446:	68fb      	ldr	r3, [r7, #12]
 8007448:	6899      	ldr	r1, [r3, #8]
 800744a:	69fb      	ldr	r3, [r7, #28]
 800744c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007450:	3b01      	subs	r3, #1
 8007452:	009b      	lsls	r3, r3, #2
 8007454:	440b      	add	r3, r1
 8007456:	4002      	ands	r2, r0
 8007458:	601a      	str	r2, [r3, #0]
   }

   //Successful operation
   return NO_ERROR;
 800745a:	2300      	movs	r3, #0
}
 800745c:	4618      	mov	r0, r3
 800745e:	3720      	adds	r7, #32
 8007460:	46bd      	mov	sp, r7
 8007462:	bd80      	pop	{r7, pc}

08007464 <mpiRandRange>:
 * @return Error code
 **/

error_t mpiRandRange(Mpi *r, const Mpi *p, const PrngAlgo *prngAlgo,
   void *prngContext)
{
 8007464:	b580      	push	{r7, lr}
 8007466:	b08a      	sub	sp, #40	; 0x28
 8007468:	af00      	add	r7, sp, #0
 800746a:	60f8      	str	r0, [r7, #12]
 800746c:	60b9      	str	r1, [r7, #8]
 800746e:	607a      	str	r2, [r7, #4]
 8007470:	603b      	str	r3, [r7, #0]
   error_t error;
   uint_t n;
   Mpi a;

   //Make sure p is greater than 1
   if(mpiCompInt(p, 1) <= 0)
 8007472:	2101      	movs	r1, #1
 8007474:	68b8      	ldr	r0, [r7, #8]
 8007476:	f7ff fec9 	bl	800720c <mpiCompInt>
 800747a:	4603      	mov	r3, r0
 800747c:	2b00      	cmp	r3, #0
 800747e:	dc01      	bgt.n	8007484 <mpiRandRange+0x20>
      return ERROR_INVALID_PARAMETER;
 8007480:	2302      	movs	r3, #2
 8007482:	e042      	b.n	800750a <mpiRandRange+0xa6>

   //Initialize multiple precision integer
   mpiInit(&a);
 8007484:	f107 0314 	add.w	r3, r7, #20
 8007488:	4618      	mov	r0, r3
 800748a:	f7ff fcdf 	bl	8006e4c <mpiInit>

   //Get the actual length of p
   n = mpiGetBitLength(p);
 800748e:	68b8      	ldr	r0, [r7, #8]
 8007490:	f7ff fdb0 	bl	8006ff4 <mpiGetBitLength>
 8007494:	6238      	str	r0, [r7, #32]

   //Generate extra random bits so that the bias produced by the modular
   //reduction is negligible
   MPI_CHECK(mpiRand(r, n + 64, prngAlgo, prngContext));
 8007496:	6a3b      	ldr	r3, [r7, #32]
 8007498:	f103 0140 	add.w	r1, r3, #64	; 0x40
 800749c:	683b      	ldr	r3, [r7, #0]
 800749e:	687a      	ldr	r2, [r7, #4]
 80074a0:	68f8      	ldr	r0, [r7, #12]
 80074a2:	f7ff ff86 	bl	80073b2 <mpiRand>
 80074a6:	4603      	mov	r3, r0
 80074a8:	84fb      	strh	r3, [r7, #38]	; 0x26
 80074aa:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80074ac:	2b00      	cmp	r3, #0
 80074ae:	d121      	bne.n	80074f4 <mpiRandRange+0x90>

   //Compute r = (r mod (p - 1)) + 1
   MPI_CHECK(mpiSubInt(&a, p, 1));
 80074b0:	f107 0314 	add.w	r3, r7, #20
 80074b4:	2201      	movs	r2, #1
 80074b6:	68b9      	ldr	r1, [r7, #8]
 80074b8:	4618      	mov	r0, r3
 80074ba:	f000 f9f1 	bl	80078a0 <mpiSubInt>
 80074be:	4603      	mov	r3, r0
 80074c0:	84fb      	strh	r3, [r7, #38]	; 0x26
 80074c2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	d117      	bne.n	80074f8 <mpiRandRange+0x94>
   MPI_CHECK(mpiMod(r, r, &a));
 80074c8:	f107 0314 	add.w	r3, r7, #20
 80074cc:	461a      	mov	r2, r3
 80074ce:	68f9      	ldr	r1, [r7, #12]
 80074d0:	68f8      	ldr	r0, [r7, #12]
 80074d2:	f000 fe1d 	bl	8008110 <mpiMod>
 80074d6:	4603      	mov	r3, r0
 80074d8:	84fb      	strh	r3, [r7, #38]	; 0x26
 80074da:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80074dc:	2b00      	cmp	r3, #0
 80074de:	d10d      	bne.n	80074fc <mpiRandRange+0x98>
   MPI_CHECK(mpiAddInt(r, r, 1));
 80074e0:	2201      	movs	r2, #1
 80074e2:	68f9      	ldr	r1, [r7, #12]
 80074e4:	68f8      	ldr	r0, [r7, #12]
 80074e6:	f000 f97b 	bl	80077e0 <mpiAddInt>
 80074ea:	4603      	mov	r3, r0
 80074ec:	84fb      	strh	r3, [r7, #38]	; 0x26
 80074ee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80074f0:	2b00      	cmp	r3, #0

end:
 80074f2:	e004      	b.n	80074fe <mpiRandRange+0x9a>
   MPI_CHECK(mpiRand(r, n + 64, prngAlgo, prngContext));
 80074f4:	bf00      	nop
 80074f6:	e002      	b.n	80074fe <mpiRandRange+0x9a>
   MPI_CHECK(mpiSubInt(&a, p, 1));
 80074f8:	bf00      	nop
 80074fa:	e000      	b.n	80074fe <mpiRandRange+0x9a>
   MPI_CHECK(mpiMod(r, r, &a));
 80074fc:	bf00      	nop
   //Release previously allocated memory
   mpiFree(&a);
 80074fe:	f107 0314 	add.w	r3, r7, #20
 8007502:	4618      	mov	r0, r3
 8007504:	f7ff fcb5 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8007508:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 800750a:	4618      	mov	r0, r3
 800750c:	3728      	adds	r7, #40	; 0x28
 800750e:	46bd      	mov	sp, r7
 8007510:	bd80      	pop	{r7, pc}

08007512 <mpiImport>:
 * @param[in] format Input format
 * @return Error code
 **/

error_t mpiImport(Mpi *r, const uint8_t *data, uint_t length, MpiFormat format)
{
 8007512:	b580      	push	{r7, lr}
 8007514:	b086      	sub	sp, #24
 8007516:	af00      	add	r7, sp, #0
 8007518:	60f8      	str	r0, [r7, #12]
 800751a:	60b9      	str	r1, [r7, #8]
 800751c:	607a      	str	r2, [r7, #4]
 800751e:	70fb      	strb	r3, [r7, #3]
   error_t error;
   uint_t i;

   //Check input format
   if(format == MPI_FORMAT_LITTLE_ENDIAN)
 8007520:	78fb      	ldrb	r3, [r7, #3]
 8007522:	2b00      	cmp	r3, #0
 8007524:	d14d      	bne.n	80075c2 <mpiImport+0xb0>
   {
      //Skip trailing zeroes
      while(length > 0 && data[length - 1] == 0)
 8007526:	e002      	b.n	800752e <mpiImport+0x1c>
      {
         length--;
 8007528:	687b      	ldr	r3, [r7, #4]
 800752a:	3b01      	subs	r3, #1
 800752c:	607b      	str	r3, [r7, #4]
      while(length > 0 && data[length - 1] == 0)
 800752e:	687b      	ldr	r3, [r7, #4]
 8007530:	2b00      	cmp	r3, #0
 8007532:	d006      	beq.n	8007542 <mpiImport+0x30>
 8007534:	687b      	ldr	r3, [r7, #4]
 8007536:	3b01      	subs	r3, #1
 8007538:	68ba      	ldr	r2, [r7, #8]
 800753a:	4413      	add	r3, r2
 800753c:	781b      	ldrb	r3, [r3, #0]
 800753e:	2b00      	cmp	r3, #0
 8007540:	d0f2      	beq.n	8007528 <mpiImport+0x16>
      }

      //Ajust the size of the multiple precision integer
      error = mpiGrow(r, (length + MPI_INT_SIZE - 1) / MPI_INT_SIZE);
 8007542:	687b      	ldr	r3, [r7, #4]
 8007544:	3303      	adds	r3, #3
 8007546:	089b      	lsrs	r3, r3, #2
 8007548:	4619      	mov	r1, r3
 800754a:	68f8      	ldr	r0, [r7, #12]
 800754c:	f7ff fcb1 	bl	8006eb2 <mpiGrow>
 8007550:	4603      	mov	r3, r0
 8007552:	82fb      	strh	r3, [r7, #22]

      //Check status code
      if(!error)
 8007554:	8afb      	ldrh	r3, [r7, #22]
 8007556:	2b00      	cmp	r3, #0
 8007558:	f040 808a 	bne.w	8007670 <mpiImport+0x15e>
      {
         //Clear the contents of the multiple precision integer
         osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 800755c:	68fb      	ldr	r3, [r7, #12]
 800755e:	6898      	ldr	r0, [r3, #8]
 8007560:	68fb      	ldr	r3, [r7, #12]
 8007562:	685b      	ldr	r3, [r3, #4]
 8007564:	009b      	lsls	r3, r3, #2
 8007566:	461a      	mov	r2, r3
 8007568:	2100      	movs	r1, #0
 800756a:	f006 ffbb 	bl	800e4e4 <memset>
         //Set sign
         r->sign = 1;
 800756e:	68fb      	ldr	r3, [r7, #12]
 8007570:	2201      	movs	r2, #1
 8007572:	601a      	str	r2, [r3, #0]

         //Import data
         for(i = 0; i < length; i++, data++)
 8007574:	2300      	movs	r3, #0
 8007576:	613b      	str	r3, [r7, #16]
 8007578:	e01e      	b.n	80075b8 <mpiImport+0xa6>
         {
            r->data[i / MPI_INT_SIZE] |= *data << ((i % MPI_INT_SIZE) * 8);
 800757a:	68fb      	ldr	r3, [r7, #12]
 800757c:	689a      	ldr	r2, [r3, #8]
 800757e:	693b      	ldr	r3, [r7, #16]
 8007580:	f023 0303 	bic.w	r3, r3, #3
 8007584:	4413      	add	r3, r2
 8007586:	681a      	ldr	r2, [r3, #0]
 8007588:	68bb      	ldr	r3, [r7, #8]
 800758a:	781b      	ldrb	r3, [r3, #0]
 800758c:	4619      	mov	r1, r3
 800758e:	693b      	ldr	r3, [r7, #16]
 8007590:	f003 0303 	and.w	r3, r3, #3
 8007594:	00db      	lsls	r3, r3, #3
 8007596:	fa01 f303 	lsl.w	r3, r1, r3
 800759a:	4618      	mov	r0, r3
 800759c:	68fb      	ldr	r3, [r7, #12]
 800759e:	6899      	ldr	r1, [r3, #8]
 80075a0:	693b      	ldr	r3, [r7, #16]
 80075a2:	f023 0303 	bic.w	r3, r3, #3
 80075a6:	440b      	add	r3, r1
 80075a8:	4302      	orrs	r2, r0
 80075aa:	601a      	str	r2, [r3, #0]
         for(i = 0; i < length; i++, data++)
 80075ac:	693b      	ldr	r3, [r7, #16]
 80075ae:	3301      	adds	r3, #1
 80075b0:	613b      	str	r3, [r7, #16]
 80075b2:	68bb      	ldr	r3, [r7, #8]
 80075b4:	3301      	adds	r3, #1
 80075b6:	60bb      	str	r3, [r7, #8]
 80075b8:	693a      	ldr	r2, [r7, #16]
 80075ba:	687b      	ldr	r3, [r7, #4]
 80075bc:	429a      	cmp	r2, r3
 80075be:	d3dc      	bcc.n	800757a <mpiImport+0x68>
 80075c0:	e056      	b.n	8007670 <mpiImport+0x15e>
         }
      }
   }
   else if(format == MPI_FORMAT_BIG_ENDIAN)
 80075c2:	78fb      	ldrb	r3, [r7, #3]
 80075c4:	2b01      	cmp	r3, #1
 80075c6:	d151      	bne.n	800766c <mpiImport+0x15a>
   {
      //Skip leading zeroes
      while(length > 1 && *data == 0)
 80075c8:	e005      	b.n	80075d6 <mpiImport+0xc4>
      {
         data++;
 80075ca:	68bb      	ldr	r3, [r7, #8]
 80075cc:	3301      	adds	r3, #1
 80075ce:	60bb      	str	r3, [r7, #8]
         length--;
 80075d0:	687b      	ldr	r3, [r7, #4]
 80075d2:	3b01      	subs	r3, #1
 80075d4:	607b      	str	r3, [r7, #4]
      while(length > 1 && *data == 0)
 80075d6:	687b      	ldr	r3, [r7, #4]
 80075d8:	2b01      	cmp	r3, #1
 80075da:	d903      	bls.n	80075e4 <mpiImport+0xd2>
 80075dc:	68bb      	ldr	r3, [r7, #8]
 80075de:	781b      	ldrb	r3, [r3, #0]
 80075e0:	2b00      	cmp	r3, #0
 80075e2:	d0f2      	beq.n	80075ca <mpiImport+0xb8>
      }

      //Ajust the size of the multiple precision integer
      error = mpiGrow(r, (length + MPI_INT_SIZE - 1) / MPI_INT_SIZE);
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	3303      	adds	r3, #3
 80075e8:	089b      	lsrs	r3, r3, #2
 80075ea:	4619      	mov	r1, r3
 80075ec:	68f8      	ldr	r0, [r7, #12]
 80075ee:	f7ff fc60 	bl	8006eb2 <mpiGrow>
 80075f2:	4603      	mov	r3, r0
 80075f4:	82fb      	strh	r3, [r7, #22]

      //Check status code
      if(!error)
 80075f6:	8afb      	ldrh	r3, [r7, #22]
 80075f8:	2b00      	cmp	r3, #0
 80075fa:	d139      	bne.n	8007670 <mpiImport+0x15e>
      {
         //Clear the contents of the multiple precision integer
         osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 80075fc:	68fb      	ldr	r3, [r7, #12]
 80075fe:	6898      	ldr	r0, [r3, #8]
 8007600:	68fb      	ldr	r3, [r7, #12]
 8007602:	685b      	ldr	r3, [r3, #4]
 8007604:	009b      	lsls	r3, r3, #2
 8007606:	461a      	mov	r2, r3
 8007608:	2100      	movs	r1, #0
 800760a:	f006 ff6b 	bl	800e4e4 <memset>
         //Set sign
         r->sign = 1;
 800760e:	68fb      	ldr	r3, [r7, #12]
 8007610:	2201      	movs	r2, #1
 8007612:	601a      	str	r2, [r3, #0]

         //Start from the least significant byte
         data += length - 1;
 8007614:	687b      	ldr	r3, [r7, #4]
 8007616:	3b01      	subs	r3, #1
 8007618:	68ba      	ldr	r2, [r7, #8]
 800761a:	4413      	add	r3, r2
 800761c:	60bb      	str	r3, [r7, #8]

         //Import data
         for(i = 0; i < length; i++, data--)
 800761e:	2300      	movs	r3, #0
 8007620:	613b      	str	r3, [r7, #16]
 8007622:	e01e      	b.n	8007662 <mpiImport+0x150>
         {
            r->data[i / MPI_INT_SIZE] |= *data << ((i % MPI_INT_SIZE) * 8);
 8007624:	68fb      	ldr	r3, [r7, #12]
 8007626:	689a      	ldr	r2, [r3, #8]
 8007628:	693b      	ldr	r3, [r7, #16]
 800762a:	f023 0303 	bic.w	r3, r3, #3
 800762e:	4413      	add	r3, r2
 8007630:	681a      	ldr	r2, [r3, #0]
 8007632:	68bb      	ldr	r3, [r7, #8]
 8007634:	781b      	ldrb	r3, [r3, #0]
 8007636:	4619      	mov	r1, r3
 8007638:	693b      	ldr	r3, [r7, #16]
 800763a:	f003 0303 	and.w	r3, r3, #3
 800763e:	00db      	lsls	r3, r3, #3
 8007640:	fa01 f303 	lsl.w	r3, r1, r3
 8007644:	4618      	mov	r0, r3
 8007646:	68fb      	ldr	r3, [r7, #12]
 8007648:	6899      	ldr	r1, [r3, #8]
 800764a:	693b      	ldr	r3, [r7, #16]
 800764c:	f023 0303 	bic.w	r3, r3, #3
 8007650:	440b      	add	r3, r1
 8007652:	4302      	orrs	r2, r0
 8007654:	601a      	str	r2, [r3, #0]
         for(i = 0; i < length; i++, data--)
 8007656:	693b      	ldr	r3, [r7, #16]
 8007658:	3301      	adds	r3, #1
 800765a:	613b      	str	r3, [r7, #16]
 800765c:	68bb      	ldr	r3, [r7, #8]
 800765e:	3b01      	subs	r3, #1
 8007660:	60bb      	str	r3, [r7, #8]
 8007662:	693a      	ldr	r2, [r7, #16]
 8007664:	687b      	ldr	r3, [r7, #4]
 8007666:	429a      	cmp	r2, r3
 8007668:	d3dc      	bcc.n	8007624 <mpiImport+0x112>
 800766a:	e001      	b.n	8007670 <mpiImport+0x15e>
      }
   }
   else
   {
      //Report an error
      error = ERROR_INVALID_PARAMETER;
 800766c:	2302      	movs	r3, #2
 800766e:	82fb      	strh	r3, [r7, #22]
   }

   //Return status code
   return error;
 8007670:	8afb      	ldrh	r3, [r7, #22]
}
 8007672:	4618      	mov	r0, r3
 8007674:	3718      	adds	r7, #24
 8007676:	46bd      	mov	sp, r7
 8007678:	bd80      	pop	{r7, pc}

0800767a <mpiExport>:
 * @param[in] format Output format
 * @return Error code
 **/

error_t mpiExport(const Mpi *a, uint8_t *data, uint_t length, MpiFormat format)
{
 800767a:	b580      	push	{r7, lr}
 800767c:	b088      	sub	sp, #32
 800767e:	af00      	add	r7, sp, #0
 8007680:	60f8      	str	r0, [r7, #12]
 8007682:	60b9      	str	r1, [r7, #8]
 8007684:	607a      	str	r2, [r7, #4]
 8007686:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   uint_t n;
   error_t error;

   //Initialize status code
   error = NO_ERROR;
 8007688:	2300      	movs	r3, #0
 800768a:	837b      	strh	r3, [r7, #26]

   //Check input format
   if(format == MPI_FORMAT_LITTLE_ENDIAN)
 800768c:	78fb      	ldrb	r3, [r7, #3]
 800768e:	2b00      	cmp	r3, #0
 8007690:	d12d      	bne.n	80076ee <mpiExport+0x74>
   {
      //Get the actual length in bytes
      n = mpiGetByteLength(a);
 8007692:	68f8      	ldr	r0, [r7, #12]
 8007694:	f7ff fc74 	bl	8006f80 <mpiGetByteLength>
 8007698:	6178      	str	r0, [r7, #20]

      //Make sure the output buffer is large enough
      if(n <= length)
 800769a:	697a      	ldr	r2, [r7, #20]
 800769c:	687b      	ldr	r3, [r7, #4]
 800769e:	429a      	cmp	r2, r3
 80076a0:	d822      	bhi.n	80076e8 <mpiExport+0x6e>
      {
         //Clear output buffer
         osMemset(data, 0, length);
 80076a2:	687a      	ldr	r2, [r7, #4]
 80076a4:	2100      	movs	r1, #0
 80076a6:	68b8      	ldr	r0, [r7, #8]
 80076a8:	f006 ff1c 	bl	800e4e4 <memset>

         //Export data
         for(i = 0; i < n; i++, data++)
 80076ac:	2300      	movs	r3, #0
 80076ae:	61fb      	str	r3, [r7, #28]
 80076b0:	e015      	b.n	80076de <mpiExport+0x64>
         {
            *data = a->data[i / MPI_INT_SIZE] >> ((i % MPI_INT_SIZE) * 8);
 80076b2:	68fb      	ldr	r3, [r7, #12]
 80076b4:	689a      	ldr	r2, [r3, #8]
 80076b6:	69fb      	ldr	r3, [r7, #28]
 80076b8:	f023 0303 	bic.w	r3, r3, #3
 80076bc:	4413      	add	r3, r2
 80076be:	681a      	ldr	r2, [r3, #0]
 80076c0:	69fb      	ldr	r3, [r7, #28]
 80076c2:	f003 0303 	and.w	r3, r3, #3
 80076c6:	00db      	lsls	r3, r3, #3
 80076c8:	fa22 f303 	lsr.w	r3, r2, r3
 80076cc:	b2da      	uxtb	r2, r3
 80076ce:	68bb      	ldr	r3, [r7, #8]
 80076d0:	701a      	strb	r2, [r3, #0]
         for(i = 0; i < n; i++, data++)
 80076d2:	69fb      	ldr	r3, [r7, #28]
 80076d4:	3301      	adds	r3, #1
 80076d6:	61fb      	str	r3, [r7, #28]
 80076d8:	68bb      	ldr	r3, [r7, #8]
 80076da:	3301      	adds	r3, #1
 80076dc:	60bb      	str	r3, [r7, #8]
 80076de:	69fa      	ldr	r2, [r7, #28]
 80076e0:	697b      	ldr	r3, [r7, #20]
 80076e2:	429a      	cmp	r2, r3
 80076e4:	d3e5      	bcc.n	80076b2 <mpiExport+0x38>
 80076e6:	e03a      	b.n	800775e <mpiExport+0xe4>
         }
      }
      else
      {
         //Report an error
         error = ERROR_INVALID_LENGTH;
 80076e8:	23ec      	movs	r3, #236	; 0xec
 80076ea:	837b      	strh	r3, [r7, #26]
 80076ec:	e037      	b.n	800775e <mpiExport+0xe4>
      }
   }
   else if(format == MPI_FORMAT_BIG_ENDIAN)
 80076ee:	78fb      	ldrb	r3, [r7, #3]
 80076f0:	2b01      	cmp	r3, #1
 80076f2:	d132      	bne.n	800775a <mpiExport+0xe0>
   {
      //Get the actual length in bytes
      n = mpiGetByteLength(a);
 80076f4:	68f8      	ldr	r0, [r7, #12]
 80076f6:	f7ff fc43 	bl	8006f80 <mpiGetByteLength>
 80076fa:	6178      	str	r0, [r7, #20]

      //Make sure the output buffer is large enough
      if(n <= length)
 80076fc:	697a      	ldr	r2, [r7, #20]
 80076fe:	687b      	ldr	r3, [r7, #4]
 8007700:	429a      	cmp	r2, r3
 8007702:	d827      	bhi.n	8007754 <mpiExport+0xda>
      {
         //Clear output buffer
         osMemset(data, 0, length);
 8007704:	687a      	ldr	r2, [r7, #4]
 8007706:	2100      	movs	r1, #0
 8007708:	68b8      	ldr	r0, [r7, #8]
 800770a:	f006 feeb 	bl	800e4e4 <memset>

         //Point to the least significant word
         data += length - 1;
 800770e:	687b      	ldr	r3, [r7, #4]
 8007710:	3b01      	subs	r3, #1
 8007712:	68ba      	ldr	r2, [r7, #8]
 8007714:	4413      	add	r3, r2
 8007716:	60bb      	str	r3, [r7, #8]

         //Export data
         for(i = 0; i < n; i++, data--)
 8007718:	2300      	movs	r3, #0
 800771a:	61fb      	str	r3, [r7, #28]
 800771c:	e015      	b.n	800774a <mpiExport+0xd0>
         {
            *data = a->data[i / MPI_INT_SIZE] >> ((i % MPI_INT_SIZE) * 8);
 800771e:	68fb      	ldr	r3, [r7, #12]
 8007720:	689a      	ldr	r2, [r3, #8]
 8007722:	69fb      	ldr	r3, [r7, #28]
 8007724:	f023 0303 	bic.w	r3, r3, #3
 8007728:	4413      	add	r3, r2
 800772a:	681a      	ldr	r2, [r3, #0]
 800772c:	69fb      	ldr	r3, [r7, #28]
 800772e:	f003 0303 	and.w	r3, r3, #3
 8007732:	00db      	lsls	r3, r3, #3
 8007734:	fa22 f303 	lsr.w	r3, r2, r3
 8007738:	b2da      	uxtb	r2, r3
 800773a:	68bb      	ldr	r3, [r7, #8]
 800773c:	701a      	strb	r2, [r3, #0]
         for(i = 0; i < n; i++, data--)
 800773e:	69fb      	ldr	r3, [r7, #28]
 8007740:	3301      	adds	r3, #1
 8007742:	61fb      	str	r3, [r7, #28]
 8007744:	68bb      	ldr	r3, [r7, #8]
 8007746:	3b01      	subs	r3, #1
 8007748:	60bb      	str	r3, [r7, #8]
 800774a:	69fa      	ldr	r2, [r7, #28]
 800774c:	697b      	ldr	r3, [r7, #20]
 800774e:	429a      	cmp	r2, r3
 8007750:	d3e5      	bcc.n	800771e <mpiExport+0xa4>
 8007752:	e004      	b.n	800775e <mpiExport+0xe4>
         }
      }
      else
      {
         //Report an error
         error = ERROR_INVALID_LENGTH;
 8007754:	23ec      	movs	r3, #236	; 0xec
 8007756:	837b      	strh	r3, [r7, #26]
 8007758:	e001      	b.n	800775e <mpiExport+0xe4>
      }
   }
   else
   {
      //Report an error
      error = ERROR_INVALID_PARAMETER;
 800775a:	2302      	movs	r3, #2
 800775c:	837b      	strh	r3, [r7, #26]
   }

   //Return status code
   return error;
 800775e:	8b7b      	ldrh	r3, [r7, #26]
}
 8007760:	4618      	mov	r0, r3
 8007762:	3720      	adds	r7, #32
 8007764:	46bd      	mov	sp, r7
 8007766:	bd80      	pop	{r7, pc}

08007768 <mpiAdd>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiAdd(Mpi *r, const Mpi *a, const Mpi *b)
{
 8007768:	b580      	push	{r7, lr}
 800776a:	b086      	sub	sp, #24
 800776c:	af00      	add	r7, sp, #0
 800776e:	60f8      	str	r0, [r7, #12]
 8007770:	60b9      	str	r1, [r7, #8]
 8007772:	607a      	str	r2, [r7, #4]
   error_t error;
   int_t sign;

   //Retrieve the sign of A
   sign = a->sign;
 8007774:	68bb      	ldr	r3, [r7, #8]
 8007776:	681b      	ldr	r3, [r3, #0]
 8007778:	613b      	str	r3, [r7, #16]

   //Both operands have the same sign?
   if(a->sign == b->sign)
 800777a:	68bb      	ldr	r3, [r7, #8]
 800777c:	681a      	ldr	r2, [r3, #0]
 800777e:	687b      	ldr	r3, [r7, #4]
 8007780:	681b      	ldr	r3, [r3, #0]
 8007782:	429a      	cmp	r2, r3
 8007784:	d10a      	bne.n	800779c <mpiAdd+0x34>
   {
      //Perform addition
      error = mpiAddAbs(r, a, b);
 8007786:	687a      	ldr	r2, [r7, #4]
 8007788:	68b9      	ldr	r1, [r7, #8]
 800778a:	68f8      	ldr	r0, [r7, #12]
 800778c:	f000 f8ac 	bl	80078e8 <mpiAddAbs>
 8007790:	4603      	mov	r3, r0
 8007792:	82fb      	strh	r3, [r7, #22]
      //Set the sign of the resulting number
      r->sign = sign;
 8007794:	68fb      	ldr	r3, [r7, #12]
 8007796:	693a      	ldr	r2, [r7, #16]
 8007798:	601a      	str	r2, [r3, #0]
 800779a:	e01c      	b.n	80077d6 <mpiAdd+0x6e>
   }
   //Operands have different signs?
   else
   {
      //Compare the absolute value of A and B
      if(mpiCompAbs(a, b) >= 0)
 800779c:	6879      	ldr	r1, [r7, #4]
 800779e:	68b8      	ldr	r0, [r7, #8]
 80077a0:	f7ff fd56 	bl	8007250 <mpiCompAbs>
 80077a4:	4603      	mov	r3, r0
 80077a6:	2b00      	cmp	r3, #0
 80077a8:	db0a      	blt.n	80077c0 <mpiAdd+0x58>
      {
         //Perform subtraction
         error = mpiSubAbs(r, a, b);
 80077aa:	687a      	ldr	r2, [r7, #4]
 80077ac:	68b9      	ldr	r1, [r7, #8]
 80077ae:	68f8      	ldr	r0, [r7, #12]
 80077b0:	f000 f94b 	bl	8007a4a <mpiSubAbs>
 80077b4:	4603      	mov	r3, r0
 80077b6:	82fb      	strh	r3, [r7, #22]
         //Set the sign of the resulting number
         r->sign = sign;
 80077b8:	68fb      	ldr	r3, [r7, #12]
 80077ba:	693a      	ldr	r2, [r7, #16]
 80077bc:	601a      	str	r2, [r3, #0]
 80077be:	e00a      	b.n	80077d6 <mpiAdd+0x6e>
      }
      else
      {
         //Perform subtraction
         error = mpiSubAbs(r, b, a);
 80077c0:	68ba      	ldr	r2, [r7, #8]
 80077c2:	6879      	ldr	r1, [r7, #4]
 80077c4:	68f8      	ldr	r0, [r7, #12]
 80077c6:	f000 f940 	bl	8007a4a <mpiSubAbs>
 80077ca:	4603      	mov	r3, r0
 80077cc:	82fb      	strh	r3, [r7, #22]
         //Set the sign of the resulting number
         r->sign = -sign;
 80077ce:	693b      	ldr	r3, [r7, #16]
 80077d0:	425a      	negs	r2, r3
 80077d2:	68fb      	ldr	r3, [r7, #12]
 80077d4:	601a      	str	r2, [r3, #0]
      }
   }

   //Return status code
   return error;
 80077d6:	8afb      	ldrh	r3, [r7, #22]
}
 80077d8:	4618      	mov	r0, r3
 80077da:	3718      	adds	r7, #24
 80077dc:	46bd      	mov	sp, r7
 80077de:	bd80      	pop	{r7, pc}

080077e0 <mpiAddInt>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiAddInt(Mpi *r, const Mpi *a, int_t b)
{
 80077e0:	b580      	push	{r7, lr}
 80077e2:	b088      	sub	sp, #32
 80077e4:	af00      	add	r7, sp, #0
 80077e6:	60f8      	str	r0, [r7, #12]
 80077e8:	60b9      	str	r1, [r7, #8]
 80077ea:	607a      	str	r2, [r7, #4]
   uint_t value;
   Mpi t;

   //Convert the second operand to a multiple precision integer
   value = (b >= 0) ? b : -b;
 80077ec:	687b      	ldr	r3, [r7, #4]
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	bfb8      	it	lt
 80077f2:	425b      	neglt	r3, r3
 80077f4:	61fb      	str	r3, [r7, #28]
   t.sign = (b >= 0) ? 1 : -1;
 80077f6:	687b      	ldr	r3, [r7, #4]
 80077f8:	2b00      	cmp	r3, #0
 80077fa:	db01      	blt.n	8007800 <mpiAddInt+0x20>
 80077fc:	2301      	movs	r3, #1
 80077fe:	e001      	b.n	8007804 <mpiAddInt+0x24>
 8007800:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007804:	613b      	str	r3, [r7, #16]
   t.size = 1;
 8007806:	2301      	movs	r3, #1
 8007808:	617b      	str	r3, [r7, #20]
   t.data = &value;
 800780a:	f107 031c 	add.w	r3, r7, #28
 800780e:	61bb      	str	r3, [r7, #24]

   //Perform addition
   return mpiAdd(r, a, &t);
 8007810:	f107 0310 	add.w	r3, r7, #16
 8007814:	461a      	mov	r2, r3
 8007816:	68b9      	ldr	r1, [r7, #8]
 8007818:	68f8      	ldr	r0, [r7, #12]
 800781a:	f7ff ffa5 	bl	8007768 <mpiAdd>
 800781e:	4603      	mov	r3, r0
}
 8007820:	4618      	mov	r0, r3
 8007822:	3720      	adds	r7, #32
 8007824:	46bd      	mov	sp, r7
 8007826:	bd80      	pop	{r7, pc}

08007828 <mpiSub>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiSub(Mpi *r, const Mpi *a, const Mpi *b)
{
 8007828:	b580      	push	{r7, lr}
 800782a:	b086      	sub	sp, #24
 800782c:	af00      	add	r7, sp, #0
 800782e:	60f8      	str	r0, [r7, #12]
 8007830:	60b9      	str	r1, [r7, #8]
 8007832:	607a      	str	r2, [r7, #4]
   error_t error;
   int_t sign;

   //Retrieve the sign of A
   sign = a->sign;
 8007834:	68bb      	ldr	r3, [r7, #8]
 8007836:	681b      	ldr	r3, [r3, #0]
 8007838:	613b      	str	r3, [r7, #16]

   //Both operands have the same sign?
   if(a->sign == b->sign)
 800783a:	68bb      	ldr	r3, [r7, #8]
 800783c:	681a      	ldr	r2, [r3, #0]
 800783e:	687b      	ldr	r3, [r7, #4]
 8007840:	681b      	ldr	r3, [r3, #0]
 8007842:	429a      	cmp	r2, r3
 8007844:	d11d      	bne.n	8007882 <mpiSub+0x5a>
   {
      //Compare the absolute value of A and B
      if(mpiCompAbs(a, b) >= 0)
 8007846:	6879      	ldr	r1, [r7, #4]
 8007848:	68b8      	ldr	r0, [r7, #8]
 800784a:	f7ff fd01 	bl	8007250 <mpiCompAbs>
 800784e:	4603      	mov	r3, r0
 8007850:	2b00      	cmp	r3, #0
 8007852:	db0a      	blt.n	800786a <mpiSub+0x42>
      {
         //Perform subtraction
         error = mpiSubAbs(r, a, b);
 8007854:	687a      	ldr	r2, [r7, #4]
 8007856:	68b9      	ldr	r1, [r7, #8]
 8007858:	68f8      	ldr	r0, [r7, #12]
 800785a:	f000 f8f6 	bl	8007a4a <mpiSubAbs>
 800785e:	4603      	mov	r3, r0
 8007860:	82fb      	strh	r3, [r7, #22]
         //Set the sign of the resulting number
         r->sign = sign;
 8007862:	68fb      	ldr	r3, [r7, #12]
 8007864:	693a      	ldr	r2, [r7, #16]
 8007866:	601a      	str	r2, [r3, #0]
 8007868:	e015      	b.n	8007896 <mpiSub+0x6e>
      }
      else
      {
         //Perform subtraction
         error = mpiSubAbs(r, b, a);
 800786a:	68ba      	ldr	r2, [r7, #8]
 800786c:	6879      	ldr	r1, [r7, #4]
 800786e:	68f8      	ldr	r0, [r7, #12]
 8007870:	f000 f8eb 	bl	8007a4a <mpiSubAbs>
 8007874:	4603      	mov	r3, r0
 8007876:	82fb      	strh	r3, [r7, #22]
         //Set the sign of the resulting number
         r->sign = -sign;
 8007878:	693b      	ldr	r3, [r7, #16]
 800787a:	425a      	negs	r2, r3
 800787c:	68fb      	ldr	r3, [r7, #12]
 800787e:	601a      	str	r2, [r3, #0]
 8007880:	e009      	b.n	8007896 <mpiSub+0x6e>
   }
   //Operands have different signs?
   else
   {
      //Perform addition
      error = mpiAddAbs(r, a, b);
 8007882:	687a      	ldr	r2, [r7, #4]
 8007884:	68b9      	ldr	r1, [r7, #8]
 8007886:	68f8      	ldr	r0, [r7, #12]
 8007888:	f000 f82e 	bl	80078e8 <mpiAddAbs>
 800788c:	4603      	mov	r3, r0
 800788e:	82fb      	strh	r3, [r7, #22]
      //Set the sign of the resulting number
      r->sign = sign;
 8007890:	68fb      	ldr	r3, [r7, #12]
 8007892:	693a      	ldr	r2, [r7, #16]
 8007894:	601a      	str	r2, [r3, #0]
   }

   //Return status code
   return error;
 8007896:	8afb      	ldrh	r3, [r7, #22]
}
 8007898:	4618      	mov	r0, r3
 800789a:	3718      	adds	r7, #24
 800789c:	46bd      	mov	sp, r7
 800789e:	bd80      	pop	{r7, pc}

080078a0 <mpiSubInt>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiSubInt(Mpi *r, const Mpi *a, int_t b)
{
 80078a0:	b580      	push	{r7, lr}
 80078a2:	b088      	sub	sp, #32
 80078a4:	af00      	add	r7, sp, #0
 80078a6:	60f8      	str	r0, [r7, #12]
 80078a8:	60b9      	str	r1, [r7, #8]
 80078aa:	607a      	str	r2, [r7, #4]
   uint_t value;
   Mpi t;

   //Convert the second operand to a multiple precision integer
   value = (b >= 0) ? b : -b;
 80078ac:	687b      	ldr	r3, [r7, #4]
 80078ae:	2b00      	cmp	r3, #0
 80078b0:	bfb8      	it	lt
 80078b2:	425b      	neglt	r3, r3
 80078b4:	61fb      	str	r3, [r7, #28]
   t.sign = (b >= 0) ? 1 : -1;
 80078b6:	687b      	ldr	r3, [r7, #4]
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	db01      	blt.n	80078c0 <mpiSubInt+0x20>
 80078bc:	2301      	movs	r3, #1
 80078be:	e001      	b.n	80078c4 <mpiSubInt+0x24>
 80078c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80078c4:	613b      	str	r3, [r7, #16]
   t.size = 1;
 80078c6:	2301      	movs	r3, #1
 80078c8:	617b      	str	r3, [r7, #20]
   t.data = &value;
 80078ca:	f107 031c 	add.w	r3, r7, #28
 80078ce:	61bb      	str	r3, [r7, #24]

   //Perform subtraction
   return mpiSub(r, a, &t);
 80078d0:	f107 0310 	add.w	r3, r7, #16
 80078d4:	461a      	mov	r2, r3
 80078d6:	68b9      	ldr	r1, [r7, #8]
 80078d8:	68f8      	ldr	r0, [r7, #12]
 80078da:	f7ff ffa5 	bl	8007828 <mpiSub>
 80078de:	4603      	mov	r3, r0
}
 80078e0:	4618      	mov	r0, r3
 80078e2:	3720      	adds	r7, #32
 80078e4:	46bd      	mov	sp, r7
 80078e6:	bd80      	pop	{r7, pc}

080078e8 <mpiAddAbs>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiAddAbs(Mpi *r, const Mpi *a, const Mpi *b)
{
 80078e8:	b580      	push	{r7, lr}
 80078ea:	b08a      	sub	sp, #40	; 0x28
 80078ec:	af00      	add	r7, sp, #0
 80078ee:	60f8      	str	r0, [r7, #12]
 80078f0:	60b9      	str	r1, [r7, #8]
 80078f2:	607a      	str	r2, [r7, #4]
   uint_t n;
   uint_t c;
   uint_t d;

   //R and B are the same instance?
   if(r == b)
 80078f4:	68fa      	ldr	r2, [r7, #12]
 80078f6:	687b      	ldr	r3, [r7, #4]
 80078f8:	429a      	cmp	r2, r3
 80078fa:	d106      	bne.n	800790a <mpiAddAbs+0x22>
   {
      //Swap A and B
      const Mpi *t = a;
 80078fc:	68bb      	ldr	r3, [r7, #8]
 80078fe:	61bb      	str	r3, [r7, #24]
      a = b;
 8007900:	687b      	ldr	r3, [r7, #4]
 8007902:	60bb      	str	r3, [r7, #8]
      b = t;
 8007904:	69bb      	ldr	r3, [r7, #24]
 8007906:	607b      	str	r3, [r7, #4]
 8007908:	e00d      	b.n	8007926 <mpiAddAbs+0x3e>
   }
   //R is neither A nor B?
   else if(r != a)
 800790a:	68fa      	ldr	r2, [r7, #12]
 800790c:	68bb      	ldr	r3, [r7, #8]
 800790e:	429a      	cmp	r2, r3
 8007910:	d009      	beq.n	8007926 <mpiAddAbs+0x3e>
   {
      //Copy the first operand to R
      MPI_CHECK(mpiCopy(r, a));
 8007912:	68b9      	ldr	r1, [r7, #8]
 8007914:	68f8      	ldr	r0, [r7, #12]
 8007916:	f7ff fce8 	bl	80072ea <mpiCopy>
 800791a:	4603      	mov	r3, r0
 800791c:	84fb      	strh	r3, [r7, #38]	; 0x26
 800791e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007920:	2b00      	cmp	r3, #0
 8007922:	f040 8086 	bne.w	8007a32 <mpiAddAbs+0x14a>
   }

   //Determine the actual length of B
   n = mpiGetLength(b);
 8007926:	6878      	ldr	r0, [r7, #4]
 8007928:	f7ff fb03 	bl	8006f32 <mpiGetLength>
 800792c:	6178      	str	r0, [r7, #20]
   //Extend the size of the destination register as needed
   MPI_CHECK(mpiGrow(r, n));
 800792e:	6979      	ldr	r1, [r7, #20]
 8007930:	68f8      	ldr	r0, [r7, #12]
 8007932:	f7ff fabe 	bl	8006eb2 <mpiGrow>
 8007936:	4603      	mov	r3, r0
 8007938:	84fb      	strh	r3, [r7, #38]	; 0x26
 800793a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800793c:	2b00      	cmp	r3, #0
 800793e:	d17a      	bne.n	8007a36 <mpiAddAbs+0x14e>

   //The result is always positive
   r->sign = 1;
 8007940:	68fb      	ldr	r3, [r7, #12]
 8007942:	2201      	movs	r2, #1
 8007944:	601a      	str	r2, [r3, #0]
   //Clear carry bit
   c = 0;
 8007946:	2300      	movs	r3, #0
 8007948:	61fb      	str	r3, [r7, #28]

   //Add operands
   for(i = 0; i < n; i++)
 800794a:	2300      	movs	r3, #0
 800794c:	623b      	str	r3, [r7, #32]
 800794e:	e02b      	b.n	80079a8 <mpiAddAbs+0xc0>
   {
      //Add carry bit
      d = r->data[i] + c;
 8007950:	68fb      	ldr	r3, [r7, #12]
 8007952:	689a      	ldr	r2, [r3, #8]
 8007954:	6a3b      	ldr	r3, [r7, #32]
 8007956:	009b      	lsls	r3, r3, #2
 8007958:	4413      	add	r3, r2
 800795a:	681b      	ldr	r3, [r3, #0]
 800795c:	69fa      	ldr	r2, [r7, #28]
 800795e:	4413      	add	r3, r2
 8007960:	613b      	str	r3, [r7, #16]
      //Update carry bit
      if(d != 0) c = 0;
 8007962:	693b      	ldr	r3, [r7, #16]
 8007964:	2b00      	cmp	r3, #0
 8007966:	d001      	beq.n	800796c <mpiAddAbs+0x84>
 8007968:	2300      	movs	r3, #0
 800796a:	61fb      	str	r3, [r7, #28]
      //Perform addition
      d += b->data[i];
 800796c:	687b      	ldr	r3, [r7, #4]
 800796e:	689a      	ldr	r2, [r3, #8]
 8007970:	6a3b      	ldr	r3, [r7, #32]
 8007972:	009b      	lsls	r3, r3, #2
 8007974:	4413      	add	r3, r2
 8007976:	681b      	ldr	r3, [r3, #0]
 8007978:	693a      	ldr	r2, [r7, #16]
 800797a:	4413      	add	r3, r2
 800797c:	613b      	str	r3, [r7, #16]
      //Update carry bit
      if(d < b->data[i]) c = 1;
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	689a      	ldr	r2, [r3, #8]
 8007982:	6a3b      	ldr	r3, [r7, #32]
 8007984:	009b      	lsls	r3, r3, #2
 8007986:	4413      	add	r3, r2
 8007988:	681b      	ldr	r3, [r3, #0]
 800798a:	693a      	ldr	r2, [r7, #16]
 800798c:	429a      	cmp	r2, r3
 800798e:	d201      	bcs.n	8007994 <mpiAddAbs+0xac>
 8007990:	2301      	movs	r3, #1
 8007992:	61fb      	str	r3, [r7, #28]
      //Save result
      r->data[i] = d;
 8007994:	68fb      	ldr	r3, [r7, #12]
 8007996:	689a      	ldr	r2, [r3, #8]
 8007998:	6a3b      	ldr	r3, [r7, #32]
 800799a:	009b      	lsls	r3, r3, #2
 800799c:	4413      	add	r3, r2
 800799e:	693a      	ldr	r2, [r7, #16]
 80079a0:	601a      	str	r2, [r3, #0]
   for(i = 0; i < n; i++)
 80079a2:	6a3b      	ldr	r3, [r7, #32]
 80079a4:	3301      	adds	r3, #1
 80079a6:	623b      	str	r3, [r7, #32]
 80079a8:	6a3a      	ldr	r2, [r7, #32]
 80079aa:	697b      	ldr	r3, [r7, #20]
 80079ac:	429a      	cmp	r2, r3
 80079ae:	d3cf      	bcc.n	8007950 <mpiAddAbs+0x68>
   }

   //Loop as long as the carry bit is set
   for(i = n; c && i < r->size; i++)
 80079b0:	697b      	ldr	r3, [r7, #20]
 80079b2:	623b      	str	r3, [r7, #32]
 80079b4:	e01a      	b.n	80079ec <mpiAddAbs+0x104>
   {
      //Add carry bit
      r->data[i] += c;
 80079b6:	68fb      	ldr	r3, [r7, #12]
 80079b8:	689a      	ldr	r2, [r3, #8]
 80079ba:	6a3b      	ldr	r3, [r7, #32]
 80079bc:	009b      	lsls	r3, r3, #2
 80079be:	4413      	add	r3, r2
 80079c0:	6819      	ldr	r1, [r3, #0]
 80079c2:	68fb      	ldr	r3, [r7, #12]
 80079c4:	689a      	ldr	r2, [r3, #8]
 80079c6:	6a3b      	ldr	r3, [r7, #32]
 80079c8:	009b      	lsls	r3, r3, #2
 80079ca:	4413      	add	r3, r2
 80079cc:	69fa      	ldr	r2, [r7, #28]
 80079ce:	440a      	add	r2, r1
 80079d0:	601a      	str	r2, [r3, #0]
      //Update carry bit
      if(r->data[i] != 0) c = 0;
 80079d2:	68fb      	ldr	r3, [r7, #12]
 80079d4:	689a      	ldr	r2, [r3, #8]
 80079d6:	6a3b      	ldr	r3, [r7, #32]
 80079d8:	009b      	lsls	r3, r3, #2
 80079da:	4413      	add	r3, r2
 80079dc:	681b      	ldr	r3, [r3, #0]
 80079de:	2b00      	cmp	r3, #0
 80079e0:	d001      	beq.n	80079e6 <mpiAddAbs+0xfe>
 80079e2:	2300      	movs	r3, #0
 80079e4:	61fb      	str	r3, [r7, #28]
   for(i = n; c && i < r->size; i++)
 80079e6:	6a3b      	ldr	r3, [r7, #32]
 80079e8:	3301      	adds	r3, #1
 80079ea:	623b      	str	r3, [r7, #32]
 80079ec:	69fb      	ldr	r3, [r7, #28]
 80079ee:	2b00      	cmp	r3, #0
 80079f0:	d004      	beq.n	80079fc <mpiAddAbs+0x114>
 80079f2:	68fb      	ldr	r3, [r7, #12]
 80079f4:	685b      	ldr	r3, [r3, #4]
 80079f6:	6a3a      	ldr	r2, [r7, #32]
 80079f8:	429a      	cmp	r2, r3
 80079fa:	d3dc      	bcc.n	80079b6 <mpiAddAbs+0xce>
   }

   //Check the final carry bit
   if(c && n >= r->size)
 80079fc:	69fb      	ldr	r3, [r7, #28]
 80079fe:	2b00      	cmp	r3, #0
 8007a00:	d01b      	beq.n	8007a3a <mpiAddAbs+0x152>
 8007a02:	68fb      	ldr	r3, [r7, #12]
 8007a04:	685b      	ldr	r3, [r3, #4]
 8007a06:	697a      	ldr	r2, [r7, #20]
 8007a08:	429a      	cmp	r2, r3
 8007a0a:	d316      	bcc.n	8007a3a <mpiAddAbs+0x152>
   {
      //Extend the size of the destination register
      MPI_CHECK(mpiGrow(r, n + 1));
 8007a0c:	697b      	ldr	r3, [r7, #20]
 8007a0e:	3301      	adds	r3, #1
 8007a10:	4619      	mov	r1, r3
 8007a12:	68f8      	ldr	r0, [r7, #12]
 8007a14:	f7ff fa4d 	bl	8006eb2 <mpiGrow>
 8007a18:	4603      	mov	r3, r0
 8007a1a:	84fb      	strh	r3, [r7, #38]	; 0x26
 8007a1c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d10d      	bne.n	8007a3e <mpiAddAbs+0x156>
      //Add carry bit
      r->data[n] = 1;
 8007a22:	68fb      	ldr	r3, [r7, #12]
 8007a24:	689a      	ldr	r2, [r3, #8]
 8007a26:	697b      	ldr	r3, [r7, #20]
 8007a28:	009b      	lsls	r3, r3, #2
 8007a2a:	4413      	add	r3, r2
 8007a2c:	2201      	movs	r2, #1
 8007a2e:	601a      	str	r2, [r3, #0]
 8007a30:	e006      	b.n	8007a40 <mpiAddAbs+0x158>
      MPI_CHECK(mpiCopy(r, a));
 8007a32:	bf00      	nop
 8007a34:	e004      	b.n	8007a40 <mpiAddAbs+0x158>
   MPI_CHECK(mpiGrow(r, n));
 8007a36:	bf00      	nop
 8007a38:	e002      	b.n	8007a40 <mpiAddAbs+0x158>
   }

end:
 8007a3a:	bf00      	nop
 8007a3c:	e000      	b.n	8007a40 <mpiAddAbs+0x158>
      MPI_CHECK(mpiGrow(r, n + 1));
 8007a3e:	bf00      	nop
   //Return status code
   return error;
 8007a40:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
 8007a42:	4618      	mov	r0, r3
 8007a44:	3728      	adds	r7, #40	; 0x28
 8007a46:	46bd      	mov	sp, r7
 8007a48:	bd80      	pop	{r7, pc}

08007a4a <mpiSubAbs>:
 * @param[in] b Second operand B
 * @return Error code
 **/

error_t mpiSubAbs(Mpi *r, const Mpi *a, const Mpi *b)
{
 8007a4a:	b580      	push	{r7, lr}
 8007a4c:	b08c      	sub	sp, #48	; 0x30
 8007a4e:	af00      	add	r7, sp, #0
 8007a50:	60f8      	str	r0, [r7, #12]
 8007a52:	60b9      	str	r1, [r7, #8]
 8007a54:	607a      	str	r2, [r7, #4]
   uint_t i;
   uint_t m;
   uint_t n;

   //Check input parameters
   if(mpiCompAbs(a, b) < 0)
 8007a56:	6879      	ldr	r1, [r7, #4]
 8007a58:	68b8      	ldr	r0, [r7, #8]
 8007a5a:	f7ff fbf9 	bl	8007250 <mpiCompAbs>
 8007a5e:	4603      	mov	r3, r0
 8007a60:	2b00      	cmp	r3, #0
 8007a62:	da05      	bge.n	8007a70 <mpiSubAbs+0x26>
   {
      //Swap A and B if necessary
      const Mpi *t = b;
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	623b      	str	r3, [r7, #32]
      a = b;
 8007a68:	687b      	ldr	r3, [r7, #4]
 8007a6a:	60bb      	str	r3, [r7, #8]
      b = t;
 8007a6c:	6a3b      	ldr	r3, [r7, #32]
 8007a6e:	607b      	str	r3, [r7, #4]
   }

   //Determine the actual length of A
   m = mpiGetLength(a);
 8007a70:	68b8      	ldr	r0, [r7, #8]
 8007a72:	f7ff fa5e 	bl	8006f32 <mpiGetLength>
 8007a76:	61f8      	str	r0, [r7, #28]
   //Determine the actual length of B
   n = mpiGetLength(b);
 8007a78:	6878      	ldr	r0, [r7, #4]
 8007a7a:	f7ff fa5a 	bl	8006f32 <mpiGetLength>
 8007a7e:	61b8      	str	r0, [r7, #24]

   //Extend the size of the destination register as needed
   MPI_CHECK(mpiGrow(r, m));
 8007a80:	69f9      	ldr	r1, [r7, #28]
 8007a82:	68f8      	ldr	r0, [r7, #12]
 8007a84:	f7ff fa15 	bl	8006eb2 <mpiGrow>
 8007a88:	4603      	mov	r3, r0
 8007a8a:	82fb      	strh	r3, [r7, #22]
 8007a8c:	8afb      	ldrh	r3, [r7, #22]
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	f040 8087 	bne.w	8007ba2 <mpiSubAbs+0x158>

   //The result is always positive
   r->sign = 1;
 8007a94:	68fb      	ldr	r3, [r7, #12]
 8007a96:	2201      	movs	r2, #1
 8007a98:	601a      	str	r2, [r3, #0]
   //Clear carry bit
   c = 0;
 8007a9a:	2300      	movs	r3, #0
 8007a9c:	62fb      	str	r3, [r7, #44]	; 0x2c

   //Subtract operands
   for(i = 0; i < n; i++)
 8007a9e:	2300      	movs	r3, #0
 8007aa0:	627b      	str	r3, [r7, #36]	; 0x24
 8007aa2:	e02d      	b.n	8007b00 <mpiSubAbs+0xb6>
   {
      //Read first operand
      d = a->data[i];
 8007aa4:	68bb      	ldr	r3, [r7, #8]
 8007aa6:	689a      	ldr	r2, [r3, #8]
 8007aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007aaa:	009b      	lsls	r3, r3, #2
 8007aac:	4413      	add	r3, r2
 8007aae:	681b      	ldr	r3, [r3, #0]
 8007ab0:	62bb      	str	r3, [r7, #40]	; 0x28

      //Check the carry bit
      if(c)
 8007ab2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007ab4:	2b00      	cmp	r3, #0
 8007ab6:	d007      	beq.n	8007ac8 <mpiSubAbs+0x7e>
      {
         //Update carry bit
         if(d != 0) c = 0;
 8007ab8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007aba:	2b00      	cmp	r3, #0
 8007abc:	d001      	beq.n	8007ac2 <mpiSubAbs+0x78>
 8007abe:	2300      	movs	r3, #0
 8007ac0:	62fb      	str	r3, [r7, #44]	; 0x2c
         //Propagate carry bit
         d -= 1;
 8007ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007ac4:	3b01      	subs	r3, #1
 8007ac6:	62bb      	str	r3, [r7, #40]	; 0x28
      }

      //Update carry bit
      if(d < b->data[i]) c = 1;
 8007ac8:	687b      	ldr	r3, [r7, #4]
 8007aca:	689a      	ldr	r2, [r3, #8]
 8007acc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ace:	009b      	lsls	r3, r3, #2
 8007ad0:	4413      	add	r3, r2
 8007ad2:	681b      	ldr	r3, [r3, #0]
 8007ad4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007ad6:	429a      	cmp	r2, r3
 8007ad8:	d201      	bcs.n	8007ade <mpiSubAbs+0x94>
 8007ada:	2301      	movs	r3, #1
 8007adc:	62fb      	str	r3, [r7, #44]	; 0x2c
      //Perform subtraction
      r->data[i] = d - b->data[i];
 8007ade:	687b      	ldr	r3, [r7, #4]
 8007ae0:	689a      	ldr	r2, [r3, #8]
 8007ae2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ae4:	009b      	lsls	r3, r3, #2
 8007ae6:	4413      	add	r3, r2
 8007ae8:	681a      	ldr	r2, [r3, #0]
 8007aea:	68fb      	ldr	r3, [r7, #12]
 8007aec:	6899      	ldr	r1, [r3, #8]
 8007aee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007af0:	009b      	lsls	r3, r3, #2
 8007af2:	440b      	add	r3, r1
 8007af4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007af6:	1a8a      	subs	r2, r1, r2
 8007af8:	601a      	str	r2, [r3, #0]
   for(i = 0; i < n; i++)
 8007afa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007afc:	3301      	adds	r3, #1
 8007afe:	627b      	str	r3, [r7, #36]	; 0x24
 8007b00:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007b02:	69bb      	ldr	r3, [r7, #24]
 8007b04:	429a      	cmp	r2, r3
 8007b06:	d3cd      	bcc.n	8007aa4 <mpiSubAbs+0x5a>
   }

   //Loop as long as the carry bit is set
   for(i = n; c && i < m; i++)
 8007b08:	69bb      	ldr	r3, [r7, #24]
 8007b0a:	627b      	str	r3, [r7, #36]	; 0x24
 8007b0c:	e019      	b.n	8007b42 <mpiSubAbs+0xf8>
   {
      //Update carry bit
      if(a->data[i] != 0) c = 0;
 8007b0e:	68bb      	ldr	r3, [r7, #8]
 8007b10:	689a      	ldr	r2, [r3, #8]
 8007b12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b14:	009b      	lsls	r3, r3, #2
 8007b16:	4413      	add	r3, r2
 8007b18:	681b      	ldr	r3, [r3, #0]
 8007b1a:	2b00      	cmp	r3, #0
 8007b1c:	d001      	beq.n	8007b22 <mpiSubAbs+0xd8>
 8007b1e:	2300      	movs	r3, #0
 8007b20:	62fb      	str	r3, [r7, #44]	; 0x2c
      //Propagate carry bit
      r->data[i] = a->data[i] - 1;
 8007b22:	68bb      	ldr	r3, [r7, #8]
 8007b24:	689a      	ldr	r2, [r3, #8]
 8007b26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b28:	009b      	lsls	r3, r3, #2
 8007b2a:	4413      	add	r3, r2
 8007b2c:	681a      	ldr	r2, [r3, #0]
 8007b2e:	68fb      	ldr	r3, [r7, #12]
 8007b30:	6899      	ldr	r1, [r3, #8]
 8007b32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b34:	009b      	lsls	r3, r3, #2
 8007b36:	440b      	add	r3, r1
 8007b38:	3a01      	subs	r2, #1
 8007b3a:	601a      	str	r2, [r3, #0]
   for(i = n; c && i < m; i++)
 8007b3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b3e:	3301      	adds	r3, #1
 8007b40:	627b      	str	r3, [r7, #36]	; 0x24
 8007b42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007b44:	2b00      	cmp	r3, #0
 8007b46:	d003      	beq.n	8007b50 <mpiSubAbs+0x106>
 8007b48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007b4a:	69fb      	ldr	r3, [r7, #28]
 8007b4c:	429a      	cmp	r2, r3
 8007b4e:	d3de      	bcc.n	8007b0e <mpiSubAbs+0xc4>
   }

   //R and A are not the same instance?
   if(r != a)
 8007b50:	68fa      	ldr	r2, [r7, #12]
 8007b52:	68bb      	ldr	r3, [r7, #8]
 8007b54:	429a      	cmp	r2, r3
 8007b56:	d026      	beq.n	8007ba6 <mpiSubAbs+0x15c>
   {
      //Copy the remaining words
      for(; i < m; i++)
 8007b58:	e00e      	b.n	8007b78 <mpiSubAbs+0x12e>
      {
         r->data[i] = a->data[i];
 8007b5a:	68bb      	ldr	r3, [r7, #8]
 8007b5c:	689a      	ldr	r2, [r3, #8]
 8007b5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b60:	009b      	lsls	r3, r3, #2
 8007b62:	441a      	add	r2, r3
 8007b64:	68fb      	ldr	r3, [r7, #12]
 8007b66:	6899      	ldr	r1, [r3, #8]
 8007b68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b6a:	009b      	lsls	r3, r3, #2
 8007b6c:	440b      	add	r3, r1
 8007b6e:	6812      	ldr	r2, [r2, #0]
 8007b70:	601a      	str	r2, [r3, #0]
      for(; i < m; i++)
 8007b72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b74:	3301      	adds	r3, #1
 8007b76:	627b      	str	r3, [r7, #36]	; 0x24
 8007b78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007b7a:	69fb      	ldr	r3, [r7, #28]
 8007b7c:	429a      	cmp	r2, r3
 8007b7e:	d3ec      	bcc.n	8007b5a <mpiSubAbs+0x110>
      }

      //Zero the upper part of R
      for(; i < r->size; i++)
 8007b80:	e009      	b.n	8007b96 <mpiSubAbs+0x14c>
      {
         r->data[i] = 0;
 8007b82:	68fb      	ldr	r3, [r7, #12]
 8007b84:	689a      	ldr	r2, [r3, #8]
 8007b86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b88:	009b      	lsls	r3, r3, #2
 8007b8a:	4413      	add	r3, r2
 8007b8c:	2200      	movs	r2, #0
 8007b8e:	601a      	str	r2, [r3, #0]
      for(; i < r->size; i++)
 8007b90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b92:	3301      	adds	r3, #1
 8007b94:	627b      	str	r3, [r7, #36]	; 0x24
 8007b96:	68fb      	ldr	r3, [r7, #12]
 8007b98:	685b      	ldr	r3, [r3, #4]
 8007b9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007b9c:	429a      	cmp	r2, r3
 8007b9e:	d3f0      	bcc.n	8007b82 <mpiSubAbs+0x138>
      }
   }

end:
 8007ba0:	e001      	b.n	8007ba6 <mpiSubAbs+0x15c>
   MPI_CHECK(mpiGrow(r, m));
 8007ba2:	bf00      	nop
 8007ba4:	e000      	b.n	8007ba8 <mpiSubAbs+0x15e>
end:
 8007ba6:	bf00      	nop
   //Return status code
   return error;
 8007ba8:	8afb      	ldrh	r3, [r7, #22]
}
 8007baa:	4618      	mov	r0, r3
 8007bac:	3730      	adds	r7, #48	; 0x30
 8007bae:	46bd      	mov	sp, r7
 8007bb0:	bd80      	pop	{r7, pc}

08007bb2 <mpiShiftLeft>:
 * @param[in] n The number of bits to shift
 * @return Error code
 **/

error_t mpiShiftLeft(Mpi *r, uint_t n)
{
 8007bb2:	b580      	push	{r7, lr}
 8007bb4:	b086      	sub	sp, #24
 8007bb6:	af00      	add	r7, sp, #0
 8007bb8:	6078      	str	r0, [r7, #4]
 8007bba:	6039      	str	r1, [r7, #0]
   error_t error;
   uint_t i;

   //Number of 32-bit words to shift
   uint_t n1 = n / (MPI_INT_SIZE * 8);
 8007bbc:	683b      	ldr	r3, [r7, #0]
 8007bbe:	095b      	lsrs	r3, r3, #5
 8007bc0:	613b      	str	r3, [r7, #16]
   //Number of bits to shift
   uint_t n2 = n % (MPI_INT_SIZE * 8);
 8007bc2:	683b      	ldr	r3, [r7, #0]
 8007bc4:	f003 031f 	and.w	r3, r3, #31
 8007bc8:	60fb      	str	r3, [r7, #12]

   //Check parameters
   if(!r->size || !n)
 8007bca:	687b      	ldr	r3, [r7, #4]
 8007bcc:	685b      	ldr	r3, [r3, #4]
 8007bce:	2b00      	cmp	r3, #0
 8007bd0:	d002      	beq.n	8007bd8 <mpiShiftLeft+0x26>
 8007bd2:	683b      	ldr	r3, [r7, #0]
 8007bd4:	2b00      	cmp	r3, #0
 8007bd6:	d101      	bne.n	8007bdc <mpiShiftLeft+0x2a>
      return NO_ERROR;
 8007bd8:	2300      	movs	r3, #0
 8007bda:	e073      	b.n	8007cc4 <mpiShiftLeft+0x112>

   //Increase the size of the multiple-precision number
   error = mpiGrow(r, r->size + (n + 31) / 32);
 8007bdc:	687b      	ldr	r3, [r7, #4]
 8007bde:	685a      	ldr	r2, [r3, #4]
 8007be0:	683b      	ldr	r3, [r7, #0]
 8007be2:	331f      	adds	r3, #31
 8007be4:	095b      	lsrs	r3, r3, #5
 8007be6:	4413      	add	r3, r2
 8007be8:	4619      	mov	r1, r3
 8007bea:	6878      	ldr	r0, [r7, #4]
 8007bec:	f7ff f961 	bl	8006eb2 <mpiGrow>
 8007bf0:	4603      	mov	r3, r0
 8007bf2:	817b      	strh	r3, [r7, #10]
   //Check return code
   if(error)
 8007bf4:	897b      	ldrh	r3, [r7, #10]
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d001      	beq.n	8007bfe <mpiShiftLeft+0x4c>
      return error;
 8007bfa:	897b      	ldrh	r3, [r7, #10]
 8007bfc:	e062      	b.n	8007cc4 <mpiShiftLeft+0x112>

   //First, shift words
   if(n1 > 0)
 8007bfe:	693b      	ldr	r3, [r7, #16]
 8007c00:	2b00      	cmp	r3, #0
 8007c02:	d02a      	beq.n	8007c5a <mpiShiftLeft+0xa8>
   {
      //Process the most significant words
      for(i = r->size - 1; i >= n1; i--)
 8007c04:	687b      	ldr	r3, [r7, #4]
 8007c06:	685b      	ldr	r3, [r3, #4]
 8007c08:	3b01      	subs	r3, #1
 8007c0a:	617b      	str	r3, [r7, #20]
 8007c0c:	e010      	b.n	8007c30 <mpiShiftLeft+0x7e>
      {
         r->data[i] = r->data[i - n1];
 8007c0e:	687b      	ldr	r3, [r7, #4]
 8007c10:	689a      	ldr	r2, [r3, #8]
 8007c12:	6979      	ldr	r1, [r7, #20]
 8007c14:	693b      	ldr	r3, [r7, #16]
 8007c16:	1acb      	subs	r3, r1, r3
 8007c18:	009b      	lsls	r3, r3, #2
 8007c1a:	441a      	add	r2, r3
 8007c1c:	687b      	ldr	r3, [r7, #4]
 8007c1e:	6899      	ldr	r1, [r3, #8]
 8007c20:	697b      	ldr	r3, [r7, #20]
 8007c22:	009b      	lsls	r3, r3, #2
 8007c24:	440b      	add	r3, r1
 8007c26:	6812      	ldr	r2, [r2, #0]
 8007c28:	601a      	str	r2, [r3, #0]
      for(i = r->size - 1; i >= n1; i--)
 8007c2a:	697b      	ldr	r3, [r7, #20]
 8007c2c:	3b01      	subs	r3, #1
 8007c2e:	617b      	str	r3, [r7, #20]
 8007c30:	697a      	ldr	r2, [r7, #20]
 8007c32:	693b      	ldr	r3, [r7, #16]
 8007c34:	429a      	cmp	r2, r3
 8007c36:	d2ea      	bcs.n	8007c0e <mpiShiftLeft+0x5c>
      }

      //Fill the rest with zeroes
      for(i = 0; i < n1; i++)
 8007c38:	2300      	movs	r3, #0
 8007c3a:	617b      	str	r3, [r7, #20]
 8007c3c:	e009      	b.n	8007c52 <mpiShiftLeft+0xa0>
      {
         r->data[i] = 0;
 8007c3e:	687b      	ldr	r3, [r7, #4]
 8007c40:	689a      	ldr	r2, [r3, #8]
 8007c42:	697b      	ldr	r3, [r7, #20]
 8007c44:	009b      	lsls	r3, r3, #2
 8007c46:	4413      	add	r3, r2
 8007c48:	2200      	movs	r2, #0
 8007c4a:	601a      	str	r2, [r3, #0]
      for(i = 0; i < n1; i++)
 8007c4c:	697b      	ldr	r3, [r7, #20]
 8007c4e:	3301      	adds	r3, #1
 8007c50:	617b      	str	r3, [r7, #20]
 8007c52:	697a      	ldr	r2, [r7, #20]
 8007c54:	693b      	ldr	r3, [r7, #16]
 8007c56:	429a      	cmp	r2, r3
 8007c58:	d3f1      	bcc.n	8007c3e <mpiShiftLeft+0x8c>
      }
   }

   //Then shift bits
   if(n2 > 0)
 8007c5a:	68fb      	ldr	r3, [r7, #12]
 8007c5c:	2b00      	cmp	r3, #0
 8007c5e:	d030      	beq.n	8007cc2 <mpiShiftLeft+0x110>
   {
      //Process the most significant words
      for(i = r->size - 1; i >= 1; i--)
 8007c60:	687b      	ldr	r3, [r7, #4]
 8007c62:	685b      	ldr	r3, [r3, #4]
 8007c64:	3b01      	subs	r3, #1
 8007c66:	617b      	str	r3, [r7, #20]
 8007c68:	e01f      	b.n	8007caa <mpiShiftLeft+0xf8>
      {
         r->data[i] = (r->data[i] << n2) | (r->data[i - 1] >> (32 - n2));
 8007c6a:	687b      	ldr	r3, [r7, #4]
 8007c6c:	689a      	ldr	r2, [r3, #8]
 8007c6e:	697b      	ldr	r3, [r7, #20]
 8007c70:	009b      	lsls	r3, r3, #2
 8007c72:	4413      	add	r3, r2
 8007c74:	681a      	ldr	r2, [r3, #0]
 8007c76:	68fb      	ldr	r3, [r7, #12]
 8007c78:	fa02 f103 	lsl.w	r1, r2, r3
 8007c7c:	687b      	ldr	r3, [r7, #4]
 8007c7e:	689a      	ldr	r2, [r3, #8]
 8007c80:	697b      	ldr	r3, [r7, #20]
 8007c82:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007c86:	3b01      	subs	r3, #1
 8007c88:	009b      	lsls	r3, r3, #2
 8007c8a:	4413      	add	r3, r2
 8007c8c:	681a      	ldr	r2, [r3, #0]
 8007c8e:	68fb      	ldr	r3, [r7, #12]
 8007c90:	f1c3 0320 	rsb	r3, r3, #32
 8007c94:	40da      	lsrs	r2, r3
 8007c96:	687b      	ldr	r3, [r7, #4]
 8007c98:	6898      	ldr	r0, [r3, #8]
 8007c9a:	697b      	ldr	r3, [r7, #20]
 8007c9c:	009b      	lsls	r3, r3, #2
 8007c9e:	4403      	add	r3, r0
 8007ca0:	430a      	orrs	r2, r1
 8007ca2:	601a      	str	r2, [r3, #0]
      for(i = r->size - 1; i >= 1; i--)
 8007ca4:	697b      	ldr	r3, [r7, #20]
 8007ca6:	3b01      	subs	r3, #1
 8007ca8:	617b      	str	r3, [r7, #20]
 8007caa:	697b      	ldr	r3, [r7, #20]
 8007cac:	2b00      	cmp	r3, #0
 8007cae:	d1dc      	bne.n	8007c6a <mpiShiftLeft+0xb8>
      }

      //The least significant word requires a special handling
      r->data[0] <<= n2;
 8007cb0:	687b      	ldr	r3, [r7, #4]
 8007cb2:	689b      	ldr	r3, [r3, #8]
 8007cb4:	6819      	ldr	r1, [r3, #0]
 8007cb6:	687b      	ldr	r3, [r7, #4]
 8007cb8:	689b      	ldr	r3, [r3, #8]
 8007cba:	68fa      	ldr	r2, [r7, #12]
 8007cbc:	fa01 f202 	lsl.w	r2, r1, r2
 8007cc0:	601a      	str	r2, [r3, #0]
   }

   //Shift operation is complete
   return NO_ERROR;
 8007cc2:	2300      	movs	r3, #0
}
 8007cc4:	4618      	mov	r0, r3
 8007cc6:	3718      	adds	r7, #24
 8007cc8:	46bd      	mov	sp, r7
 8007cca:	bd80      	pop	{r7, pc}

08007ccc <mpiShiftRight>:
 * @param[in] n The number of bits to shift
 * @return Error code
 **/

error_t mpiShiftRight(Mpi *r, uint_t n)
{
 8007ccc:	b580      	push	{r7, lr}
 8007cce:	b086      	sub	sp, #24
 8007cd0:	af00      	add	r7, sp, #0
 8007cd2:	6078      	str	r0, [r7, #4]
 8007cd4:	6039      	str	r1, [r7, #0]
   uint_t i;
   uint_t m;

   //Number of 32-bit words to shift
   uint_t n1 = n / (MPI_INT_SIZE * 8);
 8007cd6:	683b      	ldr	r3, [r7, #0]
 8007cd8:	095b      	lsrs	r3, r3, #5
 8007cda:	613b      	str	r3, [r7, #16]
   //Number of bits to shift
   uint_t n2 = n % (MPI_INT_SIZE * 8);
 8007cdc:	683b      	ldr	r3, [r7, #0]
 8007cde:	f003 031f 	and.w	r3, r3, #31
 8007ce2:	60fb      	str	r3, [r7, #12]

   //Check parameters
   if(n1 >= r->size)
 8007ce4:	687b      	ldr	r3, [r7, #4]
 8007ce6:	685b      	ldr	r3, [r3, #4]
 8007ce8:	693a      	ldr	r2, [r7, #16]
 8007cea:	429a      	cmp	r2, r3
 8007cec:	d30a      	bcc.n	8007d04 <mpiShiftRight+0x38>
   {
      osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	6898      	ldr	r0, [r3, #8]
 8007cf2:	687b      	ldr	r3, [r7, #4]
 8007cf4:	685b      	ldr	r3, [r3, #4]
 8007cf6:	009b      	lsls	r3, r3, #2
 8007cf8:	461a      	mov	r2, r3
 8007cfa:	2100      	movs	r1, #0
 8007cfc:	f006 fbf2 	bl	800e4e4 <memset>
      return NO_ERROR;
 8007d00:	2300      	movs	r3, #0
 8007d02:	e06f      	b.n	8007de4 <mpiShiftRight+0x118>
   }

   //First, shift words
   if(n1 > 0)
 8007d04:	693b      	ldr	r3, [r7, #16]
 8007d06:	2b00      	cmp	r3, #0
 8007d08:	d02e      	beq.n	8007d68 <mpiShiftRight+0x9c>
   {
      //Process the least significant words
      for(m = r->size - n1, i = 0; i < m; i++)
 8007d0a:	687b      	ldr	r3, [r7, #4]
 8007d0c:	685a      	ldr	r2, [r3, #4]
 8007d0e:	693b      	ldr	r3, [r7, #16]
 8007d10:	1ad3      	subs	r3, r2, r3
 8007d12:	60bb      	str	r3, [r7, #8]
 8007d14:	2300      	movs	r3, #0
 8007d16:	617b      	str	r3, [r7, #20]
 8007d18:	e010      	b.n	8007d3c <mpiShiftRight+0x70>
      {
         r->data[i] = r->data[i + n1];
 8007d1a:	687b      	ldr	r3, [r7, #4]
 8007d1c:	689a      	ldr	r2, [r3, #8]
 8007d1e:	6979      	ldr	r1, [r7, #20]
 8007d20:	693b      	ldr	r3, [r7, #16]
 8007d22:	440b      	add	r3, r1
 8007d24:	009b      	lsls	r3, r3, #2
 8007d26:	441a      	add	r2, r3
 8007d28:	687b      	ldr	r3, [r7, #4]
 8007d2a:	6899      	ldr	r1, [r3, #8]
 8007d2c:	697b      	ldr	r3, [r7, #20]
 8007d2e:	009b      	lsls	r3, r3, #2
 8007d30:	440b      	add	r3, r1
 8007d32:	6812      	ldr	r2, [r2, #0]
 8007d34:	601a      	str	r2, [r3, #0]
      for(m = r->size - n1, i = 0; i < m; i++)
 8007d36:	697b      	ldr	r3, [r7, #20]
 8007d38:	3301      	adds	r3, #1
 8007d3a:	617b      	str	r3, [r7, #20]
 8007d3c:	697a      	ldr	r2, [r7, #20]
 8007d3e:	68bb      	ldr	r3, [r7, #8]
 8007d40:	429a      	cmp	r2, r3
 8007d42:	d3ea      	bcc.n	8007d1a <mpiShiftRight+0x4e>
      }

      //Fill the rest with zeroes
      for(i = m; i < r->size; i++)
 8007d44:	68bb      	ldr	r3, [r7, #8]
 8007d46:	617b      	str	r3, [r7, #20]
 8007d48:	e009      	b.n	8007d5e <mpiShiftRight+0x92>
      {
         r->data[i] = 0;
 8007d4a:	687b      	ldr	r3, [r7, #4]
 8007d4c:	689a      	ldr	r2, [r3, #8]
 8007d4e:	697b      	ldr	r3, [r7, #20]
 8007d50:	009b      	lsls	r3, r3, #2
 8007d52:	4413      	add	r3, r2
 8007d54:	2200      	movs	r2, #0
 8007d56:	601a      	str	r2, [r3, #0]
      for(i = m; i < r->size; i++)
 8007d58:	697b      	ldr	r3, [r7, #20]
 8007d5a:	3301      	adds	r3, #1
 8007d5c:	617b      	str	r3, [r7, #20]
 8007d5e:	687b      	ldr	r3, [r7, #4]
 8007d60:	685b      	ldr	r3, [r3, #4]
 8007d62:	697a      	ldr	r2, [r7, #20]
 8007d64:	429a      	cmp	r2, r3
 8007d66:	d3f0      	bcc.n	8007d4a <mpiShiftRight+0x7e>
      }
   }

   //Then shift bits
   if(n2 > 0)
 8007d68:	68fb      	ldr	r3, [r7, #12]
 8007d6a:	2b00      	cmp	r3, #0
 8007d6c:	d039      	beq.n	8007de2 <mpiShiftRight+0x116>
   {
      //Process the least significant words
      for(m = r->size - n1 - 1, i = 0; i < m; i++)
 8007d6e:	687b      	ldr	r3, [r7, #4]
 8007d70:	685a      	ldr	r2, [r3, #4]
 8007d72:	693b      	ldr	r3, [r7, #16]
 8007d74:	1ad3      	subs	r3, r2, r3
 8007d76:	3b01      	subs	r3, #1
 8007d78:	60bb      	str	r3, [r7, #8]
 8007d7a:	2300      	movs	r3, #0
 8007d7c:	617b      	str	r3, [r7, #20]
 8007d7e:	e01d      	b.n	8007dbc <mpiShiftRight+0xf0>
      {
         r->data[i] = (r->data[i] >> n2) | (r->data[i + 1] << (32 - n2));
 8007d80:	687b      	ldr	r3, [r7, #4]
 8007d82:	689a      	ldr	r2, [r3, #8]
 8007d84:	697b      	ldr	r3, [r7, #20]
 8007d86:	009b      	lsls	r3, r3, #2
 8007d88:	4413      	add	r3, r2
 8007d8a:	681a      	ldr	r2, [r3, #0]
 8007d8c:	68fb      	ldr	r3, [r7, #12]
 8007d8e:	fa22 f103 	lsr.w	r1, r2, r3
 8007d92:	687b      	ldr	r3, [r7, #4]
 8007d94:	689a      	ldr	r2, [r3, #8]
 8007d96:	697b      	ldr	r3, [r7, #20]
 8007d98:	3301      	adds	r3, #1
 8007d9a:	009b      	lsls	r3, r3, #2
 8007d9c:	4413      	add	r3, r2
 8007d9e:	681a      	ldr	r2, [r3, #0]
 8007da0:	68fb      	ldr	r3, [r7, #12]
 8007da2:	f1c3 0320 	rsb	r3, r3, #32
 8007da6:	409a      	lsls	r2, r3
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	6898      	ldr	r0, [r3, #8]
 8007dac:	697b      	ldr	r3, [r7, #20]
 8007dae:	009b      	lsls	r3, r3, #2
 8007db0:	4403      	add	r3, r0
 8007db2:	430a      	orrs	r2, r1
 8007db4:	601a      	str	r2, [r3, #0]
      for(m = r->size - n1 - 1, i = 0; i < m; i++)
 8007db6:	697b      	ldr	r3, [r7, #20]
 8007db8:	3301      	adds	r3, #1
 8007dba:	617b      	str	r3, [r7, #20]
 8007dbc:	697a      	ldr	r2, [r7, #20]
 8007dbe:	68bb      	ldr	r3, [r7, #8]
 8007dc0:	429a      	cmp	r2, r3
 8007dc2:	d3dd      	bcc.n	8007d80 <mpiShiftRight+0xb4>
      }

      //The most significant word requires a special handling
      r->data[m] >>= n2;
 8007dc4:	687b      	ldr	r3, [r7, #4]
 8007dc6:	689a      	ldr	r2, [r3, #8]
 8007dc8:	68bb      	ldr	r3, [r7, #8]
 8007dca:	009b      	lsls	r3, r3, #2
 8007dcc:	4413      	add	r3, r2
 8007dce:	6819      	ldr	r1, [r3, #0]
 8007dd0:	687b      	ldr	r3, [r7, #4]
 8007dd2:	689a      	ldr	r2, [r3, #8]
 8007dd4:	68bb      	ldr	r3, [r7, #8]
 8007dd6:	009b      	lsls	r3, r3, #2
 8007dd8:	4413      	add	r3, r2
 8007dda:	68fa      	ldr	r2, [r7, #12]
 8007ddc:	fa21 f202 	lsr.w	r2, r1, r2
 8007de0:	601a      	str	r2, [r3, #0]
   }

   //Shift operation is complete
   return NO_ERROR;
 8007de2:	2300      	movs	r3, #0
}
 8007de4:	4618      	mov	r0, r3
 8007de6:	3718      	adds	r7, #24
 8007de8:	46bd      	mov	sp, r7
 8007dea:	bd80      	pop	{r7, pc}

08007dec <mpiMul>:
 * @param[in] b Second operand B
 * @return Error code
 **/

__weak_func error_t mpiMul(Mpi *r, const Mpi *a, const Mpi *b)
{
 8007dec:	b580      	push	{r7, lr}
 8007dee:	b08e      	sub	sp, #56	; 0x38
 8007df0:	af00      	add	r7, sp, #0
 8007df2:	60f8      	str	r0, [r7, #12]
 8007df4:	60b9      	str	r1, [r7, #8]
 8007df6:	607a      	str	r2, [r7, #4]
   int_t n;
   Mpi ta;
   Mpi tb;

   //Initialize multiple precision integers
   mpiInit(&ta);
 8007df8:	f107 031c 	add.w	r3, r7, #28
 8007dfc:	4618      	mov	r0, r3
 8007dfe:	f7ff f825 	bl	8006e4c <mpiInit>
   mpiInit(&tb);
 8007e02:	f107 0310 	add.w	r3, r7, #16
 8007e06:	4618      	mov	r0, r3
 8007e08:	f7ff f820 	bl	8006e4c <mpiInit>

   //R and A are the same instance?
   if(r == a)
 8007e0c:	68fa      	ldr	r2, [r7, #12]
 8007e0e:	68bb      	ldr	r3, [r7, #8]
 8007e10:	429a      	cmp	r2, r3
 8007e12:	d10d      	bne.n	8007e30 <mpiMul+0x44>
   {
      //Copy A to TA
      MPI_CHECK(mpiCopy(&ta, a));
 8007e14:	f107 031c 	add.w	r3, r7, #28
 8007e18:	68b9      	ldr	r1, [r7, #8]
 8007e1a:	4618      	mov	r0, r3
 8007e1c:	f7ff fa65 	bl	80072ea <mpiCopy>
 8007e20:	4603      	mov	r3, r0
 8007e22:	86fb      	strh	r3, [r7, #54]	; 0x36
 8007e24:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8007e26:	2b00      	cmp	r3, #0
 8007e28:	d179      	bne.n	8007f1e <mpiMul+0x132>
      //Use TA instead of A
      a = &ta;
 8007e2a:	f107 031c 	add.w	r3, r7, #28
 8007e2e:	60bb      	str	r3, [r7, #8]
   }

   //R and B are the same instance?
   if(r == b)
 8007e30:	68fa      	ldr	r2, [r7, #12]
 8007e32:	687b      	ldr	r3, [r7, #4]
 8007e34:	429a      	cmp	r2, r3
 8007e36:	d10d      	bne.n	8007e54 <mpiMul+0x68>
   {
      //Copy B to TB
      MPI_CHECK(mpiCopy(&tb, b));
 8007e38:	f107 0310 	add.w	r3, r7, #16
 8007e3c:	6879      	ldr	r1, [r7, #4]
 8007e3e:	4618      	mov	r0, r3
 8007e40:	f7ff fa53 	bl	80072ea <mpiCopy>
 8007e44:	4603      	mov	r3, r0
 8007e46:	86fb      	strh	r3, [r7, #54]	; 0x36
 8007e48:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8007e4a:	2b00      	cmp	r3, #0
 8007e4c:	d169      	bne.n	8007f22 <mpiMul+0x136>
      //Use TB instead of B
      b = &tb;
 8007e4e:	f107 0310 	add.w	r3, r7, #16
 8007e52:	607b      	str	r3, [r7, #4]
   }

   //Determine the actual length of A and B
   m = mpiGetLength(a);
 8007e54:	68b8      	ldr	r0, [r7, #8]
 8007e56:	f7ff f86c 	bl	8006f32 <mpiGetLength>
 8007e5a:	4603      	mov	r3, r0
 8007e5c:	62fb      	str	r3, [r7, #44]	; 0x2c
   n = mpiGetLength(b);
 8007e5e:	6878      	ldr	r0, [r7, #4]
 8007e60:	f7ff f867 	bl	8006f32 <mpiGetLength>
 8007e64:	4603      	mov	r3, r0
 8007e66:	62bb      	str	r3, [r7, #40]	; 0x28

   //Adjust the size of R
   MPI_CHECK(mpiGrow(r, m + n));
 8007e68:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007e6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007e6c:	4413      	add	r3, r2
 8007e6e:	4619      	mov	r1, r3
 8007e70:	68f8      	ldr	r0, [r7, #12]
 8007e72:	f7ff f81e 	bl	8006eb2 <mpiGrow>
 8007e76:	4603      	mov	r3, r0
 8007e78:	86fb      	strh	r3, [r7, #54]	; 0x36
 8007e7a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	d152      	bne.n	8007f26 <mpiMul+0x13a>
   //Set the sign of R
   r->sign = (a->sign == b->sign) ? 1 : -1;
 8007e80:	68bb      	ldr	r3, [r7, #8]
 8007e82:	681a      	ldr	r2, [r3, #0]
 8007e84:	687b      	ldr	r3, [r7, #4]
 8007e86:	681b      	ldr	r3, [r3, #0]
 8007e88:	429a      	cmp	r2, r3
 8007e8a:	d101      	bne.n	8007e90 <mpiMul+0xa4>
 8007e8c:	2201      	movs	r2, #1
 8007e8e:	e001      	b.n	8007e94 <mpiMul+0xa8>
 8007e90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007e94:	68fb      	ldr	r3, [r7, #12]
 8007e96:	601a      	str	r2, [r3, #0]

   //Clear the contents of the destination integer
   osMemset(r->data, 0, r->size * MPI_INT_SIZE);
 8007e98:	68fb      	ldr	r3, [r7, #12]
 8007e9a:	6898      	ldr	r0, [r3, #8]
 8007e9c:	68fb      	ldr	r3, [r7, #12]
 8007e9e:	685b      	ldr	r3, [r3, #4]
 8007ea0:	009b      	lsls	r3, r3, #2
 8007ea2:	461a      	mov	r2, r3
 8007ea4:	2100      	movs	r1, #0
 8007ea6:	f006 fb1d 	bl	800e4e4 <memset>

   //Perform multiplication
   if(m < n)
 8007eaa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007eac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007eae:	429a      	cmp	r2, r3
 8007eb0:	da1a      	bge.n	8007ee8 <mpiMul+0xfc>
   {
      for(i = 0; i < m; i++)
 8007eb2:	2300      	movs	r3, #0
 8007eb4:	633b      	str	r3, [r7, #48]	; 0x30
 8007eb6:	e012      	b.n	8007ede <mpiMul+0xf2>
      {
         mpiMulAccCore(&r->data[i], b->data, n, a->data[i]);
 8007eb8:	68fb      	ldr	r3, [r7, #12]
 8007eba:	689a      	ldr	r2, [r3, #8]
 8007ebc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ebe:	009b      	lsls	r3, r3, #2
 8007ec0:	18d0      	adds	r0, r2, r3
 8007ec2:	687b      	ldr	r3, [r7, #4]
 8007ec4:	6899      	ldr	r1, [r3, #8]
 8007ec6:	68bb      	ldr	r3, [r7, #8]
 8007ec8:	689a      	ldr	r2, [r3, #8]
 8007eca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ecc:	009b      	lsls	r3, r3, #2
 8007ece:	4413      	add	r3, r2
 8007ed0:	681b      	ldr	r3, [r3, #0]
 8007ed2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007ed4:	f000 faf5 	bl	80084c2 <mpiMulAccCore>
      for(i = 0; i < m; i++)
 8007ed8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007eda:	3301      	adds	r3, #1
 8007edc:	633b      	str	r3, [r7, #48]	; 0x30
 8007ede:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007ee2:	429a      	cmp	r2, r3
 8007ee4:	dbe8      	blt.n	8007eb8 <mpiMul+0xcc>
 8007ee6:	e01f      	b.n	8007f28 <mpiMul+0x13c>
      }
   }
   else
   {
      for(i = 0; i < n; i++)
 8007ee8:	2300      	movs	r3, #0
 8007eea:	633b      	str	r3, [r7, #48]	; 0x30
 8007eec:	e012      	b.n	8007f14 <mpiMul+0x128>
      {
         mpiMulAccCore(&r->data[i], a->data, m, b->data[i]);
 8007eee:	68fb      	ldr	r3, [r7, #12]
 8007ef0:	689a      	ldr	r2, [r3, #8]
 8007ef2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ef4:	009b      	lsls	r3, r3, #2
 8007ef6:	18d0      	adds	r0, r2, r3
 8007ef8:	68bb      	ldr	r3, [r7, #8]
 8007efa:	6899      	ldr	r1, [r3, #8]
 8007efc:	687b      	ldr	r3, [r7, #4]
 8007efe:	689a      	ldr	r2, [r3, #8]
 8007f00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007f02:	009b      	lsls	r3, r3, #2
 8007f04:	4413      	add	r3, r2
 8007f06:	681b      	ldr	r3, [r3, #0]
 8007f08:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007f0a:	f000 fada 	bl	80084c2 <mpiMulAccCore>
      for(i = 0; i < n; i++)
 8007f0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007f10:	3301      	adds	r3, #1
 8007f12:	633b      	str	r3, [r7, #48]	; 0x30
 8007f14:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007f16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f18:	429a      	cmp	r2, r3
 8007f1a:	dbe8      	blt.n	8007eee <mpiMul+0x102>
      }
   }

end:
 8007f1c:	e004      	b.n	8007f28 <mpiMul+0x13c>
      MPI_CHECK(mpiCopy(&ta, a));
 8007f1e:	bf00      	nop
 8007f20:	e002      	b.n	8007f28 <mpiMul+0x13c>
      MPI_CHECK(mpiCopy(&tb, b));
 8007f22:	bf00      	nop
 8007f24:	e000      	b.n	8007f28 <mpiMul+0x13c>
   MPI_CHECK(mpiGrow(r, m + n));
 8007f26:	bf00      	nop
   //Release multiple precision integers
   mpiFree(&ta);
 8007f28:	f107 031c 	add.w	r3, r7, #28
 8007f2c:	4618      	mov	r0, r3
 8007f2e:	f7fe ffa0 	bl	8006e72 <mpiFree>
   mpiFree(&tb);
 8007f32:	f107 0310 	add.w	r3, r7, #16
 8007f36:	4618      	mov	r0, r3
 8007f38:	f7fe ff9b 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8007f3c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
 8007f3e:	4618      	mov	r0, r3
 8007f40:	3738      	adds	r7, #56	; 0x38
 8007f42:	46bd      	mov	sp, r7
 8007f44:	bd80      	pop	{r7, pc}

08007f46 <mpiDiv>:
 * @param[in] b The divisor B
 * @return Error code
 **/

error_t mpiDiv(Mpi *q, Mpi *r, const Mpi *a, const Mpi *b)
{
 8007f46:	b580      	push	{r7, lr}
 8007f48:	b090      	sub	sp, #64	; 0x40
 8007f4a:	af00      	add	r7, sp, #0
 8007f4c:	60f8      	str	r0, [r7, #12]
 8007f4e:	60b9      	str	r1, [r7, #8]
 8007f50:	607a      	str	r2, [r7, #4]
 8007f52:	603b      	str	r3, [r7, #0]
   Mpi c;
   Mpi d;
   Mpi e;

   //Check whether the divisor is equal to zero
   if(!mpiCompInt(b, 0))
 8007f54:	2100      	movs	r1, #0
 8007f56:	6838      	ldr	r0, [r7, #0]
 8007f58:	f7ff f958 	bl	800720c <mpiCompInt>
 8007f5c:	4603      	mov	r3, r0
 8007f5e:	2b00      	cmp	r3, #0
 8007f60:	d101      	bne.n	8007f66 <mpiDiv+0x20>
      return ERROR_INVALID_PARAMETER;
 8007f62:	2302      	movs	r3, #2
 8007f64:	e0d0      	b.n	8008108 <mpiDiv+0x1c2>

   //Initialize multiple precision integers
   mpiInit(&c);
 8007f66:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007f6a:	4618      	mov	r0, r3
 8007f6c:	f7fe ff6e 	bl	8006e4c <mpiInit>
   mpiInit(&d);
 8007f70:	f107 031c 	add.w	r3, r7, #28
 8007f74:	4618      	mov	r0, r3
 8007f76:	f7fe ff69 	bl	8006e4c <mpiInit>
   mpiInit(&e);
 8007f7a:	f107 0310 	add.w	r3, r7, #16
 8007f7e:	4618      	mov	r0, r3
 8007f80:	f7fe ff64 	bl	8006e4c <mpiInit>

   MPI_CHECK(mpiCopy(&c, a));
 8007f84:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007f88:	6879      	ldr	r1, [r7, #4]
 8007f8a:	4618      	mov	r0, r3
 8007f8c:	f7ff f9ad 	bl	80072ea <mpiCopy>
 8007f90:	4603      	mov	r3, r0
 8007f92:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8007f94:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8007f96:	2b00      	cmp	r3, #0
 8007f98:	f040 8093 	bne.w	80080c2 <mpiDiv+0x17c>
   MPI_CHECK(mpiCopy(&d, b));
 8007f9c:	f107 031c 	add.w	r3, r7, #28
 8007fa0:	6839      	ldr	r1, [r7, #0]
 8007fa2:	4618      	mov	r0, r3
 8007fa4:	f7ff f9a1 	bl	80072ea <mpiCopy>
 8007fa8:	4603      	mov	r3, r0
 8007faa:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8007fac:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8007fae:	2b00      	cmp	r3, #0
 8007fb0:	f040 8089 	bne.w	80080c6 <mpiDiv+0x180>
   MPI_CHECK(mpiSetValue(&e, 0));
 8007fb4:	f107 0310 	add.w	r3, r7, #16
 8007fb8:	2100      	movs	r1, #0
 8007fba:	4618      	mov	r0, r3
 8007fbc:	f7ff f9ca 	bl	8007354 <mpiSetValue>
 8007fc0:	4603      	mov	r3, r0
 8007fc2:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8007fc4:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d17f      	bne.n	80080ca <mpiDiv+0x184>

   m = mpiGetBitLength(&c);
 8007fca:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8007fce:	4618      	mov	r0, r3
 8007fd0:	f7ff f810 	bl	8006ff4 <mpiGetBitLength>
 8007fd4:	6378      	str	r0, [r7, #52]	; 0x34
   n = mpiGetBitLength(&d);
 8007fd6:	f107 031c 	add.w	r3, r7, #28
 8007fda:	4618      	mov	r0, r3
 8007fdc:	f7ff f80a 	bl	8006ff4 <mpiGetBitLength>
 8007fe0:	63b8      	str	r0, [r7, #56]	; 0x38

   if(m > n)
 8007fe2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007fe4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007fe6:	429a      	cmp	r2, r3
 8007fe8:	d949      	bls.n	800807e <mpiDiv+0x138>
      MPI_CHECK(mpiShiftLeft(&d, m - n));
 8007fea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007fec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007fee:	1ad2      	subs	r2, r2, r3
 8007ff0:	f107 031c 	add.w	r3, r7, #28
 8007ff4:	4611      	mov	r1, r2
 8007ff6:	4618      	mov	r0, r3
 8007ff8:	f7ff fddb 	bl	8007bb2 <mpiShiftLeft>
 8007ffc:	4603      	mov	r3, r0
 8007ffe:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8008000:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8008002:	2b00      	cmp	r3, #0
 8008004:	d163      	bne.n	80080ce <mpiDiv+0x188>

   while(n++ <= m)
 8008006:	e03a      	b.n	800807e <mpiDiv+0x138>
   {
      MPI_CHECK(mpiShiftLeft(&e, 1));
 8008008:	f107 0310 	add.w	r3, r7, #16
 800800c:	2101      	movs	r1, #1
 800800e:	4618      	mov	r0, r3
 8008010:	f7ff fdcf 	bl	8007bb2 <mpiShiftLeft>
 8008014:	4603      	mov	r3, r0
 8008016:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8008018:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800801a:	2b00      	cmp	r3, #0
 800801c:	d159      	bne.n	80080d2 <mpiDiv+0x18c>

      if(mpiComp(&c, &d) >= 0)
 800801e:	f107 021c 	add.w	r2, r7, #28
 8008022:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008026:	4611      	mov	r1, r2
 8008028:	4618      	mov	r0, r3
 800802a:	f7ff f889 	bl	8007140 <mpiComp>
 800802e:	4603      	mov	r3, r0
 8008030:	2b00      	cmp	r3, #0
 8008032:	db19      	blt.n	8008068 <mpiDiv+0x122>
      {
         MPI_CHECK(mpiSetBitValue(&e, 0, 1));
 8008034:	f107 0310 	add.w	r3, r7, #16
 8008038:	2201      	movs	r2, #1
 800803a:	2100      	movs	r1, #0
 800803c:	4618      	mov	r0, r3
 800803e:	f7ff f813 	bl	8007068 <mpiSetBitValue>
 8008042:	4603      	mov	r3, r0
 8008044:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8008046:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8008048:	2b00      	cmp	r3, #0
 800804a:	d144      	bne.n	80080d6 <mpiDiv+0x190>
         MPI_CHECK(mpiSub(&c, &c, &d));
 800804c:	f107 021c 	add.w	r2, r7, #28
 8008050:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8008054:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008058:	4618      	mov	r0, r3
 800805a:	f7ff fbe5 	bl	8007828 <mpiSub>
 800805e:	4603      	mov	r3, r0
 8008060:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8008062:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8008064:	2b00      	cmp	r3, #0
 8008066:	d138      	bne.n	80080da <mpiDiv+0x194>
      }

      MPI_CHECK(mpiShiftRight(&d, 1));
 8008068:	f107 031c 	add.w	r3, r7, #28
 800806c:	2101      	movs	r1, #1
 800806e:	4618      	mov	r0, r3
 8008070:	f7ff fe2c 	bl	8007ccc <mpiShiftRight>
 8008074:	4603      	mov	r3, r0
 8008076:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8008078:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800807a:	2b00      	cmp	r3, #0
 800807c:	d12f      	bne.n	80080de <mpiDiv+0x198>
   while(n++ <= m)
 800807e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008080:	1c5a      	adds	r2, r3, #1
 8008082:	63ba      	str	r2, [r7, #56]	; 0x38
 8008084:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008086:	429a      	cmp	r2, r3
 8008088:	d2be      	bcs.n	8008008 <mpiDiv+0xc2>
   }

   if(q != NULL)
 800808a:	68fb      	ldr	r3, [r7, #12]
 800808c:	2b00      	cmp	r3, #0
 800808e:	d00a      	beq.n	80080a6 <mpiDiv+0x160>
      MPI_CHECK(mpiCopy(q, &e));
 8008090:	f107 0310 	add.w	r3, r7, #16
 8008094:	4619      	mov	r1, r3
 8008096:	68f8      	ldr	r0, [r7, #12]
 8008098:	f7ff f927 	bl	80072ea <mpiCopy>
 800809c:	4603      	mov	r3, r0
 800809e:	87fb      	strh	r3, [r7, #62]	; 0x3e
 80080a0:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80080a2:	2b00      	cmp	r3, #0
 80080a4:	d11d      	bne.n	80080e2 <mpiDiv+0x19c>

   if(r != NULL)
 80080a6:	68bb      	ldr	r3, [r7, #8]
 80080a8:	2b00      	cmp	r3, #0
 80080aa:	d01c      	beq.n	80080e6 <mpiDiv+0x1a0>
      MPI_CHECK(mpiCopy(r, &c));
 80080ac:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80080b0:	4619      	mov	r1, r3
 80080b2:	68b8      	ldr	r0, [r7, #8]
 80080b4:	f7ff f919 	bl	80072ea <mpiCopy>
 80080b8:	4603      	mov	r3, r0
 80080ba:	87fb      	strh	r3, [r7, #62]	; 0x3e
 80080bc:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80080be:	2b00      	cmp	r3, #0

end:
 80080c0:	e011      	b.n	80080e6 <mpiDiv+0x1a0>
   MPI_CHECK(mpiCopy(&c, a));
 80080c2:	bf00      	nop
 80080c4:	e010      	b.n	80080e8 <mpiDiv+0x1a2>
   MPI_CHECK(mpiCopy(&d, b));
 80080c6:	bf00      	nop
 80080c8:	e00e      	b.n	80080e8 <mpiDiv+0x1a2>
   MPI_CHECK(mpiSetValue(&e, 0));
 80080ca:	bf00      	nop
 80080cc:	e00c      	b.n	80080e8 <mpiDiv+0x1a2>
      MPI_CHECK(mpiShiftLeft(&d, m - n));
 80080ce:	bf00      	nop
 80080d0:	e00a      	b.n	80080e8 <mpiDiv+0x1a2>
      MPI_CHECK(mpiShiftLeft(&e, 1));
 80080d2:	bf00      	nop
 80080d4:	e008      	b.n	80080e8 <mpiDiv+0x1a2>
         MPI_CHECK(mpiSetBitValue(&e, 0, 1));
 80080d6:	bf00      	nop
 80080d8:	e006      	b.n	80080e8 <mpiDiv+0x1a2>
         MPI_CHECK(mpiSub(&c, &c, &d));
 80080da:	bf00      	nop
 80080dc:	e004      	b.n	80080e8 <mpiDiv+0x1a2>
      MPI_CHECK(mpiShiftRight(&d, 1));
 80080de:	bf00      	nop
 80080e0:	e002      	b.n	80080e8 <mpiDiv+0x1a2>
      MPI_CHECK(mpiCopy(q, &e));
 80080e2:	bf00      	nop
 80080e4:	e000      	b.n	80080e8 <mpiDiv+0x1a2>
end:
 80080e6:	bf00      	nop
   //Release previously allocated memory
   mpiFree(&c);
 80080e8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80080ec:	4618      	mov	r0, r3
 80080ee:	f7fe fec0 	bl	8006e72 <mpiFree>
   mpiFree(&d);
 80080f2:	f107 031c 	add.w	r3, r7, #28
 80080f6:	4618      	mov	r0, r3
 80080f8:	f7fe febb 	bl	8006e72 <mpiFree>
   mpiFree(&e);
 80080fc:	f107 0310 	add.w	r3, r7, #16
 8008100:	4618      	mov	r0, r3
 8008102:	f7fe feb6 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8008106:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 8008108:	4618      	mov	r0, r3
 800810a:	3740      	adds	r7, #64	; 0x40
 800810c:	46bd      	mov	sp, r7
 800810e:	bd80      	pop	{r7, pc}

08008110 <mpiMod>:
 * @param[in] p The modulus P
 * @return Error code
 **/

error_t mpiMod(Mpi *r, const Mpi *a, const Mpi *p)
{
 8008110:	b580      	push	{r7, lr}
 8008112:	b08c      	sub	sp, #48	; 0x30
 8008114:	af00      	add	r7, sp, #0
 8008116:	60f8      	str	r0, [r7, #12]
 8008118:	60b9      	str	r1, [r7, #8]
 800811a:	607a      	str	r2, [r7, #4]
   uint_t m;
   uint_t n;
   Mpi c;

   //Make sure the modulus is positive
   if(mpiCompInt(p, 0) <= 0)
 800811c:	2100      	movs	r1, #0
 800811e:	6878      	ldr	r0, [r7, #4]
 8008120:	f7ff f874 	bl	800720c <mpiCompInt>
 8008124:	4603      	mov	r3, r0
 8008126:	2b00      	cmp	r3, #0
 8008128:	dc01      	bgt.n	800812e <mpiMod+0x1e>
      return ERROR_INVALID_PARAMETER;
 800812a:	2302      	movs	r3, #2
 800812c:	e07b      	b.n	8008226 <mpiMod+0x116>

   //Initialize multiple precision integer
   mpiInit(&c);
 800812e:	f107 0314 	add.w	r3, r7, #20
 8008132:	4618      	mov	r0, r3
 8008134:	f7fe fe8a 	bl	8006e4c <mpiInit>

   //Save the sign of A
   sign = a->sign;
 8008138:	68bb      	ldr	r3, [r7, #8]
 800813a:	681b      	ldr	r3, [r3, #0]
 800813c:	62bb      	str	r3, [r7, #40]	; 0x28
   //Determine the actual length of A
   m = mpiGetBitLength(a);
 800813e:	68b8      	ldr	r0, [r7, #8]
 8008140:	f7fe ff58 	bl	8006ff4 <mpiGetBitLength>
 8008144:	6278      	str	r0, [r7, #36]	; 0x24
   //Determine the actual length of P
   n = mpiGetBitLength(p);
 8008146:	6878      	ldr	r0, [r7, #4]
 8008148:	f7fe ff54 	bl	8006ff4 <mpiGetBitLength>
 800814c:	6238      	str	r0, [r7, #32]

   //Let R = A
   MPI_CHECK(mpiCopy(r, a));
 800814e:	68b9      	ldr	r1, [r7, #8]
 8008150:	68f8      	ldr	r0, [r7, #12]
 8008152:	f7ff f8ca 	bl	80072ea <mpiCopy>
 8008156:	4603      	mov	r3, r0
 8008158:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800815a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800815c:	2b00      	cmp	r3, #0
 800815e:	d151      	bne.n	8008204 <mpiMod+0xf4>

   if(m >= n)
 8008160:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008162:	6a3b      	ldr	r3, [r7, #32]
 8008164:	429a      	cmp	r2, r3
 8008166:	d340      	bcc.n	80081ea <mpiMod+0xda>
   {
      MPI_CHECK(mpiCopy(&c, p));
 8008168:	f107 0314 	add.w	r3, r7, #20
 800816c:	6879      	ldr	r1, [r7, #4]
 800816e:	4618      	mov	r0, r3
 8008170:	f7ff f8bb 	bl	80072ea <mpiCopy>
 8008174:	4603      	mov	r3, r0
 8008176:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8008178:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800817a:	2b00      	cmp	r3, #0
 800817c:	d144      	bne.n	8008208 <mpiMod+0xf8>
      MPI_CHECK(mpiShiftLeft(&c, m - n));
 800817e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008180:	6a3b      	ldr	r3, [r7, #32]
 8008182:	1ad2      	subs	r2, r2, r3
 8008184:	f107 0314 	add.w	r3, r7, #20
 8008188:	4611      	mov	r1, r2
 800818a:	4618      	mov	r0, r3
 800818c:	f7ff fd11 	bl	8007bb2 <mpiShiftLeft>
 8008190:	4603      	mov	r3, r0
 8008192:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8008194:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8008196:	2b00      	cmp	r3, #0
 8008198:	d138      	bne.n	800820c <mpiMod+0xfc>

      while(mpiCompAbs(r, p) >= 0)
 800819a:	e01f      	b.n	80081dc <mpiMod+0xcc>
      {
         if(mpiCompAbs(r, &c) >= 0)
 800819c:	f107 0314 	add.w	r3, r7, #20
 80081a0:	4619      	mov	r1, r3
 80081a2:	68f8      	ldr	r0, [r7, #12]
 80081a4:	f7ff f854 	bl	8007250 <mpiCompAbs>
 80081a8:	4603      	mov	r3, r0
 80081aa:	2b00      	cmp	r3, #0
 80081ac:	db0b      	blt.n	80081c6 <mpiMod+0xb6>
         {
            MPI_CHECK(mpiSubAbs(r, r, &c));
 80081ae:	f107 0314 	add.w	r3, r7, #20
 80081b2:	461a      	mov	r2, r3
 80081b4:	68f9      	ldr	r1, [r7, #12]
 80081b6:	68f8      	ldr	r0, [r7, #12]
 80081b8:	f7ff fc47 	bl	8007a4a <mpiSubAbs>
 80081bc:	4603      	mov	r3, r0
 80081be:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80081c0:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80081c2:	2b00      	cmp	r3, #0
 80081c4:	d124      	bne.n	8008210 <mpiMod+0x100>
         }

         MPI_CHECK(mpiShiftRight(&c, 1));
 80081c6:	f107 0314 	add.w	r3, r7, #20
 80081ca:	2101      	movs	r1, #1
 80081cc:	4618      	mov	r0, r3
 80081ce:	f7ff fd7d 	bl	8007ccc <mpiShiftRight>
 80081d2:	4603      	mov	r3, r0
 80081d4:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80081d6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80081d8:	2b00      	cmp	r3, #0
 80081da:	d11b      	bne.n	8008214 <mpiMod+0x104>
      while(mpiCompAbs(r, p) >= 0)
 80081dc:	6879      	ldr	r1, [r7, #4]
 80081de:	68f8      	ldr	r0, [r7, #12]
 80081e0:	f7ff f836 	bl	8007250 <mpiCompAbs>
 80081e4:	4603      	mov	r3, r0
 80081e6:	2b00      	cmp	r3, #0
 80081e8:	dad8      	bge.n	800819c <mpiMod+0x8c>
      }
   }

   if(sign < 0)
 80081ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80081ec:	2b00      	cmp	r3, #0
 80081ee:	da13      	bge.n	8008218 <mpiMod+0x108>
   {
      MPI_CHECK(mpiSubAbs(r, p, r));
 80081f0:	68fa      	ldr	r2, [r7, #12]
 80081f2:	6879      	ldr	r1, [r7, #4]
 80081f4:	68f8      	ldr	r0, [r7, #12]
 80081f6:	f7ff fc28 	bl	8007a4a <mpiSubAbs>
 80081fa:	4603      	mov	r3, r0
 80081fc:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80081fe:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8008200:	2b00      	cmp	r3, #0
   }

end:
 8008202:	e009      	b.n	8008218 <mpiMod+0x108>
   MPI_CHECK(mpiCopy(r, a));
 8008204:	bf00      	nop
 8008206:	e008      	b.n	800821a <mpiMod+0x10a>
      MPI_CHECK(mpiCopy(&c, p));
 8008208:	bf00      	nop
 800820a:	e006      	b.n	800821a <mpiMod+0x10a>
      MPI_CHECK(mpiShiftLeft(&c, m - n));
 800820c:	bf00      	nop
 800820e:	e004      	b.n	800821a <mpiMod+0x10a>
            MPI_CHECK(mpiSubAbs(r, r, &c));
 8008210:	bf00      	nop
 8008212:	e002      	b.n	800821a <mpiMod+0x10a>
         MPI_CHECK(mpiShiftRight(&c, 1));
 8008214:	bf00      	nop
 8008216:	e000      	b.n	800821a <mpiMod+0x10a>
end:
 8008218:	bf00      	nop
   //Release previously allocated memory
   mpiFree(&c);
 800821a:	f107 0314 	add.w	r3, r7, #20
 800821e:	4618      	mov	r0, r3
 8008220:	f7fe fe27 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 8008224:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
}
 8008226:	4618      	mov	r0, r3
 8008228:	3730      	adds	r7, #48	; 0x30
 800822a:	46bd      	mov	sp, r7
 800822c:	bd80      	pop	{r7, pc}

0800822e <mpiInvMod>:
 * @param[in] p The modulus P
 * @return Error code
 **/

__weak_func error_t mpiInvMod(Mpi *r, const Mpi *a, const Mpi *p)
{
 800822e:	b580      	push	{r7, lr}
 8008230:	b09a      	sub	sp, #104	; 0x68
 8008232:	af00      	add	r7, sp, #0
 8008234:	60f8      	str	r0, [r7, #12]
 8008236:	60b9      	str	r1, [r7, #8]
 8008238:	607a      	str	r2, [r7, #4]
   Mpi t;
   Mpi u;
   Mpi v;

   //Initialize multiple precision integers
   mpiInit(&b);
 800823a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800823e:	4618      	mov	r0, r3
 8008240:	f7fe fe04 	bl	8006e4c <mpiInit>
   mpiInit(&c);
 8008244:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8008248:	4618      	mov	r0, r3
 800824a:	f7fe fdff 	bl	8006e4c <mpiInit>
   mpiInit(&q0);
 800824e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8008252:	4618      	mov	r0, r3
 8008254:	f7fe fdfa 	bl	8006e4c <mpiInit>
   mpiInit(&r0);
 8008258:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800825c:	4618      	mov	r0, r3
 800825e:	f7fe fdf5 	bl	8006e4c <mpiInit>
   mpiInit(&t);
 8008262:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008266:	4618      	mov	r0, r3
 8008268:	f7fe fdf0 	bl	8006e4c <mpiInit>
   mpiInit(&u);
 800826c:	f107 031c 	add.w	r3, r7, #28
 8008270:	4618      	mov	r0, r3
 8008272:	f7fe fdeb 	bl	8006e4c <mpiInit>
   mpiInit(&v);
 8008276:	f107 0310 	add.w	r3, r7, #16
 800827a:	4618      	mov	r0, r3
 800827c:	f7fe fde6 	bl	8006e4c <mpiInit>

   MPI_CHECK(mpiCopy(&b, p));
 8008280:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8008284:	6879      	ldr	r1, [r7, #4]
 8008286:	4618      	mov	r0, r3
 8008288:	f7ff f82f 	bl	80072ea <mpiCopy>
 800828c:	4603      	mov	r3, r0
 800828e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8008292:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008296:	2b00      	cmp	r3, #0
 8008298:	f040 80d5 	bne.w	8008446 <mpiInvMod+0x218>
   MPI_CHECK(mpiCopy(&c, a));
 800829c:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80082a0:	68b9      	ldr	r1, [r7, #8]
 80082a2:	4618      	mov	r0, r3
 80082a4:	f7ff f821 	bl	80072ea <mpiCopy>
 80082a8:	4603      	mov	r3, r0
 80082aa:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80082ae:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80082b2:	2b00      	cmp	r3, #0
 80082b4:	f040 80c9 	bne.w	800844a <mpiInvMod+0x21c>
   MPI_CHECK(mpiSetValue(&u, 0));
 80082b8:	f107 031c 	add.w	r3, r7, #28
 80082bc:	2100      	movs	r1, #0
 80082be:	4618      	mov	r0, r3
 80082c0:	f7ff f848 	bl	8007354 <mpiSetValue>
 80082c4:	4603      	mov	r3, r0
 80082c6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80082ca:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80082ce:	2b00      	cmp	r3, #0
 80082d0:	f040 80bd 	bne.w	800844e <mpiInvMod+0x220>
   MPI_CHECK(mpiSetValue(&v, 1));
 80082d4:	f107 0310 	add.w	r3, r7, #16
 80082d8:	2101      	movs	r1, #1
 80082da:	4618      	mov	r0, r3
 80082dc:	f7ff f83a 	bl	8007354 <mpiSetValue>
 80082e0:	4603      	mov	r3, r0
 80082e2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80082e6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80082ea:	2b00      	cmp	r3, #0
 80082ec:	f040 80b1 	bne.w	8008452 <mpiInvMod+0x224>

   while(mpiCompInt(&c, 0) > 0)
 80082f0:	e06f      	b.n	80083d2 <mpiInvMod+0x1a4>
   {
      MPI_CHECK(mpiDiv(&q0, &r0, &b, &c));
 80082f2:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80082f6:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80082fa:	f107 0134 	add.w	r1, r7, #52	; 0x34
 80082fe:	f107 0040 	add.w	r0, r7, #64	; 0x40
 8008302:	f7ff fe20 	bl	8007f46 <mpiDiv>
 8008306:	4603      	mov	r3, r0
 8008308:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800830c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008310:	2b00      	cmp	r3, #0
 8008312:	f040 80a0 	bne.w	8008456 <mpiInvMod+0x228>

      MPI_CHECK(mpiCopy(&b, &c));
 8008316:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 800831a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800831e:	4611      	mov	r1, r2
 8008320:	4618      	mov	r0, r3
 8008322:	f7fe ffe2 	bl	80072ea <mpiCopy>
 8008326:	4603      	mov	r3, r0
 8008328:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800832c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008330:	2b00      	cmp	r3, #0
 8008332:	f040 8092 	bne.w	800845a <mpiInvMod+0x22c>
      MPI_CHECK(mpiCopy(&c, &r0));
 8008336:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800833a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800833e:	4611      	mov	r1, r2
 8008340:	4618      	mov	r0, r3
 8008342:	f7fe ffd2 	bl	80072ea <mpiCopy>
 8008346:	4603      	mov	r3, r0
 8008348:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800834c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008350:	2b00      	cmp	r3, #0
 8008352:	f040 8084 	bne.w	800845e <mpiInvMod+0x230>

      MPI_CHECK(mpiCopy(&t, &v));
 8008356:	f107 0210 	add.w	r2, r7, #16
 800835a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800835e:	4611      	mov	r1, r2
 8008360:	4618      	mov	r0, r3
 8008362:	f7fe ffc2 	bl	80072ea <mpiCopy>
 8008366:	4603      	mov	r3, r0
 8008368:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800836c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008370:	2b00      	cmp	r3, #0
 8008372:	d176      	bne.n	8008462 <mpiInvMod+0x234>
      MPI_CHECK(mpiMul(&q0, &q0, &v));
 8008374:	f107 0210 	add.w	r2, r7, #16
 8008378:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800837c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8008380:	4618      	mov	r0, r3
 8008382:	f7ff fd33 	bl	8007dec <mpiMul>
 8008386:	4603      	mov	r3, r0
 8008388:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800838c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008390:	2b00      	cmp	r3, #0
 8008392:	d168      	bne.n	8008466 <mpiInvMod+0x238>
      MPI_CHECK(mpiSub(&v, &u, &q0));
 8008394:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8008398:	f107 011c 	add.w	r1, r7, #28
 800839c:	f107 0310 	add.w	r3, r7, #16
 80083a0:	4618      	mov	r0, r3
 80083a2:	f7ff fa41 	bl	8007828 <mpiSub>
 80083a6:	4603      	mov	r3, r0
 80083a8:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80083ac:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80083b0:	2b00      	cmp	r3, #0
 80083b2:	d15a      	bne.n	800846a <mpiInvMod+0x23c>
      MPI_CHECK(mpiCopy(&u, &t));
 80083b4:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80083b8:	f107 031c 	add.w	r3, r7, #28
 80083bc:	4611      	mov	r1, r2
 80083be:	4618      	mov	r0, r3
 80083c0:	f7fe ff93 	bl	80072ea <mpiCopy>
 80083c4:	4603      	mov	r3, r0
 80083c6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80083ca:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80083ce:	2b00      	cmp	r3, #0
 80083d0:	d14d      	bne.n	800846e <mpiInvMod+0x240>
   while(mpiCompInt(&c, 0) > 0)
 80083d2:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80083d6:	2100      	movs	r1, #0
 80083d8:	4618      	mov	r0, r3
 80083da:	f7fe ff17 	bl	800720c <mpiCompInt>
 80083de:	4603      	mov	r3, r0
 80083e0:	2b00      	cmp	r3, #0
 80083e2:	dc86      	bgt.n	80082f2 <mpiInvMod+0xc4>
   }

   if(mpiCompInt(&b, 1))
 80083e4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80083e8:	2101      	movs	r1, #1
 80083ea:	4618      	mov	r0, r3
 80083ec:	f7fe ff0e 	bl	800720c <mpiCompInt>
 80083f0:	4603      	mov	r3, r0
 80083f2:	2b00      	cmp	r3, #0
 80083f4:	d003      	beq.n	80083fe <mpiInvMod+0x1d0>
   {
      MPI_CHECK(ERROR_FAILURE);
 80083f6:	2301      	movs	r3, #1
 80083f8:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80083fc:	e038      	b.n	8008470 <mpiInvMod+0x242>
   }

   if(mpiCompInt(&u, 0) > 0)
 80083fe:	f107 031c 	add.w	r3, r7, #28
 8008402:	2100      	movs	r1, #0
 8008404:	4618      	mov	r0, r3
 8008406:	f7fe ff01 	bl	800720c <mpiCompInt>
 800840a:	4603      	mov	r3, r0
 800840c:	2b00      	cmp	r3, #0
 800840e:	dd0c      	ble.n	800842a <mpiInvMod+0x1fc>
   {
      MPI_CHECK(mpiCopy(r, &u));
 8008410:	f107 031c 	add.w	r3, r7, #28
 8008414:	4619      	mov	r1, r3
 8008416:	68f8      	ldr	r0, [r7, #12]
 8008418:	f7fe ff67 	bl	80072ea <mpiCopy>
 800841c:	4603      	mov	r3, r0
 800841e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8008422:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008426:	2b00      	cmp	r3, #0
 8008428:	e022      	b.n	8008470 <mpiInvMod+0x242>
   }
   else
   {
      MPI_CHECK(mpiAdd(r, &u, p));
 800842a:	f107 031c 	add.w	r3, r7, #28
 800842e:	687a      	ldr	r2, [r7, #4]
 8008430:	4619      	mov	r1, r3
 8008432:	68f8      	ldr	r0, [r7, #12]
 8008434:	f7ff f998 	bl	8007768 <mpiAdd>
 8008438:	4603      	mov	r3, r0
 800843a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800843e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8008442:	2b00      	cmp	r3, #0
   }

end:
 8008444:	e014      	b.n	8008470 <mpiInvMod+0x242>
   MPI_CHECK(mpiCopy(&b, p));
 8008446:	bf00      	nop
 8008448:	e012      	b.n	8008470 <mpiInvMod+0x242>
   MPI_CHECK(mpiCopy(&c, a));
 800844a:	bf00      	nop
 800844c:	e010      	b.n	8008470 <mpiInvMod+0x242>
   MPI_CHECK(mpiSetValue(&u, 0));
 800844e:	bf00      	nop
 8008450:	e00e      	b.n	8008470 <mpiInvMod+0x242>
   MPI_CHECK(mpiSetValue(&v, 1));
 8008452:	bf00      	nop
 8008454:	e00c      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiDiv(&q0, &r0, &b, &c));
 8008456:	bf00      	nop
 8008458:	e00a      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiCopy(&b, &c));
 800845a:	bf00      	nop
 800845c:	e008      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiCopy(&c, &r0));
 800845e:	bf00      	nop
 8008460:	e006      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiCopy(&t, &v));
 8008462:	bf00      	nop
 8008464:	e004      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiMul(&q0, &q0, &v));
 8008466:	bf00      	nop
 8008468:	e002      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiSub(&v, &u, &q0));
 800846a:	bf00      	nop
 800846c:	e000      	b.n	8008470 <mpiInvMod+0x242>
      MPI_CHECK(mpiCopy(&u, &t));
 800846e:	bf00      	nop
   //Release previously allocated memory
   mpiFree(&b);
 8008470:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8008474:	4618      	mov	r0, r3
 8008476:	f7fe fcfc 	bl	8006e72 <mpiFree>
   mpiFree(&c);
 800847a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 800847e:	4618      	mov	r0, r3
 8008480:	f7fe fcf7 	bl	8006e72 <mpiFree>
   mpiFree(&q0);
 8008484:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8008488:	4618      	mov	r0, r3
 800848a:	f7fe fcf2 	bl	8006e72 <mpiFree>
   mpiFree(&r0);
 800848e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8008492:	4618      	mov	r0, r3
 8008494:	f7fe fced 	bl	8006e72 <mpiFree>
   mpiFree(&t);
 8008498:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800849c:	4618      	mov	r0, r3
 800849e:	f7fe fce8 	bl	8006e72 <mpiFree>
   mpiFree(&u);
 80084a2:	f107 031c 	add.w	r3, r7, #28
 80084a6:	4618      	mov	r0, r3
 80084a8:	f7fe fce3 	bl	8006e72 <mpiFree>
   mpiFree(&v);
 80084ac:	f107 0310 	add.w	r3, r7, #16
 80084b0:	4618      	mov	r0, r3
 80084b2:	f7fe fcde 	bl	8006e72 <mpiFree>

   //Return status code
   return error;
 80084b6:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
}
 80084ba:	4618      	mov	r0, r3
 80084bc:	3768      	adds	r7, #104	; 0x68
 80084be:	46bd      	mov	sp, r7
 80084c0:	bd80      	pop	{r7, pc}

080084c2 <mpiMulAccCore>:
 * @param[in] m Size of A in words
 * @param[in] b Second operand B
 **/

void mpiMulAccCore(uint_t *r, const uint_t *a, int_t m, const uint_t b)
{
 80084c2:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80084c6:	b08b      	sub	sp, #44	; 0x2c
 80084c8:	af00      	add	r7, sp, #0
 80084ca:	60f8      	str	r0, [r7, #12]
 80084cc:	60b9      	str	r1, [r7, #8]
 80084ce:	607a      	str	r2, [r7, #4]
 80084d0:	603b      	str	r3, [r7, #0]
   uint32_t u;
   uint32_t v;
   uint64_t p;

   //Clear variables
   c = 0;
 80084d2:	2300      	movs	r3, #0
 80084d4:	623b      	str	r3, [r7, #32]
   u = 0;
 80084d6:	2300      	movs	r3, #0
 80084d8:	61bb      	str	r3, [r7, #24]
   v = 0;
 80084da:	2300      	movs	r3, #0
 80084dc:	61fb      	str	r3, [r7, #28]

   //Perform multiplication
   for(i = 0; i < m; i++)
 80084de:	2300      	movs	r3, #0
 80084e0:	627b      	str	r3, [r7, #36]	; 0x24
 80084e2:	e04d      	b.n	8008580 <mpiMulAccCore+0xbe>
   {
      p = (uint64_t) a[i] * b;
 80084e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80084e6:	009b      	lsls	r3, r3, #2
 80084e8:	68ba      	ldr	r2, [r7, #8]
 80084ea:	4413      	add	r3, r2
 80084ec:	681b      	ldr	r3, [r3, #0]
 80084ee:	2200      	movs	r2, #0
 80084f0:	4698      	mov	r8, r3
 80084f2:	4691      	mov	r9, r2
 80084f4:	683b      	ldr	r3, [r7, #0]
 80084f6:	2200      	movs	r2, #0
 80084f8:	469a      	mov	sl, r3
 80084fa:	4693      	mov	fp, r2
 80084fc:	fb0a f209 	mul.w	r2, sl, r9
 8008500:	fb08 f30b 	mul.w	r3, r8, fp
 8008504:	4413      	add	r3, r2
 8008506:	fba8 450a 	umull	r4, r5, r8, sl
 800850a:	442b      	add	r3, r5
 800850c:	461d      	mov	r5, r3
 800850e:	e9c7 4504 	strd	r4, r5, [r7, #16]
 8008512:	e9c7 4504 	strd	r4, r5, [r7, #16]
      u = (uint32_t) p;
 8008516:	693b      	ldr	r3, [r7, #16]
 8008518:	61bb      	str	r3, [r7, #24]
      v = (uint32_t) (p >> 32);
 800851a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800851e:	f04f 0200 	mov.w	r2, #0
 8008522:	f04f 0300 	mov.w	r3, #0
 8008526:	000a      	movs	r2, r1
 8008528:	2300      	movs	r3, #0
 800852a:	4613      	mov	r3, r2
 800852c:	61fb      	str	r3, [r7, #28]

      u += c;
 800852e:	69ba      	ldr	r2, [r7, #24]
 8008530:	6a3b      	ldr	r3, [r7, #32]
 8008532:	4413      	add	r3, r2
 8008534:	61bb      	str	r3, [r7, #24]
      if(u < c) v++;
 8008536:	69ba      	ldr	r2, [r7, #24]
 8008538:	6a3b      	ldr	r3, [r7, #32]
 800853a:	429a      	cmp	r2, r3
 800853c:	d202      	bcs.n	8008544 <mpiMulAccCore+0x82>
 800853e:	69fb      	ldr	r3, [r7, #28]
 8008540:	3301      	adds	r3, #1
 8008542:	61fb      	str	r3, [r7, #28]

      u += r[i];
 8008544:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008546:	009b      	lsls	r3, r3, #2
 8008548:	68fa      	ldr	r2, [r7, #12]
 800854a:	4413      	add	r3, r2
 800854c:	681b      	ldr	r3, [r3, #0]
 800854e:	69ba      	ldr	r2, [r7, #24]
 8008550:	4413      	add	r3, r2
 8008552:	61bb      	str	r3, [r7, #24]
      if(u < r[i]) v++;
 8008554:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008556:	009b      	lsls	r3, r3, #2
 8008558:	68fa      	ldr	r2, [r7, #12]
 800855a:	4413      	add	r3, r2
 800855c:	681b      	ldr	r3, [r3, #0]
 800855e:	69ba      	ldr	r2, [r7, #24]
 8008560:	429a      	cmp	r2, r3
 8008562:	d202      	bcs.n	800856a <mpiMulAccCore+0xa8>
 8008564:	69fb      	ldr	r3, [r7, #28]
 8008566:	3301      	adds	r3, #1
 8008568:	61fb      	str	r3, [r7, #28]

      r[i] = u;
 800856a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800856c:	009b      	lsls	r3, r3, #2
 800856e:	68fa      	ldr	r2, [r7, #12]
 8008570:	4413      	add	r3, r2
 8008572:	69ba      	ldr	r2, [r7, #24]
 8008574:	601a      	str	r2, [r3, #0]
      c = v;
 8008576:	69fb      	ldr	r3, [r7, #28]
 8008578:	623b      	str	r3, [r7, #32]
   for(i = 0; i < m; i++)
 800857a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800857c:	3301      	adds	r3, #1
 800857e:	627b      	str	r3, [r7, #36]	; 0x24
 8008580:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008582:	687b      	ldr	r3, [r7, #4]
 8008584:	429a      	cmp	r2, r3
 8008586:	dbad      	blt.n	80084e4 <mpiMulAccCore+0x22>
   }

   //Propagate carry
   for(; c != 0; i++)
 8008588:	e01a      	b.n	80085c0 <mpiMulAccCore+0xfe>
   {
      r[i] += c;
 800858a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800858c:	009b      	lsls	r3, r3, #2
 800858e:	68fa      	ldr	r2, [r7, #12]
 8008590:	4413      	add	r3, r2
 8008592:	6819      	ldr	r1, [r3, #0]
 8008594:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008596:	009b      	lsls	r3, r3, #2
 8008598:	68fa      	ldr	r2, [r7, #12]
 800859a:	4413      	add	r3, r2
 800859c:	6a3a      	ldr	r2, [r7, #32]
 800859e:	440a      	add	r2, r1
 80085a0:	601a      	str	r2, [r3, #0]
      c = (r[i] < c);
 80085a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80085a4:	009b      	lsls	r3, r3, #2
 80085a6:	68fa      	ldr	r2, [r7, #12]
 80085a8:	4413      	add	r3, r2
 80085aa:	681b      	ldr	r3, [r3, #0]
 80085ac:	6a3a      	ldr	r2, [r7, #32]
 80085ae:	429a      	cmp	r2, r3
 80085b0:	bf8c      	ite	hi
 80085b2:	2301      	movhi	r3, #1
 80085b4:	2300      	movls	r3, #0
 80085b6:	b2db      	uxtb	r3, r3
 80085b8:	623b      	str	r3, [r7, #32]
   for(; c != 0; i++)
 80085ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80085bc:	3301      	adds	r3, #1
 80085be:	627b      	str	r3, [r7, #36]	; 0x24
 80085c0:	6a3b      	ldr	r3, [r7, #32]
 80085c2:	2b00      	cmp	r3, #0
 80085c4:	d1e1      	bne.n	800858a <mpiMulAccCore+0xc8>
   }
}
 80085c6:	bf00      	nop
 80085c8:	bf00      	nop
 80085ca:	372c      	adds	r7, #44	; 0x2c
 80085cc:	46bd      	mov	sp, r7
 80085ce:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80085d2:	4770      	bx	lr

080085d4 <shakeInit>:
 *   256 for SHAKE256)
 * @return Error code
 **/

error_t shakeInit(ShakeContext *context, uint_t strength)
{
 80085d4:	b580      	push	{r7, lr}
 80085d6:	b084      	sub	sp, #16
 80085d8:	af00      	add	r7, sp, #0
 80085da:	6078      	str	r0, [r7, #4]
 80085dc:	6039      	str	r1, [r7, #0]
   error_t error;

   //SHAKE128 and SHAKE256 provides respectively 128 and 256 bits of security
   if(strength == 128 || strength == 256)
 80085de:	683b      	ldr	r3, [r7, #0]
 80085e0:	2b80      	cmp	r3, #128	; 0x80
 80085e2:	d003      	beq.n	80085ec <shakeInit+0x18>
 80085e4:	683b      	ldr	r3, [r7, #0]
 80085e6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80085ea:	d109      	bne.n	8008600 <shakeInit+0x2c>
   {
      //Initialize Keccak context
      error = keccakInit(&context->keccakContext, 2 * strength);
 80085ec:	687a      	ldr	r2, [r7, #4]
 80085ee:	683b      	ldr	r3, [r7, #0]
 80085f0:	005b      	lsls	r3, r3, #1
 80085f2:	4619      	mov	r1, r3
 80085f4:	4610      	mov	r0, r2
 80085f6:	f001 fb7b 	bl	8009cf0 <keccakInit>
 80085fa:	4603      	mov	r3, r0
 80085fc:	81fb      	strh	r3, [r7, #14]
 80085fe:	e001      	b.n	8008604 <shakeInit+0x30>
   }
   else
   {
      //Report an error
      error = ERROR_INVALID_PARAMETER;
 8008600:	2302      	movs	r3, #2
 8008602:	81fb      	strh	r3, [r7, #14]
   }

   //Return status code
   return error;
 8008604:	89fb      	ldrh	r3, [r7, #14]
}
 8008606:	4618      	mov	r0, r3
 8008608:	3710      	adds	r7, #16
 800860a:	46bd      	mov	sp, r7
 800860c:	bd80      	pop	{r7, pc}

0800860e <shakeAbsorb>:
 * @param[in] input Pointer to the buffer being hashed
 * @param[in] length Length of the buffer
 **/

void shakeAbsorb(ShakeContext *context, const void *input, size_t length)
{
 800860e:	b580      	push	{r7, lr}
 8008610:	b084      	sub	sp, #16
 8008612:	af00      	add	r7, sp, #0
 8008614:	60f8      	str	r0, [r7, #12]
 8008616:	60b9      	str	r1, [r7, #8]
 8008618:	607a      	str	r2, [r7, #4]
   //Absorb the input data
   keccakAbsorb(&context->keccakContext, input, length);
 800861a:	68fb      	ldr	r3, [r7, #12]
 800861c:	687a      	ldr	r2, [r7, #4]
 800861e:	68b9      	ldr	r1, [r7, #8]
 8008620:	4618      	mov	r0, r3
 8008622:	f001 fb90 	bl	8009d46 <keccakAbsorb>
}
 8008626:	bf00      	nop
 8008628:	3710      	adds	r7, #16
 800862a:	46bd      	mov	sp, r7
 800862c:	bd80      	pop	{r7, pc}

0800862e <shakeFinal>:
 * @brief Finish absorbing phase
 * @param[in] context Pointer to the SHAKE context
 **/

void shakeFinal(ShakeContext *context)
{
 800862e:	b580      	push	{r7, lr}
 8008630:	b082      	sub	sp, #8
 8008632:	af00      	add	r7, sp, #0
 8008634:	6078      	str	r0, [r7, #4]
   //Finish absorbing phase (padding byte is 0x1F for XOFs)
   keccakFinal(&context->keccakContext, KECCAK_SHAKE_PAD);
 8008636:	687b      	ldr	r3, [r7, #4]
 8008638:	211f      	movs	r1, #31
 800863a:	4618      	mov	r0, r3
 800863c:	f001 fbf0 	bl	8009e20 <keccakFinal>
}
 8008640:	bf00      	nop
 8008642:	3708      	adds	r7, #8
 8008644:	46bd      	mov	sp, r7
 8008646:	bd80      	pop	{r7, pc}

08008648 <shakeSqueeze>:
 * @param[out] output Output string
 * @param[in] length Desired output length, in bytes
 **/

void shakeSqueeze(ShakeContext *context, uint8_t *output, size_t length)
{
 8008648:	b580      	push	{r7, lr}
 800864a:	b084      	sub	sp, #16
 800864c:	af00      	add	r7, sp, #0
 800864e:	60f8      	str	r0, [r7, #12]
 8008650:	60b9      	str	r1, [r7, #8]
 8008652:	607a      	str	r2, [r7, #4]
   //Extract data from the squeezing phase
   keccakSqueeze(&context->keccakContext, output, length);
 8008654:	68fb      	ldr	r3, [r7, #12]
 8008656:	687a      	ldr	r2, [r7, #4]
 8008658:	68b9      	ldr	r1, [r7, #8]
 800865a:	4618      	mov	r0, r3
 800865c:	f001 fc6d 	bl	8009f3a <keccakSqueeze>
}
 8008660:	bf00      	nop
 8008662:	3710      	adds	r7, #16
 8008664:	46bd      	mov	sp, r7
 8008666:	bd80      	pop	{r7, pc}

08008668 <theta>:
 * @brief Apply theta transformation
 * @param[in,out] a State array
 **/

static void theta(keccak_lane_t a[5][5])
{
 8008668:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 800866c:	b0ff      	sub	sp, #508	; 0x1fc
 800866e:	af00      	add	r7, sp, #0
 8008670:	f8c7 01a4 	str.w	r0, [r7, #420]	; 0x1a4
   keccak_lane_t c[5];
   keccak_lane_t d[5];

   //The effect of the theta transformation is to XOR each bit in the state
   //with the parities of two columns in the array
   c[0] = a[0][0] ^ a[1][0] ^ a[2][0] ^ a[3][0] ^ a[4][0];
 8008674:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008678:	e9d3 0100 	ldrd	r0, r1, [r3]
 800867c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008680:	3328      	adds	r3, #40	; 0x28
 8008682:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008686:	ea80 0402 	eor.w	r4, r0, r2
 800868a:	ea81 0503 	eor.w	r5, r1, r3
 800868e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008692:	3350      	adds	r3, #80	; 0x50
 8008694:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008698:	ea84 0802 	eor.w	r8, r4, r2
 800869c:	ea85 0903 	eor.w	r9, r5, r3
 80086a0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80086a4:	3378      	adds	r3, #120	; 0x78
 80086a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086aa:	ea88 0a02 	eor.w	sl, r8, r2
 80086ae:	ea89 0b03 	eor.w	fp, r9, r3
 80086b2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80086b6:	33a0      	adds	r3, #160	; 0xa0
 80086b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80086bc:	ea8a 0102 	eor.w	r1, sl, r2
 80086c0:	f8c7 1198 	str.w	r1, [r7, #408]	; 0x198
 80086c4:	ea8b 0303 	eor.w	r3, fp, r3
 80086c8:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
 80086cc:	e9d7 3466 	ldrd	r3, r4, [r7, #408]	; 0x198
 80086d0:	e9c7 3474 	strd	r3, r4, [r7, #464]	; 0x1d0
   c[1] = a[0][1] ^ a[1][1] ^ a[2][1] ^ a[3][1] ^ a[4][1];
 80086d4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80086d8:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80086dc:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80086e0:	3328      	adds	r3, #40	; 0x28
 80086e2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80086e6:	ea80 0402 	eor.w	r4, r0, r2
 80086ea:	f8c7 4190 	str.w	r4, [r7, #400]	; 0x190
 80086ee:	404b      	eors	r3, r1
 80086f0:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 80086f4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80086f8:	3350      	adds	r3, #80	; 0x50
 80086fa:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80086fe:	e9d7 4564 	ldrd	r4, r5, [r7, #400]	; 0x190
 8008702:	4621      	mov	r1, r4
 8008704:	4051      	eors	r1, r2
 8008706:	f8c7 1188 	str.w	r1, [r7, #392]	; 0x188
 800870a:	4629      	mov	r1, r5
 800870c:	4059      	eors	r1, r3
 800870e:	f8c7 118c 	str.w	r1, [r7, #396]	; 0x18c
 8008712:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008716:	3378      	adds	r3, #120	; 0x78
 8008718:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800871c:	e9d7 4562 	ldrd	r4, r5, [r7, #392]	; 0x188
 8008720:	4621      	mov	r1, r4
 8008722:	4051      	eors	r1, r2
 8008724:	f8c7 1180 	str.w	r1, [r7, #384]	; 0x180
 8008728:	4629      	mov	r1, r5
 800872a:	4059      	eors	r1, r3
 800872c:	f8c7 1184 	str.w	r1, [r7, #388]	; 0x184
 8008730:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008734:	33a0      	adds	r3, #160	; 0xa0
 8008736:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800873a:	e9d7 4560 	ldrd	r4, r5, [r7, #384]	; 0x180
 800873e:	4621      	mov	r1, r4
 8008740:	4051      	eors	r1, r2
 8008742:	f8c7 1178 	str.w	r1, [r7, #376]	; 0x178
 8008746:	4629      	mov	r1, r5
 8008748:	4059      	eors	r1, r3
 800874a:	f8c7 117c 	str.w	r1, [r7, #380]	; 0x17c
 800874e:	e9d7 345e 	ldrd	r3, r4, [r7, #376]	; 0x178
 8008752:	e9c7 3476 	strd	r3, r4, [r7, #472]	; 0x1d8
   c[2] = a[0][2] ^ a[1][2] ^ a[2][2] ^ a[3][2] ^ a[4][2];
 8008756:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800875a:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800875e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008762:	3328      	adds	r3, #40	; 0x28
 8008764:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008768:	ea80 0402 	eor.w	r4, r0, r2
 800876c:	f8c7 4170 	str.w	r4, [r7, #368]	; 0x170
 8008770:	404b      	eors	r3, r1
 8008772:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 8008776:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800877a:	3350      	adds	r3, #80	; 0x50
 800877c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008780:	e9d7 455c 	ldrd	r4, r5, [r7, #368]	; 0x170
 8008784:	4621      	mov	r1, r4
 8008786:	4051      	eors	r1, r2
 8008788:	f8c7 1168 	str.w	r1, [r7, #360]	; 0x168
 800878c:	4629      	mov	r1, r5
 800878e:	4059      	eors	r1, r3
 8008790:	f8c7 116c 	str.w	r1, [r7, #364]	; 0x16c
 8008794:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008798:	3378      	adds	r3, #120	; 0x78
 800879a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800879e:	e9d7 455a 	ldrd	r4, r5, [r7, #360]	; 0x168
 80087a2:	4621      	mov	r1, r4
 80087a4:	4051      	eors	r1, r2
 80087a6:	f8c7 1160 	str.w	r1, [r7, #352]	; 0x160
 80087aa:	4629      	mov	r1, r5
 80087ac:	4059      	eors	r1, r3
 80087ae:	f8c7 1164 	str.w	r1, [r7, #356]	; 0x164
 80087b2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80087b6:	33a0      	adds	r3, #160	; 0xa0
 80087b8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80087bc:	e9d7 4558 	ldrd	r4, r5, [r7, #352]	; 0x160
 80087c0:	4621      	mov	r1, r4
 80087c2:	4051      	eors	r1, r2
 80087c4:	f8c7 1158 	str.w	r1, [r7, #344]	; 0x158
 80087c8:	4629      	mov	r1, r5
 80087ca:	4059      	eors	r1, r3
 80087cc:	f8c7 115c 	str.w	r1, [r7, #348]	; 0x15c
 80087d0:	e9d7 3456 	ldrd	r3, r4, [r7, #344]	; 0x158
 80087d4:	e9c7 3478 	strd	r3, r4, [r7, #480]	; 0x1e0
   c[3] = a[0][3] ^ a[1][3] ^ a[2][3] ^ a[3][3] ^ a[4][3];
 80087d8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80087dc:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 80087e0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80087e4:	3328      	adds	r3, #40	; 0x28
 80087e6:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80087ea:	ea80 0402 	eor.w	r4, r0, r2
 80087ee:	f8c7 4150 	str.w	r4, [r7, #336]	; 0x150
 80087f2:	404b      	eors	r3, r1
 80087f4:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
 80087f8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80087fc:	3350      	adds	r3, #80	; 0x50
 80087fe:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8008802:	e9d7 4554 	ldrd	r4, r5, [r7, #336]	; 0x150
 8008806:	4621      	mov	r1, r4
 8008808:	4051      	eors	r1, r2
 800880a:	f8c7 1148 	str.w	r1, [r7, #328]	; 0x148
 800880e:	4629      	mov	r1, r5
 8008810:	4059      	eors	r1, r3
 8008812:	f8c7 114c 	str.w	r1, [r7, #332]	; 0x14c
 8008816:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800881a:	3378      	adds	r3, #120	; 0x78
 800881c:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8008820:	e9d7 4552 	ldrd	r4, r5, [r7, #328]	; 0x148
 8008824:	4621      	mov	r1, r4
 8008826:	4051      	eors	r1, r2
 8008828:	f8c7 1140 	str.w	r1, [r7, #320]	; 0x140
 800882c:	4629      	mov	r1, r5
 800882e:	4059      	eors	r1, r3
 8008830:	f8c7 1144 	str.w	r1, [r7, #324]	; 0x144
 8008834:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008838:	33a0      	adds	r3, #160	; 0xa0
 800883a:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800883e:	e9d7 4550 	ldrd	r4, r5, [r7, #320]	; 0x140
 8008842:	4621      	mov	r1, r4
 8008844:	4051      	eors	r1, r2
 8008846:	f8c7 1138 	str.w	r1, [r7, #312]	; 0x138
 800884a:	4629      	mov	r1, r5
 800884c:	4059      	eors	r1, r3
 800884e:	f8c7 113c 	str.w	r1, [r7, #316]	; 0x13c
 8008852:	e9d7 344e 	ldrd	r3, r4, [r7, #312]	; 0x138
 8008856:	e9c7 347a 	strd	r3, r4, [r7, #488]	; 0x1e8
   c[4] = a[0][4] ^ a[1][4] ^ a[2][4] ^ a[3][4] ^ a[4][4];
 800885a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800885e:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008862:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008866:	3328      	adds	r3, #40	; 0x28
 8008868:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800886c:	ea80 0402 	eor.w	r4, r0, r2
 8008870:	f8c7 4130 	str.w	r4, [r7, #304]	; 0x130
 8008874:	404b      	eors	r3, r1
 8008876:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 800887a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800887e:	3350      	adds	r3, #80	; 0x50
 8008880:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8008884:	e9d7 454c 	ldrd	r4, r5, [r7, #304]	; 0x130
 8008888:	4621      	mov	r1, r4
 800888a:	4051      	eors	r1, r2
 800888c:	f8c7 1128 	str.w	r1, [r7, #296]	; 0x128
 8008890:	4629      	mov	r1, r5
 8008892:	4059      	eors	r1, r3
 8008894:	f8c7 112c 	str.w	r1, [r7, #300]	; 0x12c
 8008898:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800889c:	3378      	adds	r3, #120	; 0x78
 800889e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80088a2:	e9d7 454a 	ldrd	r4, r5, [r7, #296]	; 0x128
 80088a6:	4621      	mov	r1, r4
 80088a8:	4051      	eors	r1, r2
 80088aa:	f8c7 1120 	str.w	r1, [r7, #288]	; 0x120
 80088ae:	4629      	mov	r1, r5
 80088b0:	4059      	eors	r1, r3
 80088b2:	f8c7 1124 	str.w	r1, [r7, #292]	; 0x124
 80088b6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80088ba:	33a0      	adds	r3, #160	; 0xa0
 80088bc:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80088c0:	e9d7 4548 	ldrd	r4, r5, [r7, #288]	; 0x120
 80088c4:	4621      	mov	r1, r4
 80088c6:	4051      	eors	r1, r2
 80088c8:	f8c7 1118 	str.w	r1, [r7, #280]	; 0x118
 80088cc:	4629      	mov	r1, r5
 80088ce:	4059      	eors	r1, r3
 80088d0:	f8c7 111c 	str.w	r1, [r7, #284]	; 0x11c
 80088d4:	e9d7 3446 	ldrd	r3, r4, [r7, #280]	; 0x118
 80088d8:	e9c7 347c 	strd	r3, r4, [r7, #496]	; 0x1f0

   d[0] = c[4] ^ KECCAK_ROL(c[1], 1);
 80088dc:	e9d7 457c 	ldrd	r4, r5, [r7, #496]	; 0x1f0
 80088e0:	e9d7 2376 	ldrd	r2, r3, [r7, #472]	; 0x1d8
 80088e4:	0fd0      	lsrs	r0, r2, #31
 80088e6:	0059      	lsls	r1, r3, #1
 80088e8:	4301      	orrs	r1, r0
 80088ea:	f8c7 1114 	str.w	r1, [r7, #276]	; 0x114
 80088ee:	0fd9      	lsrs	r1, r3, #31
 80088f0:	0053      	lsls	r3, r2, #1
 80088f2:	430b      	orrs	r3, r1
 80088f4:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
 80088f8:	e9d7 1244 	ldrd	r1, r2, [r7, #272]	; 0x110
 80088fc:	460b      	mov	r3, r1
 80088fe:	4063      	eors	r3, r4
 8008900:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 8008904:	4613      	mov	r3, r2
 8008906:	406b      	eors	r3, r5
 8008908:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 800890c:	e9d7 3442 	ldrd	r3, r4, [r7, #264]	; 0x108
 8008910:	e9c7 346a 	strd	r3, r4, [r7, #424]	; 0x1a8
   d[1] = c[0] ^ KECCAK_ROL(c[2], 1);
 8008914:	e9d7 4574 	ldrd	r4, r5, [r7, #464]	; 0x1d0
 8008918:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	; 0x1e0
 800891c:	0fd0      	lsrs	r0, r2, #31
 800891e:	0059      	lsls	r1, r3, #1
 8008920:	4301      	orrs	r1, r0
 8008922:	f8c7 1104 	str.w	r1, [r7, #260]	; 0x104
 8008926:	0fd9      	lsrs	r1, r3, #31
 8008928:	0053      	lsls	r3, r2, #1
 800892a:	430b      	orrs	r3, r1
 800892c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8008930:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	; 0x100
 8008934:	460b      	mov	r3, r1
 8008936:	4063      	eors	r3, r4
 8008938:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800893c:	4613      	mov	r3, r2
 800893e:	406b      	eors	r3, r5
 8008940:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8008944:	e9d7 343e 	ldrd	r3, r4, [r7, #248]	; 0xf8
 8008948:	e9c7 346c 	strd	r3, r4, [r7, #432]	; 0x1b0
   d[2] = c[1] ^ KECCAK_ROL(c[3], 1);
 800894c:	e9d7 4576 	ldrd	r4, r5, [r7, #472]	; 0x1d8
 8008950:	e9d7 237a 	ldrd	r2, r3, [r7, #488]	; 0x1e8
 8008954:	0fd0      	lsrs	r0, r2, #31
 8008956:	0059      	lsls	r1, r3, #1
 8008958:	4301      	orrs	r1, r0
 800895a:	f8c7 10f4 	str.w	r1, [r7, #244]	; 0xf4
 800895e:	0fd9      	lsrs	r1, r3, #31
 8008960:	0053      	lsls	r3, r2, #1
 8008962:	430b      	orrs	r3, r1
 8008964:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8008968:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	; 0xf0
 800896c:	460b      	mov	r3, r1
 800896e:	4063      	eors	r3, r4
 8008970:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8008974:	4613      	mov	r3, r2
 8008976:	406b      	eors	r3, r5
 8008978:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800897c:	e9d7 343a 	ldrd	r3, r4, [r7, #232]	; 0xe8
 8008980:	e9c7 346e 	strd	r3, r4, [r7, #440]	; 0x1b8
   d[3] = c[2] ^ KECCAK_ROL(c[4], 1);
 8008984:	e9d7 4578 	ldrd	r4, r5, [r7, #480]	; 0x1e0
 8008988:	e9d7 237c 	ldrd	r2, r3, [r7, #496]	; 0x1f0
 800898c:	0fd0      	lsrs	r0, r2, #31
 800898e:	0059      	lsls	r1, r3, #1
 8008990:	4301      	orrs	r1, r0
 8008992:	f8c7 10e4 	str.w	r1, [r7, #228]	; 0xe4
 8008996:	0fd9      	lsrs	r1, r3, #31
 8008998:	0053      	lsls	r3, r2, #1
 800899a:	430b      	orrs	r3, r1
 800899c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 80089a0:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	; 0xe0
 80089a4:	460b      	mov	r3, r1
 80089a6:	4063      	eors	r3, r4
 80089a8:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 80089ac:	4613      	mov	r3, r2
 80089ae:	406b      	eors	r3, r5
 80089b0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80089b4:	e9d7 3436 	ldrd	r3, r4, [r7, #216]	; 0xd8
 80089b8:	e9c7 3470 	strd	r3, r4, [r7, #448]	; 0x1c0
   d[4] = c[3] ^ KECCAK_ROL(c[0], 1);
 80089bc:	e9d7 457a 	ldrd	r4, r5, [r7, #488]	; 0x1e8
 80089c0:	e9d7 2374 	ldrd	r2, r3, [r7, #464]	; 0x1d0
 80089c4:	0fd0      	lsrs	r0, r2, #31
 80089c6:	0059      	lsls	r1, r3, #1
 80089c8:	4301      	orrs	r1, r0
 80089ca:	f8c7 10d4 	str.w	r1, [r7, #212]	; 0xd4
 80089ce:	0fd9      	lsrs	r1, r3, #31
 80089d0:	0053      	lsls	r3, r2, #1
 80089d2:	430b      	orrs	r3, r1
 80089d4:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 80089d8:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	; 0xd0
 80089dc:	460b      	mov	r3, r1
 80089de:	4063      	eors	r3, r4
 80089e0:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 80089e4:	4613      	mov	r3, r2
 80089e6:	406b      	eors	r3, r5
 80089e8:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 80089ec:	e9d7 3432 	ldrd	r3, r4, [r7, #200]	; 0xc8
 80089f0:	e9c7 3472 	strd	r3, r4, [r7, #456]	; 0x1c8

   a[0][0] ^= d[0];
 80089f4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80089f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80089fc:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	; 0x1a8
 8008a00:	ea80 0402 	eor.w	r4, r0, r2
 8008a04:	f8c7 40c0 	str.w	r4, [r7, #192]	; 0xc0
 8008a08:	404b      	eors	r3, r1
 8008a0a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8008a0e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a12:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 8008a16:	e9c3 1200 	strd	r1, r2, [r3]
   a[1][0] ^= d[0];
 8008a1a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a1e:	3328      	adds	r3, #40	; 0x28
 8008a20:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008a24:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	; 0x1a8
 8008a28:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a2c:	3328      	adds	r3, #40	; 0x28
 8008a2e:	ea84 0200 	eor.w	r2, r4, r0
 8008a32:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
 8008a36:	ea85 0201 	eor.w	r2, r5, r1
 8008a3a:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
 8008a3e:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	; 0xb8
 8008a42:	e9c3 1200 	strd	r1, r2, [r3]
   a[2][0] ^= d[0];
 8008a46:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a4a:	3350      	adds	r3, #80	; 0x50
 8008a4c:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008a50:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	; 0x1a8
 8008a54:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a58:	3350      	adds	r3, #80	; 0x50
 8008a5a:	ea84 0200 	eor.w	r2, r4, r0
 8008a5e:	f8c7 20b0 	str.w	r2, [r7, #176]	; 0xb0
 8008a62:	ea85 0201 	eor.w	r2, r5, r1
 8008a66:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
 8008a6a:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
 8008a6e:	e9c3 1200 	strd	r1, r2, [r3]
   a[3][0] ^= d[0];
 8008a72:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a76:	3378      	adds	r3, #120	; 0x78
 8008a78:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008a7c:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	; 0x1a8
 8008a80:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008a84:	3378      	adds	r3, #120	; 0x78
 8008a86:	ea84 0200 	eor.w	r2, r4, r0
 8008a8a:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 8008a8e:	ea85 0201 	eor.w	r2, r5, r1
 8008a92:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
 8008a96:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 8008a9a:	e9c3 1200 	strd	r1, r2, [r3]
   a[4][0] ^= d[0];
 8008a9e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008aa2:	33a0      	adds	r3, #160	; 0xa0
 8008aa4:	e9d3 4500 	ldrd	r4, r5, [r3]
 8008aa8:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	; 0x1a8
 8008aac:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008ab0:	33a0      	adds	r3, #160	; 0xa0
 8008ab2:	ea84 0200 	eor.w	r2, r4, r0
 8008ab6:	f8c7 20a0 	str.w	r2, [r7, #160]	; 0xa0
 8008aba:	ea85 0201 	eor.w	r2, r5, r1
 8008abe:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
 8008ac2:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
 8008ac6:	e9c3 1200 	strd	r1, r2, [r3]

   a[0][1] ^= d[1];
 8008aca:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008ace:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8008ad2:	e9d7 236c 	ldrd	r2, r3, [r7, #432]	; 0x1b0
 8008ad6:	ea80 0402 	eor.w	r4, r0, r2
 8008ada:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
 8008ade:	404b      	eors	r3, r1
 8008ae0:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8008ae4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008ae8:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	; 0x98
 8008aec:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[1][1] ^= d[1];
 8008af0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008af4:	3328      	adds	r3, #40	; 0x28
 8008af6:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8008afa:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	; 0x1b0
 8008afe:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b02:	3328      	adds	r3, #40	; 0x28
 8008b04:	ea84 0200 	eor.w	r2, r4, r0
 8008b08:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 8008b0c:	ea85 0201 	eor.w	r2, r5, r1
 8008b10:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
 8008b14:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
 8008b18:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[2][1] ^= d[1];
 8008b1c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b20:	3350      	adds	r3, #80	; 0x50
 8008b22:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8008b26:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	; 0x1b0
 8008b2a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b2e:	3350      	adds	r3, #80	; 0x50
 8008b30:	ea84 0200 	eor.w	r2, r4, r0
 8008b34:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
 8008b38:	ea85 0201 	eor.w	r2, r5, r1
 8008b3c:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 8008b40:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
 8008b44:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[3][1] ^= d[1];
 8008b48:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b4c:	3378      	adds	r3, #120	; 0x78
 8008b4e:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8008b52:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	; 0x1b0
 8008b56:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b5a:	3378      	adds	r3, #120	; 0x78
 8008b5c:	ea84 0200 	eor.w	r2, r4, r0
 8008b60:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 8008b64:	ea85 0201 	eor.w	r2, r5, r1
 8008b68:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
 8008b6c:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
 8008b70:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[4][1] ^= d[1];
 8008b74:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b78:	33a0      	adds	r3, #160	; 0xa0
 8008b7a:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8008b7e:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	; 0x1b0
 8008b82:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008b86:	33a0      	adds	r3, #160	; 0xa0
 8008b88:	ea84 0200 	eor.w	r2, r4, r0
 8008b8c:	67ba      	str	r2, [r7, #120]	; 0x78
 8008b8e:	ea85 0201 	eor.w	r2, r5, r1
 8008b92:	67fa      	str	r2, [r7, #124]	; 0x7c
 8008b94:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
 8008b98:	e9c3 1202 	strd	r1, r2, [r3, #8]

   a[0][2] ^= d[2];
 8008b9c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008ba0:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8008ba4:	e9d7 236e 	ldrd	r2, r3, [r7, #440]	; 0x1b8
 8008ba8:	ea80 0402 	eor.w	r4, r0, r2
 8008bac:	673c      	str	r4, [r7, #112]	; 0x70
 8008bae:	404b      	eors	r3, r1
 8008bb0:	677b      	str	r3, [r7, #116]	; 0x74
 8008bb2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008bb6:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	; 0x70
 8008bba:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[1][2] ^= d[2];
 8008bbe:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008bc2:	3328      	adds	r3, #40	; 0x28
 8008bc4:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 8008bc8:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	; 0x1b8
 8008bcc:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008bd0:	3328      	adds	r3, #40	; 0x28
 8008bd2:	ea84 0200 	eor.w	r2, r4, r0
 8008bd6:	66ba      	str	r2, [r7, #104]	; 0x68
 8008bd8:	ea85 0201 	eor.w	r2, r5, r1
 8008bdc:	66fa      	str	r2, [r7, #108]	; 0x6c
 8008bde:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	; 0x68
 8008be2:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[2][2] ^= d[2];
 8008be6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008bea:	3350      	adds	r3, #80	; 0x50
 8008bec:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 8008bf0:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	; 0x1b8
 8008bf4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008bf8:	3350      	adds	r3, #80	; 0x50
 8008bfa:	ea84 0200 	eor.w	r2, r4, r0
 8008bfe:	663a      	str	r2, [r7, #96]	; 0x60
 8008c00:	ea85 0201 	eor.w	r2, r5, r1
 8008c04:	667a      	str	r2, [r7, #100]	; 0x64
 8008c06:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
 8008c0a:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[3][2] ^= d[2];
 8008c0e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c12:	3378      	adds	r3, #120	; 0x78
 8008c14:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 8008c18:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	; 0x1b8
 8008c1c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c20:	3378      	adds	r3, #120	; 0x78
 8008c22:	ea84 0200 	eor.w	r2, r4, r0
 8008c26:	65ba      	str	r2, [r7, #88]	; 0x58
 8008c28:	ea85 0201 	eor.w	r2, r5, r1
 8008c2c:	65fa      	str	r2, [r7, #92]	; 0x5c
 8008c2e:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
 8008c32:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[4][2] ^= d[2];
 8008c36:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c3a:	33a0      	adds	r3, #160	; 0xa0
 8008c3c:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 8008c40:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	; 0x1b8
 8008c44:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c48:	33a0      	adds	r3, #160	; 0xa0
 8008c4a:	ea84 0200 	eor.w	r2, r4, r0
 8008c4e:	653a      	str	r2, [r7, #80]	; 0x50
 8008c50:	ea85 0201 	eor.w	r2, r5, r1
 8008c54:	657a      	str	r2, [r7, #84]	; 0x54
 8008c56:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 8008c5a:	e9c3 1204 	strd	r1, r2, [r3, #16]

   a[0][3] ^= d[3];
 8008c5e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c62:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8008c66:	e9d7 2370 	ldrd	r2, r3, [r7, #448]	; 0x1c0
 8008c6a:	ea80 0402 	eor.w	r4, r0, r2
 8008c6e:	64bc      	str	r4, [r7, #72]	; 0x48
 8008c70:	404b      	eors	r3, r1
 8008c72:	64fb      	str	r3, [r7, #76]	; 0x4c
 8008c74:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c78:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 8008c7c:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[1][3] ^= d[3];
 8008c80:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c84:	3328      	adds	r3, #40	; 0x28
 8008c86:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8008c8a:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	; 0x1c0
 8008c8e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008c92:	3328      	adds	r3, #40	; 0x28
 8008c94:	ea84 0200 	eor.w	r2, r4, r0
 8008c98:	643a      	str	r2, [r7, #64]	; 0x40
 8008c9a:	ea85 0201 	eor.w	r2, r5, r1
 8008c9e:	647a      	str	r2, [r7, #68]	; 0x44
 8008ca0:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
 8008ca4:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[2][3] ^= d[3];
 8008ca8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008cac:	3350      	adds	r3, #80	; 0x50
 8008cae:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8008cb2:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	; 0x1c0
 8008cb6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008cba:	3350      	adds	r3, #80	; 0x50
 8008cbc:	ea84 0200 	eor.w	r2, r4, r0
 8008cc0:	63ba      	str	r2, [r7, #56]	; 0x38
 8008cc2:	ea85 0201 	eor.w	r2, r5, r1
 8008cc6:	63fa      	str	r2, [r7, #60]	; 0x3c
 8008cc8:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 8008ccc:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[3][3] ^= d[3];
 8008cd0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008cd4:	3378      	adds	r3, #120	; 0x78
 8008cd6:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8008cda:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	; 0x1c0
 8008cde:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008ce2:	3378      	adds	r3, #120	; 0x78
 8008ce4:	ea84 0200 	eor.w	r2, r4, r0
 8008ce8:	633a      	str	r2, [r7, #48]	; 0x30
 8008cea:	ea85 0201 	eor.w	r2, r5, r1
 8008cee:	637a      	str	r2, [r7, #52]	; 0x34
 8008cf0:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 8008cf4:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[4][3] ^= d[3];
 8008cf8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008cfc:	33a0      	adds	r3, #160	; 0xa0
 8008cfe:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8008d02:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	; 0x1c0
 8008d06:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d0a:	33a0      	adds	r3, #160	; 0xa0
 8008d0c:	ea84 0200 	eor.w	r2, r4, r0
 8008d10:	62ba      	str	r2, [r7, #40]	; 0x28
 8008d12:	ea85 0201 	eor.w	r2, r5, r1
 8008d16:	62fa      	str	r2, [r7, #44]	; 0x2c
 8008d18:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 8008d1c:	e9c3 1206 	strd	r1, r2, [r3, #24]

   a[0][4] ^= d[4];
 8008d20:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d24:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008d28:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	; 0x1c8
 8008d2c:	ea80 0402 	eor.w	r4, r0, r2
 8008d30:	623c      	str	r4, [r7, #32]
 8008d32:	404b      	eors	r3, r1
 8008d34:	627b      	str	r3, [r7, #36]	; 0x24
 8008d36:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d3a:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8008d3e:	e9c3 1208 	strd	r1, r2, [r3, #32]
   a[1][4] ^= d[4];
 8008d42:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d46:	3328      	adds	r3, #40	; 0x28
 8008d48:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008d4c:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	; 0x1c8
 8008d50:	f8d7 41a4 	ldr.w	r4, [r7, #420]	; 0x1a4
 8008d54:	3428      	adds	r4, #40	; 0x28
 8008d56:	ea80 0502 	eor.w	r5, r0, r2
 8008d5a:	61bd      	str	r5, [r7, #24]
 8008d5c:	404b      	eors	r3, r1
 8008d5e:	61fb      	str	r3, [r7, #28]
 8008d60:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8008d64:	e9c4 2308 	strd	r2, r3, [r4, #32]
   a[2][4] ^= d[4];
 8008d68:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d6c:	3350      	adds	r3, #80	; 0x50
 8008d6e:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008d72:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	; 0x1c8
 8008d76:	f8d7 41a4 	ldr.w	r4, [r7, #420]	; 0x1a4
 8008d7a:	3450      	adds	r4, #80	; 0x50
 8008d7c:	ea80 0502 	eor.w	r5, r0, r2
 8008d80:	613d      	str	r5, [r7, #16]
 8008d82:	404b      	eors	r3, r1
 8008d84:	617b      	str	r3, [r7, #20]
 8008d86:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8008d8a:	e9c4 2308 	strd	r2, r3, [r4, #32]
   a[3][4] ^= d[4];
 8008d8e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008d92:	3378      	adds	r3, #120	; 0x78
 8008d94:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008d98:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	; 0x1c8
 8008d9c:	f8d7 41a4 	ldr.w	r4, [r7, #420]	; 0x1a4
 8008da0:	3478      	adds	r4, #120	; 0x78
 8008da2:	ea80 0502 	eor.w	r5, r0, r2
 8008da6:	60bd      	str	r5, [r7, #8]
 8008da8:	404b      	eors	r3, r1
 8008daa:	60fb      	str	r3, [r7, #12]
 8008dac:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8008db0:	e9c4 2308 	strd	r2, r3, [r4, #32]
   a[4][4] ^= d[4];
 8008db4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8008db8:	33a0      	adds	r3, #160	; 0xa0
 8008dba:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8008dbe:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	; 0x1c8
 8008dc2:	f8d7 41a4 	ldr.w	r4, [r7, #420]	; 0x1a4
 8008dc6:	34a0      	adds	r4, #160	; 0xa0
 8008dc8:	ea80 0502 	eor.w	r5, r0, r2
 8008dcc:	603d      	str	r5, [r7, #0]
 8008dce:	404b      	eors	r3, r1
 8008dd0:	607b      	str	r3, [r7, #4]
 8008dd2:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008dd6:	e9c4 2308 	strd	r2, r3, [r4, #32]
}
 8008dda:	bf00      	nop
 8008ddc:	f507 77fe 	add.w	r7, r7, #508	; 0x1fc
 8008de0:	46bd      	mov	sp, r7
 8008de2:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8008de6:	4770      	bx	lr

08008de8 <rho>:
 * @brief Apply rho transformation
 * @param[in,out] a State array
 **/

static void rho(keccak_lane_t a[5][5])
{
 8008de8:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8008dec:	b0ad      	sub	sp, #180	; 0xb4
 8008dee:	af00      	add	r7, sp, #0
 8008df0:	f8c7 00ac 	str.w	r0, [r7, #172]	; 0xac
   //The effect of the rho transformation is to rotate the bits of each lane by
   //an offset, which depends on the fixed x and y coordinates of the lane
   a[0][1] = KECCAK_ROL(a[0][1], 1   % KECCAK_W);
 8008df4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008df8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8008dfc:	0fd0      	lsrs	r0, r2, #31
 8008dfe:	0059      	lsls	r1, r3, #1
 8008e00:	ea40 0501 	orr.w	r5, r0, r1
 8008e04:	0fd9      	lsrs	r1, r3, #31
 8008e06:	0053      	lsls	r3, r2, #1
 8008e08:	ea41 0403 	orr.w	r4, r1, r3
 8008e0c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e10:	e9c3 4502 	strd	r4, r5, [r3, #8]
   a[0][2] = KECCAK_ROL(a[0][2], 190 % KECCAK_W);
 8008e14:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e18:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008e1c:	0798      	lsls	r0, r3, #30
 8008e1e:	0891      	lsrs	r1, r2, #2
 8008e20:	ea40 0801 	orr.w	r8, r0, r1
 8008e24:	0791      	lsls	r1, r2, #30
 8008e26:	089b      	lsrs	r3, r3, #2
 8008e28:	ea41 0903 	orr.w	r9, r1, r3
 8008e2c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e30:	e9c3 8904 	strd	r8, r9, [r3, #16]
   a[0][3] = KECCAK_ROL(a[0][3], 28  % KECCAK_W);
 8008e34:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e38:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8008e3c:	0910      	lsrs	r0, r2, #4
 8008e3e:	0719      	lsls	r1, r3, #28
 8008e40:	ea40 0b01 	orr.w	fp, r0, r1
 8008e44:	0919      	lsrs	r1, r3, #4
 8008e46:	0713      	lsls	r3, r2, #28
 8008e48:	ea41 0a03 	orr.w	sl, r1, r3
 8008e4c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e50:	e9c3 ab06 	strd	sl, fp, [r3, #24]
   a[0][4] = KECCAK_ROL(a[0][4], 91  % KECCAK_W);
 8008e54:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e58:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8008e5c:	0950      	lsrs	r0, r2, #5
 8008e5e:	06d9      	lsls	r1, r3, #27
 8008e60:	4301      	orrs	r1, r0
 8008e62:	f8c7 10a4 	str.w	r1, [r7, #164]	; 0xa4
 8008e66:	0959      	lsrs	r1, r3, #5
 8008e68:	06d3      	lsls	r3, r2, #27
 8008e6a:	430b      	orrs	r3, r1
 8008e6c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8008e70:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e74:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
 8008e78:	e9c3 1208 	strd	r1, r2, [r3, #32]

   a[1][0] = KECCAK_ROL(a[1][0], 36  % KECCAK_W);
 8008e7c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008e80:	3328      	adds	r3, #40	; 0x28
 8008e82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008e86:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008e8a:	f101 0428 	add.w	r4, r1, #40	; 0x28
 8008e8e:	0118      	lsls	r0, r3, #4
 8008e90:	0f11      	lsrs	r1, r2, #28
 8008e92:	4301      	orrs	r1, r0
 8008e94:	f8c7 1098 	str.w	r1, [r7, #152]	; 0x98
 8008e98:	0111      	lsls	r1, r2, #4
 8008e9a:	0f1b      	lsrs	r3, r3, #28
 8008e9c:	430b      	orrs	r3, r1
 8008e9e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8008ea2:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	; 0x98
 8008ea6:	e9c4 2300 	strd	r2, r3, [r4]
   a[1][1] = KECCAK_ROL(a[1][1], 300 % KECCAK_W);
 8008eaa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008eae:	3328      	adds	r3, #40	; 0x28
 8008eb0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8008eb4:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008eb8:	f101 0428 	add.w	r4, r1, #40	; 0x28
 8008ebc:	0318      	lsls	r0, r3, #12
 8008ebe:	0d11      	lsrs	r1, r2, #20
 8008ec0:	4301      	orrs	r1, r0
 8008ec2:	f8c7 1090 	str.w	r1, [r7, #144]	; 0x90
 8008ec6:	0311      	lsls	r1, r2, #12
 8008ec8:	0d1b      	lsrs	r3, r3, #20
 8008eca:	430b      	orrs	r3, r1
 8008ecc:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8008ed0:	e9d7 2324 	ldrd	r2, r3, [r7, #144]	; 0x90
 8008ed4:	e9c4 2302 	strd	r2, r3, [r4, #8]
   a[1][2] = KECCAK_ROL(a[1][2], 6   % KECCAK_W);
 8008ed8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008edc:	3328      	adds	r3, #40	; 0x28
 8008ede:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008ee2:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008ee6:	f101 0428 	add.w	r4, r1, #40	; 0x28
 8008eea:	0e90      	lsrs	r0, r2, #26
 8008eec:	0199      	lsls	r1, r3, #6
 8008eee:	4301      	orrs	r1, r0
 8008ef0:	f8c7 108c 	str.w	r1, [r7, #140]	; 0x8c
 8008ef4:	0e99      	lsrs	r1, r3, #26
 8008ef6:	0193      	lsls	r3, r2, #6
 8008ef8:	430b      	orrs	r3, r1
 8008efa:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8008efe:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 8008f02:	e9c4 2304 	strd	r2, r3, [r4, #16]
   a[1][3] = KECCAK_ROL(a[1][3], 55  % KECCAK_W);
 8008f06:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008f0a:	3328      	adds	r3, #40	; 0x28
 8008f0c:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8008f10:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008f14:	f101 0428 	add.w	r4, r1, #40	; 0x28
 8008f18:	05d8      	lsls	r0, r3, #23
 8008f1a:	0a51      	lsrs	r1, r2, #9
 8008f1c:	4301      	orrs	r1, r0
 8008f1e:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
 8008f22:	05d1      	lsls	r1, r2, #23
 8008f24:	0a5b      	lsrs	r3, r3, #9
 8008f26:	430b      	orrs	r3, r1
 8008f28:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8008f2c:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	; 0x80
 8008f30:	e9c4 2306 	strd	r2, r3, [r4, #24]
   a[1][4] = KECCAK_ROL(a[1][4], 276 % KECCAK_W);
 8008f34:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008f38:	3328      	adds	r3, #40	; 0x28
 8008f3a:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8008f3e:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008f42:	f101 0428 	add.w	r4, r1, #40	; 0x28
 8008f46:	0b10      	lsrs	r0, r2, #12
 8008f48:	0519      	lsls	r1, r3, #20
 8008f4a:	4301      	orrs	r1, r0
 8008f4c:	67f9      	str	r1, [r7, #124]	; 0x7c
 8008f4e:	0b19      	lsrs	r1, r3, #12
 8008f50:	0513      	lsls	r3, r2, #20
 8008f52:	430b      	orrs	r3, r1
 8008f54:	67bb      	str	r3, [r7, #120]	; 0x78
 8008f56:	e9d7 231e 	ldrd	r2, r3, [r7, #120]	; 0x78
 8008f5a:	e9c4 2308 	strd	r2, r3, [r4, #32]

   a[2][0] = KECCAK_ROL(a[2][0], 3   % KECCAK_W);
 8008f5e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008f62:	3350      	adds	r3, #80	; 0x50
 8008f64:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f68:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008f6c:	f101 0450 	add.w	r4, r1, #80	; 0x50
 8008f70:	0f50      	lsrs	r0, r2, #29
 8008f72:	00d9      	lsls	r1, r3, #3
 8008f74:	4301      	orrs	r1, r0
 8008f76:	6779      	str	r1, [r7, #116]	; 0x74
 8008f78:	0f59      	lsrs	r1, r3, #29
 8008f7a:	00d3      	lsls	r3, r2, #3
 8008f7c:	430b      	orrs	r3, r1
 8008f7e:	673b      	str	r3, [r7, #112]	; 0x70
 8008f80:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 8008f84:	e9c4 2300 	strd	r2, r3, [r4]
   a[2][1] = KECCAK_ROL(a[2][1], 10  % KECCAK_W);
 8008f88:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008f8c:	3350      	adds	r3, #80	; 0x50
 8008f8e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8008f92:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008f96:	f101 0450 	add.w	r4, r1, #80	; 0x50
 8008f9a:	0d90      	lsrs	r0, r2, #22
 8008f9c:	0299      	lsls	r1, r3, #10
 8008f9e:	4301      	orrs	r1, r0
 8008fa0:	66f9      	str	r1, [r7, #108]	; 0x6c
 8008fa2:	0d99      	lsrs	r1, r3, #22
 8008fa4:	0293      	lsls	r3, r2, #10
 8008fa6:	430b      	orrs	r3, r1
 8008fa8:	66bb      	str	r3, [r7, #104]	; 0x68
 8008faa:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
 8008fae:	e9c4 2302 	strd	r2, r3, [r4, #8]
   a[2][2] = KECCAK_ROL(a[2][2], 171 % KECCAK_W);
 8008fb2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008fb6:	3350      	adds	r3, #80	; 0x50
 8008fb8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8008fbc:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008fc0:	f101 0450 	add.w	r4, r1, #80	; 0x50
 8008fc4:	02d8      	lsls	r0, r3, #11
 8008fc6:	0d51      	lsrs	r1, r2, #21
 8008fc8:	4301      	orrs	r1, r0
 8008fca:	6639      	str	r1, [r7, #96]	; 0x60
 8008fcc:	02d1      	lsls	r1, r2, #11
 8008fce:	0d5b      	lsrs	r3, r3, #21
 8008fd0:	430b      	orrs	r3, r1
 8008fd2:	667b      	str	r3, [r7, #100]	; 0x64
 8008fd4:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 8008fd8:	e9c4 2304 	strd	r2, r3, [r4, #16]
   a[2][3] = KECCAK_ROL(a[2][3], 153 % KECCAK_W);
 8008fdc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008fe0:	3350      	adds	r3, #80	; 0x50
 8008fe2:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8008fe6:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8008fea:	f101 0450 	add.w	r4, r1, #80	; 0x50
 8008fee:	09d0      	lsrs	r0, r2, #7
 8008ff0:	0659      	lsls	r1, r3, #25
 8008ff2:	4301      	orrs	r1, r0
 8008ff4:	65f9      	str	r1, [r7, #92]	; 0x5c
 8008ff6:	09d9      	lsrs	r1, r3, #7
 8008ff8:	0653      	lsls	r3, r2, #25
 8008ffa:	430b      	orrs	r3, r1
 8008ffc:	65bb      	str	r3, [r7, #88]	; 0x58
 8008ffe:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 8009002:	e9c4 2306 	strd	r2, r3, [r4, #24]
   a[2][4] = KECCAK_ROL(a[2][4], 231 % KECCAK_W);
 8009006:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800900a:	3350      	adds	r3, #80	; 0x50
 800900c:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009010:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8009014:	f101 0450 	add.w	r4, r1, #80	; 0x50
 8009018:	01d8      	lsls	r0, r3, #7
 800901a:	0e51      	lsrs	r1, r2, #25
 800901c:	4301      	orrs	r1, r0
 800901e:	6539      	str	r1, [r7, #80]	; 0x50
 8009020:	01d1      	lsls	r1, r2, #7
 8009022:	0e5b      	lsrs	r3, r3, #25
 8009024:	430b      	orrs	r3, r1
 8009026:	657b      	str	r3, [r7, #84]	; 0x54
 8009028:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 800902c:	e9c4 2308 	strd	r2, r3, [r4, #32]

   a[3][0] = KECCAK_ROL(a[3][0], 105 % KECCAK_W);
 8009030:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009034:	3378      	adds	r3, #120	; 0x78
 8009036:	e9d3 2300 	ldrd	r2, r3, [r3]
 800903a:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 800903e:	f101 0478 	add.w	r4, r1, #120	; 0x78
 8009042:	0258      	lsls	r0, r3, #9
 8009044:	0dd1      	lsrs	r1, r2, #23
 8009046:	4301      	orrs	r1, r0
 8009048:	64b9      	str	r1, [r7, #72]	; 0x48
 800904a:	0251      	lsls	r1, r2, #9
 800904c:	0ddb      	lsrs	r3, r3, #23
 800904e:	430b      	orrs	r3, r1
 8009050:	64fb      	str	r3, [r7, #76]	; 0x4c
 8009052:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8009056:	e9c4 2300 	strd	r2, r3, [r4]
   a[3][1] = KECCAK_ROL(a[3][1], 45  % KECCAK_W);
 800905a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800905e:	3378      	adds	r3, #120	; 0x78
 8009060:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009064:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8009068:	f101 0478 	add.w	r4, r1, #120	; 0x78
 800906c:	0358      	lsls	r0, r3, #13
 800906e:	0cd1      	lsrs	r1, r2, #19
 8009070:	4301      	orrs	r1, r0
 8009072:	6439      	str	r1, [r7, #64]	; 0x40
 8009074:	0351      	lsls	r1, r2, #13
 8009076:	0cdb      	lsrs	r3, r3, #19
 8009078:	430b      	orrs	r3, r1
 800907a:	647b      	str	r3, [r7, #68]	; 0x44
 800907c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8009080:	e9c4 2302 	strd	r2, r3, [r4, #8]
   a[3][2] = KECCAK_ROL(a[3][2], 15  % KECCAK_W);
 8009084:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009088:	3378      	adds	r3, #120	; 0x78
 800908a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800908e:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8009092:	f101 0478 	add.w	r4, r1, #120	; 0x78
 8009096:	0c50      	lsrs	r0, r2, #17
 8009098:	03d9      	lsls	r1, r3, #15
 800909a:	4301      	orrs	r1, r0
 800909c:	63f9      	str	r1, [r7, #60]	; 0x3c
 800909e:	0c59      	lsrs	r1, r3, #17
 80090a0:	03d3      	lsls	r3, r2, #15
 80090a2:	430b      	orrs	r3, r1
 80090a4:	63bb      	str	r3, [r7, #56]	; 0x38
 80090a6:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80090aa:	e9c4 2304 	strd	r2, r3, [r4, #16]
   a[3][3] = KECCAK_ROL(a[3][3], 21  % KECCAK_W);
 80090ae:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80090b2:	3378      	adds	r3, #120	; 0x78
 80090b4:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80090b8:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 80090bc:	f101 0478 	add.w	r4, r1, #120	; 0x78
 80090c0:	0ad0      	lsrs	r0, r2, #11
 80090c2:	0559      	lsls	r1, r3, #21
 80090c4:	4301      	orrs	r1, r0
 80090c6:	6379      	str	r1, [r7, #52]	; 0x34
 80090c8:	0ad9      	lsrs	r1, r3, #11
 80090ca:	0553      	lsls	r3, r2, #21
 80090cc:	430b      	orrs	r3, r1
 80090ce:	633b      	str	r3, [r7, #48]	; 0x30
 80090d0:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 80090d4:	e9c4 2306 	strd	r2, r3, [r4, #24]
   a[3][4] = KECCAK_ROL(a[3][4], 136 % KECCAK_W);
 80090d8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80090dc:	3378      	adds	r3, #120	; 0x78
 80090de:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80090e2:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 80090e6:	f101 0478 	add.w	r4, r1, #120	; 0x78
 80090ea:	0e10      	lsrs	r0, r2, #24
 80090ec:	0219      	lsls	r1, r3, #8
 80090ee:	4301      	orrs	r1, r0
 80090f0:	62f9      	str	r1, [r7, #44]	; 0x2c
 80090f2:	0e19      	lsrs	r1, r3, #24
 80090f4:	0213      	lsls	r3, r2, #8
 80090f6:	430b      	orrs	r3, r1
 80090f8:	62bb      	str	r3, [r7, #40]	; 0x28
 80090fa:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 80090fe:	e9c4 2308 	strd	r2, r3, [r4, #32]

   a[4][0] = KECCAK_ROL(a[4][0], 210 % KECCAK_W);
 8009102:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009106:	33a0      	adds	r3, #160	; 0xa0
 8009108:	e9d3 2300 	ldrd	r2, r3, [r3]
 800910c:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8009110:	f101 00a0 	add.w	r0, r1, #160	; 0xa0
 8009114:	0b94      	lsrs	r4, r2, #14
 8009116:	0499      	lsls	r1, r3, #18
 8009118:	4321      	orrs	r1, r4
 800911a:	6279      	str	r1, [r7, #36]	; 0x24
 800911c:	0b99      	lsrs	r1, r3, #14
 800911e:	0493      	lsls	r3, r2, #18
 8009120:	430b      	orrs	r3, r1
 8009122:	623b      	str	r3, [r7, #32]
 8009124:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 8009128:	e9c0 3400 	strd	r3, r4, [r0]
   a[4][1] = KECCAK_ROL(a[4][1], 66  % KECCAK_W);
 800912c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009130:	33a0      	adds	r3, #160	; 0xa0
 8009132:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009136:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 800913a:	31a0      	adds	r1, #160	; 0xa0
 800913c:	0f94      	lsrs	r4, r2, #30
 800913e:	0098      	lsls	r0, r3, #2
 8009140:	4320      	orrs	r0, r4
 8009142:	61f8      	str	r0, [r7, #28]
 8009144:	0f98      	lsrs	r0, r3, #30
 8009146:	0093      	lsls	r3, r2, #2
 8009148:	4303      	orrs	r3, r0
 800914a:	61bb      	str	r3, [r7, #24]
 800914c:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8009150:	e9c1 3402 	strd	r3, r4, [r1, #8]
   a[4][2] = KECCAK_ROL(a[4][2], 253 % KECCAK_W);
 8009154:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009158:	33a0      	adds	r3, #160	; 0xa0
 800915a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800915e:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8009162:	31a0      	adds	r1, #160	; 0xa0
 8009164:	075c      	lsls	r4, r3, #29
 8009166:	08d0      	lsrs	r0, r2, #3
 8009168:	4320      	orrs	r0, r4
 800916a:	6138      	str	r0, [r7, #16]
 800916c:	0750      	lsls	r0, r2, #29
 800916e:	08db      	lsrs	r3, r3, #3
 8009170:	4303      	orrs	r3, r0
 8009172:	617b      	str	r3, [r7, #20]
 8009174:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8009178:	e9c1 3404 	strd	r3, r4, [r1, #16]
   a[4][3] = KECCAK_ROL(a[4][3], 120 % KECCAK_W);
 800917c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8009180:	33a0      	adds	r3, #160	; 0xa0
 8009182:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009186:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 800918a:	31a0      	adds	r1, #160	; 0xa0
 800918c:	061c      	lsls	r4, r3, #24
 800918e:	0a10      	lsrs	r0, r2, #8
 8009190:	4320      	orrs	r0, r4
 8009192:	60b8      	str	r0, [r7, #8]
 8009194:	0610      	lsls	r0, r2, #24
 8009196:	0a1b      	lsrs	r3, r3, #8
 8009198:	4303      	orrs	r3, r0
 800919a:	60fb      	str	r3, [r7, #12]
 800919c:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 80091a0:	e9c1 3406 	strd	r3, r4, [r1, #24]
   a[4][4] = KECCAK_ROL(a[4][4], 78  % KECCAK_W);
 80091a4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80091a8:	33a0      	adds	r3, #160	; 0xa0
 80091aa:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80091ae:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 80091b2:	31a0      	adds	r1, #160	; 0xa0
 80091b4:	0c94      	lsrs	r4, r2, #18
 80091b6:	0398      	lsls	r0, r3, #14
 80091b8:	4320      	orrs	r0, r4
 80091ba:	6078      	str	r0, [r7, #4]
 80091bc:	0c98      	lsrs	r0, r3, #18
 80091be:	0393      	lsls	r3, r2, #14
 80091c0:	4303      	orrs	r3, r0
 80091c2:	603b      	str	r3, [r7, #0]
 80091c4:	e9d7 3400 	ldrd	r3, r4, [r7]
 80091c8:	e9c1 3408 	strd	r3, r4, [r1, #32]
}
 80091cc:	bf00      	nop
 80091ce:	37b4      	adds	r7, #180	; 0xb4
 80091d0:	46bd      	mov	sp, r7
 80091d2:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 80091d6:	4770      	bx	lr

080091d8 <pi>:
 * @brief Apply pi transformation
 * @param[in,out] a State array
 **/

static void pi(keccak_lane_t a[5][5])
{
 80091d8:	b480      	push	{r7}
 80091da:	b085      	sub	sp, #20
 80091dc:	af00      	add	r7, sp, #0
 80091de:	6078      	str	r0, [r7, #4]
   keccak_lane_t temp;

   //The effect of the pi transformation is to rearrange the positions of
   //the lanes
   temp = a[0][1];
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80091e6:	e9c7 2302 	strd	r2, r3, [r7, #8]
   a[0][1] = a[1][1];
 80091ea:	687b      	ldr	r3, [r7, #4]
 80091ec:	3328      	adds	r3, #40	; 0x28
 80091ee:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80091f2:	6879      	ldr	r1, [r7, #4]
 80091f4:	e9c1 2302 	strd	r2, r3, [r1, #8]
   a[1][1] = a[1][4];
 80091f8:	687b      	ldr	r3, [r7, #4]
 80091fa:	3328      	adds	r3, #40	; 0x28
 80091fc:	687a      	ldr	r2, [r7, #4]
 80091fe:	f102 0128 	add.w	r1, r2, #40	; 0x28
 8009202:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009206:	e9c1 2302 	strd	r2, r3, [r1, #8]
   a[1][4] = a[4][2];
 800920a:	687b      	ldr	r3, [r7, #4]
 800920c:	33a0      	adds	r3, #160	; 0xa0
 800920e:	687a      	ldr	r2, [r7, #4]
 8009210:	f102 0128 	add.w	r1, r2, #40	; 0x28
 8009214:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009218:	e9c1 2308 	strd	r2, r3, [r1, #32]
   a[4][2] = a[2][4];
 800921c:	687b      	ldr	r3, [r7, #4]
 800921e:	3350      	adds	r3, #80	; 0x50
 8009220:	687a      	ldr	r2, [r7, #4]
 8009222:	f102 01a0 	add.w	r1, r2, #160	; 0xa0
 8009226:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800922a:	e9c1 2304 	strd	r2, r3, [r1, #16]
   a[2][4] = a[4][0];
 800922e:	687b      	ldr	r3, [r7, #4]
 8009230:	33a0      	adds	r3, #160	; 0xa0
 8009232:	687a      	ldr	r2, [r7, #4]
 8009234:	f102 0150 	add.w	r1, r2, #80	; 0x50
 8009238:	e9d3 2300 	ldrd	r2, r3, [r3]
 800923c:	e9c1 2308 	strd	r2, r3, [r1, #32]
   a[4][0] = a[0][2];
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	f103 01a0 	add.w	r1, r3, #160	; 0xa0
 8009246:	687b      	ldr	r3, [r7, #4]
 8009248:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800924c:	e9c1 2300 	strd	r2, r3, [r1]
   a[0][2] = a[2][2];
 8009250:	687b      	ldr	r3, [r7, #4]
 8009252:	3350      	adds	r3, #80	; 0x50
 8009254:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009258:	6879      	ldr	r1, [r7, #4]
 800925a:	e9c1 2304 	strd	r2, r3, [r1, #16]
   a[2][2] = a[2][3];
 800925e:	687b      	ldr	r3, [r7, #4]
 8009260:	3350      	adds	r3, #80	; 0x50
 8009262:	687a      	ldr	r2, [r7, #4]
 8009264:	f102 0150 	add.w	r1, r2, #80	; 0x50
 8009268:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800926c:	e9c1 2304 	strd	r2, r3, [r1, #16]
   a[2][3] = a[3][4];
 8009270:	687b      	ldr	r3, [r7, #4]
 8009272:	3378      	adds	r3, #120	; 0x78
 8009274:	687a      	ldr	r2, [r7, #4]
 8009276:	f102 0150 	add.w	r1, r2, #80	; 0x50
 800927a:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800927e:	e9c1 2306 	strd	r2, r3, [r1, #24]
   a[3][4] = a[4][3];
 8009282:	687b      	ldr	r3, [r7, #4]
 8009284:	33a0      	adds	r3, #160	; 0xa0
 8009286:	687a      	ldr	r2, [r7, #4]
 8009288:	f102 0178 	add.w	r1, r2, #120	; 0x78
 800928c:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009290:	e9c1 2308 	strd	r2, r3, [r1, #32]
   a[4][3] = a[3][0];
 8009294:	687b      	ldr	r3, [r7, #4]
 8009296:	3378      	adds	r3, #120	; 0x78
 8009298:	687a      	ldr	r2, [r7, #4]
 800929a:	f102 01a0 	add.w	r1, r2, #160	; 0xa0
 800929e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80092a2:	e9c1 2306 	strd	r2, r3, [r1, #24]
   a[3][0] = a[0][4];
 80092a6:	687b      	ldr	r3, [r7, #4]
 80092a8:	f103 0178 	add.w	r1, r3, #120	; 0x78
 80092ac:	687b      	ldr	r3, [r7, #4]
 80092ae:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80092b2:	e9c1 2300 	strd	r2, r3, [r1]
   a[0][4] = a[4][4];
 80092b6:	687b      	ldr	r3, [r7, #4]
 80092b8:	33a0      	adds	r3, #160	; 0xa0
 80092ba:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80092be:	6879      	ldr	r1, [r7, #4]
 80092c0:	e9c1 2308 	strd	r2, r3, [r1, #32]
   a[4][4] = a[4][1];
 80092c4:	687b      	ldr	r3, [r7, #4]
 80092c6:	33a0      	adds	r3, #160	; 0xa0
 80092c8:	687a      	ldr	r2, [r7, #4]
 80092ca:	f102 01a0 	add.w	r1, r2, #160	; 0xa0
 80092ce:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80092d2:	e9c1 2308 	strd	r2, r3, [r1, #32]
   a[4][1] = a[1][3];
 80092d6:	687b      	ldr	r3, [r7, #4]
 80092d8:	3328      	adds	r3, #40	; 0x28
 80092da:	687a      	ldr	r2, [r7, #4]
 80092dc:	f102 01a0 	add.w	r1, r2, #160	; 0xa0
 80092e0:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80092e4:	e9c1 2302 	strd	r2, r3, [r1, #8]
   a[1][3] = a[3][1];
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	3378      	adds	r3, #120	; 0x78
 80092ec:	687a      	ldr	r2, [r7, #4]
 80092ee:	f102 0128 	add.w	r1, r2, #40	; 0x28
 80092f2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80092f6:	e9c1 2306 	strd	r2, r3, [r1, #24]
   a[3][1] = a[1][0];
 80092fa:	687b      	ldr	r3, [r7, #4]
 80092fc:	3328      	adds	r3, #40	; 0x28
 80092fe:	687a      	ldr	r2, [r7, #4]
 8009300:	f102 0178 	add.w	r1, r2, #120	; 0x78
 8009304:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009308:	e9c1 2302 	strd	r2, r3, [r1, #8]
   a[1][0] = a[0][3];
 800930c:	687b      	ldr	r3, [r7, #4]
 800930e:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8009312:	687b      	ldr	r3, [r7, #4]
 8009314:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009318:	e9c1 2300 	strd	r2, r3, [r1]
   a[0][3] = a[3][3];
 800931c:	687b      	ldr	r3, [r7, #4]
 800931e:	3378      	adds	r3, #120	; 0x78
 8009320:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009324:	6879      	ldr	r1, [r7, #4]
 8009326:	e9c1 2306 	strd	r2, r3, [r1, #24]
   a[3][3] = a[3][2];
 800932a:	687b      	ldr	r3, [r7, #4]
 800932c:	3378      	adds	r3, #120	; 0x78
 800932e:	687a      	ldr	r2, [r7, #4]
 8009330:	f102 0178 	add.w	r1, r2, #120	; 0x78
 8009334:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009338:	e9c1 2306 	strd	r2, r3, [r1, #24]
   a[3][2] = a[2][1];
 800933c:	687b      	ldr	r3, [r7, #4]
 800933e:	3350      	adds	r3, #80	; 0x50
 8009340:	687a      	ldr	r2, [r7, #4]
 8009342:	f102 0178 	add.w	r1, r2, #120	; 0x78
 8009346:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800934a:	e9c1 2304 	strd	r2, r3, [r1, #16]
   a[2][1] = a[1][2];
 800934e:	687b      	ldr	r3, [r7, #4]
 8009350:	3328      	adds	r3, #40	; 0x28
 8009352:	687a      	ldr	r2, [r7, #4]
 8009354:	f102 0150 	add.w	r1, r2, #80	; 0x50
 8009358:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800935c:	e9c1 2302 	strd	r2, r3, [r1, #8]
   a[1][2] = a[2][0];
 8009360:	687b      	ldr	r3, [r7, #4]
 8009362:	3350      	adds	r3, #80	; 0x50
 8009364:	687a      	ldr	r2, [r7, #4]
 8009366:	f102 0128 	add.w	r1, r2, #40	; 0x28
 800936a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800936e:	e9c1 2304 	strd	r2, r3, [r1, #16]
   a[2][0] = temp;
 8009372:	687b      	ldr	r3, [r7, #4]
 8009374:	f103 0150 	add.w	r1, r3, #80	; 0x50
 8009378:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800937c:	e9c1 2300 	strd	r2, r3, [r1]
}
 8009380:	bf00      	nop
 8009382:	3714      	adds	r7, #20
 8009384:	46bd      	mov	sp, r7
 8009386:	f85d 7b04 	ldr.w	r7, [sp], #4
 800938a:	4770      	bx	lr

0800938c <chi>:
 * @brief Apply chi transformation
 * @param[in,out] a State array
 **/

static void chi(keccak_lane_t a[5][5])
{
 800938c:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8009390:	f5ad 7d17 	sub.w	sp, sp, #604	; 0x25c
 8009394:	af00      	add	r7, sp, #0
 8009396:	f8c7 0244 	str.w	r0, [r7, #580]	; 0x244
   keccak_lane_t temp1;
   keccak_lane_t temp2;

   //The effect of the chi transformation is to XOR each bit with a non
   //linear function of two other bits in its row
   temp1 = a[0][0];
 800939a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800939e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80093a2:	e9c7 2394 	strd	r2, r3, [r7, #592]	; 0x250
   temp2 = a[0][1];
 80093a6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093aa:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80093ae:	e9c7 2392 	strd	r2, r3, [r7, #584]	; 0x248
   a[0][0] ^= ~a[0][1] & a[0][2];
 80093b2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093b6:	e9d3 0100 	ldrd	r0, r1, [r3]
 80093ba:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80093c2:	ea6f 0802 	mvn.w	r8, r2
 80093c6:	ea6f 0903 	mvn.w	r9, r3
 80093ca:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093ce:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80093d2:	ea08 0402 	and.w	r4, r8, r2
 80093d6:	ea09 0503 	and.w	r5, r9, r3
 80093da:	ea80 0304 	eor.w	r3, r0, r4
 80093de:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
 80093e2:	ea81 0305 	eor.w	r3, r1, r5
 80093e6:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
 80093ea:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093ee:	e9d7 128e 	ldrd	r1, r2, [r7, #568]	; 0x238
 80093f2:	e9c3 1200 	strd	r1, r2, [r3]
   a[0][1] ^= ~a[0][2] & a[0][3];
 80093f6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80093fa:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80093fe:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009402:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009406:	43d4      	mvns	r4, r2
 8009408:	f8c7 4230 	str.w	r4, [r7, #560]	; 0x230
 800940c:	43db      	mvns	r3, r3
 800940e:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 8009412:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009416:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800941a:	e9d7 898c 	ldrd	r8, r9, [r7, #560]	; 0x230
 800941e:	4644      	mov	r4, r8
 8009420:	ea04 0a02 	and.w	sl, r4, r2
 8009424:	464c      	mov	r4, r9
 8009426:	ea04 0b03 	and.w	fp, r4, r3
 800942a:	ea80 030a 	eor.w	r3, r0, sl
 800942e:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
 8009432:	ea81 030b 	eor.w	r3, r1, fp
 8009436:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
 800943a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800943e:	e9d7 128a 	ldrd	r1, r2, [r7, #552]	; 0x228
 8009442:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[0][2] ^= ~a[0][3] & a[0][4];
 8009446:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800944a:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800944e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009452:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009456:	43d4      	mvns	r4, r2
 8009458:	f8c7 4220 	str.w	r4, [r7, #544]	; 0x220
 800945c:	43db      	mvns	r3, r3
 800945e:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
 8009462:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009466:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800946a:	e9d7 8988 	ldrd	r8, r9, [r7, #544]	; 0x220
 800946e:	4644      	mov	r4, r8
 8009470:	4014      	ands	r4, r2
 8009472:	f8c7 4218 	str.w	r4, [r7, #536]	; 0x218
 8009476:	464c      	mov	r4, r9
 8009478:	401c      	ands	r4, r3
 800947a:	f8c7 421c 	str.w	r4, [r7, #540]	; 0x21c
 800947e:	e9d7 4586 	ldrd	r4, r5, [r7, #536]	; 0x218
 8009482:	4623      	mov	r3, r4
 8009484:	4043      	eors	r3, r0
 8009486:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
 800948a:	462b      	mov	r3, r5
 800948c:	404b      	eors	r3, r1
 800948e:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
 8009492:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009496:	e9d7 1284 	ldrd	r1, r2, [r7, #528]	; 0x210
 800949a:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[0][3] ^= ~a[0][4] & temp1;
 800949e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80094a2:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 80094a6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80094aa:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80094ae:	43d4      	mvns	r4, r2
 80094b0:	f8c7 4208 	str.w	r4, [r7, #520]	; 0x208
 80094b4:	43db      	mvns	r3, r3
 80094b6:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
 80094ba:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 80094be:	e9d7 8982 	ldrd	r8, r9, [r7, #520]	; 0x208
 80094c2:	4644      	mov	r4, r8
 80094c4:	4014      	ands	r4, r2
 80094c6:	f8c7 4200 	str.w	r4, [r7, #512]	; 0x200
 80094ca:	464c      	mov	r4, r9
 80094cc:	401c      	ands	r4, r3
 80094ce:	f8c7 4204 	str.w	r4, [r7, #516]	; 0x204
 80094d2:	e9d7 4580 	ldrd	r4, r5, [r7, #512]	; 0x200
 80094d6:	4623      	mov	r3, r4
 80094d8:	4043      	eors	r3, r0
 80094da:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8
 80094de:	462b      	mov	r3, r5
 80094e0:	404b      	eors	r3, r1
 80094e2:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
 80094e6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80094ea:	e9d7 127e 	ldrd	r1, r2, [r7, #504]	; 0x1f8
 80094ee:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[0][4] ^= ~temp1 & temp2;
 80094f2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80094f6:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 80094fa:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 80094fe:	43d4      	mvns	r4, r2
 8009500:	f8c7 41f0 	str.w	r4, [r7, #496]	; 0x1f0
 8009504:	43db      	mvns	r3, r3
 8009506:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
 800950a:	e9d7 2392 	ldrd	r2, r3, [r7, #584]	; 0x248
 800950e:	e9d7 897c 	ldrd	r8, r9, [r7, #496]	; 0x1f0
 8009512:	4644      	mov	r4, r8
 8009514:	4014      	ands	r4, r2
 8009516:	f8c7 41e8 	str.w	r4, [r7, #488]	; 0x1e8
 800951a:	464c      	mov	r4, r9
 800951c:	401c      	ands	r4, r3
 800951e:	f8c7 41ec 	str.w	r4, [r7, #492]	; 0x1ec
 8009522:	e9d7 457a 	ldrd	r4, r5, [r7, #488]	; 0x1e8
 8009526:	4623      	mov	r3, r4
 8009528:	4043      	eors	r3, r0
 800952a:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
 800952e:	462b      	mov	r3, r5
 8009530:	404b      	eors	r3, r1
 8009532:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
 8009536:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800953a:	e9d7 1278 	ldrd	r1, r2, [r7, #480]	; 0x1e0
 800953e:	e9c3 1208 	strd	r1, r2, [r3, #32]

   temp1 = a[1][0];
 8009542:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009546:	3328      	adds	r3, #40	; 0x28
 8009548:	e9d3 2300 	ldrd	r2, r3, [r3]
 800954c:	e9c7 2394 	strd	r2, r3, [r7, #592]	; 0x250
   temp2 = a[1][1];
 8009550:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009554:	3328      	adds	r3, #40	; 0x28
 8009556:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800955a:	e9c7 2392 	strd	r2, r3, [r7, #584]	; 0x248
   a[1][0] ^= ~a[1][1] & a[1][2];
 800955e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009562:	3328      	adds	r3, #40	; 0x28
 8009564:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009568:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800956c:	3328      	adds	r3, #40	; 0x28
 800956e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009572:	43d4      	mvns	r4, r2
 8009574:	f8c7 41d8 	str.w	r4, [r7, #472]	; 0x1d8
 8009578:	43db      	mvns	r3, r3
 800957a:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
 800957e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009582:	3328      	adds	r3, #40	; 0x28
 8009584:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009588:	e9d7 8976 	ldrd	r8, r9, [r7, #472]	; 0x1d8
 800958c:	4644      	mov	r4, r8
 800958e:	4014      	ands	r4, r2
 8009590:	f8c7 41d0 	str.w	r4, [r7, #464]	; 0x1d0
 8009594:	464c      	mov	r4, r9
 8009596:	401c      	ands	r4, r3
 8009598:	f8c7 41d4 	str.w	r4, [r7, #468]	; 0x1d4
 800959c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80095a0:	3328      	adds	r3, #40	; 0x28
 80095a2:	e9d7 4574 	ldrd	r4, r5, [r7, #464]	; 0x1d0
 80095a6:	4622      	mov	r2, r4
 80095a8:	4042      	eors	r2, r0
 80095aa:	f8c7 21c8 	str.w	r2, [r7, #456]	; 0x1c8
 80095ae:	462a      	mov	r2, r5
 80095b0:	404a      	eors	r2, r1
 80095b2:	f8c7 21cc 	str.w	r2, [r7, #460]	; 0x1cc
 80095b6:	e9d7 1272 	ldrd	r1, r2, [r7, #456]	; 0x1c8
 80095ba:	e9c3 1200 	strd	r1, r2, [r3]
   a[1][1] ^= ~a[1][2] & a[1][3];
 80095be:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80095c2:	3328      	adds	r3, #40	; 0x28
 80095c4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80095c8:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80095cc:	3328      	adds	r3, #40	; 0x28
 80095ce:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80095d2:	43d4      	mvns	r4, r2
 80095d4:	f8c7 41c0 	str.w	r4, [r7, #448]	; 0x1c0
 80095d8:	43db      	mvns	r3, r3
 80095da:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
 80095de:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80095e2:	3328      	adds	r3, #40	; 0x28
 80095e4:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80095e8:	e9d7 8970 	ldrd	r8, r9, [r7, #448]	; 0x1c0
 80095ec:	4644      	mov	r4, r8
 80095ee:	4014      	ands	r4, r2
 80095f0:	f8c7 41b8 	str.w	r4, [r7, #440]	; 0x1b8
 80095f4:	464c      	mov	r4, r9
 80095f6:	401c      	ands	r4, r3
 80095f8:	f8c7 41bc 	str.w	r4, [r7, #444]	; 0x1bc
 80095fc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009600:	3328      	adds	r3, #40	; 0x28
 8009602:	e9d7 456e 	ldrd	r4, r5, [r7, #440]	; 0x1b8
 8009606:	4622      	mov	r2, r4
 8009608:	4042      	eors	r2, r0
 800960a:	f8c7 21b0 	str.w	r2, [r7, #432]	; 0x1b0
 800960e:	462a      	mov	r2, r5
 8009610:	404a      	eors	r2, r1
 8009612:	f8c7 21b4 	str.w	r2, [r7, #436]	; 0x1b4
 8009616:	e9d7 126c 	ldrd	r1, r2, [r7, #432]	; 0x1b0
 800961a:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[1][2] ^= ~a[1][3] & a[1][4];
 800961e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009622:	3328      	adds	r3, #40	; 0x28
 8009624:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8009628:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800962c:	3328      	adds	r3, #40	; 0x28
 800962e:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009632:	43d4      	mvns	r4, r2
 8009634:	f8c7 41a8 	str.w	r4, [r7, #424]	; 0x1a8
 8009638:	43db      	mvns	r3, r3
 800963a:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 800963e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009642:	3328      	adds	r3, #40	; 0x28
 8009644:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009648:	e9d7 896a 	ldrd	r8, r9, [r7, #424]	; 0x1a8
 800964c:	4644      	mov	r4, r8
 800964e:	4014      	ands	r4, r2
 8009650:	f8c7 41a0 	str.w	r4, [r7, #416]	; 0x1a0
 8009654:	464c      	mov	r4, r9
 8009656:	401c      	ands	r4, r3
 8009658:	f8c7 41a4 	str.w	r4, [r7, #420]	; 0x1a4
 800965c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009660:	3328      	adds	r3, #40	; 0x28
 8009662:	e9d7 4568 	ldrd	r4, r5, [r7, #416]	; 0x1a0
 8009666:	4622      	mov	r2, r4
 8009668:	4042      	eors	r2, r0
 800966a:	f8c7 2198 	str.w	r2, [r7, #408]	; 0x198
 800966e:	462a      	mov	r2, r5
 8009670:	404a      	eors	r2, r1
 8009672:	f8c7 219c 	str.w	r2, [r7, #412]	; 0x19c
 8009676:	e9d7 1266 	ldrd	r1, r2, [r7, #408]	; 0x198
 800967a:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[1][3] ^= ~a[1][4] & temp1;
 800967e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009682:	3328      	adds	r3, #40	; 0x28
 8009684:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8009688:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800968c:	3328      	adds	r3, #40	; 0x28
 800968e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009692:	43d4      	mvns	r4, r2
 8009694:	f8c7 4190 	str.w	r4, [r7, #400]	; 0x190
 8009698:	43db      	mvns	r3, r3
 800969a:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 800969e:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 80096a2:	e9d7 8964 	ldrd	r8, r9, [r7, #400]	; 0x190
 80096a6:	4644      	mov	r4, r8
 80096a8:	4014      	ands	r4, r2
 80096aa:	f8c7 4188 	str.w	r4, [r7, #392]	; 0x188
 80096ae:	464c      	mov	r4, r9
 80096b0:	401c      	ands	r4, r3
 80096b2:	f8c7 418c 	str.w	r4, [r7, #396]	; 0x18c
 80096b6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80096ba:	3328      	adds	r3, #40	; 0x28
 80096bc:	e9d7 4562 	ldrd	r4, r5, [r7, #392]	; 0x188
 80096c0:	4622      	mov	r2, r4
 80096c2:	4042      	eors	r2, r0
 80096c4:	f8c7 2180 	str.w	r2, [r7, #384]	; 0x180
 80096c8:	462a      	mov	r2, r5
 80096ca:	404a      	eors	r2, r1
 80096cc:	f8c7 2184 	str.w	r2, [r7, #388]	; 0x184
 80096d0:	e9d7 1260 	ldrd	r1, r2, [r7, #384]	; 0x180
 80096d4:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[1][4] ^= ~temp1 & temp2;
 80096d8:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80096dc:	3328      	adds	r3, #40	; 0x28
 80096de:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 80096e2:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 80096e6:	43d4      	mvns	r4, r2
 80096e8:	f8c7 4178 	str.w	r4, [r7, #376]	; 0x178
 80096ec:	43db      	mvns	r3, r3
 80096ee:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 80096f2:	e9d7 2392 	ldrd	r2, r3, [r7, #584]	; 0x248
 80096f6:	e9d7 895e 	ldrd	r8, r9, [r7, #376]	; 0x178
 80096fa:	4644      	mov	r4, r8
 80096fc:	4014      	ands	r4, r2
 80096fe:	f8c7 4170 	str.w	r4, [r7, #368]	; 0x170
 8009702:	464c      	mov	r4, r9
 8009704:	401c      	ands	r4, r3
 8009706:	f8c7 4174 	str.w	r4, [r7, #372]	; 0x174
 800970a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800970e:	3328      	adds	r3, #40	; 0x28
 8009710:	e9d7 455c 	ldrd	r4, r5, [r7, #368]	; 0x170
 8009714:	4622      	mov	r2, r4
 8009716:	4042      	eors	r2, r0
 8009718:	f8c7 2168 	str.w	r2, [r7, #360]	; 0x168
 800971c:	462a      	mov	r2, r5
 800971e:	404a      	eors	r2, r1
 8009720:	f8c7 216c 	str.w	r2, [r7, #364]	; 0x16c
 8009724:	e9d7 125a 	ldrd	r1, r2, [r7, #360]	; 0x168
 8009728:	e9c3 1208 	strd	r1, r2, [r3, #32]

   temp1 = a[2][0];
 800972c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009730:	3350      	adds	r3, #80	; 0x50
 8009732:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009736:	e9c7 2394 	strd	r2, r3, [r7, #592]	; 0x250
   temp2 = a[2][1];
 800973a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800973e:	3350      	adds	r3, #80	; 0x50
 8009740:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009744:	e9c7 2392 	strd	r2, r3, [r7, #584]	; 0x248
   a[2][0] ^= ~a[2][1] & a[2][2];
 8009748:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800974c:	3350      	adds	r3, #80	; 0x50
 800974e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009752:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009756:	3350      	adds	r3, #80	; 0x50
 8009758:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800975c:	43d4      	mvns	r4, r2
 800975e:	f8c7 4160 	str.w	r4, [r7, #352]	; 0x160
 8009762:	43db      	mvns	r3, r3
 8009764:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 8009768:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800976c:	3350      	adds	r3, #80	; 0x50
 800976e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009772:	e9d7 8958 	ldrd	r8, r9, [r7, #352]	; 0x160
 8009776:	4644      	mov	r4, r8
 8009778:	4014      	ands	r4, r2
 800977a:	f8c7 4158 	str.w	r4, [r7, #344]	; 0x158
 800977e:	464c      	mov	r4, r9
 8009780:	401c      	ands	r4, r3
 8009782:	f8c7 415c 	str.w	r4, [r7, #348]	; 0x15c
 8009786:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800978a:	3350      	adds	r3, #80	; 0x50
 800978c:	e9d7 4556 	ldrd	r4, r5, [r7, #344]	; 0x158
 8009790:	4622      	mov	r2, r4
 8009792:	4042      	eors	r2, r0
 8009794:	f8c7 2150 	str.w	r2, [r7, #336]	; 0x150
 8009798:	462a      	mov	r2, r5
 800979a:	404a      	eors	r2, r1
 800979c:	f8c7 2154 	str.w	r2, [r7, #340]	; 0x154
 80097a0:	e9d7 1254 	ldrd	r1, r2, [r7, #336]	; 0x150
 80097a4:	e9c3 1200 	strd	r1, r2, [r3]
   a[2][1] ^= ~a[2][2] & a[2][3];
 80097a8:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80097ac:	3350      	adds	r3, #80	; 0x50
 80097ae:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80097b2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80097b6:	3350      	adds	r3, #80	; 0x50
 80097b8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80097bc:	43d4      	mvns	r4, r2
 80097be:	f8c7 4148 	str.w	r4, [r7, #328]	; 0x148
 80097c2:	43db      	mvns	r3, r3
 80097c4:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
 80097c8:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80097cc:	3350      	adds	r3, #80	; 0x50
 80097ce:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80097d2:	e9d7 8952 	ldrd	r8, r9, [r7, #328]	; 0x148
 80097d6:	4644      	mov	r4, r8
 80097d8:	4014      	ands	r4, r2
 80097da:	f8c7 4140 	str.w	r4, [r7, #320]	; 0x140
 80097de:	464c      	mov	r4, r9
 80097e0:	401c      	ands	r4, r3
 80097e2:	f8c7 4144 	str.w	r4, [r7, #324]	; 0x144
 80097e6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80097ea:	3350      	adds	r3, #80	; 0x50
 80097ec:	e9d7 4550 	ldrd	r4, r5, [r7, #320]	; 0x140
 80097f0:	4622      	mov	r2, r4
 80097f2:	4042      	eors	r2, r0
 80097f4:	f8c7 2138 	str.w	r2, [r7, #312]	; 0x138
 80097f8:	462a      	mov	r2, r5
 80097fa:	404a      	eors	r2, r1
 80097fc:	f8c7 213c 	str.w	r2, [r7, #316]	; 0x13c
 8009800:	e9d7 124e 	ldrd	r1, r2, [r7, #312]	; 0x138
 8009804:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[2][2] ^= ~a[2][3] & a[2][4];
 8009808:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800980c:	3350      	adds	r3, #80	; 0x50
 800980e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8009812:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009816:	3350      	adds	r3, #80	; 0x50
 8009818:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800981c:	43d4      	mvns	r4, r2
 800981e:	f8c7 4130 	str.w	r4, [r7, #304]	; 0x130
 8009822:	43db      	mvns	r3, r3
 8009824:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 8009828:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800982c:	3350      	adds	r3, #80	; 0x50
 800982e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009832:	e9d7 894c 	ldrd	r8, r9, [r7, #304]	; 0x130
 8009836:	4644      	mov	r4, r8
 8009838:	4014      	ands	r4, r2
 800983a:	f8c7 4128 	str.w	r4, [r7, #296]	; 0x128
 800983e:	464c      	mov	r4, r9
 8009840:	401c      	ands	r4, r3
 8009842:	f8c7 412c 	str.w	r4, [r7, #300]	; 0x12c
 8009846:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800984a:	3350      	adds	r3, #80	; 0x50
 800984c:	e9d7 454a 	ldrd	r4, r5, [r7, #296]	; 0x128
 8009850:	4622      	mov	r2, r4
 8009852:	4042      	eors	r2, r0
 8009854:	f8c7 2120 	str.w	r2, [r7, #288]	; 0x120
 8009858:	462a      	mov	r2, r5
 800985a:	404a      	eors	r2, r1
 800985c:	f8c7 2124 	str.w	r2, [r7, #292]	; 0x124
 8009860:	e9d7 1248 	ldrd	r1, r2, [r7, #288]	; 0x120
 8009864:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[2][3] ^= ~a[2][4] & temp1;
 8009868:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800986c:	3350      	adds	r3, #80	; 0x50
 800986e:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8009872:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009876:	3350      	adds	r3, #80	; 0x50
 8009878:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800987c:	43d4      	mvns	r4, r2
 800987e:	f8c7 4118 	str.w	r4, [r7, #280]	; 0x118
 8009882:	43db      	mvns	r3, r3
 8009884:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8009888:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 800988c:	e9d7 8946 	ldrd	r8, r9, [r7, #280]	; 0x118
 8009890:	4644      	mov	r4, r8
 8009892:	4014      	ands	r4, r2
 8009894:	f8c7 4110 	str.w	r4, [r7, #272]	; 0x110
 8009898:	464c      	mov	r4, r9
 800989a:	401c      	ands	r4, r3
 800989c:	f8c7 4114 	str.w	r4, [r7, #276]	; 0x114
 80098a0:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80098a4:	3350      	adds	r3, #80	; 0x50
 80098a6:	e9d7 4544 	ldrd	r4, r5, [r7, #272]	; 0x110
 80098aa:	4622      	mov	r2, r4
 80098ac:	4042      	eors	r2, r0
 80098ae:	f8c7 2108 	str.w	r2, [r7, #264]	; 0x108
 80098b2:	462a      	mov	r2, r5
 80098b4:	404a      	eors	r2, r1
 80098b6:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
 80098ba:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	; 0x108
 80098be:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[2][4] ^= ~temp1 & temp2;
 80098c2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80098c6:	3350      	adds	r3, #80	; 0x50
 80098c8:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 80098cc:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 80098d0:	43d4      	mvns	r4, r2
 80098d2:	f8c7 4100 	str.w	r4, [r7, #256]	; 0x100
 80098d6:	43db      	mvns	r3, r3
 80098d8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 80098dc:	e9d7 2392 	ldrd	r2, r3, [r7, #584]	; 0x248
 80098e0:	e9d7 8940 	ldrd	r8, r9, [r7, #256]	; 0x100
 80098e4:	4644      	mov	r4, r8
 80098e6:	4014      	ands	r4, r2
 80098e8:	f8c7 40f8 	str.w	r4, [r7, #248]	; 0xf8
 80098ec:	464c      	mov	r4, r9
 80098ee:	401c      	ands	r4, r3
 80098f0:	f8c7 40fc 	str.w	r4, [r7, #252]	; 0xfc
 80098f4:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80098f8:	3350      	adds	r3, #80	; 0x50
 80098fa:	e9d7 453e 	ldrd	r4, r5, [r7, #248]	; 0xf8
 80098fe:	4622      	mov	r2, r4
 8009900:	4042      	eors	r2, r0
 8009902:	f8c7 20f0 	str.w	r2, [r7, #240]	; 0xf0
 8009906:	462a      	mov	r2, r5
 8009908:	404a      	eors	r2, r1
 800990a:	f8c7 20f4 	str.w	r2, [r7, #244]	; 0xf4
 800990e:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	; 0xf0
 8009912:	e9c3 1208 	strd	r1, r2, [r3, #32]

   temp1 = a[3][0];
 8009916:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 800991a:	3378      	adds	r3, #120	; 0x78
 800991c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009920:	e9c7 2394 	strd	r2, r3, [r7, #592]	; 0x250
   temp2 = a[3][1];
 8009924:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009928:	3378      	adds	r3, #120	; 0x78
 800992a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800992e:	e9c7 2392 	strd	r2, r3, [r7, #584]	; 0x248
   a[3][0] ^= ~a[3][1] & a[3][2];
 8009932:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009936:	3378      	adds	r3, #120	; 0x78
 8009938:	e9d3 0100 	ldrd	r0, r1, [r3]
 800993c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009940:	3378      	adds	r3, #120	; 0x78
 8009942:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009946:	43d4      	mvns	r4, r2
 8009948:	f8c7 40e8 	str.w	r4, [r7, #232]	; 0xe8
 800994c:	43db      	mvns	r3, r3
 800994e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8009952:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009956:	3378      	adds	r3, #120	; 0x78
 8009958:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800995c:	e9d7 893a 	ldrd	r8, r9, [r7, #232]	; 0xe8
 8009960:	4644      	mov	r4, r8
 8009962:	4014      	ands	r4, r2
 8009964:	f8c7 40e0 	str.w	r4, [r7, #224]	; 0xe0
 8009968:	464c      	mov	r4, r9
 800996a:	401c      	ands	r4, r3
 800996c:	f8c7 40e4 	str.w	r4, [r7, #228]	; 0xe4
 8009970:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009974:	3378      	adds	r3, #120	; 0x78
 8009976:	e9d7 4538 	ldrd	r4, r5, [r7, #224]	; 0xe0
 800997a:	4622      	mov	r2, r4
 800997c:	4042      	eors	r2, r0
 800997e:	f8c7 20d8 	str.w	r2, [r7, #216]	; 0xd8
 8009982:	462a      	mov	r2, r5
 8009984:	404a      	eors	r2, r1
 8009986:	f8c7 20dc 	str.w	r2, [r7, #220]	; 0xdc
 800998a:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	; 0xd8
 800998e:	e9c3 1200 	strd	r1, r2, [r3]
   a[3][1] ^= ~a[3][2] & a[3][3];
 8009992:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009996:	3378      	adds	r3, #120	; 0x78
 8009998:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800999c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80099a0:	3378      	adds	r3, #120	; 0x78
 80099a2:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80099a6:	43d4      	mvns	r4, r2
 80099a8:	f8c7 40d0 	str.w	r4, [r7, #208]	; 0xd0
 80099ac:	43db      	mvns	r3, r3
 80099ae:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80099b2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80099b6:	3378      	adds	r3, #120	; 0x78
 80099b8:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80099bc:	e9d7 8934 	ldrd	r8, r9, [r7, #208]	; 0xd0
 80099c0:	4644      	mov	r4, r8
 80099c2:	4014      	ands	r4, r2
 80099c4:	f8c7 40c8 	str.w	r4, [r7, #200]	; 0xc8
 80099c8:	464c      	mov	r4, r9
 80099ca:	401c      	ands	r4, r3
 80099cc:	f8c7 40cc 	str.w	r4, [r7, #204]	; 0xcc
 80099d0:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80099d4:	3378      	adds	r3, #120	; 0x78
 80099d6:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	; 0xc8
 80099da:	4622      	mov	r2, r4
 80099dc:	4042      	eors	r2, r0
 80099de:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 80099e2:	462a      	mov	r2, r5
 80099e4:	404a      	eors	r2, r1
 80099e6:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 80099ea:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 80099ee:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[3][2] ^= ~a[3][3] & a[3][4];
 80099f2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80099f6:	3378      	adds	r3, #120	; 0x78
 80099f8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80099fc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a00:	3378      	adds	r3, #120	; 0x78
 8009a02:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009a06:	43d4      	mvns	r4, r2
 8009a08:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
 8009a0c:	43db      	mvns	r3, r3
 8009a0e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8009a12:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a16:	3378      	adds	r3, #120	; 0x78
 8009a18:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009a1c:	e9d7 892e 	ldrd	r8, r9, [r7, #184]	; 0xb8
 8009a20:	4644      	mov	r4, r8
 8009a22:	4014      	ands	r4, r2
 8009a24:	f8c7 40b0 	str.w	r4, [r7, #176]	; 0xb0
 8009a28:	464c      	mov	r4, r9
 8009a2a:	401c      	ands	r4, r3
 8009a2c:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
 8009a30:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a34:	3378      	adds	r3, #120	; 0x78
 8009a36:	e9d7 452c 	ldrd	r4, r5, [r7, #176]	; 0xb0
 8009a3a:	4622      	mov	r2, r4
 8009a3c:	4042      	eors	r2, r0
 8009a3e:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 8009a42:	462a      	mov	r2, r5
 8009a44:	404a      	eors	r2, r1
 8009a46:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
 8009a4a:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 8009a4e:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[3][3] ^= ~a[3][4] & temp1;
 8009a52:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a56:	3378      	adds	r3, #120	; 0x78
 8009a58:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8009a5c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a60:	3378      	adds	r3, #120	; 0x78
 8009a62:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009a66:	43d4      	mvns	r4, r2
 8009a68:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
 8009a6c:	43db      	mvns	r3, r3
 8009a6e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8009a72:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 8009a76:	e9d7 8928 	ldrd	r8, r9, [r7, #160]	; 0xa0
 8009a7a:	4644      	mov	r4, r8
 8009a7c:	4014      	ands	r4, r2
 8009a7e:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
 8009a82:	464c      	mov	r4, r9
 8009a84:	401c      	ands	r4, r3
 8009a86:	f8c7 409c 	str.w	r4, [r7, #156]	; 0x9c
 8009a8a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009a8e:	3378      	adds	r3, #120	; 0x78
 8009a90:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	; 0x98
 8009a94:	4622      	mov	r2, r4
 8009a96:	4042      	eors	r2, r0
 8009a98:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 8009a9c:	462a      	mov	r2, r5
 8009a9e:	404a      	eors	r2, r1
 8009aa0:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
 8009aa4:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
 8009aa8:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[3][4] ^= ~temp1 & temp2;
 8009aac:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009ab0:	3378      	adds	r3, #120	; 0x78
 8009ab2:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8009ab6:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 8009aba:	43d4      	mvns	r4, r2
 8009abc:	f8c7 4088 	str.w	r4, [r7, #136]	; 0x88
 8009ac0:	43db      	mvns	r3, r3
 8009ac2:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8009ac6:	e9d7 2392 	ldrd	r2, r3, [r7, #584]	; 0x248
 8009aca:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	; 0x88
 8009ace:	4644      	mov	r4, r8
 8009ad0:	4014      	ands	r4, r2
 8009ad2:	f8c7 4080 	str.w	r4, [r7, #128]	; 0x80
 8009ad6:	464c      	mov	r4, r9
 8009ad8:	401c      	ands	r4, r3
 8009ada:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
 8009ade:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009ae2:	3378      	adds	r3, #120	; 0x78
 8009ae4:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	; 0x80
 8009ae8:	4622      	mov	r2, r4
 8009aea:	4042      	eors	r2, r0
 8009aec:	67ba      	str	r2, [r7, #120]	; 0x78
 8009aee:	462a      	mov	r2, r5
 8009af0:	404a      	eors	r2, r1
 8009af2:	67fa      	str	r2, [r7, #124]	; 0x7c
 8009af4:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
 8009af8:	e9c3 1208 	strd	r1, r2, [r3, #32]

   temp1 = a[4][0];
 8009afc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b00:	33a0      	adds	r3, #160	; 0xa0
 8009b02:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009b06:	e9c7 2394 	strd	r2, r3, [r7, #592]	; 0x250
   temp2 = a[4][1];
 8009b0a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b0e:	33a0      	adds	r3, #160	; 0xa0
 8009b10:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009b14:	e9c7 2392 	strd	r2, r3, [r7, #584]	; 0x248
   a[4][0] ^= ~a[4][1] & a[4][2];
 8009b18:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b1c:	33a0      	adds	r3, #160	; 0xa0
 8009b1e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009b22:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b26:	33a0      	adds	r3, #160	; 0xa0
 8009b28:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009b2c:	43d4      	mvns	r4, r2
 8009b2e:	673c      	str	r4, [r7, #112]	; 0x70
 8009b30:	43db      	mvns	r3, r3
 8009b32:	677b      	str	r3, [r7, #116]	; 0x74
 8009b34:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b38:	33a0      	adds	r3, #160	; 0xa0
 8009b3a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009b3e:	e9d7 891c 	ldrd	r8, r9, [r7, #112]	; 0x70
 8009b42:	4644      	mov	r4, r8
 8009b44:	4014      	ands	r4, r2
 8009b46:	66bc      	str	r4, [r7, #104]	; 0x68
 8009b48:	464c      	mov	r4, r9
 8009b4a:	401c      	ands	r4, r3
 8009b4c:	66fc      	str	r4, [r7, #108]	; 0x6c
 8009b4e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b52:	33a0      	adds	r3, #160	; 0xa0
 8009b54:	e9d7 451a 	ldrd	r4, r5, [r7, #104]	; 0x68
 8009b58:	4622      	mov	r2, r4
 8009b5a:	4042      	eors	r2, r0
 8009b5c:	663a      	str	r2, [r7, #96]	; 0x60
 8009b5e:	462a      	mov	r2, r5
 8009b60:	404a      	eors	r2, r1
 8009b62:	667a      	str	r2, [r7, #100]	; 0x64
 8009b64:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
 8009b68:	e9c3 1200 	strd	r1, r2, [r3]
   a[4][1] ^= ~a[4][2] & a[4][3];
 8009b6c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b70:	33a0      	adds	r3, #160	; 0xa0
 8009b72:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8009b76:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b7a:	33a0      	adds	r3, #160	; 0xa0
 8009b7c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8009b80:	43d4      	mvns	r4, r2
 8009b82:	65bc      	str	r4, [r7, #88]	; 0x58
 8009b84:	43db      	mvns	r3, r3
 8009b86:	65fb      	str	r3, [r7, #92]	; 0x5c
 8009b88:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009b8c:	33a0      	adds	r3, #160	; 0xa0
 8009b8e:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009b92:	e9d7 8916 	ldrd	r8, r9, [r7, #88]	; 0x58
 8009b96:	4644      	mov	r4, r8
 8009b98:	4014      	ands	r4, r2
 8009b9a:	653c      	str	r4, [r7, #80]	; 0x50
 8009b9c:	464c      	mov	r4, r9
 8009b9e:	401c      	ands	r4, r3
 8009ba0:	657c      	str	r4, [r7, #84]	; 0x54
 8009ba2:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009ba6:	33a0      	adds	r3, #160	; 0xa0
 8009ba8:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	; 0x50
 8009bac:	4622      	mov	r2, r4
 8009bae:	4042      	eors	r2, r0
 8009bb0:	64ba      	str	r2, [r7, #72]	; 0x48
 8009bb2:	462a      	mov	r2, r5
 8009bb4:	404a      	eors	r2, r1
 8009bb6:	64fa      	str	r2, [r7, #76]	; 0x4c
 8009bb8:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 8009bbc:	e9c3 1202 	strd	r1, r2, [r3, #8]
   a[4][2] ^= ~a[4][3] & a[4][4];
 8009bc0:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009bc4:	33a0      	adds	r3, #160	; 0xa0
 8009bc6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8009bca:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009bce:	33a0      	adds	r3, #160	; 0xa0
 8009bd0:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8009bd4:	43d4      	mvns	r4, r2
 8009bd6:	643c      	str	r4, [r7, #64]	; 0x40
 8009bd8:	43db      	mvns	r3, r3
 8009bda:	647b      	str	r3, [r7, #68]	; 0x44
 8009bdc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009be0:	33a0      	adds	r3, #160	; 0xa0
 8009be2:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009be6:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	; 0x40
 8009bea:	4644      	mov	r4, r8
 8009bec:	4014      	ands	r4, r2
 8009bee:	63bc      	str	r4, [r7, #56]	; 0x38
 8009bf0:	464c      	mov	r4, r9
 8009bf2:	401c      	ands	r4, r3
 8009bf4:	63fc      	str	r4, [r7, #60]	; 0x3c
 8009bf6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009bfa:	33a0      	adds	r3, #160	; 0xa0
 8009bfc:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	; 0x38
 8009c00:	4622      	mov	r2, r4
 8009c02:	4042      	eors	r2, r0
 8009c04:	633a      	str	r2, [r7, #48]	; 0x30
 8009c06:	462a      	mov	r2, r5
 8009c08:	404a      	eors	r2, r1
 8009c0a:	637a      	str	r2, [r7, #52]	; 0x34
 8009c0c:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 8009c10:	e9c3 1204 	strd	r1, r2, [r3, #16]
   a[4][3] ^= ~a[4][4] & temp1;
 8009c14:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009c18:	33a0      	adds	r3, #160	; 0xa0
 8009c1a:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8009c1e:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009c22:	33a0      	adds	r3, #160	; 0xa0
 8009c24:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009c28:	43d4      	mvns	r4, r2
 8009c2a:	62bc      	str	r4, [r7, #40]	; 0x28
 8009c2c:	43db      	mvns	r3, r3
 8009c2e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009c30:	e9d7 2394 	ldrd	r2, r3, [r7, #592]	; 0x250
 8009c34:	e9d7 890a 	ldrd	r8, r9, [r7, #40]	; 0x28
 8009c38:	4644      	mov	r4, r8
 8009c3a:	4014      	ands	r4, r2
 8009c3c:	623c      	str	r4, [r7, #32]
 8009c3e:	464c      	mov	r4, r9
 8009c40:	401c      	ands	r4, r3
 8009c42:	627c      	str	r4, [r7, #36]	; 0x24
 8009c44:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009c48:	33a0      	adds	r3, #160	; 0xa0
 8009c4a:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 8009c4e:	4622      	mov	r2, r4
 8009c50:	4042      	eors	r2, r0
 8009c52:	61ba      	str	r2, [r7, #24]
 8009c54:	462a      	mov	r2, r5
 8009c56:	404a      	eors	r2, r1
 8009c58:	61fa      	str	r2, [r7, #28]
 8009c5a:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8009c5e:	e9c3 1206 	strd	r1, r2, [r3, #24]
   a[4][4] ^= ~temp1 & temp2;
 8009c62:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8009c66:	33a0      	adds	r3, #160	; 0xa0
 8009c68:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8009c6c:	e9d7 0194 	ldrd	r0, r1, [r7, #592]	; 0x250
 8009c70:	43c4      	mvns	r4, r0
 8009c72:	613c      	str	r4, [r7, #16]
 8009c74:	43c9      	mvns	r1, r1
 8009c76:	6179      	str	r1, [r7, #20]
 8009c78:	e9d7 0192 	ldrd	r0, r1, [r7, #584]	; 0x248
 8009c7c:	e9d7 8904 	ldrd	r8, r9, [r7, #16]
 8009c80:	4644      	mov	r4, r8
 8009c82:	4004      	ands	r4, r0
 8009c84:	60bc      	str	r4, [r7, #8]
 8009c86:	464c      	mov	r4, r9
 8009c88:	400c      	ands	r4, r1
 8009c8a:	60fc      	str	r4, [r7, #12]
 8009c8c:	f8d7 1244 	ldr.w	r1, [r7, #580]	; 0x244
 8009c90:	31a0      	adds	r1, #160	; 0xa0
 8009c92:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 8009c96:	4620      	mov	r0, r4
 8009c98:	4050      	eors	r0, r2
 8009c9a:	6038      	str	r0, [r7, #0]
 8009c9c:	4628      	mov	r0, r5
 8009c9e:	4058      	eors	r0, r3
 8009ca0:	6078      	str	r0, [r7, #4]
 8009ca2:	e9d7 3400 	ldrd	r3, r4, [r7]
 8009ca6:	e9c1 3408 	strd	r3, r4, [r1, #32]
}
 8009caa:	bf00      	nop
 8009cac:	f507 7717 	add.w	r7, r7, #604	; 0x25c
 8009cb0:	46bd      	mov	sp, r7
 8009cb2:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8009cb6:	4770      	bx	lr

08009cb8 <iota>:
 * @param[in,out] a State array
 * @param[index] round Round index
 **/

static void iota(keccak_lane_t a[5][5], uint_t index)
{
 8009cb8:	b4b0      	push	{r4, r5, r7}
 8009cba:	b083      	sub	sp, #12
 8009cbc:	af00      	add	r7, sp, #0
 8009cbe:	6078      	str	r0, [r7, #4]
 8009cc0:	6039      	str	r1, [r7, #0]
   //The iota transformation is parameterized by the round index
   a[0][0] ^= rc[index];
 8009cc2:	6879      	ldr	r1, [r7, #4]
 8009cc4:	e9d1 4500 	ldrd	r4, r5, [r1]
 8009cc8:	4808      	ldr	r0, [pc, #32]	; (8009cec <iota+0x34>)
 8009cca:	6839      	ldr	r1, [r7, #0]
 8009ccc:	00c9      	lsls	r1, r1, #3
 8009cce:	4401      	add	r1, r0
 8009cd0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009cd4:	ea84 0200 	eor.w	r2, r4, r0
 8009cd8:	ea85 0301 	eor.w	r3, r5, r1
 8009cdc:	6879      	ldr	r1, [r7, #4]
 8009cde:	e9c1 2300 	strd	r2, r3, [r1]
}
 8009ce2:	bf00      	nop
 8009ce4:	370c      	adds	r7, #12
 8009ce6:	46bd      	mov	sp, r7
 8009ce8:	bcb0      	pop	{r4, r5, r7}
 8009cea:	4770      	bx	lr
 8009cec:	0800f430 	.word	0x0800f430

08009cf0 <keccakInit>:
 * @param[in] context Pointer to the Keccak context to initialize
 * @param[in] capacity Capacity of the sponge function
 **/

error_t keccakInit(KeccakContext *context, uint_t capacity)
{
 8009cf0:	b580      	push	{r7, lr}
 8009cf2:	b084      	sub	sp, #16
 8009cf4:	af00      	add	r7, sp, #0
 8009cf6:	6078      	str	r0, [r7, #4]
 8009cf8:	6039      	str	r1, [r7, #0]
   uint_t rate;

   //Make sure the Keccak context is valid
   if(context == NULL)
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	2b00      	cmp	r3, #0
 8009cfe:	d101      	bne.n	8009d04 <keccakInit+0x14>
      return ERROR_INVALID_PARAMETER;
 8009d00:	2302      	movs	r3, #2
 8009d02:	e01c      	b.n	8009d3e <keccakInit+0x4e>

   //Clear Keccak context
   osMemset(context, 0, sizeof(KeccakContext));
 8009d04:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8009d08:	2100      	movs	r1, #0
 8009d0a:	6878      	ldr	r0, [r7, #4]
 8009d0c:	f004 fbea 	bl	800e4e4 <memset>

   //The capacity cannot exceed the width of a Keccak-p permutation
   if(capacity >= KECCAK_B)
 8009d10:	683b      	ldr	r3, [r7, #0]
 8009d12:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8009d16:	d301      	bcc.n	8009d1c <keccakInit+0x2c>
      return ERROR_INVALID_PARAMETER;
 8009d18:	2302      	movs	r3, #2
 8009d1a:	e010      	b.n	8009d3e <keccakInit+0x4e>

   //The rate depends on the capacity of the sponge function
   rate = KECCAK_B - capacity;
 8009d1c:	683b      	ldr	r3, [r7, #0]
 8009d1e:	f5c3 63c8 	rsb	r3, r3, #1600	; 0x640
 8009d22:	60fb      	str	r3, [r7, #12]

   //The rate must be multiple of the lane size
   if((rate % KECCAK_W) != 0)
 8009d24:	68fb      	ldr	r3, [r7, #12]
 8009d26:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009d2a:	2b00      	cmp	r3, #0
 8009d2c:	d001      	beq.n	8009d32 <keccakInit+0x42>
      return ERROR_INVALID_PARAMETER;
 8009d2e:	2302      	movs	r3, #2
 8009d30:	e005      	b.n	8009d3e <keccakInit+0x4e>

   //Save the block size, in bytes
   context->blockSize = rate / 8;
 8009d32:	68fb      	ldr	r3, [r7, #12]
 8009d34:	08da      	lsrs	r2, r3, #3
 8009d36:	687b      	ldr	r3, [r7, #4]
 8009d38:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188

   //Successful initialization
   return NO_ERROR;
 8009d3c:	2300      	movs	r3, #0
}
 8009d3e:	4618      	mov	r0, r3
 8009d40:	3710      	adds	r7, #16
 8009d42:	46bd      	mov	sp, r7
 8009d44:	bd80      	pop	{r7, pc}

08009d46 <keccakAbsorb>:
 * @param[in] input Pointer to the buffer being hashed
 * @param[in] length Length of the buffer
 **/

void keccakAbsorb(KeccakContext *context, const void *input, size_t length)
{
 8009d46:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009d48:	b089      	sub	sp, #36	; 0x24
 8009d4a:	af00      	add	r7, sp, #0
 8009d4c:	60f8      	str	r0, [r7, #12]
 8009d4e:	60b9      	str	r1, [r7, #8]
 8009d50:	607a      	str	r2, [r7, #4]
   uint_t i;
   size_t n;
   keccak_lane_t *a;

   //Point to the state array
   a = (keccak_lane_t *) context->a;
 8009d52:	68fb      	ldr	r3, [r7, #12]
 8009d54:	61bb      	str	r3, [r7, #24]

   //Absorbing phase
   while(length > 0)
 8009d56:	e05b      	b.n	8009e10 <keccakAbsorb+0xca>
   {
      //Limit the number of bytes to process at a time
      n = MIN(length, context->blockSize - context->length);
 8009d58:	68fb      	ldr	r3, [r7, #12]
 8009d5a:	f8d3 2188 	ldr.w	r2, [r3, #392]	; 0x188
 8009d5e:	68fb      	ldr	r3, [r7, #12]
 8009d60:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009d64:	1ad3      	subs	r3, r2, r3
 8009d66:	687a      	ldr	r2, [r7, #4]
 8009d68:	4293      	cmp	r3, r2
 8009d6a:	bf28      	it	cs
 8009d6c:	4613      	movcs	r3, r2
 8009d6e:	617b      	str	r3, [r7, #20]

      //Copy the data to the buffer
      osMemcpy(context->buffer + context->length, input, n);
 8009d70:	68fb      	ldr	r3, [r7, #12]
 8009d72:	f103 02c8 	add.w	r2, r3, #200	; 0xc8
 8009d76:	68fb      	ldr	r3, [r7, #12]
 8009d78:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009d7c:	4413      	add	r3, r2
 8009d7e:	697a      	ldr	r2, [r7, #20]
 8009d80:	68b9      	ldr	r1, [r7, #8]
 8009d82:	4618      	mov	r0, r3
 8009d84:	f004 fba0 	bl	800e4c8 <memcpy>

      //Number of data bytes that have been buffered
      context->length += n;
 8009d88:	68fb      	ldr	r3, [r7, #12]
 8009d8a:	f8d3 218c 	ldr.w	r2, [r3, #396]	; 0x18c
 8009d8e:	697b      	ldr	r3, [r7, #20]
 8009d90:	441a      	add	r2, r3
 8009d92:	68fb      	ldr	r3, [r7, #12]
 8009d94:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c

      //Advance the data pointer
      input = (uint8_t *) input + n;
 8009d98:	68ba      	ldr	r2, [r7, #8]
 8009d9a:	697b      	ldr	r3, [r7, #20]
 8009d9c:	4413      	add	r3, r2
 8009d9e:	60bb      	str	r3, [r7, #8]
      //Remaining bytes to process
      length -= n;
 8009da0:	687a      	ldr	r2, [r7, #4]
 8009da2:	697b      	ldr	r3, [r7, #20]
 8009da4:	1ad3      	subs	r3, r2, r3
 8009da6:	607b      	str	r3, [r7, #4]

      //Absorb the message block by block
      if(context->length == context->blockSize)
 8009da8:	68fb      	ldr	r3, [r7, #12]
 8009daa:	f8d3 218c 	ldr.w	r2, [r3, #396]	; 0x18c
 8009dae:	68fb      	ldr	r3, [r7, #12]
 8009db0:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009db4:	429a      	cmp	r2, r3
 8009db6:	d12b      	bne.n	8009e10 <keccakAbsorb+0xca>
      {
         //Absorb the current block
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009db8:	2300      	movs	r3, #0
 8009dba:	61fb      	str	r3, [r7, #28]
 8009dbc:	e01a      	b.n	8009df4 <keccakAbsorb+0xae>
         {
            a[i] ^= KECCAK_LETOH(context->block[i]);
 8009dbe:	69fb      	ldr	r3, [r7, #28]
 8009dc0:	00db      	lsls	r3, r3, #3
 8009dc2:	69ba      	ldr	r2, [r7, #24]
 8009dc4:	4413      	add	r3, r2
 8009dc6:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009dca:	68fa      	ldr	r2, [r7, #12]
 8009dcc:	69fb      	ldr	r3, [r7, #28]
 8009dce:	3319      	adds	r3, #25
 8009dd0:	00db      	lsls	r3, r3, #3
 8009dd2:	4413      	add	r3, r2
 8009dd4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009dd8:	69fe      	ldr	r6, [r7, #28]
 8009dda:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
 8009dde:	69be      	ldr	r6, [r7, #24]
 8009de0:	4466      	add	r6, ip
 8009de2:	ea80 0402 	eor.w	r4, r0, r2
 8009de6:	ea81 0503 	eor.w	r5, r1, r3
 8009dea:	e9c6 4500 	strd	r4, r5, [r6]
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009dee:	69fb      	ldr	r3, [r7, #28]
 8009df0:	3301      	adds	r3, #1
 8009df2:	61fb      	str	r3, [r7, #28]
 8009df4:	68fb      	ldr	r3, [r7, #12]
 8009df6:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009dfa:	08db      	lsrs	r3, r3, #3
 8009dfc:	69fa      	ldr	r2, [r7, #28]
 8009dfe:	429a      	cmp	r2, r3
 8009e00:	d3dd      	bcc.n	8009dbe <keccakAbsorb+0x78>
         }

         //Apply block permutation function
         keccakPermutBlock(context);
 8009e02:	68f8      	ldr	r0, [r7, #12]
 8009e04:	f000 f913 	bl	800a02e <keccakPermutBlock>

         //The input buffer is empty
         context->length = 0;
 8009e08:	68fb      	ldr	r3, [r7, #12]
 8009e0a:	2200      	movs	r2, #0
 8009e0c:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
   while(length > 0)
 8009e10:	687b      	ldr	r3, [r7, #4]
 8009e12:	2b00      	cmp	r3, #0
 8009e14:	d1a0      	bne.n	8009d58 <keccakAbsorb+0x12>
      }
   }
}
 8009e16:	bf00      	nop
 8009e18:	bf00      	nop
 8009e1a:	3724      	adds	r7, #36	; 0x24
 8009e1c:	46bd      	mov	sp, r7
 8009e1e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009e20 <keccakFinal>:
 * @param[in] context Pointer to the Keccak context
 * @param[in] pad Padding byte used for domain separation
 **/

void keccakFinal(KeccakContext *context, uint8_t pad)
{
 8009e20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009e22:	b087      	sub	sp, #28
 8009e24:	af00      	add	r7, sp, #0
 8009e26:	6078      	str	r0, [r7, #4]
 8009e28:	460b      	mov	r3, r1
 8009e2a:	70fb      	strb	r3, [r7, #3]
   uint_t i;
   size_t q;
   keccak_lane_t *a;

   //Point to the state array
   a = (keccak_lane_t *) context->a;
 8009e2c:	687b      	ldr	r3, [r7, #4]
 8009e2e:	613b      	str	r3, [r7, #16]

   //Compute the number of padding bytes
   q = context->blockSize - context->length;
 8009e30:	687b      	ldr	r3, [r7, #4]
 8009e32:	f8d3 2188 	ldr.w	r2, [r3, #392]	; 0x188
 8009e36:	687b      	ldr	r3, [r7, #4]
 8009e38:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009e3c:	1ad3      	subs	r3, r2, r3
 8009e3e:	60fb      	str	r3, [r7, #12]

   //Append padding
   osMemset(context->buffer + context->length, 0, q);
 8009e40:	687b      	ldr	r3, [r7, #4]
 8009e42:	f103 02c8 	add.w	r2, r3, #200	; 0xc8
 8009e46:	687b      	ldr	r3, [r7, #4]
 8009e48:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009e4c:	4413      	add	r3, r2
 8009e4e:	68fa      	ldr	r2, [r7, #12]
 8009e50:	2100      	movs	r1, #0
 8009e52:	4618      	mov	r0, r3
 8009e54:	f004 fb46 	bl	800e4e4 <memset>
   context->buffer[context->length] |= pad;
 8009e58:	687b      	ldr	r3, [r7, #4]
 8009e5a:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009e5e:	687a      	ldr	r2, [r7, #4]
 8009e60:	4413      	add	r3, r2
 8009e62:	f893 10c8 	ldrb.w	r1, [r3, #200]	; 0xc8
 8009e66:	687b      	ldr	r3, [r7, #4]
 8009e68:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009e6c:	78fa      	ldrb	r2, [r7, #3]
 8009e6e:	430a      	orrs	r2, r1
 8009e70:	b2d1      	uxtb	r1, r2
 8009e72:	687a      	ldr	r2, [r7, #4]
 8009e74:	4413      	add	r3, r2
 8009e76:	460a      	mov	r2, r1
 8009e78:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
   context->buffer[context->blockSize - 1] |= 0x80;
 8009e7c:	687b      	ldr	r3, [r7, #4]
 8009e7e:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009e82:	3b01      	subs	r3, #1
 8009e84:	687a      	ldr	r2, [r7, #4]
 8009e86:	4413      	add	r3, r2
 8009e88:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
 8009e8c:	687b      	ldr	r3, [r7, #4]
 8009e8e:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009e92:	3b01      	subs	r3, #1
 8009e94:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8009e98:	b2d1      	uxtb	r1, r2
 8009e9a:	687a      	ldr	r2, [r7, #4]
 8009e9c:	4413      	add	r3, r2
 8009e9e:	460a      	mov	r2, r1
 8009ea0:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8

   //Absorb the final block
   for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009ea4:	2300      	movs	r3, #0
 8009ea6:	617b      	str	r3, [r7, #20]
 8009ea8:	e01a      	b.n	8009ee0 <keccakFinal+0xc0>
   {
      a[i] ^= KECCAK_LETOH(context->block[i]);
 8009eaa:	697b      	ldr	r3, [r7, #20]
 8009eac:	00db      	lsls	r3, r3, #3
 8009eae:	693a      	ldr	r2, [r7, #16]
 8009eb0:	4413      	add	r3, r2
 8009eb2:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009eb6:	687a      	ldr	r2, [r7, #4]
 8009eb8:	697b      	ldr	r3, [r7, #20]
 8009eba:	3319      	adds	r3, #25
 8009ebc:	00db      	lsls	r3, r3, #3
 8009ebe:	4413      	add	r3, r2
 8009ec0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009ec4:	697e      	ldr	r6, [r7, #20]
 8009ec6:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
 8009eca:	693e      	ldr	r6, [r7, #16]
 8009ecc:	4466      	add	r6, ip
 8009ece:	ea80 0402 	eor.w	r4, r0, r2
 8009ed2:	ea81 0503 	eor.w	r5, r1, r3
 8009ed6:	e9c6 4500 	strd	r4, r5, [r6]
   for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009eda:	697b      	ldr	r3, [r7, #20]
 8009edc:	3301      	adds	r3, #1
 8009ede:	617b      	str	r3, [r7, #20]
 8009ee0:	687b      	ldr	r3, [r7, #4]
 8009ee2:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009ee6:	08db      	lsrs	r3, r3, #3
 8009ee8:	697a      	ldr	r2, [r7, #20]
 8009eea:	429a      	cmp	r2, r3
 8009eec:	d3dd      	bcc.n	8009eaa <keccakFinal+0x8a>
   }

   //Apply block permutation function
   keccakPermutBlock(context);
 8009eee:	6878      	ldr	r0, [r7, #4]
 8009ef0:	f000 f89d 	bl	800a02e <keccakPermutBlock>

   //Convert lanes to little-endian byte order
   for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009ef4:	2300      	movs	r3, #0
 8009ef6:	617b      	str	r3, [r7, #20]
 8009ef8:	e00e      	b.n	8009f18 <keccakFinal+0xf8>
   {
      a[i] = KECCAK_HTOLE(a[i]);
 8009efa:	697b      	ldr	r3, [r7, #20]
 8009efc:	00db      	lsls	r3, r3, #3
 8009efe:	693a      	ldr	r2, [r7, #16]
 8009f00:	4413      	add	r3, r2
 8009f02:	697a      	ldr	r2, [r7, #20]
 8009f04:	00d2      	lsls	r2, r2, #3
 8009f06:	6939      	ldr	r1, [r7, #16]
 8009f08:	4411      	add	r1, r2
 8009f0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f0e:	e9c1 2300 	strd	r2, r3, [r1]
   for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009f12:	697b      	ldr	r3, [r7, #20]
 8009f14:	3301      	adds	r3, #1
 8009f16:	617b      	str	r3, [r7, #20]
 8009f18:	687b      	ldr	r3, [r7, #4]
 8009f1a:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009f1e:	08db      	lsrs	r3, r3, #3
 8009f20:	697a      	ldr	r2, [r7, #20]
 8009f22:	429a      	cmp	r2, r3
 8009f24:	d3e9      	bcc.n	8009efa <keccakFinal+0xda>
   }

   //Number of bytes available in the output buffer
   context->length = context->blockSize;
 8009f26:	687b      	ldr	r3, [r7, #4]
 8009f28:	f8d3 2188 	ldr.w	r2, [r3, #392]	; 0x188
 8009f2c:	687b      	ldr	r3, [r7, #4]
 8009f2e:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
}
 8009f32:	bf00      	nop
 8009f34:	371c      	adds	r7, #28
 8009f36:	46bd      	mov	sp, r7
 8009f38:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009f3a <keccakSqueeze>:
 * @param[out] output Output string
 * @param[in] length Desired output length, in bytes
 **/

void keccakSqueeze(KeccakContext *context, uint8_t *output, size_t length)
{
 8009f3a:	b580      	push	{r7, lr}
 8009f3c:	b088      	sub	sp, #32
 8009f3e:	af00      	add	r7, sp, #0
 8009f40:	60f8      	str	r0, [r7, #12]
 8009f42:	60b9      	str	r1, [r7, #8]
 8009f44:	607a      	str	r2, [r7, #4]
   uint_t i;
   size_t n;
   keccak_lane_t *a;

   //Point to the state array
   a = (keccak_lane_t *) context->a;
 8009f46:	68fb      	ldr	r3, [r7, #12]
 8009f48:	61bb      	str	r3, [r7, #24]

   //An arbitrary number of output bits can be squeezed out of the state
   while(length > 0)
 8009f4a:	e068      	b.n	800a01e <keccakSqueeze+0xe4>
   {
      //Check whether more data is required
      if(context->length == 0)
 8009f4c:	68fb      	ldr	r3, [r7, #12]
 8009f4e:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	d13a      	bne.n	8009fcc <keccakSqueeze+0x92>
      {
         //Convert lanes to host byte order
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009f56:	2300      	movs	r3, #0
 8009f58:	61fb      	str	r3, [r7, #28]
 8009f5a:	e00e      	b.n	8009f7a <keccakSqueeze+0x40>
         {
            a[i] = KECCAK_LETOH(a[i]);
 8009f5c:	69fb      	ldr	r3, [r7, #28]
 8009f5e:	00db      	lsls	r3, r3, #3
 8009f60:	69ba      	ldr	r2, [r7, #24]
 8009f62:	4413      	add	r3, r2
 8009f64:	69fa      	ldr	r2, [r7, #28]
 8009f66:	00d2      	lsls	r2, r2, #3
 8009f68:	69b9      	ldr	r1, [r7, #24]
 8009f6a:	4411      	add	r1, r2
 8009f6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f70:	e9c1 2300 	strd	r2, r3, [r1]
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009f74:	69fb      	ldr	r3, [r7, #28]
 8009f76:	3301      	adds	r3, #1
 8009f78:	61fb      	str	r3, [r7, #28]
 8009f7a:	68fb      	ldr	r3, [r7, #12]
 8009f7c:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009f80:	08db      	lsrs	r3, r3, #3
 8009f82:	69fa      	ldr	r2, [r7, #28]
 8009f84:	429a      	cmp	r2, r3
 8009f86:	d3e9      	bcc.n	8009f5c <keccakSqueeze+0x22>
         }

         //Apply block permutation function
         keccakPermutBlock(context);
 8009f88:	68f8      	ldr	r0, [r7, #12]
 8009f8a:	f000 f850 	bl	800a02e <keccakPermutBlock>

         //Convert lanes to little-endian byte order
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009f8e:	2300      	movs	r3, #0
 8009f90:	61fb      	str	r3, [r7, #28]
 8009f92:	e00e      	b.n	8009fb2 <keccakSqueeze+0x78>
         {
            a[i] = KECCAK_HTOLE(a[i]);
 8009f94:	69fb      	ldr	r3, [r7, #28]
 8009f96:	00db      	lsls	r3, r3, #3
 8009f98:	69ba      	ldr	r2, [r7, #24]
 8009f9a:	4413      	add	r3, r2
 8009f9c:	69fa      	ldr	r2, [r7, #28]
 8009f9e:	00d2      	lsls	r2, r2, #3
 8009fa0:	69b9      	ldr	r1, [r7, #24]
 8009fa2:	4411      	add	r1, r2
 8009fa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009fa8:	e9c1 2300 	strd	r2, r3, [r1]
         for(i = 0; i < context->blockSize / sizeof(keccak_lane_t); i++)
 8009fac:	69fb      	ldr	r3, [r7, #28]
 8009fae:	3301      	adds	r3, #1
 8009fb0:	61fb      	str	r3, [r7, #28]
 8009fb2:	68fb      	ldr	r3, [r7, #12]
 8009fb4:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8009fb8:	08db      	lsrs	r3, r3, #3
 8009fba:	69fa      	ldr	r2, [r7, #28]
 8009fbc:	429a      	cmp	r2, r3
 8009fbe:	d3e9      	bcc.n	8009f94 <keccakSqueeze+0x5a>
         }

         //Number of bytes available in the output buffer
         context->length = context->blockSize;
 8009fc0:	68fb      	ldr	r3, [r7, #12]
 8009fc2:	f8d3 2188 	ldr.w	r2, [r3, #392]	; 0x188
 8009fc6:	68fb      	ldr	r3, [r7, #12]
 8009fc8:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
      }

      //Compute the number of bytes to process at a time
      n = MIN(length, context->length);
 8009fcc:	68fb      	ldr	r3, [r7, #12]
 8009fce:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009fd2:	687a      	ldr	r2, [r7, #4]
 8009fd4:	4293      	cmp	r3, r2
 8009fd6:	bf28      	it	cs
 8009fd8:	4613      	movcs	r3, r2
 8009fda:	617b      	str	r3, [r7, #20]

      //Copy the output string
      if(output != NULL)
 8009fdc:	68bb      	ldr	r3, [r7, #8]
 8009fde:	2b00      	cmp	r3, #0
 8009fe0:	d00d      	beq.n	8009ffe <keccakSqueeze+0xc4>
      {
         osMemcpy(output, context->digest + context->blockSize -
 8009fe2:	68fa      	ldr	r2, [r7, #12]
 8009fe4:	68fb      	ldr	r3, [r7, #12]
 8009fe6:	f8d3 1188 	ldr.w	r1, [r3, #392]	; 0x188
 8009fea:	68fb      	ldr	r3, [r7, #12]
 8009fec:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8009ff0:	1acb      	subs	r3, r1, r3
 8009ff2:	4413      	add	r3, r2
 8009ff4:	697a      	ldr	r2, [r7, #20]
 8009ff6:	4619      	mov	r1, r3
 8009ff8:	68b8      	ldr	r0, [r7, #8]
 8009ffa:	f004 fa65 	bl	800e4c8 <memcpy>
            context->length, n);
      }

      //Number of bytes available in the output buffer
      context->length -= n;
 8009ffe:	68fb      	ldr	r3, [r7, #12]
 800a000:	f8d3 218c 	ldr.w	r2, [r3, #396]	; 0x18c
 800a004:	697b      	ldr	r3, [r7, #20]
 800a006:	1ad2      	subs	r2, r2, r3
 800a008:	68fb      	ldr	r3, [r7, #12]
 800a00a:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c

      //Advance the data pointer
      output = (uint8_t *) output + n;
 800a00e:	68ba      	ldr	r2, [r7, #8]
 800a010:	697b      	ldr	r3, [r7, #20]
 800a012:	4413      	add	r3, r2
 800a014:	60bb      	str	r3, [r7, #8]
      //Number of bytes that remains to be written
      length -= n;
 800a016:	687a      	ldr	r2, [r7, #4]
 800a018:	697b      	ldr	r3, [r7, #20]
 800a01a:	1ad3      	subs	r3, r2, r3
 800a01c:	607b      	str	r3, [r7, #4]
   while(length > 0)
 800a01e:	687b      	ldr	r3, [r7, #4]
 800a020:	2b00      	cmp	r3, #0
 800a022:	d193      	bne.n	8009f4c <keccakSqueeze+0x12>
   }
}
 800a024:	bf00      	nop
 800a026:	bf00      	nop
 800a028:	3720      	adds	r7, #32
 800a02a:	46bd      	mov	sp, r7
 800a02c:	bd80      	pop	{r7, pc}

0800a02e <keccakPermutBlock>:
 * @brief Block permutation
 * @param[in] context Pointer to the Keccak context
 **/

void keccakPermutBlock(KeccakContext *context)
{
 800a02e:	b580      	push	{r7, lr}
 800a030:	b084      	sub	sp, #16
 800a032:	af00      	add	r7, sp, #0
 800a034:	6078      	str	r0, [r7, #4]
   uint_t i;

   //Each round consists of a sequence of five transformations, which are
   //called the step mappings
   for(i = 0; i < KECCAK_NR; i++)
 800a036:	2300      	movs	r3, #0
 800a038:	60fb      	str	r3, [r7, #12]
 800a03a:	e017      	b.n	800a06c <keccakPermutBlock+0x3e>
   {
      //Apply theta step mapping
      theta(context->a);
 800a03c:	687b      	ldr	r3, [r7, #4]
 800a03e:	4618      	mov	r0, r3
 800a040:	f7fe fb12 	bl	8008668 <theta>
      //Apply rho step mapping
      rho(context->a);
 800a044:	687b      	ldr	r3, [r7, #4]
 800a046:	4618      	mov	r0, r3
 800a048:	f7fe fece 	bl	8008de8 <rho>
      //Apply pi step mapping
      pi(context->a);
 800a04c:	687b      	ldr	r3, [r7, #4]
 800a04e:	4618      	mov	r0, r3
 800a050:	f7ff f8c2 	bl	80091d8 <pi>
      //Apply chi step mapping
      chi(context->a);
 800a054:	687b      	ldr	r3, [r7, #4]
 800a056:	4618      	mov	r0, r3
 800a058:	f7ff f998 	bl	800938c <chi>
      //Apply iota step mapping
      iota(context->a, i);
 800a05c:	687b      	ldr	r3, [r7, #4]
 800a05e:	68f9      	ldr	r1, [r7, #12]
 800a060:	4618      	mov	r0, r3
 800a062:	f7ff fe29 	bl	8009cb8 <iota>
   for(i = 0; i < KECCAK_NR; i++)
 800a066:	68fb      	ldr	r3, [r7, #12]
 800a068:	3301      	adds	r3, #1
 800a06a:	60fb      	str	r3, [r7, #12]
 800a06c:	68fb      	ldr	r3, [r7, #12]
 800a06e:	2b17      	cmp	r3, #23
 800a070:	d9e4      	bls.n	800a03c <keccakPermutBlock+0xe>
   }
}
 800a072:	bf00      	nop
 800a074:	bf00      	nop
 800a076:	3710      	adds	r7, #16
 800a078:	46bd      	mov	sp, r7
 800a07a:	bd80      	pop	{r7, pc}

0800a07c <sha256Init>:
 * @brief Initialize SHA-256 message digest context
 * @param[in] context Pointer to the SHA-256 context to initialize
 **/

__weak_func void sha256Init(Sha256Context *context)
{
 800a07c:	b480      	push	{r7}
 800a07e:	b083      	sub	sp, #12
 800a080:	af00      	add	r7, sp, #0
 800a082:	6078      	str	r0, [r7, #4]
   //Set initial hash value
   context->h[0] = 0x6A09E667;
 800a084:	687b      	ldr	r3, [r7, #4]
 800a086:	4a13      	ldr	r2, [pc, #76]	; (800a0d4 <sha256Init+0x58>)
 800a088:	601a      	str	r2, [r3, #0]
   context->h[1] = 0xBB67AE85;
 800a08a:	687b      	ldr	r3, [r7, #4]
 800a08c:	4a12      	ldr	r2, [pc, #72]	; (800a0d8 <sha256Init+0x5c>)
 800a08e:	605a      	str	r2, [r3, #4]
   context->h[2] = 0x3C6EF372;
 800a090:	687b      	ldr	r3, [r7, #4]
 800a092:	4a12      	ldr	r2, [pc, #72]	; (800a0dc <sha256Init+0x60>)
 800a094:	609a      	str	r2, [r3, #8]
   context->h[3] = 0xA54FF53A;
 800a096:	687b      	ldr	r3, [r7, #4]
 800a098:	4a11      	ldr	r2, [pc, #68]	; (800a0e0 <sha256Init+0x64>)
 800a09a:	60da      	str	r2, [r3, #12]
   context->h[4] = 0x510E527F;
 800a09c:	687b      	ldr	r3, [r7, #4]
 800a09e:	4a11      	ldr	r2, [pc, #68]	; (800a0e4 <sha256Init+0x68>)
 800a0a0:	611a      	str	r2, [r3, #16]
   context->h[5] = 0x9B05688C;
 800a0a2:	687b      	ldr	r3, [r7, #4]
 800a0a4:	4a10      	ldr	r2, [pc, #64]	; (800a0e8 <sha256Init+0x6c>)
 800a0a6:	615a      	str	r2, [r3, #20]
   context->h[6] = 0x1F83D9AB;
 800a0a8:	687b      	ldr	r3, [r7, #4]
 800a0aa:	4a10      	ldr	r2, [pc, #64]	; (800a0ec <sha256Init+0x70>)
 800a0ac:	619a      	str	r2, [r3, #24]
   context->h[7] = 0x5BE0CD19;
 800a0ae:	687b      	ldr	r3, [r7, #4]
 800a0b0:	4a0f      	ldr	r2, [pc, #60]	; (800a0f0 <sha256Init+0x74>)
 800a0b2:	61da      	str	r2, [r3, #28]

   //Number of bytes in the buffer
   context->size = 0;
 800a0b4:	687b      	ldr	r3, [r7, #4]
 800a0b6:	2200      	movs	r2, #0
 800a0b8:	661a      	str	r2, [r3, #96]	; 0x60
   //Total length of the message
   context->totalSize = 0;
 800a0ba:	6879      	ldr	r1, [r7, #4]
 800a0bc:	f04f 0200 	mov.w	r2, #0
 800a0c0:	f04f 0300 	mov.w	r3, #0
 800a0c4:	e9c1 231a 	strd	r2, r3, [r1, #104]	; 0x68
}
 800a0c8:	bf00      	nop
 800a0ca:	370c      	adds	r7, #12
 800a0cc:	46bd      	mov	sp, r7
 800a0ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0d2:	4770      	bx	lr
 800a0d4:	6a09e667 	.word	0x6a09e667
 800a0d8:	bb67ae85 	.word	0xbb67ae85
 800a0dc:	3c6ef372 	.word	0x3c6ef372
 800a0e0:	a54ff53a 	.word	0xa54ff53a
 800a0e4:	510e527f 	.word	0x510e527f
 800a0e8:	9b05688c 	.word	0x9b05688c
 800a0ec:	1f83d9ab 	.word	0x1f83d9ab
 800a0f0:	5be0cd19 	.word	0x5be0cd19

0800a0f4 <sha256Update>:
 * @param[in] data Pointer to the buffer being hashed
 * @param[in] length Length of the buffer
 **/

__weak_func void sha256Update(Sha256Context *context, const void *data, size_t length)
{
 800a0f4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800a0f8:	b086      	sub	sp, #24
 800a0fa:	af00      	add	r7, sp, #0
 800a0fc:	60f8      	str	r0, [r7, #12]
 800a0fe:	60b9      	str	r1, [r7, #8]
 800a100:	607a      	str	r2, [r7, #4]
   size_t n;

   //Process the incoming data
   while(length > 0)
 800a102:	e039      	b.n	800a178 <sha256Update+0x84>
   {
      //The buffer can hold at most 64 bytes
      n = MIN(length, 64 - context->size);
 800a104:	68fb      	ldr	r3, [r7, #12]
 800a106:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a108:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800a10c:	687a      	ldr	r2, [r7, #4]
 800a10e:	4293      	cmp	r3, r2
 800a110:	bf28      	it	cs
 800a112:	4613      	movcs	r3, r2
 800a114:	617b      	str	r3, [r7, #20]

      //Copy the data to the buffer
      osMemcpy(context->buffer + context->size, data, n);
 800a116:	68fb      	ldr	r3, [r7, #12]
 800a118:	f103 0220 	add.w	r2, r3, #32
 800a11c:	68fb      	ldr	r3, [r7, #12]
 800a11e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a120:	4413      	add	r3, r2
 800a122:	697a      	ldr	r2, [r7, #20]
 800a124:	68b9      	ldr	r1, [r7, #8]
 800a126:	4618      	mov	r0, r3
 800a128:	f004 f9ce 	bl	800e4c8 <memcpy>

      //Update the SHA-256 context
      context->size += n;
 800a12c:	68fb      	ldr	r3, [r7, #12]
 800a12e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800a130:	697b      	ldr	r3, [r7, #20]
 800a132:	441a      	add	r2, r3
 800a134:	68fb      	ldr	r3, [r7, #12]
 800a136:	661a      	str	r2, [r3, #96]	; 0x60
      context->totalSize += n;
 800a138:	68fb      	ldr	r3, [r7, #12]
 800a13a:	e9d3 231a 	ldrd	r2, r3, [r3, #104]	; 0x68
 800a13e:	6979      	ldr	r1, [r7, #20]
 800a140:	2000      	movs	r0, #0
 800a142:	460c      	mov	r4, r1
 800a144:	4605      	mov	r5, r0
 800a146:	eb12 0804 	adds.w	r8, r2, r4
 800a14a:	eb43 0905 	adc.w	r9, r3, r5
 800a14e:	68fb      	ldr	r3, [r7, #12]
 800a150:	e9c3 891a 	strd	r8, r9, [r3, #104]	; 0x68
      //Advance the data pointer
      data = (uint8_t *) data + n;
 800a154:	68ba      	ldr	r2, [r7, #8]
 800a156:	697b      	ldr	r3, [r7, #20]
 800a158:	4413      	add	r3, r2
 800a15a:	60bb      	str	r3, [r7, #8]
      //Remaining bytes to process
      length -= n;
 800a15c:	687a      	ldr	r2, [r7, #4]
 800a15e:	697b      	ldr	r3, [r7, #20]
 800a160:	1ad3      	subs	r3, r2, r3
 800a162:	607b      	str	r3, [r7, #4]

      //Process message in 16-word blocks
      if(context->size == 64)
 800a164:	68fb      	ldr	r3, [r7, #12]
 800a166:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a168:	2b40      	cmp	r3, #64	; 0x40
 800a16a:	d105      	bne.n	800a178 <sha256Update+0x84>
      {
         //Transform the 16-word block
         sha256ProcessBlock(context);
 800a16c:	68f8      	ldr	r0, [r7, #12]
 800a16e:	f000 f871 	bl	800a254 <sha256ProcessBlock>
         //Empty the buffer
         context->size = 0;
 800a172:	68fb      	ldr	r3, [r7, #12]
 800a174:	2200      	movs	r2, #0
 800a176:	661a      	str	r2, [r3, #96]	; 0x60
   while(length > 0)
 800a178:	687b      	ldr	r3, [r7, #4]
 800a17a:	2b00      	cmp	r3, #0
 800a17c:	d1c2      	bne.n	800a104 <sha256Update+0x10>
      }
   }
}
 800a17e:	bf00      	nop
 800a180:	bf00      	nop
 800a182:	3718      	adds	r7, #24
 800a184:	46bd      	mov	sp, r7
 800a186:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

0800a18c <sha256Final>:
 * @param[in] context Pointer to the SHA-256 context
 * @param[out] digest Calculated digest (optional parameter)
 **/

__weak_func void sha256Final(Sha256Context *context, uint8_t *digest)
{
 800a18c:	b580      	push	{r7, lr}
 800a18e:	b086      	sub	sp, #24
 800a190:	af00      	add	r7, sp, #0
 800a192:	6078      	str	r0, [r7, #4]
 800a194:	6039      	str	r1, [r7, #0]
   uint_t i;
   size_t paddingSize;
   uint64_t totalSize;

   //Length of the original message (before padding)
   totalSize = context->totalSize * 8;
 800a196:	687b      	ldr	r3, [r7, #4]
 800a198:	e9d3 011a 	ldrd	r0, r1, [r3, #104]	; 0x68
 800a19c:	f04f 0200 	mov.w	r2, #0
 800a1a0:	f04f 0300 	mov.w	r3, #0
 800a1a4:	00cb      	lsls	r3, r1, #3
 800a1a6:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800a1aa:	00c2      	lsls	r2, r0, #3
 800a1ac:	e9c7 2302 	strd	r2, r3, [r7, #8]

   //Pad the message so that its length is congruent to 56 modulo 64
   if(context->size < 56)
 800a1b0:	687b      	ldr	r3, [r7, #4]
 800a1b2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a1b4:	2b37      	cmp	r3, #55	; 0x37
 800a1b6:	d805      	bhi.n	800a1c4 <sha256Final+0x38>
   {
      paddingSize = 56 - context->size;
 800a1b8:	687b      	ldr	r3, [r7, #4]
 800a1ba:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a1bc:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 800a1c0:	613b      	str	r3, [r7, #16]
 800a1c2:	e004      	b.n	800a1ce <sha256Final+0x42>
   }
   else
   {
      paddingSize = 64 + 56 - context->size;
 800a1c4:	687b      	ldr	r3, [r7, #4]
 800a1c6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a1c8:	f1c3 0378 	rsb	r3, r3, #120	; 0x78
 800a1cc:	613b      	str	r3, [r7, #16]
   }

   //Append padding
   sha256Update(context, padding, paddingSize);
 800a1ce:	693a      	ldr	r2, [r7, #16]
 800a1d0:	491f      	ldr	r1, [pc, #124]	; (800a250 <sha256Final+0xc4>)
 800a1d2:	6878      	ldr	r0, [r7, #4]
 800a1d4:	f7ff ff8e 	bl	800a0f4 <sha256Update>

   //Append the length of the original message
   context->w[14] = htobe32((uint32_t) (totalSize >> 32));
 800a1d8:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800a1dc:	f04f 0200 	mov.w	r2, #0
 800a1e0:	f04f 0300 	mov.w	r3, #0
 800a1e4:	000a      	movs	r2, r1
 800a1e6:	2300      	movs	r3, #0
 800a1e8:	4613      	mov	r3, r2
 800a1ea:	4618      	mov	r0, r3
 800a1ec:	f001 fa14 	bl	800b618 <swapInt32>
 800a1f0:	4602      	mov	r2, r0
 800a1f2:	687b      	ldr	r3, [r7, #4]
 800a1f4:	659a      	str	r2, [r3, #88]	; 0x58
   context->w[15] = htobe32((uint32_t) totalSize);
 800a1f6:	68bb      	ldr	r3, [r7, #8]
 800a1f8:	4618      	mov	r0, r3
 800a1fa:	f001 fa0d 	bl	800b618 <swapInt32>
 800a1fe:	4602      	mov	r2, r0
 800a200:	687b      	ldr	r3, [r7, #4]
 800a202:	65da      	str	r2, [r3, #92]	; 0x5c

   //Calculate the message digest
   sha256ProcessBlock(context);
 800a204:	6878      	ldr	r0, [r7, #4]
 800a206:	f000 f825 	bl	800a254 <sha256ProcessBlock>

   //Convert from host byte order to big-endian byte order
   for(i = 0; i < 8; i++)
 800a20a:	2300      	movs	r3, #0
 800a20c:	617b      	str	r3, [r7, #20]
 800a20e:	e00e      	b.n	800a22e <sha256Final+0xa2>
   {
      context->h[i] = htobe32(context->h[i]);
 800a210:	687b      	ldr	r3, [r7, #4]
 800a212:	697a      	ldr	r2, [r7, #20]
 800a214:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a218:	4618      	mov	r0, r3
 800a21a:	f001 f9fd 	bl	800b618 <swapInt32>
 800a21e:	4601      	mov	r1, r0
 800a220:	687b      	ldr	r3, [r7, #4]
 800a222:	697a      	ldr	r2, [r7, #20]
 800a224:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   for(i = 0; i < 8; i++)
 800a228:	697b      	ldr	r3, [r7, #20]
 800a22a:	3301      	adds	r3, #1
 800a22c:	617b      	str	r3, [r7, #20]
 800a22e:	697b      	ldr	r3, [r7, #20]
 800a230:	2b07      	cmp	r3, #7
 800a232:	d9ed      	bls.n	800a210 <sha256Final+0x84>
   }

   //Copy the resulting digest
   if(digest != NULL)
 800a234:	683b      	ldr	r3, [r7, #0]
 800a236:	2b00      	cmp	r3, #0
 800a238:	d005      	beq.n	800a246 <sha256Final+0xba>
   {
      osMemcpy(digest, context->digest, SHA256_DIGEST_SIZE);
 800a23a:	687b      	ldr	r3, [r7, #4]
 800a23c:	2220      	movs	r2, #32
 800a23e:	4619      	mov	r1, r3
 800a240:	6838      	ldr	r0, [r7, #0]
 800a242:	f004 f941 	bl	800e4c8 <memcpy>
   }
}
 800a246:	bf00      	nop
 800a248:	3718      	adds	r7, #24
 800a24a:	46bd      	mov	sp, r7
 800a24c:	bd80      	pop	{r7, pc}
 800a24e:	bf00      	nop
 800a250:	0800f4f0 	.word	0x0800f4f0

0800a254 <sha256ProcessBlock>:
 * @brief Process message in 16-word blocks
 * @param[in] context Pointer to the SHA-256 context
 **/

__weak_func void sha256ProcessBlock(Sha256Context *context)
{
 800a254:	b590      	push	{r4, r7, lr}
 800a256:	b08f      	sub	sp, #60	; 0x3c
 800a258:	af00      	add	r7, sp, #0
 800a25a:	6078      	str	r0, [r7, #4]
   uint_t t;
   uint32_t temp1;
   uint32_t temp2;

   //Initialize the 8 working registers
   uint32_t a = context->h[0];
 800a25c:	687b      	ldr	r3, [r7, #4]
 800a25e:	681b      	ldr	r3, [r3, #0]
 800a260:	633b      	str	r3, [r7, #48]	; 0x30
   uint32_t b = context->h[1];
 800a262:	687b      	ldr	r3, [r7, #4]
 800a264:	685b      	ldr	r3, [r3, #4]
 800a266:	62fb      	str	r3, [r7, #44]	; 0x2c
   uint32_t c = context->h[2];
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	689b      	ldr	r3, [r3, #8]
 800a26c:	62bb      	str	r3, [r7, #40]	; 0x28
   uint32_t d = context->h[3];
 800a26e:	687b      	ldr	r3, [r7, #4]
 800a270:	68db      	ldr	r3, [r3, #12]
 800a272:	627b      	str	r3, [r7, #36]	; 0x24
   uint32_t e = context->h[4];
 800a274:	687b      	ldr	r3, [r7, #4]
 800a276:	691b      	ldr	r3, [r3, #16]
 800a278:	623b      	str	r3, [r7, #32]
   uint32_t f = context->h[5];
 800a27a:	687b      	ldr	r3, [r7, #4]
 800a27c:	695b      	ldr	r3, [r3, #20]
 800a27e:	61fb      	str	r3, [r7, #28]
   uint32_t g = context->h[6];
 800a280:	687b      	ldr	r3, [r7, #4]
 800a282:	699b      	ldr	r3, [r3, #24]
 800a284:	61bb      	str	r3, [r7, #24]
   uint32_t h = context->h[7];
 800a286:	687b      	ldr	r3, [r7, #4]
 800a288:	69db      	ldr	r3, [r3, #28]
 800a28a:	617b      	str	r3, [r7, #20]

   //Process message in 16-word blocks
   uint32_t *w = context->w;
 800a28c:	687b      	ldr	r3, [r7, #4]
 800a28e:	3320      	adds	r3, #32
 800a290:	613b      	str	r3, [r7, #16]

   //Convert from big-endian byte order to host byte order
   for(t = 0; t < 16; t++)
 800a292:	2300      	movs	r3, #0
 800a294:	637b      	str	r3, [r7, #52]	; 0x34
 800a296:	e010      	b.n	800a2ba <sha256ProcessBlock+0x66>
   {
      w[t] = betoh32(w[t]);
 800a298:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a29a:	009b      	lsls	r3, r3, #2
 800a29c:	693a      	ldr	r2, [r7, #16]
 800a29e:	4413      	add	r3, r2
 800a2a0:	6819      	ldr	r1, [r3, #0]
 800a2a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2a4:	009b      	lsls	r3, r3, #2
 800a2a6:	693a      	ldr	r2, [r7, #16]
 800a2a8:	18d4      	adds	r4, r2, r3
 800a2aa:	4608      	mov	r0, r1
 800a2ac:	f001 f9b4 	bl	800b618 <swapInt32>
 800a2b0:	4603      	mov	r3, r0
 800a2b2:	6023      	str	r3, [r4, #0]
   for(t = 0; t < 16; t++)
 800a2b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2b6:	3301      	adds	r3, #1
 800a2b8:	637b      	str	r3, [r7, #52]	; 0x34
 800a2ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2bc:	2b0f      	cmp	r3, #15
 800a2be:	d9eb      	bls.n	800a298 <sha256ProcessBlock+0x44>
   }

   //SHA-256 hash computation (alternate method)
   for(t = 0; t < 64; t++)
 800a2c0:	2300      	movs	r3, #0
 800a2c2:	637b      	str	r3, [r7, #52]	; 0x34
 800a2c4:	e0aa      	b.n	800a41c <sha256ProcessBlock+0x1c8>
   {
      //Prepare the message schedule
      if(t >= 16)
 800a2c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2c8:	2b0f      	cmp	r3, #15
 800a2ca:	d956      	bls.n	800a37a <sha256ProcessBlock+0x126>
      {
         W(t) += SIGMA4(W(t + 14)) + W(t + 9) + SIGMA3(W(t + 1));
 800a2cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2ce:	f003 030f 	and.w	r3, r3, #15
 800a2d2:	009b      	lsls	r3, r3, #2
 800a2d4:	693a      	ldr	r2, [r7, #16]
 800a2d6:	4413      	add	r3, r2
 800a2d8:	6819      	ldr	r1, [r3, #0]
 800a2da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2dc:	330e      	adds	r3, #14
 800a2de:	f003 030f 	and.w	r3, r3, #15
 800a2e2:	009b      	lsls	r3, r3, #2
 800a2e4:	693a      	ldr	r2, [r7, #16]
 800a2e6:	4413      	add	r3, r2
 800a2e8:	681b      	ldr	r3, [r3, #0]
 800a2ea:	ea4f 4273 	mov.w	r2, r3, ror #17
 800a2ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2f0:	330e      	adds	r3, #14
 800a2f2:	f003 030f 	and.w	r3, r3, #15
 800a2f6:	009b      	lsls	r3, r3, #2
 800a2f8:	6938      	ldr	r0, [r7, #16]
 800a2fa:	4403      	add	r3, r0
 800a2fc:	681b      	ldr	r3, [r3, #0]
 800a2fe:	ea4f 43f3 	mov.w	r3, r3, ror #19
 800a302:	405a      	eors	r2, r3
 800a304:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a306:	330e      	adds	r3, #14
 800a308:	f003 030f 	and.w	r3, r3, #15
 800a30c:	009b      	lsls	r3, r3, #2
 800a30e:	6938      	ldr	r0, [r7, #16]
 800a310:	4403      	add	r3, r0
 800a312:	681b      	ldr	r3, [r3, #0]
 800a314:	0a9b      	lsrs	r3, r3, #10
 800a316:	405a      	eors	r2, r3
 800a318:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a31a:	3309      	adds	r3, #9
 800a31c:	f003 030f 	and.w	r3, r3, #15
 800a320:	009b      	lsls	r3, r3, #2
 800a322:	6938      	ldr	r0, [r7, #16]
 800a324:	4403      	add	r3, r0
 800a326:	681b      	ldr	r3, [r3, #0]
 800a328:	441a      	add	r2, r3
 800a32a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a32c:	3301      	adds	r3, #1
 800a32e:	f003 030f 	and.w	r3, r3, #15
 800a332:	009b      	lsls	r3, r3, #2
 800a334:	6938      	ldr	r0, [r7, #16]
 800a336:	4403      	add	r3, r0
 800a338:	681b      	ldr	r3, [r3, #0]
 800a33a:	ea4f 10f3 	mov.w	r0, r3, ror #7
 800a33e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a340:	3301      	adds	r3, #1
 800a342:	f003 030f 	and.w	r3, r3, #15
 800a346:	009b      	lsls	r3, r3, #2
 800a348:	693c      	ldr	r4, [r7, #16]
 800a34a:	4423      	add	r3, r4
 800a34c:	681b      	ldr	r3, [r3, #0]
 800a34e:	ea4f 43b3 	mov.w	r3, r3, ror #18
 800a352:	4058      	eors	r0, r3
 800a354:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a356:	3301      	adds	r3, #1
 800a358:	f003 030f 	and.w	r3, r3, #15
 800a35c:	009b      	lsls	r3, r3, #2
 800a35e:	693c      	ldr	r4, [r7, #16]
 800a360:	4423      	add	r3, r4
 800a362:	681b      	ldr	r3, [r3, #0]
 800a364:	08db      	lsrs	r3, r3, #3
 800a366:	4043      	eors	r3, r0
 800a368:	441a      	add	r2, r3
 800a36a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a36c:	f003 030f 	and.w	r3, r3, #15
 800a370:	009b      	lsls	r3, r3, #2
 800a372:	6938      	ldr	r0, [r7, #16]
 800a374:	4403      	add	r3, r0
 800a376:	440a      	add	r2, r1
 800a378:	601a      	str	r2, [r3, #0]
      }

      //Calculate T1 and T2
      temp1 = h + SIGMA2(e) + CH(e, f, g) + k[t] + W(t);
 800a37a:	6a3b      	ldr	r3, [r7, #32]
 800a37c:	ea4f 12b3 	mov.w	r2, r3, ror #6
 800a380:	6a3b      	ldr	r3, [r7, #32]
 800a382:	ea4f 23f3 	mov.w	r3, r3, ror #11
 800a386:	405a      	eors	r2, r3
 800a388:	6a3b      	ldr	r3, [r7, #32]
 800a38a:	ea4f 6373 	mov.w	r3, r3, ror #25
 800a38e:	405a      	eors	r2, r3
 800a390:	697b      	ldr	r3, [r7, #20]
 800a392:	441a      	add	r2, r3
 800a394:	6a39      	ldr	r1, [r7, #32]
 800a396:	69fb      	ldr	r3, [r7, #28]
 800a398:	4019      	ands	r1, r3
 800a39a:	6a3b      	ldr	r3, [r7, #32]
 800a39c:	43d8      	mvns	r0, r3
 800a39e:	69bb      	ldr	r3, [r7, #24]
 800a3a0:	4003      	ands	r3, r0
 800a3a2:	430b      	orrs	r3, r1
 800a3a4:	441a      	add	r2, r3
 800a3a6:	4939      	ldr	r1, [pc, #228]	; (800a48c <sha256ProcessBlock+0x238>)
 800a3a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3aa:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800a3ae:	441a      	add	r2, r3
 800a3b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3b2:	f003 030f 	and.w	r3, r3, #15
 800a3b6:	009b      	lsls	r3, r3, #2
 800a3b8:	6939      	ldr	r1, [r7, #16]
 800a3ba:	440b      	add	r3, r1
 800a3bc:	681b      	ldr	r3, [r3, #0]
 800a3be:	4413      	add	r3, r2
 800a3c0:	60fb      	str	r3, [r7, #12]
      temp2 = SIGMA1(a) + MAJ(a, b, c);
 800a3c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3c4:	ea4f 02b3 	mov.w	r2, r3, ror #2
 800a3c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3ca:	ea4f 3373 	mov.w	r3, r3, ror #13
 800a3ce:	405a      	eors	r2, r3
 800a3d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3d2:	ea4f 53b3 	mov.w	r3, r3, ror #22
 800a3d6:	405a      	eors	r2, r3
 800a3d8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800a3da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a3dc:	4319      	orrs	r1, r3
 800a3de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a3e0:	4019      	ands	r1, r3
 800a3e2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800a3e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a3e6:	4003      	ands	r3, r0
 800a3e8:	430b      	orrs	r3, r1
 800a3ea:	4413      	add	r3, r2
 800a3ec:	60bb      	str	r3, [r7, #8]

      //Update the working registers
      h = g;
 800a3ee:	69bb      	ldr	r3, [r7, #24]
 800a3f0:	617b      	str	r3, [r7, #20]
      g = f;
 800a3f2:	69fb      	ldr	r3, [r7, #28]
 800a3f4:	61bb      	str	r3, [r7, #24]
      f = e;
 800a3f6:	6a3b      	ldr	r3, [r7, #32]
 800a3f8:	61fb      	str	r3, [r7, #28]
      e = d + temp1;
 800a3fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a3fc:	68fb      	ldr	r3, [r7, #12]
 800a3fe:	4413      	add	r3, r2
 800a400:	623b      	str	r3, [r7, #32]
      d = c;
 800a402:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a404:	627b      	str	r3, [r7, #36]	; 0x24
      c = b;
 800a406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a408:	62bb      	str	r3, [r7, #40]	; 0x28
      b = a;
 800a40a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a40c:	62fb      	str	r3, [r7, #44]	; 0x2c
      a = temp1 + temp2;
 800a40e:	68fa      	ldr	r2, [r7, #12]
 800a410:	68bb      	ldr	r3, [r7, #8]
 800a412:	4413      	add	r3, r2
 800a414:	633b      	str	r3, [r7, #48]	; 0x30
   for(t = 0; t < 64; t++)
 800a416:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a418:	3301      	adds	r3, #1
 800a41a:	637b      	str	r3, [r7, #52]	; 0x34
 800a41c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a41e:	2b3f      	cmp	r3, #63	; 0x3f
 800a420:	f67f af51 	bls.w	800a2c6 <sha256ProcessBlock+0x72>
   }

   //Update the hash value
   context->h[0] += a;
 800a424:	687b      	ldr	r3, [r7, #4]
 800a426:	681a      	ldr	r2, [r3, #0]
 800a428:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a42a:	441a      	add	r2, r3
 800a42c:	687b      	ldr	r3, [r7, #4]
 800a42e:	601a      	str	r2, [r3, #0]
   context->h[1] += b;
 800a430:	687b      	ldr	r3, [r7, #4]
 800a432:	685a      	ldr	r2, [r3, #4]
 800a434:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a436:	441a      	add	r2, r3
 800a438:	687b      	ldr	r3, [r7, #4]
 800a43a:	605a      	str	r2, [r3, #4]
   context->h[2] += c;
 800a43c:	687b      	ldr	r3, [r7, #4]
 800a43e:	689a      	ldr	r2, [r3, #8]
 800a440:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a442:	441a      	add	r2, r3
 800a444:	687b      	ldr	r3, [r7, #4]
 800a446:	609a      	str	r2, [r3, #8]
   context->h[3] += d;
 800a448:	687b      	ldr	r3, [r7, #4]
 800a44a:	68da      	ldr	r2, [r3, #12]
 800a44c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a44e:	441a      	add	r2, r3
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	60da      	str	r2, [r3, #12]
   context->h[4] += e;
 800a454:	687b      	ldr	r3, [r7, #4]
 800a456:	691a      	ldr	r2, [r3, #16]
 800a458:	6a3b      	ldr	r3, [r7, #32]
 800a45a:	441a      	add	r2, r3
 800a45c:	687b      	ldr	r3, [r7, #4]
 800a45e:	611a      	str	r2, [r3, #16]
   context->h[5] += f;
 800a460:	687b      	ldr	r3, [r7, #4]
 800a462:	695a      	ldr	r2, [r3, #20]
 800a464:	69fb      	ldr	r3, [r7, #28]
 800a466:	441a      	add	r2, r3
 800a468:	687b      	ldr	r3, [r7, #4]
 800a46a:	615a      	str	r2, [r3, #20]
   context->h[6] += g;
 800a46c:	687b      	ldr	r3, [r7, #4]
 800a46e:	699a      	ldr	r2, [r3, #24]
 800a470:	69bb      	ldr	r3, [r7, #24]
 800a472:	441a      	add	r2, r3
 800a474:	687b      	ldr	r3, [r7, #4]
 800a476:	619a      	str	r2, [r3, #24]
   context->h[7] += h;
 800a478:	687b      	ldr	r3, [r7, #4]
 800a47a:	69da      	ldr	r2, [r3, #28]
 800a47c:	697b      	ldr	r3, [r7, #20]
 800a47e:	441a      	add	r2, r3
 800a480:	687b      	ldr	r3, [r7, #4]
 800a482:	61da      	str	r2, [r3, #28]
}
 800a484:	bf00      	nop
 800a486:	373c      	adds	r7, #60	; 0x3c
 800a488:	46bd      	mov	sp, r7
 800a48a:	bd90      	pop	{r4, r7, pc}
 800a48c:	0800f530 	.word	0x0800f530

0800a490 <sha512Init>:
 * @brief Initialize SHA-512 message digest context
 * @param[in] context Pointer to the SHA-512 context to initialize
 **/

__weak_func void sha512Init(Sha512Context *context)
{
 800a490:	b480      	push	{r7}
 800a492:	b083      	sub	sp, #12
 800a494:	af00      	add	r7, sp, #0
 800a496:	6078      	str	r0, [r7, #4]
   //Set initial hash value
   context->h[0] = 0x6A09E667F3BCC908;
 800a498:	6879      	ldr	r1, [r7, #4]
 800a49a:	a321      	add	r3, pc, #132	; (adr r3, 800a520 <sha512Init+0x90>)
 800a49c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4a0:	e9c1 2300 	strd	r2, r3, [r1]
   context->h[1] = 0xBB67AE8584CAA73B;
 800a4a4:	6879      	ldr	r1, [r7, #4]
 800a4a6:	a320      	add	r3, pc, #128	; (adr r3, 800a528 <sha512Init+0x98>)
 800a4a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4ac:	e9c1 2302 	strd	r2, r3, [r1, #8]
   context->h[2] = 0x3C6EF372FE94F82B;
 800a4b0:	6879      	ldr	r1, [r7, #4]
 800a4b2:	a31f      	add	r3, pc, #124	; (adr r3, 800a530 <sha512Init+0xa0>)
 800a4b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4b8:	e9c1 2304 	strd	r2, r3, [r1, #16]
   context->h[3] = 0xA54FF53A5F1D36F1;
 800a4bc:	6879      	ldr	r1, [r7, #4]
 800a4be:	a31e      	add	r3, pc, #120	; (adr r3, 800a538 <sha512Init+0xa8>)
 800a4c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4c4:	e9c1 2306 	strd	r2, r3, [r1, #24]
   context->h[4] = 0x510E527FADE682D1;
 800a4c8:	6879      	ldr	r1, [r7, #4]
 800a4ca:	a31d      	add	r3, pc, #116	; (adr r3, 800a540 <sha512Init+0xb0>)
 800a4cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4d0:	e9c1 2308 	strd	r2, r3, [r1, #32]
   context->h[5] = 0x9B05688C2B3E6C1F;
 800a4d4:	6879      	ldr	r1, [r7, #4]
 800a4d6:	a31c      	add	r3, pc, #112	; (adr r3, 800a548 <sha512Init+0xb8>)
 800a4d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4dc:	e9c1 230a 	strd	r2, r3, [r1, #40]	; 0x28
   context->h[6] = 0x1F83D9ABFB41BD6B;
 800a4e0:	6879      	ldr	r1, [r7, #4]
 800a4e2:	a31b      	add	r3, pc, #108	; (adr r3, 800a550 <sha512Init+0xc0>)
 800a4e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4e8:	e9c1 230c 	strd	r2, r3, [r1, #48]	; 0x30
   context->h[7] = 0x5BE0CD19137E2179;
 800a4ec:	6879      	ldr	r1, [r7, #4]
 800a4ee:	a31a      	add	r3, pc, #104	; (adr r3, 800a558 <sha512Init+0xc8>)
 800a4f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a4f4:	e9c1 230e 	strd	r2, r3, [r1, #56]	; 0x38

   //Number of bytes in the buffer
   context->size = 0;
 800a4f8:	687b      	ldr	r3, [r7, #4]
 800a4fa:	2200      	movs	r2, #0
 800a4fc:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
   //Total length of the message
   context->totalSize = 0;
 800a500:	6879      	ldr	r1, [r7, #4]
 800a502:	f04f 0200 	mov.w	r2, #0
 800a506:	f04f 0300 	mov.w	r3, #0
 800a50a:	e9c1 2332 	strd	r2, r3, [r1, #200]	; 0xc8
}
 800a50e:	bf00      	nop
 800a510:	370c      	adds	r7, #12
 800a512:	46bd      	mov	sp, r7
 800a514:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a518:	4770      	bx	lr
 800a51a:	bf00      	nop
 800a51c:	f3af 8000 	nop.w
 800a520:	f3bcc908 	.word	0xf3bcc908
 800a524:	6a09e667 	.word	0x6a09e667
 800a528:	84caa73b 	.word	0x84caa73b
 800a52c:	bb67ae85 	.word	0xbb67ae85
 800a530:	fe94f82b 	.word	0xfe94f82b
 800a534:	3c6ef372 	.word	0x3c6ef372
 800a538:	5f1d36f1 	.word	0x5f1d36f1
 800a53c:	a54ff53a 	.word	0xa54ff53a
 800a540:	ade682d1 	.word	0xade682d1
 800a544:	510e527f 	.word	0x510e527f
 800a548:	2b3e6c1f 	.word	0x2b3e6c1f
 800a54c:	9b05688c 	.word	0x9b05688c
 800a550:	fb41bd6b 	.word	0xfb41bd6b
 800a554:	1f83d9ab 	.word	0x1f83d9ab
 800a558:	137e2179 	.word	0x137e2179
 800a55c:	5be0cd19 	.word	0x5be0cd19

0800a560 <sha512Update>:
 * @param[in] data Pointer to the buffer being hashed
 * @param[in] length Length of the buffer
 **/

__weak_func void sha512Update(Sha512Context *context, const void *data, size_t length)
{
 800a560:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800a564:	b086      	sub	sp, #24
 800a566:	af00      	add	r7, sp, #0
 800a568:	60f8      	str	r0, [r7, #12]
 800a56a:	60b9      	str	r1, [r7, #8]
 800a56c:	607a      	str	r2, [r7, #4]
   size_t n;

   //Process the incoming data
   while(length > 0)
 800a56e:	e03f      	b.n	800a5f0 <sha512Update+0x90>
   {
      //The buffer can hold at most 128 bytes
      n = MIN(length, 128 - context->size);
 800a570:	68fb      	ldr	r3, [r7, #12]
 800a572:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a576:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
 800a57a:	687a      	ldr	r2, [r7, #4]
 800a57c:	4293      	cmp	r3, r2
 800a57e:	bf28      	it	cs
 800a580:	4613      	movcs	r3, r2
 800a582:	617b      	str	r3, [r7, #20]

      //Copy the data to the buffer
      osMemcpy(context->buffer + context->size, data, n);
 800a584:	68fb      	ldr	r3, [r7, #12]
 800a586:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a58a:	68fb      	ldr	r3, [r7, #12]
 800a58c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a590:	4413      	add	r3, r2
 800a592:	697a      	ldr	r2, [r7, #20]
 800a594:	68b9      	ldr	r1, [r7, #8]
 800a596:	4618      	mov	r0, r3
 800a598:	f003 ff96 	bl	800e4c8 <memcpy>

      //Update the SHA-512 context
      context->size += n;
 800a59c:	68fb      	ldr	r3, [r7, #12]
 800a59e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800a5a2:	697b      	ldr	r3, [r7, #20]
 800a5a4:	441a      	add	r2, r3
 800a5a6:	68fb      	ldr	r3, [r7, #12]
 800a5a8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
      context->totalSize += n;
 800a5ac:	68fb      	ldr	r3, [r7, #12]
 800a5ae:	e9d3 2332 	ldrd	r2, r3, [r3, #200]	; 0xc8
 800a5b2:	6979      	ldr	r1, [r7, #20]
 800a5b4:	2000      	movs	r0, #0
 800a5b6:	460c      	mov	r4, r1
 800a5b8:	4605      	mov	r5, r0
 800a5ba:	eb12 0804 	adds.w	r8, r2, r4
 800a5be:	eb43 0905 	adc.w	r9, r3, r5
 800a5c2:	68fb      	ldr	r3, [r7, #12]
 800a5c4:	e9c3 8932 	strd	r8, r9, [r3, #200]	; 0xc8
      //Advance the data pointer
      data = (uint8_t *) data + n;
 800a5c8:	68ba      	ldr	r2, [r7, #8]
 800a5ca:	697b      	ldr	r3, [r7, #20]
 800a5cc:	4413      	add	r3, r2
 800a5ce:	60bb      	str	r3, [r7, #8]
      //Remaining bytes to process
      length -= n;
 800a5d0:	687a      	ldr	r2, [r7, #4]
 800a5d2:	697b      	ldr	r3, [r7, #20]
 800a5d4:	1ad3      	subs	r3, r2, r3
 800a5d6:	607b      	str	r3, [r7, #4]

      //Process message in 16-word blocks
      if(context->size == 128)
 800a5d8:	68fb      	ldr	r3, [r7, #12]
 800a5da:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a5de:	2b80      	cmp	r3, #128	; 0x80
 800a5e0:	d106      	bne.n	800a5f0 <sha512Update+0x90>
      {
         //Transform the 16-word block
         sha512ProcessBlock(context);
 800a5e2:	68f8      	ldr	r0, [r7, #12]
 800a5e4:	f000 f874 	bl	800a6d0 <sha512ProcessBlock>
         //Empty the buffer
         context->size = 0;
 800a5e8:	68fb      	ldr	r3, [r7, #12]
 800a5ea:	2200      	movs	r2, #0
 800a5ec:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
   while(length > 0)
 800a5f0:	687b      	ldr	r3, [r7, #4]
 800a5f2:	2b00      	cmp	r3, #0
 800a5f4:	d1bc      	bne.n	800a570 <sha512Update+0x10>
      }
   }
}
 800a5f6:	bf00      	nop
 800a5f8:	bf00      	nop
 800a5fa:	3718      	adds	r7, #24
 800a5fc:	46bd      	mov	sp, r7
 800a5fe:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

0800a604 <sha512Final>:
 * @param[in] context Pointer to the SHA-512 context
 * @param[out] digest Calculated digest (optional parameter)
 **/

__weak_func void sha512Final(Sha512Context *context, uint8_t *digest)
{
 800a604:	b580      	push	{r7, lr}
 800a606:	b086      	sub	sp, #24
 800a608:	af00      	add	r7, sp, #0
 800a60a:	6078      	str	r0, [r7, #4]
 800a60c:	6039      	str	r1, [r7, #0]
   uint_t i;
   size_t paddingSize;
   uint64_t totalSize;

   //Length of the original message (before padding)
   totalSize = context->totalSize * 8;
 800a60e:	687b      	ldr	r3, [r7, #4]
 800a610:	e9d3 0132 	ldrd	r0, r1, [r3, #200]	; 0xc8
 800a614:	f04f 0200 	mov.w	r2, #0
 800a618:	f04f 0300 	mov.w	r3, #0
 800a61c:	00cb      	lsls	r3, r1, #3
 800a61e:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800a622:	00c2      	lsls	r2, r0, #3
 800a624:	e9c7 2302 	strd	r2, r3, [r7, #8]

   //Pad the message so that its length is congruent to 112 modulo 128
   if(context->size < 112)
 800a628:	687b      	ldr	r3, [r7, #4]
 800a62a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a62e:	2b6f      	cmp	r3, #111	; 0x6f
 800a630:	d806      	bhi.n	800a640 <sha512Final+0x3c>
   {
      paddingSize = 112 - context->size;
 800a632:	687b      	ldr	r3, [r7, #4]
 800a634:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a638:	f1c3 0370 	rsb	r3, r3, #112	; 0x70
 800a63c:	613b      	str	r3, [r7, #16]
 800a63e:	e005      	b.n	800a64c <sha512Final+0x48>
   }
   else
   {
      paddingSize = 128 + 112 - context->size;
 800a640:	687b      	ldr	r3, [r7, #4]
 800a642:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800a646:	f1c3 03f0 	rsb	r3, r3, #240	; 0xf0
 800a64a:	613b      	str	r3, [r7, #16]
   }

   //Append padding
   sha512Update(context, padding, paddingSize);
 800a64c:	693a      	ldr	r2, [r7, #16]
 800a64e:	491f      	ldr	r1, [pc, #124]	; (800a6cc <sha512Final+0xc8>)
 800a650:	6878      	ldr	r0, [r7, #4]
 800a652:	f7ff ff85 	bl	800a560 <sha512Update>

   //Append the length of the original message
   context->w[14] = 0;
 800a656:	6879      	ldr	r1, [r7, #4]
 800a658:	f04f 0200 	mov.w	r2, #0
 800a65c:	f04f 0300 	mov.w	r3, #0
 800a660:	e9c1 232c 	strd	r2, r3, [r1, #176]	; 0xb0
   context->w[15] = htobe64(totalSize);
 800a664:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800a668:	f000 ffef 	bl	800b64a <swapInt64>
 800a66c:	4602      	mov	r2, r0
 800a66e:	460b      	mov	r3, r1
 800a670:	6879      	ldr	r1, [r7, #4]
 800a672:	e9c1 232e 	strd	r2, r3, [r1, #184]	; 0xb8

   //Calculate the message digest
   sha512ProcessBlock(context);
 800a676:	6878      	ldr	r0, [r7, #4]
 800a678:	f000 f82a 	bl	800a6d0 <sha512ProcessBlock>

   //Convert from host byte order to big-endian byte order
   for(i = 0; i < 8; i++)
 800a67c:	2300      	movs	r3, #0
 800a67e:	617b      	str	r3, [r7, #20]
 800a680:	e014      	b.n	800a6ac <sha512Final+0xa8>
   {
      context->h[i] = htobe64(context->h[i]);
 800a682:	687a      	ldr	r2, [r7, #4]
 800a684:	697b      	ldr	r3, [r7, #20]
 800a686:	00db      	lsls	r3, r3, #3
 800a688:	4413      	add	r3, r2
 800a68a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a68e:	4610      	mov	r0, r2
 800a690:	4619      	mov	r1, r3
 800a692:	f000 ffda 	bl	800b64a <swapInt64>
 800a696:	4602      	mov	r2, r0
 800a698:	460b      	mov	r3, r1
 800a69a:	6878      	ldr	r0, [r7, #4]
 800a69c:	6979      	ldr	r1, [r7, #20]
 800a69e:	00c9      	lsls	r1, r1, #3
 800a6a0:	4401      	add	r1, r0
 800a6a2:	e9c1 2300 	strd	r2, r3, [r1]
   for(i = 0; i < 8; i++)
 800a6a6:	697b      	ldr	r3, [r7, #20]
 800a6a8:	3301      	adds	r3, #1
 800a6aa:	617b      	str	r3, [r7, #20]
 800a6ac:	697b      	ldr	r3, [r7, #20]
 800a6ae:	2b07      	cmp	r3, #7
 800a6b0:	d9e7      	bls.n	800a682 <sha512Final+0x7e>
   }

   //Copy the resulting digest
   if(digest != NULL)
 800a6b2:	683b      	ldr	r3, [r7, #0]
 800a6b4:	2b00      	cmp	r3, #0
 800a6b6:	d005      	beq.n	800a6c4 <sha512Final+0xc0>
   {
      osMemcpy(digest, context->digest, SHA512_DIGEST_SIZE);
 800a6b8:	687b      	ldr	r3, [r7, #4]
 800a6ba:	2240      	movs	r2, #64	; 0x40
 800a6bc:	4619      	mov	r1, r3
 800a6be:	6838      	ldr	r0, [r7, #0]
 800a6c0:	f003 ff02 	bl	800e4c8 <memcpy>
   }
}
 800a6c4:	bf00      	nop
 800a6c6:	3718      	adds	r7, #24
 800a6c8:	46bd      	mov	sp, r7
 800a6ca:	bd80      	pop	{r7, pc}
 800a6cc:	0800f630 	.word	0x0800f630

0800a6d0 <sha512ProcessBlock>:
 * @brief Process message in 16-word blocks
 * @param[in] context Pointer to the SHA-512 context
 **/

__weak_func void sha512ProcessBlock(Sha512Context *context)
{
 800a6d0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800a6d4:	b0ee      	sub	sp, #440	; 0x1b8
 800a6d6:	af00      	add	r7, sp, #0
 800a6d8:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154
   uint_t t;
   uint64_t temp1;
   uint64_t temp2;

   //Initialize the 8 working registers
   uint64_t a = context->h[0];
 800a6dc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a6e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a6e4:	e9c7 236a 	strd	r2, r3, [r7, #424]	; 0x1a8
   uint64_t b = context->h[1];
 800a6e8:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a6ec:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a6f0:	e9c7 2368 	strd	r2, r3, [r7, #416]	; 0x1a0
   uint64_t c = context->h[2];
 800a6f4:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a6f8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800a6fc:	e9c7 2366 	strd	r2, r3, [r7, #408]	; 0x198
   uint64_t d = context->h[3];
 800a700:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a704:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800a708:	e9c7 2364 	strd	r2, r3, [r7, #400]	; 0x190
   uint64_t e = context->h[4];
 800a70c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a710:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800a714:	e9c7 2362 	strd	r2, r3, [r7, #392]	; 0x188
   uint64_t f = context->h[5];
 800a718:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a71c:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	; 0x28
 800a720:	e9c7 2360 	strd	r2, r3, [r7, #384]	; 0x180
   uint64_t g = context->h[6];
 800a724:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a728:	e9d3 230c 	ldrd	r2, r3, [r3, #48]	; 0x30
 800a72c:	e9c7 235e 	strd	r2, r3, [r7, #376]	; 0x178
   uint64_t h = context->h[7];
 800a730:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a734:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 800a738:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170

   //Process message in 16-word blocks
   uint64_t *w = context->w;
 800a73c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800a740:	3340      	adds	r3, #64	; 0x40
 800a742:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

   //Convert from big-endian byte order to host byte order
   for(t = 0; t < 16; t++)
 800a746:	2300      	movs	r3, #0
 800a748:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 800a74c:	e018      	b.n	800a780 <sha512ProcessBlock+0xb0>
   {
      w[t] = betoh64(w[t]);
 800a74e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a752:	00da      	lsls	r2, r3, #3
 800a754:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a758:	4413      	add	r3, r2
 800a75a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a75e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a762:	00da      	lsls	r2, r3, #3
 800a764:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a768:	189c      	adds	r4, r3, r2
 800a76a:	f000 ff6e 	bl	800b64a <swapInt64>
 800a76e:	4602      	mov	r2, r0
 800a770:	460b      	mov	r3, r1
 800a772:	e9c4 2300 	strd	r2, r3, [r4]
   for(t = 0; t < 16; t++)
 800a776:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a77a:	3301      	adds	r3, #1
 800a77c:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 800a780:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a784:	2b0f      	cmp	r3, #15
 800a786:	d9e2      	bls.n	800a74e <sha512ProcessBlock+0x7e>
   }

   //SHA-512 hash computation (alternate method)
   for(t = 0; t < 80; t++)
 800a788:	2300      	movs	r3, #0
 800a78a:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 800a78e:	e26c      	b.n	800ac6a <sha512ProcessBlock+0x59a>
   {
      //Prepare the message schedule
      if(t >= 16)
 800a790:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a794:	2b0f      	cmp	r3, #15
 800a796:	f240 80e4 	bls.w	800a962 <sha512ProcessBlock+0x292>
      {
         W(t) += SIGMA4(W(t + 14)) + W(t + 9) + SIGMA3(W(t + 1));
 800a79a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a79e:	f003 030f 	and.w	r3, r3, #15
 800a7a2:	00da      	lsls	r2, r3, #3
 800a7a4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a7a8:	4413      	add	r3, r2
 800a7aa:	e9d3 4500 	ldrd	r4, r5, [r3]
 800a7ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a7b2:	330e      	adds	r3, #14
 800a7b4:	f003 030f 	and.w	r3, r3, #15
 800a7b8:	00da      	lsls	r2, r3, #3
 800a7ba:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a7be:	4413      	add	r3, r2
 800a7c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7c4:	0358      	lsls	r0, r3, #13
 800a7c6:	0cd1      	lsrs	r1, r2, #19
 800a7c8:	4301      	orrs	r1, r0
 800a7ca:	f8c7 1148 	str.w	r1, [r7, #328]	; 0x148
 800a7ce:	0351      	lsls	r1, r2, #13
 800a7d0:	0cdb      	lsrs	r3, r3, #19
 800a7d2:	430b      	orrs	r3, r1
 800a7d4:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
 800a7d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a7dc:	330e      	adds	r3, #14
 800a7de:	f003 030f 	and.w	r3, r3, #15
 800a7e2:	00da      	lsls	r2, r3, #3
 800a7e4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a7e8:	4413      	add	r3, r2
 800a7ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7ee:	0f50      	lsrs	r0, r2, #29
 800a7f0:	00d9      	lsls	r1, r3, #3
 800a7f2:	4301      	orrs	r1, r0
 800a7f4:	f8c7 1124 	str.w	r1, [r7, #292]	; 0x124
 800a7f8:	0f59      	lsrs	r1, r3, #29
 800a7fa:	00d3      	lsls	r3, r2, #3
 800a7fc:	430b      	orrs	r3, r1
 800a7fe:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 800a802:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 800a806:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	; 0x120
 800a80a:	4602      	mov	r2, r0
 800a80c:	4053      	eors	r3, r2
 800a80e:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 800a812:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 800a816:	460a      	mov	r2, r1
 800a818:	4053      	eors	r3, r2
 800a81a:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
 800a81e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a822:	330e      	adds	r3, #14
 800a824:	f003 030f 	and.w	r3, r3, #15
 800a828:	00da      	lsls	r2, r3, #3
 800a82a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a82e:	4413      	add	r3, r2
 800a830:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a834:	f04f 0000 	mov.w	r0, #0
 800a838:	f04f 0100 	mov.w	r1, #0
 800a83c:	0990      	lsrs	r0, r2, #6
 800a83e:	ea40 6083 	orr.w	r0, r0, r3, lsl #26
 800a842:	0999      	lsrs	r1, r3, #6
 800a844:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 800a848:	4043      	eors	r3, r0
 800a84a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
 800a84e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 800a852:	404b      	eors	r3, r1
 800a854:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
 800a858:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a85c:	3309      	adds	r3, #9
 800a85e:	f003 030f 	and.w	r3, r3, #15
 800a862:	00da      	lsls	r2, r3, #3
 800a864:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a868:	4413      	add	r3, r2
 800a86a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a86e:	f8d7 1138 	ldr.w	r1, [r7, #312]	; 0x138
 800a872:	1889      	adds	r1, r1, r2
 800a874:	f8c7 1118 	str.w	r1, [r7, #280]	; 0x118
 800a878:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
 800a87c:	eb41 0303 	adc.w	r3, r1, r3
 800a880:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 800a884:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a888:	3301      	adds	r3, #1
 800a88a:	f003 030f 	and.w	r3, r3, #15
 800a88e:	00da      	lsls	r2, r3, #3
 800a890:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a894:	4413      	add	r3, r2
 800a896:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a89a:	07d8      	lsls	r0, r3, #31
 800a89c:	0851      	lsrs	r1, r2, #1
 800a89e:	4301      	orrs	r1, r0
 800a8a0:	f8c7 1130 	str.w	r1, [r7, #304]	; 0x130
 800a8a4:	07d1      	lsls	r1, r2, #31
 800a8a6:	085b      	lsrs	r3, r3, #1
 800a8a8:	430b      	orrs	r3, r1
 800a8aa:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 800a8ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a8b2:	3301      	adds	r3, #1
 800a8b4:	f003 030f 	and.w	r3, r3, #15
 800a8b8:	00da      	lsls	r2, r3, #3
 800a8ba:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a8be:	4413      	add	r3, r2
 800a8c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a8c4:	0618      	lsls	r0, r3, #24
 800a8c6:	0a11      	lsrs	r1, r2, #8
 800a8c8:	4301      	orrs	r1, r0
 800a8ca:	f8c7 1110 	str.w	r1, [r7, #272]	; 0x110
 800a8ce:	0611      	lsls	r1, r2, #24
 800a8d0:	0a1b      	lsrs	r3, r3, #8
 800a8d2:	430b      	orrs	r3, r1
 800a8d4:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 800a8d8:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 800a8dc:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	; 0x110
 800a8e0:	4602      	mov	r2, r0
 800a8e2:	4053      	eors	r3, r2
 800a8e4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 800a8e8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 800a8ec:	460a      	mov	r2, r1
 800a8ee:	4053      	eors	r3, r2
 800a8f0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 800a8f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a8f8:	3301      	adds	r3, #1
 800a8fa:	f003 030f 	and.w	r3, r3, #15
 800a8fe:	00da      	lsls	r2, r3, #3
 800a900:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a904:	4413      	add	r3, r2
 800a906:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a90a:	f04f 0000 	mov.w	r0, #0
 800a90e:	f04f 0100 	mov.w	r1, #0
 800a912:	09d0      	lsrs	r0, r2, #7
 800a914:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
 800a918:	09d9      	lsrs	r1, r3, #7
 800a91a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800a91e:	ea83 0a00 	eor.w	sl, r3, r0
 800a922:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800a926:	ea83 0b01 	eor.w	fp, r3, r1
 800a92a:	e9d7 1246 	ldrd	r1, r2, [r7, #280]	; 0x118
 800a92e:	460b      	mov	r3, r1
 800a930:	eb13 080a 	adds.w	r8, r3, sl
 800a934:	4613      	mov	r3, r2
 800a936:	eb43 090b 	adc.w	r9, r3, fp
 800a93a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800a93e:	f003 030f 	and.w	r3, r3, #15
 800a942:	00da      	lsls	r2, r3, #3
 800a944:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800a948:	4413      	add	r3, r2
 800a94a:	eb14 0208 	adds.w	r2, r4, r8
 800a94e:	f8c7 2108 	str.w	r2, [r7, #264]	; 0x108
 800a952:	eb45 0209 	adc.w	r2, r5, r9
 800a956:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
 800a95a:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	; 0x108
 800a95e:	e9c3 1200 	strd	r1, r2, [r3]
      }

      //Calculate T1 and T2
      temp1 = h + SIGMA2(e) + CH(e, f, g) + k[t] + W(t);
 800a962:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a966:	049a      	lsls	r2, r3, #18
 800a968:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a96c:	0b9b      	lsrs	r3, r3, #14
 800a96e:	4313      	orrs	r3, r2
 800a970:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800a974:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a978:	049a      	lsls	r2, r3, #18
 800a97a:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a97e:	0b9b      	lsrs	r3, r3, #14
 800a980:	4313      	orrs	r3, r2
 800a982:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800a986:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a98a:	039a      	lsls	r2, r3, #14
 800a98c:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a990:	0c9b      	lsrs	r3, r3, #18
 800a992:	4313      	orrs	r3, r2
 800a994:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800a998:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a99c:	039a      	lsls	r2, r3, #14
 800a99e:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a9a2:	0c9b      	lsrs	r3, r3, #18
 800a9a4:	4313      	orrs	r3, r2
 800a9a6:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 800a9aa:	e9d7 4540 	ldrd	r4, r5, [r7, #256]	; 0x100
 800a9ae:	4623      	mov	r3, r4
 800a9b0:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	; 0xf8
 800a9b4:	4602      	mov	r2, r0
 800a9b6:	4053      	eors	r3, r2
 800a9b8:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 800a9bc:	462b      	mov	r3, r5
 800a9be:	460a      	mov	r2, r1
 800a9c0:	4053      	eors	r3, r2
 800a9c2:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 800a9c6:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a9ca:	0a5a      	lsrs	r2, r3, #9
 800a9cc:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a9d0:	05db      	lsls	r3, r3, #23
 800a9d2:	4313      	orrs	r3, r2
 800a9d4:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800a9d8:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800a9dc:	0a5a      	lsrs	r2, r3, #9
 800a9de:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800a9e2:	05db      	lsls	r3, r3, #23
 800a9e4:	4313      	orrs	r3, r2
 800a9e6:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 800a9ea:	e9d7 453c 	ldrd	r4, r5, [r7, #240]	; 0xf0
 800a9ee:	4623      	mov	r3, r4
 800a9f0:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	; 0xe8
 800a9f4:	4602      	mov	r2, r0
 800a9f6:	4053      	eors	r3, r2
 800a9f8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800a9fc:	462b      	mov	r3, r5
 800a9fe:	460a      	mov	r2, r1
 800aa00:	4053      	eors	r3, r2
 800aa02:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 800aa06:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 800aa0a:	e9d7 4538 	ldrd	r4, r5, [r7, #224]	; 0xe0
 800aa0e:	4621      	mov	r1, r4
 800aa10:	1889      	adds	r1, r1, r2
 800aa12:	f8c7 10d8 	str.w	r1, [r7, #216]	; 0xd8
 800aa16:	4629      	mov	r1, r5
 800aa18:	eb41 0303 	adc.w	r3, r1, r3
 800aa1c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800aa20:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	; 0x188
 800aa24:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	; 0x180
 800aa28:	ea00 0402 	and.w	r4, r0, r2
 800aa2c:	f8c7 40d0 	str.w	r4, [r7, #208]	; 0xd0
 800aa30:	400b      	ands	r3, r1
 800aa32:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 800aa36:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	; 0x188
 800aa3a:	43d1      	mvns	r1, r2
 800aa3c:	f8c7 10c8 	str.w	r1, [r7, #200]	; 0xc8
 800aa40:	43db      	mvns	r3, r3
 800aa42:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 800aa46:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	; 0x178
 800aa4a:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	; 0xc8
 800aa4e:	4621      	mov	r1, r4
 800aa50:	4011      	ands	r1, r2
 800aa52:	f8c7 10c0 	str.w	r1, [r7, #192]	; 0xc0
 800aa56:	4629      	mov	r1, r5
 800aa58:	400b      	ands	r3, r1
 800aa5a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800aa5e:	e9d7 4534 	ldrd	r4, r5, [r7, #208]	; 0xd0
 800aa62:	4623      	mov	r3, r4
 800aa64:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	; 0xc0
 800aa68:	4602      	mov	r2, r0
 800aa6a:	4313      	orrs	r3, r2
 800aa6c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 800aa70:	462b      	mov	r3, r5
 800aa72:	460a      	mov	r2, r1
 800aa74:	4313      	orrs	r3, r2
 800aa76:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 800aa7a:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	; 0xd8
 800aa7e:	4623      	mov	r3, r4
 800aa80:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	; 0xb8
 800aa84:	4602      	mov	r2, r0
 800aa86:	189b      	adds	r3, r3, r2
 800aa88:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 800aa8c:	462b      	mov	r3, r5
 800aa8e:	460a      	mov	r2, r1
 800aa90:	4153      	adcs	r3, r2
 800aa92:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800aa96:	4abe      	ldr	r2, [pc, #760]	; (800ad90 <sha512ProcessBlock+0x6c0>)
 800aa98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800aa9c:	00db      	lsls	r3, r3, #3
 800aa9e:	4413      	add	r3, r2
 800aaa0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aaa4:	e9d7 452c 	ldrd	r4, r5, [r7, #176]	; 0xb0
 800aaa8:	4621      	mov	r1, r4
 800aaaa:	1889      	adds	r1, r1, r2
 800aaac:	f8c7 10a8 	str.w	r1, [r7, #168]	; 0xa8
 800aab0:	4629      	mov	r1, r5
 800aab2:	eb41 0303 	adc.w	r3, r1, r3
 800aab6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800aaba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800aabe:	f003 030f 	and.w	r3, r3, #15
 800aac2:	00da      	lsls	r2, r3, #3
 800aac4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800aac8:	4413      	add	r3, r2
 800aaca:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aace:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	; 0xa8
 800aad2:	4621      	mov	r1, r4
 800aad4:	1889      	adds	r1, r1, r2
 800aad6:	61b9      	str	r1, [r7, #24]
 800aad8:	4629      	mov	r1, r5
 800aada:	eb41 0303 	adc.w	r3, r1, r3
 800aade:	61fb      	str	r3, [r7, #28]
 800aae0:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800aae4:	e9c7 3458 	strd	r3, r4, [r7, #352]	; 0x160
      temp2 = SIGMA1(a) + MAJ(a, b, c);
 800aae8:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800aaec:	011a      	lsls	r2, r3, #4
 800aaee:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800aaf2:	0f1b      	lsrs	r3, r3, #28
 800aaf4:	4313      	orrs	r3, r2
 800aaf6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 800aafa:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800aafe:	011a      	lsls	r2, r3, #4
 800ab00:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800ab04:	0f1b      	lsrs	r3, r3, #28
 800ab06:	4313      	orrs	r3, r2
 800ab08:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 800ab0c:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800ab10:	089a      	lsrs	r2, r3, #2
 800ab12:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800ab16:	079b      	lsls	r3, r3, #30
 800ab18:	4313      	orrs	r3, r2
 800ab1a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800ab1e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800ab22:	089a      	lsrs	r2, r3, #2
 800ab24:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800ab28:	079b      	lsls	r3, r3, #30
 800ab2a:	4313      	orrs	r3, r2
 800ab2c:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800ab30:	e9d7 4528 	ldrd	r4, r5, [r7, #160]	; 0xa0
 800ab34:	4623      	mov	r3, r4
 800ab36:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 800ab3a:	4602      	mov	r2, r0
 800ab3c:	4053      	eors	r3, r2
 800ab3e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800ab42:	462b      	mov	r3, r5
 800ab44:	460a      	mov	r2, r1
 800ab46:	4053      	eors	r3, r2
 800ab48:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800ab4c:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800ab50:	09da      	lsrs	r2, r3, #7
 800ab52:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800ab56:	065b      	lsls	r3, r3, #25
 800ab58:	4313      	orrs	r3, r2
 800ab5a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800ab5e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 800ab62:	09da      	lsrs	r2, r3, #7
 800ab64:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 800ab68:	065b      	lsls	r3, r3, #25
 800ab6a:	4313      	orrs	r3, r2
 800ab6c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800ab70:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	; 0x90
 800ab74:	4623      	mov	r3, r4
 800ab76:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	; 0x88
 800ab7a:	4602      	mov	r2, r0
 800ab7c:	4053      	eors	r3, r2
 800ab7e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ab82:	462b      	mov	r3, r5
 800ab84:	460a      	mov	r2, r1
 800ab86:	4053      	eors	r3, r2
 800ab88:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800ab8c:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	; 0x1a0
 800ab90:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	; 0x198
 800ab94:	ea40 0402 	orr.w	r4, r0, r2
 800ab98:	67bc      	str	r4, [r7, #120]	; 0x78
 800ab9a:	430b      	orrs	r3, r1
 800ab9c:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ab9e:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	; 0x1a8
 800aba2:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	; 0x78
 800aba6:	4621      	mov	r1, r4
 800aba8:	4011      	ands	r1, r2
 800abaa:	6739      	str	r1, [r7, #112]	; 0x70
 800abac:	4629      	mov	r1, r5
 800abae:	400b      	ands	r3, r1
 800abb0:	677b      	str	r3, [r7, #116]	; 0x74
 800abb2:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	; 0x1a0
 800abb6:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	; 0x198
 800abba:	ea00 0402 	and.w	r4, r0, r2
 800abbe:	66bc      	str	r4, [r7, #104]	; 0x68
 800abc0:	400b      	ands	r3, r1
 800abc2:	66fb      	str	r3, [r7, #108]	; 0x6c
 800abc4:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	; 0x70
 800abc8:	4623      	mov	r3, r4
 800abca:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	; 0x68
 800abce:	4602      	mov	r2, r0
 800abd0:	4313      	orrs	r3, r2
 800abd2:	663b      	str	r3, [r7, #96]	; 0x60
 800abd4:	462b      	mov	r3, r5
 800abd6:	460a      	mov	r2, r1
 800abd8:	4313      	orrs	r3, r2
 800abda:	667b      	str	r3, [r7, #100]	; 0x64
 800abdc:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	; 0x80
 800abe0:	4623      	mov	r3, r4
 800abe2:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 800abe6:	4602      	mov	r2, r0
 800abe8:	189b      	adds	r3, r3, r2
 800abea:	613b      	str	r3, [r7, #16]
 800abec:	462b      	mov	r3, r5
 800abee:	460a      	mov	r2, r1
 800abf0:	4153      	adcs	r3, r2
 800abf2:	617b      	str	r3, [r7, #20]
 800abf4:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800abf8:	e9c7 3456 	strd	r3, r4, [r7, #344]	; 0x158

      //Update the working registers
      h = g;
 800abfc:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	; 0x178
 800ac00:	e9c7 235c 	strd	r2, r3, [r7, #368]	; 0x170
      g = f;
 800ac04:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	; 0x180
 800ac08:	e9c7 235e 	strd	r2, r3, [r7, #376]	; 0x178
      f = e;
 800ac0c:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	; 0x188
 800ac10:	e9c7 2360 	strd	r2, r3, [r7, #384]	; 0x180
      e = d + temp1;
 800ac14:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	; 0x190
 800ac18:	e9d7 2358 	ldrd	r2, r3, [r7, #352]	; 0x160
 800ac1c:	1884      	adds	r4, r0, r2
 800ac1e:	60bc      	str	r4, [r7, #8]
 800ac20:	eb41 0303 	adc.w	r3, r1, r3
 800ac24:	60fb      	str	r3, [r7, #12]
 800ac26:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800ac2a:	e9c7 3462 	strd	r3, r4, [r7, #392]	; 0x188
      d = c;
 800ac2e:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	; 0x198
 800ac32:	e9c7 2364 	strd	r2, r3, [r7, #400]	; 0x190
      c = b;
 800ac36:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	; 0x1a0
 800ac3a:	e9c7 2366 	strd	r2, r3, [r7, #408]	; 0x198
      b = a;
 800ac3e:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	; 0x1a8
 800ac42:	e9c7 2368 	strd	r2, r3, [r7, #416]	; 0x1a0
      a = temp1 + temp2;
 800ac46:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	; 0x160
 800ac4a:	e9d7 2356 	ldrd	r2, r3, [r7, #344]	; 0x158
 800ac4e:	1884      	adds	r4, r0, r2
 800ac50:	603c      	str	r4, [r7, #0]
 800ac52:	eb41 0303 	adc.w	r3, r1, r3
 800ac56:	607b      	str	r3, [r7, #4]
 800ac58:	e9d7 3400 	ldrd	r3, r4, [r7]
 800ac5c:	e9c7 346a 	strd	r3, r4, [r7, #424]	; 0x1a8
   for(t = 0; t < 80; t++)
 800ac60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800ac64:	3301      	adds	r3, #1
 800ac66:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 800ac6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 800ac6e:	2b4f      	cmp	r3, #79	; 0x4f
 800ac70:	f67f ad8e 	bls.w	800a790 <sha512ProcessBlock+0xc0>
   }

   //Update the hash value
   context->h[0] += a;
 800ac74:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ac78:	e9d3 0100 	ldrd	r0, r1, [r3]
 800ac7c:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	; 0x1a8
 800ac80:	1884      	adds	r4, r0, r2
 800ac82:	65bc      	str	r4, [r7, #88]	; 0x58
 800ac84:	eb41 0303 	adc.w	r3, r1, r3
 800ac88:	65fb      	str	r3, [r7, #92]	; 0x5c
 800ac8a:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ac8e:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
 800ac92:	e9c3 1200 	strd	r1, r2, [r3]
   context->h[1] += b;
 800ac96:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ac9a:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800ac9e:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	; 0x1a0
 800aca2:	1884      	adds	r4, r0, r2
 800aca4:	653c      	str	r4, [r7, #80]	; 0x50
 800aca6:	eb41 0303 	adc.w	r3, r1, r3
 800acaa:	657b      	str	r3, [r7, #84]	; 0x54
 800acac:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800acb0:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 800acb4:	e9c3 1202 	strd	r1, r2, [r3, #8]
   context->h[2] += c;
 800acb8:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800acbc:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800acc0:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	; 0x198
 800acc4:	1884      	adds	r4, r0, r2
 800acc6:	64bc      	str	r4, [r7, #72]	; 0x48
 800acc8:	eb41 0303 	adc.w	r3, r1, r3
 800accc:	64fb      	str	r3, [r7, #76]	; 0x4c
 800acce:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800acd2:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 800acd6:	e9c3 1204 	strd	r1, r2, [r3, #16]
   context->h[3] += d;
 800acda:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800acde:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800ace2:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	; 0x190
 800ace6:	1884      	adds	r4, r0, r2
 800ace8:	643c      	str	r4, [r7, #64]	; 0x40
 800acea:	eb41 0303 	adc.w	r3, r1, r3
 800acee:	647b      	str	r3, [r7, #68]	; 0x44
 800acf0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800acf4:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
 800acf8:	e9c3 1206 	strd	r1, r2, [r3, #24]
   context->h[4] += e;
 800acfc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad00:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800ad04:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	; 0x188
 800ad08:	1884      	adds	r4, r0, r2
 800ad0a:	63bc      	str	r4, [r7, #56]	; 0x38
 800ad0c:	eb41 0303 	adc.w	r3, r1, r3
 800ad10:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ad12:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad16:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 800ad1a:	e9c3 1208 	strd	r1, r2, [r3, #32]
   context->h[5] += f;
 800ad1e:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad22:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	; 0x28
 800ad26:	e9d7 2360 	ldrd	r2, r3, [r7, #384]	; 0x180
 800ad2a:	1884      	adds	r4, r0, r2
 800ad2c:	633c      	str	r4, [r7, #48]	; 0x30
 800ad2e:	eb41 0303 	adc.w	r3, r1, r3
 800ad32:	637b      	str	r3, [r7, #52]	; 0x34
 800ad34:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad38:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 800ad3c:	e9c3 120a 	strd	r1, r2, [r3, #40]	; 0x28
   context->h[6] += g;
 800ad40:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad44:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	; 0x30
 800ad48:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	; 0x178
 800ad4c:	1884      	adds	r4, r0, r2
 800ad4e:	62bc      	str	r4, [r7, #40]	; 0x28
 800ad50:	eb41 0303 	adc.w	r3, r1, r3
 800ad54:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ad56:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad5a:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 800ad5e:	e9c3 120c 	strd	r1, r2, [r3, #48]	; 0x30
   context->h[7] += h;
 800ad62:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad66:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	; 0x38
 800ad6a:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	; 0x170
 800ad6e:	1884      	adds	r4, r0, r2
 800ad70:	623c      	str	r4, [r7, #32]
 800ad72:	eb41 0303 	adc.w	r3, r1, r3
 800ad76:	627b      	str	r3, [r7, #36]	; 0x24
 800ad78:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ad7c:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 800ad80:	e9c3 120e 	strd	r1, r2, [r3, #56]	; 0x38
}
 800ad84:	bf00      	nop
 800ad86:	f507 77dc 	add.w	r7, r7, #440	; 0x1b8
 800ad8a:	46bd      	mov	sp, r7
 800ad8c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800ad90:	0800f6b0 	.word	0x0800f6b0

0800ad94 <aesInit>:
 * @return Error code
 **/

__weak_func error_t aesInit(AesContext *context, const uint8_t *key,
   size_t keyLen)
{
 800ad94:	b480      	push	{r7}
 800ad96:	b089      	sub	sp, #36	; 0x24
 800ad98:	af00      	add	r7, sp, #0
 800ad9a:	60f8      	str	r0, [r7, #12]
 800ad9c:	60b9      	str	r1, [r7, #8]
 800ad9e:	607a      	str	r2, [r7, #4]
   uint_t i;
   uint32_t temp;
   size_t keyScheduleSize;

   //Check parameters
   if(context == NULL || key == NULL)
 800ada0:	68fb      	ldr	r3, [r7, #12]
 800ada2:	2b00      	cmp	r3, #0
 800ada4:	d002      	beq.n	800adac <aesInit+0x18>
 800ada6:	68bb      	ldr	r3, [r7, #8]
 800ada8:	2b00      	cmp	r3, #0
 800adaa:	d101      	bne.n	800adb0 <aesInit+0x1c>
      return ERROR_INVALID_PARAMETER;
 800adac:	2302      	movs	r3, #2
 800adae:	e1a9      	b.n	800b104 <aesInit+0x370>

   //Check the length of the key
   if(keyLen == 16)
 800adb0:	687b      	ldr	r3, [r7, #4]
 800adb2:	2b10      	cmp	r3, #16
 800adb4:	d103      	bne.n	800adbe <aesInit+0x2a>
   {
      //10 rounds are required for 128-bit key
      context->nr = 10;
 800adb6:	68fb      	ldr	r3, [r7, #12]
 800adb8:	220a      	movs	r2, #10
 800adba:	601a      	str	r2, [r3, #0]
 800adbc:	e00f      	b.n	800adde <aesInit+0x4a>
   }
   else if(keyLen == 24)
 800adbe:	687b      	ldr	r3, [r7, #4]
 800adc0:	2b18      	cmp	r3, #24
 800adc2:	d103      	bne.n	800adcc <aesInit+0x38>
   {
      //12 rounds are required for 192-bit key
      context->nr = 12;
 800adc4:	68fb      	ldr	r3, [r7, #12]
 800adc6:	220c      	movs	r2, #12
 800adc8:	601a      	str	r2, [r3, #0]
 800adca:	e008      	b.n	800adde <aesInit+0x4a>
   }
   else if(keyLen == 32)
 800adcc:	687b      	ldr	r3, [r7, #4]
 800adce:	2b20      	cmp	r3, #32
 800add0:	d103      	bne.n	800adda <aesInit+0x46>
   {
      //14 rounds are required for 256-bit key
      context->nr = 14;
 800add2:	68fb      	ldr	r3, [r7, #12]
 800add4:	220e      	movs	r2, #14
 800add6:	601a      	str	r2, [r3, #0]
 800add8:	e001      	b.n	800adde <aesInit+0x4a>
   }
   else
   {
      //Report an error
      return ERROR_INVALID_KEY_LENGTH;
 800adda:	23e8      	movs	r3, #232	; 0xe8
 800addc:	e192      	b.n	800b104 <aesInit+0x370>
   }

   //Determine the number of 32-bit words in the key
   keyLen /= 4;
 800adde:	687b      	ldr	r3, [r7, #4]
 800ade0:	089b      	lsrs	r3, r3, #2
 800ade2:	607b      	str	r3, [r7, #4]

   //Copy the original key
   for(i = 0; i < keyLen; i++)
 800ade4:	2300      	movs	r3, #0
 800ade6:	61fb      	str	r3, [r7, #28]
 800ade8:	e026      	b.n	800ae38 <aesInit+0xa4>
   {
      context->ek[i] = LOAD32LE(key + (i * 4));
 800adea:	69fb      	ldr	r3, [r7, #28]
 800adec:	009b      	lsls	r3, r3, #2
 800adee:	68ba      	ldr	r2, [r7, #8]
 800adf0:	4413      	add	r3, r2
 800adf2:	781b      	ldrb	r3, [r3, #0]
 800adf4:	4619      	mov	r1, r3
 800adf6:	69fb      	ldr	r3, [r7, #28]
 800adf8:	009b      	lsls	r3, r3, #2
 800adfa:	68ba      	ldr	r2, [r7, #8]
 800adfc:	4413      	add	r3, r2
 800adfe:	3301      	adds	r3, #1
 800ae00:	781b      	ldrb	r3, [r3, #0]
 800ae02:	021b      	lsls	r3, r3, #8
 800ae04:	ea41 0203 	orr.w	r2, r1, r3
 800ae08:	69fb      	ldr	r3, [r7, #28]
 800ae0a:	009b      	lsls	r3, r3, #2
 800ae0c:	68b9      	ldr	r1, [r7, #8]
 800ae0e:	440b      	add	r3, r1
 800ae10:	3302      	adds	r3, #2
 800ae12:	781b      	ldrb	r3, [r3, #0]
 800ae14:	041b      	lsls	r3, r3, #16
 800ae16:	431a      	orrs	r2, r3
 800ae18:	69fb      	ldr	r3, [r7, #28]
 800ae1a:	009b      	lsls	r3, r3, #2
 800ae1c:	68b9      	ldr	r1, [r7, #8]
 800ae1e:	440b      	add	r3, r1
 800ae20:	3303      	adds	r3, #3
 800ae22:	781b      	ldrb	r3, [r3, #0]
 800ae24:	061b      	lsls	r3, r3, #24
 800ae26:	431a      	orrs	r2, r3
 800ae28:	68f9      	ldr	r1, [r7, #12]
 800ae2a:	69fb      	ldr	r3, [r7, #28]
 800ae2c:	009b      	lsls	r3, r3, #2
 800ae2e:	440b      	add	r3, r1
 800ae30:	605a      	str	r2, [r3, #4]
   for(i = 0; i < keyLen; i++)
 800ae32:	69fb      	ldr	r3, [r7, #28]
 800ae34:	3301      	adds	r3, #1
 800ae36:	61fb      	str	r3, [r7, #28]
 800ae38:	69fa      	ldr	r2, [r7, #28]
 800ae3a:	687b      	ldr	r3, [r7, #4]
 800ae3c:	429a      	cmp	r2, r3
 800ae3e:	d3d4      	bcc.n	800adea <aesInit+0x56>
   }

   //The size of the key schedule depends on the number of rounds
   keyScheduleSize = 4 * (context->nr + 1);
 800ae40:	68fb      	ldr	r3, [r7, #12]
 800ae42:	681b      	ldr	r3, [r3, #0]
 800ae44:	3301      	adds	r3, #1
 800ae46:	009b      	lsls	r3, r3, #2
 800ae48:	61bb      	str	r3, [r7, #24]

   //Generate the key schedule (encryption)
   for(i = keyLen; i < keyScheduleSize; i++)
 800ae4a:	687b      	ldr	r3, [r7, #4]
 800ae4c:	61fb      	str	r3, [r7, #28]
 800ae4e:	e0c4      	b.n	800afda <aesInit+0x246>
   {
      //Save previous word
      temp = context->ek[i - 1];
 800ae50:	69fb      	ldr	r3, [r7, #28]
 800ae52:	3b01      	subs	r3, #1
 800ae54:	68fa      	ldr	r2, [r7, #12]
 800ae56:	009b      	lsls	r3, r3, #2
 800ae58:	4413      	add	r3, r2
 800ae5a:	685b      	ldr	r3, [r3, #4]
 800ae5c:	617b      	str	r3, [r7, #20]

      //Apply transformation
      if((i % keyLen) == 0)
 800ae5e:	69fb      	ldr	r3, [r7, #28]
 800ae60:	687a      	ldr	r2, [r7, #4]
 800ae62:	fbb3 f2f2 	udiv	r2, r3, r2
 800ae66:	6879      	ldr	r1, [r7, #4]
 800ae68:	fb01 f202 	mul.w	r2, r1, r2
 800ae6c:	1a9b      	subs	r3, r3, r2
 800ae6e:	2b00      	cmp	r3, #0
 800ae70:	d14e      	bne.n	800af10 <aesInit+0x17c>
      {
         context->ek[i] = sbox[(temp >> 8) & 0xFF];
 800ae72:	697b      	ldr	r3, [r7, #20]
 800ae74:	0a1b      	lsrs	r3, r3, #8
 800ae76:	b2db      	uxtb	r3, r3
 800ae78:	4a66      	ldr	r2, [pc, #408]	; (800b014 <aesInit+0x280>)
 800ae7a:	5cd3      	ldrb	r3, [r2, r3]
 800ae7c:	4619      	mov	r1, r3
 800ae7e:	68fa      	ldr	r2, [r7, #12]
 800ae80:	69fb      	ldr	r3, [r7, #28]
 800ae82:	009b      	lsls	r3, r3, #2
 800ae84:	4413      	add	r3, r2
 800ae86:	6059      	str	r1, [r3, #4]
         context->ek[i] |= (sbox[(temp >> 16) & 0xFF] << 8);
 800ae88:	68fa      	ldr	r2, [r7, #12]
 800ae8a:	69fb      	ldr	r3, [r7, #28]
 800ae8c:	009b      	lsls	r3, r3, #2
 800ae8e:	4413      	add	r3, r2
 800ae90:	685b      	ldr	r3, [r3, #4]
 800ae92:	697a      	ldr	r2, [r7, #20]
 800ae94:	0c12      	lsrs	r2, r2, #16
 800ae96:	b2d2      	uxtb	r2, r2
 800ae98:	495e      	ldr	r1, [pc, #376]	; (800b014 <aesInit+0x280>)
 800ae9a:	5c8a      	ldrb	r2, [r1, r2]
 800ae9c:	0212      	lsls	r2, r2, #8
 800ae9e:	431a      	orrs	r2, r3
 800aea0:	68f9      	ldr	r1, [r7, #12]
 800aea2:	69fb      	ldr	r3, [r7, #28]
 800aea4:	009b      	lsls	r3, r3, #2
 800aea6:	440b      	add	r3, r1
 800aea8:	605a      	str	r2, [r3, #4]
         context->ek[i] |= (sbox[(temp >> 24) & 0xFF] << 16);
 800aeaa:	68fa      	ldr	r2, [r7, #12]
 800aeac:	69fb      	ldr	r3, [r7, #28]
 800aeae:	009b      	lsls	r3, r3, #2
 800aeb0:	4413      	add	r3, r2
 800aeb2:	685b      	ldr	r3, [r3, #4]
 800aeb4:	697a      	ldr	r2, [r7, #20]
 800aeb6:	0e12      	lsrs	r2, r2, #24
 800aeb8:	4956      	ldr	r1, [pc, #344]	; (800b014 <aesInit+0x280>)
 800aeba:	5c8a      	ldrb	r2, [r1, r2]
 800aebc:	0412      	lsls	r2, r2, #16
 800aebe:	431a      	orrs	r2, r3
 800aec0:	68f9      	ldr	r1, [r7, #12]
 800aec2:	69fb      	ldr	r3, [r7, #28]
 800aec4:	009b      	lsls	r3, r3, #2
 800aec6:	440b      	add	r3, r1
 800aec8:	605a      	str	r2, [r3, #4]
         context->ek[i] |= (sbox[temp & 0xFF] << 24);
 800aeca:	68fa      	ldr	r2, [r7, #12]
 800aecc:	69fb      	ldr	r3, [r7, #28]
 800aece:	009b      	lsls	r3, r3, #2
 800aed0:	4413      	add	r3, r2
 800aed2:	685b      	ldr	r3, [r3, #4]
 800aed4:	697a      	ldr	r2, [r7, #20]
 800aed6:	b2d2      	uxtb	r2, r2
 800aed8:	494e      	ldr	r1, [pc, #312]	; (800b014 <aesInit+0x280>)
 800aeda:	5c8a      	ldrb	r2, [r1, r2]
 800aedc:	0612      	lsls	r2, r2, #24
 800aede:	431a      	orrs	r2, r3
 800aee0:	68f9      	ldr	r1, [r7, #12]
 800aee2:	69fb      	ldr	r3, [r7, #28]
 800aee4:	009b      	lsls	r3, r3, #2
 800aee6:	440b      	add	r3, r1
 800aee8:	605a      	str	r2, [r3, #4]
         context->ek[i] ^= rcon[i / keyLen];
 800aeea:	68fa      	ldr	r2, [r7, #12]
 800aeec:	69fb      	ldr	r3, [r7, #28]
 800aeee:	009b      	lsls	r3, r3, #2
 800aef0:	4413      	add	r3, r2
 800aef2:	685a      	ldr	r2, [r3, #4]
 800aef4:	69f9      	ldr	r1, [r7, #28]
 800aef6:	687b      	ldr	r3, [r7, #4]
 800aef8:	fbb1 f3f3 	udiv	r3, r1, r3
 800aefc:	4946      	ldr	r1, [pc, #280]	; (800b018 <aesInit+0x284>)
 800aefe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800af02:	405a      	eors	r2, r3
 800af04:	68f9      	ldr	r1, [r7, #12]
 800af06:	69fb      	ldr	r3, [r7, #28]
 800af08:	009b      	lsls	r3, r3, #2
 800af0a:	440b      	add	r3, r1
 800af0c:	605a      	str	r2, [r3, #4]
 800af0e:	e04f      	b.n	800afb0 <aesInit+0x21c>
      }
      else if(keyLen > 6 && (i % keyLen) == 4)
 800af10:	687b      	ldr	r3, [r7, #4]
 800af12:	2b06      	cmp	r3, #6
 800af14:	d946      	bls.n	800afa4 <aesInit+0x210>
 800af16:	69fb      	ldr	r3, [r7, #28]
 800af18:	687a      	ldr	r2, [r7, #4]
 800af1a:	fbb3 f2f2 	udiv	r2, r3, r2
 800af1e:	6879      	ldr	r1, [r7, #4]
 800af20:	fb01 f202 	mul.w	r2, r1, r2
 800af24:	1a9b      	subs	r3, r3, r2
 800af26:	2b04      	cmp	r3, #4
 800af28:	d13c      	bne.n	800afa4 <aesInit+0x210>
      {
         context->ek[i] = sbox[temp & 0xFF];
 800af2a:	697b      	ldr	r3, [r7, #20]
 800af2c:	b2db      	uxtb	r3, r3
 800af2e:	4a39      	ldr	r2, [pc, #228]	; (800b014 <aesInit+0x280>)
 800af30:	5cd3      	ldrb	r3, [r2, r3]
 800af32:	4619      	mov	r1, r3
 800af34:	68fa      	ldr	r2, [r7, #12]
 800af36:	69fb      	ldr	r3, [r7, #28]
 800af38:	009b      	lsls	r3, r3, #2
 800af3a:	4413      	add	r3, r2
 800af3c:	6059      	str	r1, [r3, #4]
         context->ek[i] |= (sbox[(temp >> 8) & 0xFF] << 8);
 800af3e:	68fa      	ldr	r2, [r7, #12]
 800af40:	69fb      	ldr	r3, [r7, #28]
 800af42:	009b      	lsls	r3, r3, #2
 800af44:	4413      	add	r3, r2
 800af46:	685b      	ldr	r3, [r3, #4]
 800af48:	697a      	ldr	r2, [r7, #20]
 800af4a:	0a12      	lsrs	r2, r2, #8
 800af4c:	b2d2      	uxtb	r2, r2
 800af4e:	4931      	ldr	r1, [pc, #196]	; (800b014 <aesInit+0x280>)
 800af50:	5c8a      	ldrb	r2, [r1, r2]
 800af52:	0212      	lsls	r2, r2, #8
 800af54:	431a      	orrs	r2, r3
 800af56:	68f9      	ldr	r1, [r7, #12]
 800af58:	69fb      	ldr	r3, [r7, #28]
 800af5a:	009b      	lsls	r3, r3, #2
 800af5c:	440b      	add	r3, r1
 800af5e:	605a      	str	r2, [r3, #4]
         context->ek[i] |= (sbox[(temp >> 16) & 0xFF] << 16);
 800af60:	68fa      	ldr	r2, [r7, #12]
 800af62:	69fb      	ldr	r3, [r7, #28]
 800af64:	009b      	lsls	r3, r3, #2
 800af66:	4413      	add	r3, r2
 800af68:	685b      	ldr	r3, [r3, #4]
 800af6a:	697a      	ldr	r2, [r7, #20]
 800af6c:	0c12      	lsrs	r2, r2, #16
 800af6e:	b2d2      	uxtb	r2, r2
 800af70:	4928      	ldr	r1, [pc, #160]	; (800b014 <aesInit+0x280>)
 800af72:	5c8a      	ldrb	r2, [r1, r2]
 800af74:	0412      	lsls	r2, r2, #16
 800af76:	431a      	orrs	r2, r3
 800af78:	68f9      	ldr	r1, [r7, #12]
 800af7a:	69fb      	ldr	r3, [r7, #28]
 800af7c:	009b      	lsls	r3, r3, #2
 800af7e:	440b      	add	r3, r1
 800af80:	605a      	str	r2, [r3, #4]
         context->ek[i] |= (sbox[(temp >> 24) & 0xFF] << 24);
 800af82:	68fa      	ldr	r2, [r7, #12]
 800af84:	69fb      	ldr	r3, [r7, #28]
 800af86:	009b      	lsls	r3, r3, #2
 800af88:	4413      	add	r3, r2
 800af8a:	685b      	ldr	r3, [r3, #4]
 800af8c:	697a      	ldr	r2, [r7, #20]
 800af8e:	0e12      	lsrs	r2, r2, #24
 800af90:	4920      	ldr	r1, [pc, #128]	; (800b014 <aesInit+0x280>)
 800af92:	5c8a      	ldrb	r2, [r1, r2]
 800af94:	0612      	lsls	r2, r2, #24
 800af96:	431a      	orrs	r2, r3
 800af98:	68f9      	ldr	r1, [r7, #12]
 800af9a:	69fb      	ldr	r3, [r7, #28]
 800af9c:	009b      	lsls	r3, r3, #2
 800af9e:	440b      	add	r3, r1
 800afa0:	605a      	str	r2, [r3, #4]
 800afa2:	e005      	b.n	800afb0 <aesInit+0x21c>
      }
      else
      {
         context->ek[i] = temp;
 800afa4:	68fa      	ldr	r2, [r7, #12]
 800afa6:	69fb      	ldr	r3, [r7, #28]
 800afa8:	009b      	lsls	r3, r3, #2
 800afaa:	4413      	add	r3, r2
 800afac:	697a      	ldr	r2, [r7, #20]
 800afae:	605a      	str	r2, [r3, #4]
      }

      //Update the key schedule
      context->ek[i] ^= context->ek[i - keyLen];
 800afb0:	68fa      	ldr	r2, [r7, #12]
 800afb2:	69fb      	ldr	r3, [r7, #28]
 800afb4:	009b      	lsls	r3, r3, #2
 800afb6:	4413      	add	r3, r2
 800afb8:	685a      	ldr	r2, [r3, #4]
 800afba:	69f9      	ldr	r1, [r7, #28]
 800afbc:	687b      	ldr	r3, [r7, #4]
 800afbe:	1acb      	subs	r3, r1, r3
 800afc0:	68f9      	ldr	r1, [r7, #12]
 800afc2:	009b      	lsls	r3, r3, #2
 800afc4:	440b      	add	r3, r1
 800afc6:	685b      	ldr	r3, [r3, #4]
 800afc8:	405a      	eors	r2, r3
 800afca:	68f9      	ldr	r1, [r7, #12]
 800afcc:	69fb      	ldr	r3, [r7, #28]
 800afce:	009b      	lsls	r3, r3, #2
 800afd0:	440b      	add	r3, r1
 800afd2:	605a      	str	r2, [r3, #4]
   for(i = keyLen; i < keyScheduleSize; i++)
 800afd4:	69fb      	ldr	r3, [r7, #28]
 800afd6:	3301      	adds	r3, #1
 800afd8:	61fb      	str	r3, [r7, #28]
 800afda:	69fa      	ldr	r2, [r7, #28]
 800afdc:	69bb      	ldr	r3, [r7, #24]
 800afde:	429a      	cmp	r2, r3
 800afe0:	f4ff af36 	bcc.w	800ae50 <aesInit+0xbc>
   }

   //Generate the key schedule (decryption)
   for(i = 0; i < keyScheduleSize; i++)
 800afe4:	2300      	movs	r3, #0
 800afe6:	61fb      	str	r3, [r7, #28]
 800afe8:	e086      	b.n	800b0f8 <aesInit+0x364>
   {
      //Apply the InvMixColumns transformation to all round keys but the first
      //and the last
      if(i < 4 || i >= (keyScheduleSize - 4))
 800afea:	69fb      	ldr	r3, [r7, #28]
 800afec:	2b03      	cmp	r3, #3
 800afee:	d904      	bls.n	800affa <aesInit+0x266>
 800aff0:	69bb      	ldr	r3, [r7, #24]
 800aff2:	3b04      	subs	r3, #4
 800aff4:	69fa      	ldr	r2, [r7, #28]
 800aff6:	429a      	cmp	r2, r3
 800aff8:	d310      	bcc.n	800b01c <aesInit+0x288>
      {
         context->dk[i] = context->ek[i];
 800affa:	68fa      	ldr	r2, [r7, #12]
 800affc:	69fb      	ldr	r3, [r7, #28]
 800affe:	009b      	lsls	r3, r3, #2
 800b000:	4413      	add	r3, r2
 800b002:	685a      	ldr	r2, [r3, #4]
 800b004:	68f9      	ldr	r1, [r7, #12]
 800b006:	69fb      	ldr	r3, [r7, #28]
 800b008:	333c      	adds	r3, #60	; 0x3c
 800b00a:	009b      	lsls	r3, r3, #2
 800b00c:	440b      	add	r3, r1
 800b00e:	605a      	str	r2, [r3, #4]
 800b010:	e06f      	b.n	800b0f2 <aesInit+0x35e>
 800b012:	bf00      	nop
 800b014:	0800f930 	.word	0x0800f930
 800b018:	08010230 	.word	0x08010230
      }
      else
      {
         context->dk[i] = td[sbox[context->ek[i] & 0xFF]];
 800b01c:	68fa      	ldr	r2, [r7, #12]
 800b01e:	69fb      	ldr	r3, [r7, #28]
 800b020:	009b      	lsls	r3, r3, #2
 800b022:	4413      	add	r3, r2
 800b024:	685b      	ldr	r3, [r3, #4]
 800b026:	b2db      	uxtb	r3, r3
 800b028:	4a39      	ldr	r2, [pc, #228]	; (800b110 <aesInit+0x37c>)
 800b02a:	5cd3      	ldrb	r3, [r2, r3]
 800b02c:	461a      	mov	r2, r3
 800b02e:	4b39      	ldr	r3, [pc, #228]	; (800b114 <aesInit+0x380>)
 800b030:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800b034:	68f9      	ldr	r1, [r7, #12]
 800b036:	69fb      	ldr	r3, [r7, #28]
 800b038:	333c      	adds	r3, #60	; 0x3c
 800b03a:	009b      	lsls	r3, r3, #2
 800b03c:	440b      	add	r3, r1
 800b03e:	605a      	str	r2, [r3, #4]
         temp = td[sbox[(context->ek[i] >> 8) & 0xFF]];
 800b040:	68fa      	ldr	r2, [r7, #12]
 800b042:	69fb      	ldr	r3, [r7, #28]
 800b044:	009b      	lsls	r3, r3, #2
 800b046:	4413      	add	r3, r2
 800b048:	685b      	ldr	r3, [r3, #4]
 800b04a:	0a1b      	lsrs	r3, r3, #8
 800b04c:	b2db      	uxtb	r3, r3
 800b04e:	4a30      	ldr	r2, [pc, #192]	; (800b110 <aesInit+0x37c>)
 800b050:	5cd3      	ldrb	r3, [r2, r3]
 800b052:	461a      	mov	r2, r3
 800b054:	4b2f      	ldr	r3, [pc, #188]	; (800b114 <aesInit+0x380>)
 800b056:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b05a:	617b      	str	r3, [r7, #20]
         context->dk[i] ^= ROL32(temp, 8);
 800b05c:	68fa      	ldr	r2, [r7, #12]
 800b05e:	69fb      	ldr	r3, [r7, #28]
 800b060:	333c      	adds	r3, #60	; 0x3c
 800b062:	009b      	lsls	r3, r3, #2
 800b064:	4413      	add	r3, r2
 800b066:	685a      	ldr	r2, [r3, #4]
 800b068:	697b      	ldr	r3, [r7, #20]
 800b06a:	ea4f 6333 	mov.w	r3, r3, ror #24
 800b06e:	405a      	eors	r2, r3
 800b070:	68f9      	ldr	r1, [r7, #12]
 800b072:	69fb      	ldr	r3, [r7, #28]
 800b074:	333c      	adds	r3, #60	; 0x3c
 800b076:	009b      	lsls	r3, r3, #2
 800b078:	440b      	add	r3, r1
 800b07a:	605a      	str	r2, [r3, #4]
         temp = td[sbox[(context->ek[i] >> 16) & 0xFF]];
 800b07c:	68fa      	ldr	r2, [r7, #12]
 800b07e:	69fb      	ldr	r3, [r7, #28]
 800b080:	009b      	lsls	r3, r3, #2
 800b082:	4413      	add	r3, r2
 800b084:	685b      	ldr	r3, [r3, #4]
 800b086:	0c1b      	lsrs	r3, r3, #16
 800b088:	b2db      	uxtb	r3, r3
 800b08a:	4a21      	ldr	r2, [pc, #132]	; (800b110 <aesInit+0x37c>)
 800b08c:	5cd3      	ldrb	r3, [r2, r3]
 800b08e:	461a      	mov	r2, r3
 800b090:	4b20      	ldr	r3, [pc, #128]	; (800b114 <aesInit+0x380>)
 800b092:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b096:	617b      	str	r3, [r7, #20]
         context->dk[i] ^= ROL32(temp, 16);
 800b098:	68fa      	ldr	r2, [r7, #12]
 800b09a:	69fb      	ldr	r3, [r7, #28]
 800b09c:	333c      	adds	r3, #60	; 0x3c
 800b09e:	009b      	lsls	r3, r3, #2
 800b0a0:	4413      	add	r3, r2
 800b0a2:	685a      	ldr	r2, [r3, #4]
 800b0a4:	697b      	ldr	r3, [r7, #20]
 800b0a6:	ea4f 4333 	mov.w	r3, r3, ror #16
 800b0aa:	405a      	eors	r2, r3
 800b0ac:	68f9      	ldr	r1, [r7, #12]
 800b0ae:	69fb      	ldr	r3, [r7, #28]
 800b0b0:	333c      	adds	r3, #60	; 0x3c
 800b0b2:	009b      	lsls	r3, r3, #2
 800b0b4:	440b      	add	r3, r1
 800b0b6:	605a      	str	r2, [r3, #4]
         temp = td[sbox[(context->ek[i] >> 24) & 0xFF]];
 800b0b8:	68fa      	ldr	r2, [r7, #12]
 800b0ba:	69fb      	ldr	r3, [r7, #28]
 800b0bc:	009b      	lsls	r3, r3, #2
 800b0be:	4413      	add	r3, r2
 800b0c0:	685b      	ldr	r3, [r3, #4]
 800b0c2:	0e1b      	lsrs	r3, r3, #24
 800b0c4:	4a12      	ldr	r2, [pc, #72]	; (800b110 <aesInit+0x37c>)
 800b0c6:	5cd3      	ldrb	r3, [r2, r3]
 800b0c8:	461a      	mov	r2, r3
 800b0ca:	4b12      	ldr	r3, [pc, #72]	; (800b114 <aesInit+0x380>)
 800b0cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b0d0:	617b      	str	r3, [r7, #20]
         context->dk[i] ^= ROL32(temp, 24);
 800b0d2:	68fa      	ldr	r2, [r7, #12]
 800b0d4:	69fb      	ldr	r3, [r7, #28]
 800b0d6:	333c      	adds	r3, #60	; 0x3c
 800b0d8:	009b      	lsls	r3, r3, #2
 800b0da:	4413      	add	r3, r2
 800b0dc:	685a      	ldr	r2, [r3, #4]
 800b0de:	697b      	ldr	r3, [r7, #20]
 800b0e0:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b0e4:	405a      	eors	r2, r3
 800b0e6:	68f9      	ldr	r1, [r7, #12]
 800b0e8:	69fb      	ldr	r3, [r7, #28]
 800b0ea:	333c      	adds	r3, #60	; 0x3c
 800b0ec:	009b      	lsls	r3, r3, #2
 800b0ee:	440b      	add	r3, r1
 800b0f0:	605a      	str	r2, [r3, #4]
   for(i = 0; i < keyScheduleSize; i++)
 800b0f2:	69fb      	ldr	r3, [r7, #28]
 800b0f4:	3301      	adds	r3, #1
 800b0f6:	61fb      	str	r3, [r7, #28]
 800b0f8:	69fa      	ldr	r2, [r7, #28]
 800b0fa:	69bb      	ldr	r3, [r7, #24]
 800b0fc:	429a      	cmp	r2, r3
 800b0fe:	f4ff af74 	bcc.w	800afea <aesInit+0x256>
      }
   }

   //No error to report
   return NO_ERROR;
 800b102:	2300      	movs	r3, #0
}
 800b104:	4618      	mov	r0, r3
 800b106:	3724      	adds	r7, #36	; 0x24
 800b108:	46bd      	mov	sp, r7
 800b10a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b10e:	4770      	bx	lr
 800b110:	0800f930 	.word	0x0800f930
 800b114:	0800fe30 	.word	0x0800fe30

0800b118 <aesEncryptBlock>:
 * @param[out] output Ciphertext block resulting from encryption
 **/

__weak_func void aesEncryptBlock(AesContext *context, const uint8_t *input,
   uint8_t *output)
{
 800b118:	b480      	push	{r7}
 800b11a:	b08f      	sub	sp, #60	; 0x3c
 800b11c:	af00      	add	r7, sp, #0
 800b11e:	60f8      	str	r0, [r7, #12]
 800b120:	60b9      	str	r1, [r7, #8]
 800b122:	607a      	str	r2, [r7, #4]
   uint32_t t2;
   uint32_t t3;
   uint32_t temp;

   //Copy the plaintext to the state array
   s0 = LOAD32LE(input + 0);
 800b124:	68bb      	ldr	r3, [r7, #8]
 800b126:	781b      	ldrb	r3, [r3, #0]
 800b128:	461a      	mov	r2, r3
 800b12a:	68bb      	ldr	r3, [r7, #8]
 800b12c:	3301      	adds	r3, #1
 800b12e:	781b      	ldrb	r3, [r3, #0]
 800b130:	021b      	lsls	r3, r3, #8
 800b132:	431a      	orrs	r2, r3
 800b134:	68bb      	ldr	r3, [r7, #8]
 800b136:	3302      	adds	r3, #2
 800b138:	781b      	ldrb	r3, [r3, #0]
 800b13a:	041b      	lsls	r3, r3, #16
 800b13c:	431a      	orrs	r2, r3
 800b13e:	68bb      	ldr	r3, [r7, #8]
 800b140:	3303      	adds	r3, #3
 800b142:	781b      	ldrb	r3, [r3, #0]
 800b144:	061b      	lsls	r3, r3, #24
 800b146:	4313      	orrs	r3, r2
 800b148:	633b      	str	r3, [r7, #48]	; 0x30
   s1 = LOAD32LE(input + 4);
 800b14a:	68bb      	ldr	r3, [r7, #8]
 800b14c:	3304      	adds	r3, #4
 800b14e:	781b      	ldrb	r3, [r3, #0]
 800b150:	461a      	mov	r2, r3
 800b152:	68bb      	ldr	r3, [r7, #8]
 800b154:	3304      	adds	r3, #4
 800b156:	3301      	adds	r3, #1
 800b158:	781b      	ldrb	r3, [r3, #0]
 800b15a:	021b      	lsls	r3, r3, #8
 800b15c:	431a      	orrs	r2, r3
 800b15e:	68bb      	ldr	r3, [r7, #8]
 800b160:	3304      	adds	r3, #4
 800b162:	3302      	adds	r3, #2
 800b164:	781b      	ldrb	r3, [r3, #0]
 800b166:	041b      	lsls	r3, r3, #16
 800b168:	431a      	orrs	r2, r3
 800b16a:	68bb      	ldr	r3, [r7, #8]
 800b16c:	3304      	adds	r3, #4
 800b16e:	3303      	adds	r3, #3
 800b170:	781b      	ldrb	r3, [r3, #0]
 800b172:	061b      	lsls	r3, r3, #24
 800b174:	4313      	orrs	r3, r2
 800b176:	62fb      	str	r3, [r7, #44]	; 0x2c
   s2 = LOAD32LE(input + 8);
 800b178:	68bb      	ldr	r3, [r7, #8]
 800b17a:	3308      	adds	r3, #8
 800b17c:	781b      	ldrb	r3, [r3, #0]
 800b17e:	461a      	mov	r2, r3
 800b180:	68bb      	ldr	r3, [r7, #8]
 800b182:	3308      	adds	r3, #8
 800b184:	3301      	adds	r3, #1
 800b186:	781b      	ldrb	r3, [r3, #0]
 800b188:	021b      	lsls	r3, r3, #8
 800b18a:	431a      	orrs	r2, r3
 800b18c:	68bb      	ldr	r3, [r7, #8]
 800b18e:	3308      	adds	r3, #8
 800b190:	3302      	adds	r3, #2
 800b192:	781b      	ldrb	r3, [r3, #0]
 800b194:	041b      	lsls	r3, r3, #16
 800b196:	431a      	orrs	r2, r3
 800b198:	68bb      	ldr	r3, [r7, #8]
 800b19a:	3308      	adds	r3, #8
 800b19c:	3303      	adds	r3, #3
 800b19e:	781b      	ldrb	r3, [r3, #0]
 800b1a0:	061b      	lsls	r3, r3, #24
 800b1a2:	4313      	orrs	r3, r2
 800b1a4:	62bb      	str	r3, [r7, #40]	; 0x28
   s3 = LOAD32LE(input + 12);
 800b1a6:	68bb      	ldr	r3, [r7, #8]
 800b1a8:	330c      	adds	r3, #12
 800b1aa:	781b      	ldrb	r3, [r3, #0]
 800b1ac:	461a      	mov	r2, r3
 800b1ae:	68bb      	ldr	r3, [r7, #8]
 800b1b0:	330c      	adds	r3, #12
 800b1b2:	3301      	adds	r3, #1
 800b1b4:	781b      	ldrb	r3, [r3, #0]
 800b1b6:	021b      	lsls	r3, r3, #8
 800b1b8:	431a      	orrs	r2, r3
 800b1ba:	68bb      	ldr	r3, [r7, #8]
 800b1bc:	330c      	adds	r3, #12
 800b1be:	3302      	adds	r3, #2
 800b1c0:	781b      	ldrb	r3, [r3, #0]
 800b1c2:	041b      	lsls	r3, r3, #16
 800b1c4:	431a      	orrs	r2, r3
 800b1c6:	68bb      	ldr	r3, [r7, #8]
 800b1c8:	330c      	adds	r3, #12
 800b1ca:	3303      	adds	r3, #3
 800b1cc:	781b      	ldrb	r3, [r3, #0]
 800b1ce:	061b      	lsls	r3, r3, #24
 800b1d0:	4313      	orrs	r3, r2
 800b1d2:	627b      	str	r3, [r7, #36]	; 0x24

   //Initial round key addition
   s0 ^= context->ek[0];
 800b1d4:	68fb      	ldr	r3, [r7, #12]
 800b1d6:	685b      	ldr	r3, [r3, #4]
 800b1d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b1da:	4053      	eors	r3, r2
 800b1dc:	633b      	str	r3, [r7, #48]	; 0x30
   s1 ^= context->ek[1];
 800b1de:	68fb      	ldr	r3, [r7, #12]
 800b1e0:	689b      	ldr	r3, [r3, #8]
 800b1e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b1e4:	4053      	eors	r3, r2
 800b1e6:	62fb      	str	r3, [r7, #44]	; 0x2c
   s2 ^= context->ek[2];
 800b1e8:	68fb      	ldr	r3, [r7, #12]
 800b1ea:	68db      	ldr	r3, [r3, #12]
 800b1ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b1ee:	4053      	eors	r3, r2
 800b1f0:	62bb      	str	r3, [r7, #40]	; 0x28
   s3 ^= context->ek[3];
 800b1f2:	68fb      	ldr	r3, [r7, #12]
 800b1f4:	691b      	ldr	r3, [r3, #16]
 800b1f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b1f8:	4053      	eors	r3, r2
 800b1fa:	627b      	str	r3, [r7, #36]	; 0x24

   //The number of rounds depends on the key length
   for(i = 1; i < context->nr; i++)
 800b1fc:	2301      	movs	r3, #1
 800b1fe:	637b      	str	r3, [r7, #52]	; 0x34
 800b200:	e0d9      	b.n	800b3b6 <aesEncryptBlock+0x29e>
   {
      //Apply round function
      t0 = te[s0 & 0xFF];
 800b202:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b204:	b2db      	uxtb	r3, r3
 800b206:	4aa2      	ldr	r2, [pc, #648]	; (800b490 <aesEncryptBlock+0x378>)
 800b208:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b20c:	623b      	str	r3, [r7, #32]
      temp = te[(s1 >> 8) & 0xFF];
 800b20e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b210:	0a1b      	lsrs	r3, r3, #8
 800b212:	b2db      	uxtb	r3, r3
 800b214:	4a9e      	ldr	r2, [pc, #632]	; (800b490 <aesEncryptBlock+0x378>)
 800b216:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b21a:	613b      	str	r3, [r7, #16]
      t0 ^= ROL32(temp, 8);
 800b21c:	693b      	ldr	r3, [r7, #16]
 800b21e:	ea4f 6333 	mov.w	r3, r3, ror #24
 800b222:	6a3a      	ldr	r2, [r7, #32]
 800b224:	4053      	eors	r3, r2
 800b226:	623b      	str	r3, [r7, #32]
      temp = te[(s2 >> 16) & 0xFF];
 800b228:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b22a:	0c1b      	lsrs	r3, r3, #16
 800b22c:	b2db      	uxtb	r3, r3
 800b22e:	4a98      	ldr	r2, [pc, #608]	; (800b490 <aesEncryptBlock+0x378>)
 800b230:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b234:	613b      	str	r3, [r7, #16]
      t0 ^= ROL32(temp, 16);
 800b236:	693b      	ldr	r3, [r7, #16]
 800b238:	ea4f 4333 	mov.w	r3, r3, ror #16
 800b23c:	6a3a      	ldr	r2, [r7, #32]
 800b23e:	4053      	eors	r3, r2
 800b240:	623b      	str	r3, [r7, #32]
      temp = te[(s3 >> 24) & 0xFF];
 800b242:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b244:	0e1b      	lsrs	r3, r3, #24
 800b246:	4a92      	ldr	r2, [pc, #584]	; (800b490 <aesEncryptBlock+0x378>)
 800b248:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b24c:	613b      	str	r3, [r7, #16]
      t0 ^= ROL32(temp, 24);
 800b24e:	693b      	ldr	r3, [r7, #16]
 800b250:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b254:	6a3a      	ldr	r2, [r7, #32]
 800b256:	4053      	eors	r3, r2
 800b258:	623b      	str	r3, [r7, #32]

      t1 = te[s1 & 0xFF];
 800b25a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b25c:	b2db      	uxtb	r3, r3
 800b25e:	4a8c      	ldr	r2, [pc, #560]	; (800b490 <aesEncryptBlock+0x378>)
 800b260:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b264:	61fb      	str	r3, [r7, #28]
      temp = te[(s2 >> 8) & 0xFF];
 800b266:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b268:	0a1b      	lsrs	r3, r3, #8
 800b26a:	b2db      	uxtb	r3, r3
 800b26c:	4a88      	ldr	r2, [pc, #544]	; (800b490 <aesEncryptBlock+0x378>)
 800b26e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b272:	613b      	str	r3, [r7, #16]
      t1 ^= ROL32(temp, 8);
 800b274:	693b      	ldr	r3, [r7, #16]
 800b276:	ea4f 6333 	mov.w	r3, r3, ror #24
 800b27a:	69fa      	ldr	r2, [r7, #28]
 800b27c:	4053      	eors	r3, r2
 800b27e:	61fb      	str	r3, [r7, #28]
      temp = te[(s3 >> 16) & 0xFF];
 800b280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b282:	0c1b      	lsrs	r3, r3, #16
 800b284:	b2db      	uxtb	r3, r3
 800b286:	4a82      	ldr	r2, [pc, #520]	; (800b490 <aesEncryptBlock+0x378>)
 800b288:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b28c:	613b      	str	r3, [r7, #16]
      t1 ^= ROL32(temp, 16);
 800b28e:	693b      	ldr	r3, [r7, #16]
 800b290:	ea4f 4333 	mov.w	r3, r3, ror #16
 800b294:	69fa      	ldr	r2, [r7, #28]
 800b296:	4053      	eors	r3, r2
 800b298:	61fb      	str	r3, [r7, #28]
      temp = te[(s0 >> 24) & 0xFF];
 800b29a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b29c:	0e1b      	lsrs	r3, r3, #24
 800b29e:	4a7c      	ldr	r2, [pc, #496]	; (800b490 <aesEncryptBlock+0x378>)
 800b2a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b2a4:	613b      	str	r3, [r7, #16]
      t1 ^= ROL32(temp, 24);
 800b2a6:	693b      	ldr	r3, [r7, #16]
 800b2a8:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b2ac:	69fa      	ldr	r2, [r7, #28]
 800b2ae:	4053      	eors	r3, r2
 800b2b0:	61fb      	str	r3, [r7, #28]

      t2 = te[s2 & 0xFF];
 800b2b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b2b4:	b2db      	uxtb	r3, r3
 800b2b6:	4a76      	ldr	r2, [pc, #472]	; (800b490 <aesEncryptBlock+0x378>)
 800b2b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b2bc:	61bb      	str	r3, [r7, #24]
      temp = te[(s3 >> 8) & 0xFF];
 800b2be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b2c0:	0a1b      	lsrs	r3, r3, #8
 800b2c2:	b2db      	uxtb	r3, r3
 800b2c4:	4a72      	ldr	r2, [pc, #456]	; (800b490 <aesEncryptBlock+0x378>)
 800b2c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b2ca:	613b      	str	r3, [r7, #16]
      t2 ^= ROL32(temp, 8);
 800b2cc:	693b      	ldr	r3, [r7, #16]
 800b2ce:	ea4f 6333 	mov.w	r3, r3, ror #24
 800b2d2:	69ba      	ldr	r2, [r7, #24]
 800b2d4:	4053      	eors	r3, r2
 800b2d6:	61bb      	str	r3, [r7, #24]
      temp = te[(s0 >> 16) & 0xFF];
 800b2d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b2da:	0c1b      	lsrs	r3, r3, #16
 800b2dc:	b2db      	uxtb	r3, r3
 800b2de:	4a6c      	ldr	r2, [pc, #432]	; (800b490 <aesEncryptBlock+0x378>)
 800b2e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b2e4:	613b      	str	r3, [r7, #16]
      t2 ^= ROL32(temp, 16);
 800b2e6:	693b      	ldr	r3, [r7, #16]
 800b2e8:	ea4f 4333 	mov.w	r3, r3, ror #16
 800b2ec:	69ba      	ldr	r2, [r7, #24]
 800b2ee:	4053      	eors	r3, r2
 800b2f0:	61bb      	str	r3, [r7, #24]
      temp = te[(s1 >> 24) & 0xFF];
 800b2f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2f4:	0e1b      	lsrs	r3, r3, #24
 800b2f6:	4a66      	ldr	r2, [pc, #408]	; (800b490 <aesEncryptBlock+0x378>)
 800b2f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b2fc:	613b      	str	r3, [r7, #16]
      t2 ^= ROL32(temp, 24);
 800b2fe:	693b      	ldr	r3, [r7, #16]
 800b300:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b304:	69ba      	ldr	r2, [r7, #24]
 800b306:	4053      	eors	r3, r2
 800b308:	61bb      	str	r3, [r7, #24]

      t3 = te[s3 & 0xFF];
 800b30a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b30c:	b2db      	uxtb	r3, r3
 800b30e:	4a60      	ldr	r2, [pc, #384]	; (800b490 <aesEncryptBlock+0x378>)
 800b310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b314:	617b      	str	r3, [r7, #20]
      temp = te[(s0 >> 8) & 0xFF];
 800b316:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b318:	0a1b      	lsrs	r3, r3, #8
 800b31a:	b2db      	uxtb	r3, r3
 800b31c:	4a5c      	ldr	r2, [pc, #368]	; (800b490 <aesEncryptBlock+0x378>)
 800b31e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b322:	613b      	str	r3, [r7, #16]
      t3 ^= ROL32(temp, 8);
 800b324:	693b      	ldr	r3, [r7, #16]
 800b326:	ea4f 6333 	mov.w	r3, r3, ror #24
 800b32a:	697a      	ldr	r2, [r7, #20]
 800b32c:	4053      	eors	r3, r2
 800b32e:	617b      	str	r3, [r7, #20]
      temp = te[(s1 >> 16) & 0xFF];
 800b330:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b332:	0c1b      	lsrs	r3, r3, #16
 800b334:	b2db      	uxtb	r3, r3
 800b336:	4a56      	ldr	r2, [pc, #344]	; (800b490 <aesEncryptBlock+0x378>)
 800b338:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b33c:	613b      	str	r3, [r7, #16]
      t3 ^= ROL32(temp, 16);
 800b33e:	693b      	ldr	r3, [r7, #16]
 800b340:	ea4f 4333 	mov.w	r3, r3, ror #16
 800b344:	697a      	ldr	r2, [r7, #20]
 800b346:	4053      	eors	r3, r2
 800b348:	617b      	str	r3, [r7, #20]
      temp = te[(s2 >> 24) & 0xFF];
 800b34a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b34c:	0e1b      	lsrs	r3, r3, #24
 800b34e:	4a50      	ldr	r2, [pc, #320]	; (800b490 <aesEncryptBlock+0x378>)
 800b350:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b354:	613b      	str	r3, [r7, #16]
      t3 ^= ROL32(temp, 24);
 800b356:	693b      	ldr	r3, [r7, #16]
 800b358:	ea4f 2333 	mov.w	r3, r3, ror #8
 800b35c:	697a      	ldr	r2, [r7, #20]
 800b35e:	4053      	eors	r3, r2
 800b360:	617b      	str	r3, [r7, #20]

      //Round key addition
      s0 = t0 ^ context->ek[i * 4];
 800b362:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b364:	009b      	lsls	r3, r3, #2
 800b366:	68fa      	ldr	r2, [r7, #12]
 800b368:	009b      	lsls	r3, r3, #2
 800b36a:	4413      	add	r3, r2
 800b36c:	685b      	ldr	r3, [r3, #4]
 800b36e:	6a3a      	ldr	r2, [r7, #32]
 800b370:	4053      	eors	r3, r2
 800b372:	633b      	str	r3, [r7, #48]	; 0x30
      s1 = t1 ^ context->ek[i * 4 + 1];
 800b374:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b376:	009b      	lsls	r3, r3, #2
 800b378:	3301      	adds	r3, #1
 800b37a:	68fa      	ldr	r2, [r7, #12]
 800b37c:	009b      	lsls	r3, r3, #2
 800b37e:	4413      	add	r3, r2
 800b380:	685b      	ldr	r3, [r3, #4]
 800b382:	69fa      	ldr	r2, [r7, #28]
 800b384:	4053      	eors	r3, r2
 800b386:	62fb      	str	r3, [r7, #44]	; 0x2c
      s2 = t2 ^ context->ek[i * 4 + 2];
 800b388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b38a:	009b      	lsls	r3, r3, #2
 800b38c:	3302      	adds	r3, #2
 800b38e:	68fa      	ldr	r2, [r7, #12]
 800b390:	009b      	lsls	r3, r3, #2
 800b392:	4413      	add	r3, r2
 800b394:	685b      	ldr	r3, [r3, #4]
 800b396:	69ba      	ldr	r2, [r7, #24]
 800b398:	4053      	eors	r3, r2
 800b39a:	62bb      	str	r3, [r7, #40]	; 0x28
      s3 = t3 ^ context->ek[i * 4 + 3];
 800b39c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b39e:	009b      	lsls	r3, r3, #2
 800b3a0:	3303      	adds	r3, #3
 800b3a2:	68fa      	ldr	r2, [r7, #12]
 800b3a4:	009b      	lsls	r3, r3, #2
 800b3a6:	4413      	add	r3, r2
 800b3a8:	685b      	ldr	r3, [r3, #4]
 800b3aa:	697a      	ldr	r2, [r7, #20]
 800b3ac:	4053      	eors	r3, r2
 800b3ae:	627b      	str	r3, [r7, #36]	; 0x24
   for(i = 1; i < context->nr; i++)
 800b3b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b3b2:	3301      	adds	r3, #1
 800b3b4:	637b      	str	r3, [r7, #52]	; 0x34
 800b3b6:	68fb      	ldr	r3, [r7, #12]
 800b3b8:	681b      	ldr	r3, [r3, #0]
 800b3ba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b3bc:	429a      	cmp	r2, r3
 800b3be:	f4ff af20 	bcc.w	800b202 <aesEncryptBlock+0xea>
   }

   //The last round differs slightly from the first rounds
   t0 = sbox[s0 & 0xFF];
 800b3c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b3c4:	b2db      	uxtb	r3, r3
 800b3c6:	4a33      	ldr	r2, [pc, #204]	; (800b494 <aesEncryptBlock+0x37c>)
 800b3c8:	5cd3      	ldrb	r3, [r2, r3]
 800b3ca:	623b      	str	r3, [r7, #32]
   t0 |= sbox[(s1 >> 8) & 0xFF] << 8;
 800b3cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3ce:	0a1b      	lsrs	r3, r3, #8
 800b3d0:	b2db      	uxtb	r3, r3
 800b3d2:	4a30      	ldr	r2, [pc, #192]	; (800b494 <aesEncryptBlock+0x37c>)
 800b3d4:	5cd3      	ldrb	r3, [r2, r3]
 800b3d6:	021b      	lsls	r3, r3, #8
 800b3d8:	461a      	mov	r2, r3
 800b3da:	6a3b      	ldr	r3, [r7, #32]
 800b3dc:	4313      	orrs	r3, r2
 800b3de:	623b      	str	r3, [r7, #32]
   t0 |= sbox[(s2 >> 16) & 0xFF] << 16;
 800b3e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b3e2:	0c1b      	lsrs	r3, r3, #16
 800b3e4:	b2db      	uxtb	r3, r3
 800b3e6:	4a2b      	ldr	r2, [pc, #172]	; (800b494 <aesEncryptBlock+0x37c>)
 800b3e8:	5cd3      	ldrb	r3, [r2, r3]
 800b3ea:	041b      	lsls	r3, r3, #16
 800b3ec:	461a      	mov	r2, r3
 800b3ee:	6a3b      	ldr	r3, [r7, #32]
 800b3f0:	4313      	orrs	r3, r2
 800b3f2:	623b      	str	r3, [r7, #32]
   t0 |= sbox[(s3 >> 24) & 0xFF] << 24;
 800b3f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b3f6:	0e1b      	lsrs	r3, r3, #24
 800b3f8:	4a26      	ldr	r2, [pc, #152]	; (800b494 <aesEncryptBlock+0x37c>)
 800b3fa:	5cd3      	ldrb	r3, [r2, r3]
 800b3fc:	061b      	lsls	r3, r3, #24
 800b3fe:	461a      	mov	r2, r3
 800b400:	6a3b      	ldr	r3, [r7, #32]
 800b402:	4313      	orrs	r3, r2
 800b404:	623b      	str	r3, [r7, #32]

   t1 = sbox[s1 & 0xFF];
 800b406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b408:	b2db      	uxtb	r3, r3
 800b40a:	4a22      	ldr	r2, [pc, #136]	; (800b494 <aesEncryptBlock+0x37c>)
 800b40c:	5cd3      	ldrb	r3, [r2, r3]
 800b40e:	61fb      	str	r3, [r7, #28]
   t1 |= sbox[(s2 >> 8) & 0xFF] << 8;
 800b410:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b412:	0a1b      	lsrs	r3, r3, #8
 800b414:	b2db      	uxtb	r3, r3
 800b416:	4a1f      	ldr	r2, [pc, #124]	; (800b494 <aesEncryptBlock+0x37c>)
 800b418:	5cd3      	ldrb	r3, [r2, r3]
 800b41a:	021b      	lsls	r3, r3, #8
 800b41c:	461a      	mov	r2, r3
 800b41e:	69fb      	ldr	r3, [r7, #28]
 800b420:	4313      	orrs	r3, r2
 800b422:	61fb      	str	r3, [r7, #28]
   t1 |= sbox[(s3 >> 16) & 0xFF] << 16;
 800b424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b426:	0c1b      	lsrs	r3, r3, #16
 800b428:	b2db      	uxtb	r3, r3
 800b42a:	4a1a      	ldr	r2, [pc, #104]	; (800b494 <aesEncryptBlock+0x37c>)
 800b42c:	5cd3      	ldrb	r3, [r2, r3]
 800b42e:	041b      	lsls	r3, r3, #16
 800b430:	461a      	mov	r2, r3
 800b432:	69fb      	ldr	r3, [r7, #28]
 800b434:	4313      	orrs	r3, r2
 800b436:	61fb      	str	r3, [r7, #28]
   t1 |= sbox[(s0 >> 24) & 0xFF] << 24;
 800b438:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b43a:	0e1b      	lsrs	r3, r3, #24
 800b43c:	4a15      	ldr	r2, [pc, #84]	; (800b494 <aesEncryptBlock+0x37c>)
 800b43e:	5cd3      	ldrb	r3, [r2, r3]
 800b440:	061b      	lsls	r3, r3, #24
 800b442:	461a      	mov	r2, r3
 800b444:	69fb      	ldr	r3, [r7, #28]
 800b446:	4313      	orrs	r3, r2
 800b448:	61fb      	str	r3, [r7, #28]

   t2 = sbox[s2 & 0xFF];
 800b44a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b44c:	b2db      	uxtb	r3, r3
 800b44e:	4a11      	ldr	r2, [pc, #68]	; (800b494 <aesEncryptBlock+0x37c>)
 800b450:	5cd3      	ldrb	r3, [r2, r3]
 800b452:	61bb      	str	r3, [r7, #24]
   t2 |= sbox[(s3 >> 8) & 0xFF] << 8;
 800b454:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b456:	0a1b      	lsrs	r3, r3, #8
 800b458:	b2db      	uxtb	r3, r3
 800b45a:	4a0e      	ldr	r2, [pc, #56]	; (800b494 <aesEncryptBlock+0x37c>)
 800b45c:	5cd3      	ldrb	r3, [r2, r3]
 800b45e:	021b      	lsls	r3, r3, #8
 800b460:	461a      	mov	r2, r3
 800b462:	69bb      	ldr	r3, [r7, #24]
 800b464:	4313      	orrs	r3, r2
 800b466:	61bb      	str	r3, [r7, #24]
   t2 |= sbox[(s0 >> 16) & 0xFF] << 16;
 800b468:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b46a:	0c1b      	lsrs	r3, r3, #16
 800b46c:	b2db      	uxtb	r3, r3
 800b46e:	4a09      	ldr	r2, [pc, #36]	; (800b494 <aesEncryptBlock+0x37c>)
 800b470:	5cd3      	ldrb	r3, [r2, r3]
 800b472:	041b      	lsls	r3, r3, #16
 800b474:	461a      	mov	r2, r3
 800b476:	69bb      	ldr	r3, [r7, #24]
 800b478:	4313      	orrs	r3, r2
 800b47a:	61bb      	str	r3, [r7, #24]
   t2 |= sbox[(s1 >> 24) & 0xFF] << 24;
 800b47c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b47e:	0e1b      	lsrs	r3, r3, #24
 800b480:	4a04      	ldr	r2, [pc, #16]	; (800b494 <aesEncryptBlock+0x37c>)
 800b482:	5cd3      	ldrb	r3, [r2, r3]
 800b484:	061b      	lsls	r3, r3, #24
 800b486:	461a      	mov	r2, r3
 800b488:	69bb      	ldr	r3, [r7, #24]
 800b48a:	4313      	orrs	r3, r2
 800b48c:	e004      	b.n	800b498 <aesEncryptBlock+0x380>
 800b48e:	bf00      	nop
 800b490:	0800fa30 	.word	0x0800fa30
 800b494:	0800f930 	.word	0x0800f930
 800b498:	61bb      	str	r3, [r7, #24]

   t3 = sbox[s3 & 0xFF];
 800b49a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b49c:	b2db      	uxtb	r3, r3
 800b49e:	4a56      	ldr	r2, [pc, #344]	; (800b5f8 <aesEncryptBlock+0x4e0>)
 800b4a0:	5cd3      	ldrb	r3, [r2, r3]
 800b4a2:	617b      	str	r3, [r7, #20]
   t3 |= sbox[(s0 >> 8) & 0xFF] << 8;
 800b4a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b4a6:	0a1b      	lsrs	r3, r3, #8
 800b4a8:	b2db      	uxtb	r3, r3
 800b4aa:	4a53      	ldr	r2, [pc, #332]	; (800b5f8 <aesEncryptBlock+0x4e0>)
 800b4ac:	5cd3      	ldrb	r3, [r2, r3]
 800b4ae:	021b      	lsls	r3, r3, #8
 800b4b0:	461a      	mov	r2, r3
 800b4b2:	697b      	ldr	r3, [r7, #20]
 800b4b4:	4313      	orrs	r3, r2
 800b4b6:	617b      	str	r3, [r7, #20]
   t3 |= sbox[(s1 >> 16) & 0xFF] << 16;
 800b4b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4ba:	0c1b      	lsrs	r3, r3, #16
 800b4bc:	b2db      	uxtb	r3, r3
 800b4be:	4a4e      	ldr	r2, [pc, #312]	; (800b5f8 <aesEncryptBlock+0x4e0>)
 800b4c0:	5cd3      	ldrb	r3, [r2, r3]
 800b4c2:	041b      	lsls	r3, r3, #16
 800b4c4:	461a      	mov	r2, r3
 800b4c6:	697b      	ldr	r3, [r7, #20]
 800b4c8:	4313      	orrs	r3, r2
 800b4ca:	617b      	str	r3, [r7, #20]
   t3 |= sbox[(s2 >> 24) & 0xFF] << 24;
 800b4cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4ce:	0e1b      	lsrs	r3, r3, #24
 800b4d0:	4a49      	ldr	r2, [pc, #292]	; (800b5f8 <aesEncryptBlock+0x4e0>)
 800b4d2:	5cd3      	ldrb	r3, [r2, r3]
 800b4d4:	061b      	lsls	r3, r3, #24
 800b4d6:	461a      	mov	r2, r3
 800b4d8:	697b      	ldr	r3, [r7, #20]
 800b4da:	4313      	orrs	r3, r2
 800b4dc:	617b      	str	r3, [r7, #20]

   //Last round key addition
   s0 = t0 ^ context->ek[context->nr * 4];
 800b4de:	68fb      	ldr	r3, [r7, #12]
 800b4e0:	681b      	ldr	r3, [r3, #0]
 800b4e2:	009b      	lsls	r3, r3, #2
 800b4e4:	68fa      	ldr	r2, [r7, #12]
 800b4e6:	009b      	lsls	r3, r3, #2
 800b4e8:	4413      	add	r3, r2
 800b4ea:	685b      	ldr	r3, [r3, #4]
 800b4ec:	6a3a      	ldr	r2, [r7, #32]
 800b4ee:	4053      	eors	r3, r2
 800b4f0:	633b      	str	r3, [r7, #48]	; 0x30
   s1 = t1 ^ context->ek[context->nr * 4 + 1];
 800b4f2:	68fb      	ldr	r3, [r7, #12]
 800b4f4:	681b      	ldr	r3, [r3, #0]
 800b4f6:	009b      	lsls	r3, r3, #2
 800b4f8:	3301      	adds	r3, #1
 800b4fa:	68fa      	ldr	r2, [r7, #12]
 800b4fc:	009b      	lsls	r3, r3, #2
 800b4fe:	4413      	add	r3, r2
 800b500:	685b      	ldr	r3, [r3, #4]
 800b502:	69fa      	ldr	r2, [r7, #28]
 800b504:	4053      	eors	r3, r2
 800b506:	62fb      	str	r3, [r7, #44]	; 0x2c
   s2 = t2 ^ context->ek[context->nr * 4 + 2];
 800b508:	68fb      	ldr	r3, [r7, #12]
 800b50a:	681b      	ldr	r3, [r3, #0]
 800b50c:	009b      	lsls	r3, r3, #2
 800b50e:	3302      	adds	r3, #2
 800b510:	68fa      	ldr	r2, [r7, #12]
 800b512:	009b      	lsls	r3, r3, #2
 800b514:	4413      	add	r3, r2
 800b516:	685b      	ldr	r3, [r3, #4]
 800b518:	69ba      	ldr	r2, [r7, #24]
 800b51a:	4053      	eors	r3, r2
 800b51c:	62bb      	str	r3, [r7, #40]	; 0x28
   s3 = t3 ^ context->ek[context->nr * 4 + 3];
 800b51e:	68fb      	ldr	r3, [r7, #12]
 800b520:	681b      	ldr	r3, [r3, #0]
 800b522:	009b      	lsls	r3, r3, #2
 800b524:	3303      	adds	r3, #3
 800b526:	68fa      	ldr	r2, [r7, #12]
 800b528:	009b      	lsls	r3, r3, #2
 800b52a:	4413      	add	r3, r2
 800b52c:	685b      	ldr	r3, [r3, #4]
 800b52e:	697a      	ldr	r2, [r7, #20]
 800b530:	4053      	eors	r3, r2
 800b532:	627b      	str	r3, [r7, #36]	; 0x24

   //The final state is then copied to the output
   STORE32LE(s0, output + 0);
 800b534:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b536:	b2da      	uxtb	r2, r3
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	701a      	strb	r2, [r3, #0]
 800b53c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b53e:	0a1a      	lsrs	r2, r3, #8
 800b540:	687b      	ldr	r3, [r7, #4]
 800b542:	3301      	adds	r3, #1
 800b544:	b2d2      	uxtb	r2, r2
 800b546:	701a      	strb	r2, [r3, #0]
 800b548:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b54a:	0c1a      	lsrs	r2, r3, #16
 800b54c:	687b      	ldr	r3, [r7, #4]
 800b54e:	3302      	adds	r3, #2
 800b550:	b2d2      	uxtb	r2, r2
 800b552:	701a      	strb	r2, [r3, #0]
 800b554:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b556:	0e1a      	lsrs	r2, r3, #24
 800b558:	687b      	ldr	r3, [r7, #4]
 800b55a:	3303      	adds	r3, #3
 800b55c:	b2d2      	uxtb	r2, r2
 800b55e:	701a      	strb	r2, [r3, #0]
   STORE32LE(s1, output + 4);
 800b560:	687b      	ldr	r3, [r7, #4]
 800b562:	3304      	adds	r3, #4
 800b564:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b566:	b2d2      	uxtb	r2, r2
 800b568:	701a      	strb	r2, [r3, #0]
 800b56a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b56c:	0a1a      	lsrs	r2, r3, #8
 800b56e:	687b      	ldr	r3, [r7, #4]
 800b570:	3305      	adds	r3, #5
 800b572:	b2d2      	uxtb	r2, r2
 800b574:	701a      	strb	r2, [r3, #0]
 800b576:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b578:	0c1a      	lsrs	r2, r3, #16
 800b57a:	687b      	ldr	r3, [r7, #4]
 800b57c:	3306      	adds	r3, #6
 800b57e:	b2d2      	uxtb	r2, r2
 800b580:	701a      	strb	r2, [r3, #0]
 800b582:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b584:	0e1a      	lsrs	r2, r3, #24
 800b586:	687b      	ldr	r3, [r7, #4]
 800b588:	3307      	adds	r3, #7
 800b58a:	b2d2      	uxtb	r2, r2
 800b58c:	701a      	strb	r2, [r3, #0]
   STORE32LE(s2, output + 8);
 800b58e:	687b      	ldr	r3, [r7, #4]
 800b590:	3308      	adds	r3, #8
 800b592:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b594:	b2d2      	uxtb	r2, r2
 800b596:	701a      	strb	r2, [r3, #0]
 800b598:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b59a:	0a1a      	lsrs	r2, r3, #8
 800b59c:	687b      	ldr	r3, [r7, #4]
 800b59e:	3309      	adds	r3, #9
 800b5a0:	b2d2      	uxtb	r2, r2
 800b5a2:	701a      	strb	r2, [r3, #0]
 800b5a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b5a6:	0c1a      	lsrs	r2, r3, #16
 800b5a8:	687b      	ldr	r3, [r7, #4]
 800b5aa:	330a      	adds	r3, #10
 800b5ac:	b2d2      	uxtb	r2, r2
 800b5ae:	701a      	strb	r2, [r3, #0]
 800b5b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b5b2:	0e1a      	lsrs	r2, r3, #24
 800b5b4:	687b      	ldr	r3, [r7, #4]
 800b5b6:	330b      	adds	r3, #11
 800b5b8:	b2d2      	uxtb	r2, r2
 800b5ba:	701a      	strb	r2, [r3, #0]
   STORE32LE(s3, output + 12);
 800b5bc:	687b      	ldr	r3, [r7, #4]
 800b5be:	330c      	adds	r3, #12
 800b5c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b5c2:	b2d2      	uxtb	r2, r2
 800b5c4:	701a      	strb	r2, [r3, #0]
 800b5c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5c8:	0a1a      	lsrs	r2, r3, #8
 800b5ca:	687b      	ldr	r3, [r7, #4]
 800b5cc:	330d      	adds	r3, #13
 800b5ce:	b2d2      	uxtb	r2, r2
 800b5d0:	701a      	strb	r2, [r3, #0]
 800b5d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5d4:	0c1a      	lsrs	r2, r3, #16
 800b5d6:	687b      	ldr	r3, [r7, #4]
 800b5d8:	330e      	adds	r3, #14
 800b5da:	b2d2      	uxtb	r2, r2
 800b5dc:	701a      	strb	r2, [r3, #0]
 800b5de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5e0:	0e1a      	lsrs	r2, r3, #24
 800b5e2:	687b      	ldr	r3, [r7, #4]
 800b5e4:	330f      	adds	r3, #15
 800b5e6:	b2d2      	uxtb	r2, r2
 800b5e8:	701a      	strb	r2, [r3, #0]
}
 800b5ea:	bf00      	nop
 800b5ec:	373c      	adds	r7, #60	; 0x3c
 800b5ee:	46bd      	mov	sp, r7
 800b5f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5f4:	4770      	bx	lr
 800b5f6:	bf00      	nop
 800b5f8:	0800f930 	.word	0x0800f930

0800b5fc <aesDeinit>:
 * @brief Release AES context
 * @param[in] context Pointer to the AES context
 **/

__weak_func void aesDeinit(AesContext *context)
{
 800b5fc:	b580      	push	{r7, lr}
 800b5fe:	b082      	sub	sp, #8
 800b600:	af00      	add	r7, sp, #0
 800b602:	6078      	str	r0, [r7, #4]
   //Clear AES context
   osMemset(context, 0, sizeof(AesContext));
 800b604:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
 800b608:	2100      	movs	r1, #0
 800b60a:	6878      	ldr	r0, [r7, #4]
 800b60c:	f002 ff6a 	bl	800e4e4 <memset>
}
 800b610:	bf00      	nop
 800b612:	3708      	adds	r7, #8
 800b614:	46bd      	mov	sp, r7
 800b616:	bd80      	pop	{r7, pc}

0800b618 <swapInt32>:
 * @param[in] value 32-bit value
 * @return 32-bit value with byte order swapped
 **/

uint32_t swapInt32(uint32_t value)
{
 800b618:	b480      	push	{r7}
 800b61a:	b083      	sub	sp, #12
 800b61c:	af00      	add	r7, sp, #0
 800b61e:	6078      	str	r0, [r7, #4]
   return SWAPINT32(value);
 800b620:	687b      	ldr	r3, [r7, #4]
 800b622:	061a      	lsls	r2, r3, #24
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	021b      	lsls	r3, r3, #8
 800b628:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800b62c:	431a      	orrs	r2, r3
 800b62e:	687b      	ldr	r3, [r7, #4]
 800b630:	0a1b      	lsrs	r3, r3, #8
 800b632:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800b636:	431a      	orrs	r2, r3
 800b638:	687b      	ldr	r3, [r7, #4]
 800b63a:	0e1b      	lsrs	r3, r3, #24
 800b63c:	4313      	orrs	r3, r2
}
 800b63e:	4618      	mov	r0, r3
 800b640:	370c      	adds	r7, #12
 800b642:	46bd      	mov	sp, r7
 800b644:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b648:	4770      	bx	lr

0800b64a <swapInt64>:
 * @param[in] value 64-bit value
 * @return 64-bit value with byte order swapped
 **/

uint64_t swapInt64(uint64_t value)
{
 800b64a:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 800b64e:	b099      	sub	sp, #100	; 0x64
 800b650:	af00      	add	r7, sp, #0
 800b652:	e9c7 0116 	strd	r0, r1, [r7, #88]	; 0x58
   return SWAPINT64(value);
 800b656:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b65a:	f04f 0800 	mov.w	r8, #0
 800b65e:	f04f 0900 	mov.w	r9, #0
 800b662:	ea4f 6902 	mov.w	r9, r2, lsl #24
 800b666:	f04f 0800 	mov.w	r8, #0
 800b66a:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b66e:	f04f 0000 	mov.w	r0, #0
 800b672:	f04f 0100 	mov.w	r1, #0
 800b676:	0211      	lsls	r1, r2, #8
 800b678:	2000      	movs	r0, #0
 800b67a:	2400      	movs	r4, #0
 800b67c:	f401 057f 	and.w	r5, r1, #16711680	; 0xff0000
 800b680:	ea48 0304 	orr.w	r3, r8, r4
 800b684:	653b      	str	r3, [r7, #80]	; 0x50
 800b686:	ea49 0305 	orr.w	r3, r9, r5
 800b68a:	657b      	str	r3, [r7, #84]	; 0x54
 800b68c:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b690:	f04f 0000 	mov.w	r0, #0
 800b694:	f04f 0100 	mov.w	r1, #0
 800b698:	0619      	lsls	r1, r3, #24
 800b69a:	ea41 2112 	orr.w	r1, r1, r2, lsr #8
 800b69e:	0610      	lsls	r0, r2, #24
 800b6a0:	f04f 0a00 	mov.w	sl, #0
 800b6a4:	f401 4b7f 	and.w	fp, r1, #65280	; 0xff00
 800b6a8:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 800b6ac:	460b      	mov	r3, r1
 800b6ae:	ea43 030a 	orr.w	r3, r3, sl
 800b6b2:	64bb      	str	r3, [r7, #72]	; 0x48
 800b6b4:	4613      	mov	r3, r2
 800b6b6:	ea43 030b 	orr.w	r3, r3, fp
 800b6ba:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b6bc:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b6c0:	f04f 0000 	mov.w	r0, #0
 800b6c4:	f04f 0100 	mov.w	r1, #0
 800b6c8:	0219      	lsls	r1, r3, #8
 800b6ca:	ea41 6112 	orr.w	r1, r1, r2, lsr #24
 800b6ce:	0210      	lsls	r0, r2, #8
 800b6d0:	2300      	movs	r3, #0
 800b6d2:	643b      	str	r3, [r7, #64]	; 0x40
 800b6d4:	f001 03ff 	and.w	r3, r1, #255	; 0xff
 800b6d8:	647b      	str	r3, [r7, #68]	; 0x44
 800b6da:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	; 0x48
 800b6de:	4623      	mov	r3, r4
 800b6e0:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 800b6e4:	4602      	mov	r2, r0
 800b6e6:	4313      	orrs	r3, r2
 800b6e8:	63bb      	str	r3, [r7, #56]	; 0x38
 800b6ea:	462b      	mov	r3, r5
 800b6ec:	460a      	mov	r2, r1
 800b6ee:	4313      	orrs	r3, r2
 800b6f0:	63fb      	str	r3, [r7, #60]	; 0x3c
 800b6f2:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b6f6:	f04f 0000 	mov.w	r0, #0
 800b6fa:	f04f 0100 	mov.w	r1, #0
 800b6fe:	0a10      	lsrs	r0, r2, #8
 800b700:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 800b704:	0a19      	lsrs	r1, r3, #8
 800b706:	f000 437f 	and.w	r3, r0, #4278190080	; 0xff000000
 800b70a:	633b      	str	r3, [r7, #48]	; 0x30
 800b70c:	2300      	movs	r3, #0
 800b70e:	637b      	str	r3, [r7, #52]	; 0x34
 800b710:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	; 0x38
 800b714:	4623      	mov	r3, r4
 800b716:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 800b71a:	4602      	mov	r2, r0
 800b71c:	4313      	orrs	r3, r2
 800b71e:	62bb      	str	r3, [r7, #40]	; 0x28
 800b720:	462b      	mov	r3, r5
 800b722:	460a      	mov	r2, r1
 800b724:	4313      	orrs	r3, r2
 800b726:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b728:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800b72c:	f04f 0000 	mov.w	r0, #0
 800b730:	f04f 0100 	mov.w	r1, #0
 800b734:	0e10      	lsrs	r0, r2, #24
 800b736:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 800b73a:	0e19      	lsrs	r1, r3, #24
 800b73c:	f400 037f 	and.w	r3, r0, #16711680	; 0xff0000
 800b740:	623b      	str	r3, [r7, #32]
 800b742:	2300      	movs	r3, #0
 800b744:	627b      	str	r3, [r7, #36]	; 0x24
 800b746:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	; 0x28
 800b74a:	4623      	mov	r3, r4
 800b74c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800b750:	4602      	mov	r2, r0
 800b752:	4313      	orrs	r3, r2
 800b754:	61bb      	str	r3, [r7, #24]
 800b756:	462b      	mov	r3, r5
 800b758:	460a      	mov	r2, r1
 800b75a:	4313      	orrs	r3, r2
 800b75c:	61fb      	str	r3, [r7, #28]
 800b75e:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 800b762:	f04f 0200 	mov.w	r2, #0
 800b766:	f04f 0300 	mov.w	r3, #0
 800b76a:	0a0a      	lsrs	r2, r1, #8
 800b76c:	2300      	movs	r3, #0
 800b76e:	f402 437f 	and.w	r3, r2, #65280	; 0xff00
 800b772:	613b      	str	r3, [r7, #16]
 800b774:	2300      	movs	r3, #0
 800b776:	617b      	str	r3, [r7, #20]
 800b778:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
 800b77c:	4623      	mov	r3, r4
 800b77e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800b782:	4602      	mov	r2, r0
 800b784:	4313      	orrs	r3, r2
 800b786:	60bb      	str	r3, [r7, #8]
 800b788:	462b      	mov	r3, r5
 800b78a:	460a      	mov	r2, r1
 800b78c:	4313      	orrs	r3, r2
 800b78e:	60fb      	str	r3, [r7, #12]
 800b790:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 800b794:	f04f 0200 	mov.w	r2, #0
 800b798:	f04f 0300 	mov.w	r3, #0
 800b79c:	0e0a      	lsrs	r2, r1, #24
 800b79e:	2300      	movs	r3, #0
 800b7a0:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 800b7a4:	4621      	mov	r1, r4
 800b7a6:	4311      	orrs	r1, r2
 800b7a8:	6039      	str	r1, [r7, #0]
 800b7aa:	4629      	mov	r1, r5
 800b7ac:	4319      	orrs	r1, r3
 800b7ae:	6079      	str	r1, [r7, #4]
 800b7b0:	e9d7 2300 	ldrd	r2, r3, [r7]
}
 800b7b4:	4610      	mov	r0, r2
 800b7b6:	4619      	mov	r1, r3
 800b7b8:	3764      	adds	r7, #100	; 0x64
 800b7ba:	46bd      	mov	sp, r7
 800b7bc:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 800b7c0:	4770      	bx	lr
	...

0800b7c4 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 800b7c4:	b580      	push	{r7, lr}
 800b7c6:	b08a      	sub	sp, #40	; 0x28
 800b7c8:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800b7ca:	f107 0314 	add.w	r3, r7, #20
 800b7ce:	2200      	movs	r2, #0
 800b7d0:	601a      	str	r2, [r3, #0]
 800b7d2:	605a      	str	r2, [r3, #4]
 800b7d4:	609a      	str	r2, [r3, #8]
 800b7d6:	60da      	str	r2, [r3, #12]
 800b7d8:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800b7da:	2300      	movs	r3, #0
 800b7dc:	613b      	str	r3, [r7, #16]
 800b7de:	4b2d      	ldr	r3, [pc, #180]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b7e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7e2:	4a2c      	ldr	r2, [pc, #176]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b7e4:	f043 0304 	orr.w	r3, r3, #4
 800b7e8:	6313      	str	r3, [r2, #48]	; 0x30
 800b7ea:	4b2a      	ldr	r3, [pc, #168]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b7ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7ee:	f003 0304 	and.w	r3, r3, #4
 800b7f2:	613b      	str	r3, [r7, #16]
 800b7f4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800b7f6:	2300      	movs	r3, #0
 800b7f8:	60fb      	str	r3, [r7, #12]
 800b7fa:	4b26      	ldr	r3, [pc, #152]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b7fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7fe:	4a25      	ldr	r2, [pc, #148]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b800:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b804:	6313      	str	r3, [r2, #48]	; 0x30
 800b806:	4b23      	ldr	r3, [pc, #140]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b808:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b80a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b80e:	60fb      	str	r3, [r7, #12]
 800b810:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800b812:	2300      	movs	r3, #0
 800b814:	60bb      	str	r3, [r7, #8]
 800b816:	4b1f      	ldr	r3, [pc, #124]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b818:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b81a:	4a1e      	ldr	r2, [pc, #120]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b81c:	f043 0301 	orr.w	r3, r3, #1
 800b820:	6313      	str	r3, [r2, #48]	; 0x30
 800b822:	4b1c      	ldr	r3, [pc, #112]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b824:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b826:	f003 0301 	and.w	r3, r3, #1
 800b82a:	60bb      	str	r3, [r7, #8]
 800b82c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800b82e:	2300      	movs	r3, #0
 800b830:	607b      	str	r3, [r7, #4]
 800b832:	4b18      	ldr	r3, [pc, #96]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b834:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b836:	4a17      	ldr	r2, [pc, #92]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b838:	f043 0302 	orr.w	r3, r3, #2
 800b83c:	6313      	str	r3, [r2, #48]	; 0x30
 800b83e:	4b15      	ldr	r3, [pc, #84]	; (800b894 <MX_GPIO_Init+0xd0>)
 800b840:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b842:	f003 0302 	and.w	r3, r3, #2
 800b846:	607b      	str	r3, [r7, #4]
 800b848:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 800b84a:	2200      	movs	r2, #0
 800b84c:	2120      	movs	r1, #32
 800b84e:	4812      	ldr	r0, [pc, #72]	; (800b898 <MX_GPIO_Init+0xd4>)
 800b850:	f001 f874 	bl	800c93c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = B1_Pin;
 800b854:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b858:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800b85a:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
 800b85e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800b860:	2300      	movs	r3, #0
 800b862:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 800b864:	f107 0314 	add.w	r3, r7, #20
 800b868:	4619      	mov	r1, r3
 800b86a:	480c      	ldr	r0, [pc, #48]	; (800b89c <MX_GPIO_Init+0xd8>)
 800b86c:	f000 fed2 	bl	800c614 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LD2_Pin;
 800b870:	2320      	movs	r3, #32
 800b872:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800b874:	2301      	movs	r3, #1
 800b876:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800b878:	2300      	movs	r3, #0
 800b87a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800b87c:	2300      	movs	r3, #0
 800b87e:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 800b880:	f107 0314 	add.w	r3, r7, #20
 800b884:	4619      	mov	r1, r3
 800b886:	4804      	ldr	r0, [pc, #16]	; (800b898 <MX_GPIO_Init+0xd4>)
 800b888:	f000 fec4 	bl	800c614 <HAL_GPIO_Init>

}
 800b88c:	bf00      	nop
 800b88e:	3728      	adds	r7, #40	; 0x28
 800b890:	46bd      	mov	sp, r7
 800b892:	bd80      	pop	{r7, pc}
 800b894:	40023800 	.word	0x40023800
 800b898:	40020000 	.word	0x40020000
 800b89c:	40020800 	.word	0x40020800

0800b8a0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800b8a0:	b580      	push	{r7, lr}
 800b8a2:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800b8a4:	f000 fd5e 	bl	800c364 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800b8a8:	f000 f80a 	bl	800b8c0 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800b8ac:	f7ff ff8a 	bl	800b7c4 <MX_GPIO_Init>
  MX_USART2_UART_Init();
 800b8b0:	f000 fa78 	bl	800bda4 <MX_USART2_UART_Init>
  MX_TIM2_Init();
 800b8b4:	f000 fa0a 	bl	800bccc <MX_TIM2_Init>
//  RC6Test();



//  RsaTest();
  EcTest();
 800b8b8:	f7f4 fe30 	bl	800051c <EcTest>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 800b8bc:	e7fe      	b.n	800b8bc <main+0x1c>
	...

0800b8c0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800b8c0:	b580      	push	{r7, lr}
 800b8c2:	b094      	sub	sp, #80	; 0x50
 800b8c4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800b8c6:	f107 031c 	add.w	r3, r7, #28
 800b8ca:	2234      	movs	r2, #52	; 0x34
 800b8cc:	2100      	movs	r1, #0
 800b8ce:	4618      	mov	r0, r3
 800b8d0:	f002 fe08 	bl	800e4e4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800b8d4:	f107 0308 	add.w	r3, r7, #8
 800b8d8:	2200      	movs	r2, #0
 800b8da:	601a      	str	r2, [r3, #0]
 800b8dc:	605a      	str	r2, [r3, #4]
 800b8de:	609a      	str	r2, [r3, #8]
 800b8e0:	60da      	str	r2, [r3, #12]
 800b8e2:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 800b8e4:	2300      	movs	r3, #0
 800b8e6:	607b      	str	r3, [r7, #4]
 800b8e8:	4b2c      	ldr	r3, [pc, #176]	; (800b99c <SystemClock_Config+0xdc>)
 800b8ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b8ec:	4a2b      	ldr	r2, [pc, #172]	; (800b99c <SystemClock_Config+0xdc>)
 800b8ee:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800b8f2:	6413      	str	r3, [r2, #64]	; 0x40
 800b8f4:	4b29      	ldr	r3, [pc, #164]	; (800b99c <SystemClock_Config+0xdc>)
 800b8f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b8f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800b8fc:	607b      	str	r3, [r7, #4]
 800b8fe:	687b      	ldr	r3, [r7, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800b900:	2300      	movs	r3, #0
 800b902:	603b      	str	r3, [r7, #0]
 800b904:	4b26      	ldr	r3, [pc, #152]	; (800b9a0 <SystemClock_Config+0xe0>)
 800b906:	681b      	ldr	r3, [r3, #0]
 800b908:	4a25      	ldr	r2, [pc, #148]	; (800b9a0 <SystemClock_Config+0xe0>)
 800b90a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800b90e:	6013      	str	r3, [r2, #0]
 800b910:	4b23      	ldr	r3, [pc, #140]	; (800b9a0 <SystemClock_Config+0xe0>)
 800b912:	681b      	ldr	r3, [r3, #0]
 800b914:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800b918:	603b      	str	r3, [r7, #0]
 800b91a:	683b      	ldr	r3, [r7, #0]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800b91c:	2302      	movs	r3, #2
 800b91e:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800b920:	2301      	movs	r3, #1
 800b922:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800b924:	2310      	movs	r3, #16
 800b926:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800b928:	2302      	movs	r3, #2
 800b92a:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800b92c:	2300      	movs	r3, #0
 800b92e:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLM = 8;
 800b930:	2308      	movs	r3, #8
 800b932:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 180;
 800b934:	23b4      	movs	r3, #180	; 0xb4
 800b936:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800b938:	2302      	movs	r3, #2
 800b93a:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 2;
 800b93c:	2302      	movs	r3, #2
 800b93e:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = 2;
 800b940:	2302      	movs	r3, #2
 800b942:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800b944:	f107 031c 	add.w	r3, r7, #28
 800b948:	4618      	mov	r0, r3
 800b94a:	f001 fbab 	bl	800d0a4 <HAL_RCC_OscConfig>
 800b94e:	4603      	mov	r3, r0
 800b950:	2b00      	cmp	r3, #0
 800b952:	d001      	beq.n	800b958 <SystemClock_Config+0x98>
  {
    Error_Handler();
 800b954:	f000 f826 	bl	800b9a4 <Error_Handler>
  }

  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 800b958:	f001 f80a 	bl	800c970 <HAL_PWREx_EnableOverDrive>
 800b95c:	4603      	mov	r3, r0
 800b95e:	2b00      	cmp	r3, #0
 800b960:	d001      	beq.n	800b966 <SystemClock_Config+0xa6>
  {
    Error_Handler();
 800b962:	f000 f81f 	bl	800b9a4 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800b966:	230f      	movs	r3, #15
 800b968:	60bb      	str	r3, [r7, #8]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800b96a:	2302      	movs	r3, #2
 800b96c:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800b96e:	2300      	movs	r3, #0
 800b970:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800b972:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800b976:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800b978:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b97c:	61bb      	str	r3, [r7, #24]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800b97e:	f107 0308 	add.w	r3, r7, #8
 800b982:	2105      	movs	r1, #5
 800b984:	4618      	mov	r0, r3
 800b986:	f001 f843 	bl	800ca10 <HAL_RCC_ClockConfig>
 800b98a:	4603      	mov	r3, r0
 800b98c:	2b00      	cmp	r3, #0
 800b98e:	d001      	beq.n	800b994 <SystemClock_Config+0xd4>
  {
    Error_Handler();
 800b990:	f000 f808 	bl	800b9a4 <Error_Handler>
  }
}
 800b994:	bf00      	nop
 800b996:	3750      	adds	r7, #80	; 0x50
 800b998:	46bd      	mov	sp, r7
 800b99a:	bd80      	pop	{r7, pc}
 800b99c:	40023800 	.word	0x40023800
 800b9a0:	40007000 	.word	0x40007000

0800b9a4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800b9a4:	b480      	push	{r7}
 800b9a6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800b9a8:	b672      	cpsid	i
}
 800b9aa:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800b9ac:	e7fe      	b.n	800b9ac <Error_Handler+0x8>

0800b9ae <osCreateMutex>:
 * @return The function returns TRUE if the mutex was successfully
 *   created. Otherwise, FALSE is returned
 **/

bool_t osCreateMutex(OsMutex *mutex)
{
 800b9ae:	b480      	push	{r7}
 800b9b0:	b083      	sub	sp, #12
 800b9b2:	af00      	add	r7, sp, #0
 800b9b4:	6078      	str	r0, [r7, #4]
   //The mutex was successfully created
   return TRUE;
 800b9b6:	2301      	movs	r3, #1
}
 800b9b8:	4618      	mov	r0, r3
 800b9ba:	370c      	adds	r7, #12
 800b9bc:	46bd      	mov	sp, r7
 800b9be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9c2:	4770      	bx	lr

0800b9c4 <osDeleteMutex>:
 * @brief Delete a mutex object
 * @param[in] mutex Pointer to the mutex object
 **/

void osDeleteMutex(OsMutex *mutex)
{
 800b9c4:	b480      	push	{r7}
 800b9c6:	b083      	sub	sp, #12
 800b9c8:	af00      	add	r7, sp, #0
 800b9ca:	6078      	str	r0, [r7, #4]
   //Not implemented
}
 800b9cc:	bf00      	nop
 800b9ce:	370c      	adds	r7, #12
 800b9d0:	46bd      	mov	sp, r7
 800b9d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9d6:	4770      	bx	lr

0800b9d8 <osAcquireMutex>:
 * @brief Acquire ownership of the specified mutex object
 * @param[in] mutex Pointer to the mutex object
 **/

void osAcquireMutex(OsMutex *mutex)
{
 800b9d8:	b480      	push	{r7}
 800b9da:	b083      	sub	sp, #12
 800b9dc:	af00      	add	r7, sp, #0
 800b9de:	6078      	str	r0, [r7, #4]
   //Not implemented
}
 800b9e0:	bf00      	nop
 800b9e2:	370c      	adds	r7, #12
 800b9e4:	46bd      	mov	sp, r7
 800b9e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9ea:	4770      	bx	lr

0800b9ec <osReleaseMutex>:
 * @brief Release ownership of the specified mutex object
 * @param[in] mutex Pointer to the mutex object
 **/

void osReleaseMutex(OsMutex *mutex)
{
 800b9ec:	b480      	push	{r7}
 800b9ee:	b083      	sub	sp, #12
 800b9f0:	af00      	add	r7, sp, #0
 800b9f2:	6078      	str	r0, [r7, #4]
   //Not implemented
}
 800b9f4:	bf00      	nop
 800b9f6:	370c      	adds	r7, #12
 800b9f8:	46bd      	mov	sp, r7
 800b9fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9fe:	4770      	bx	lr

0800ba00 <osAllocMem>:
 * @return A pointer to the allocated memory block or NULL if
 *   there is insufficient memory available
 **/

__weak_func void *osAllocMem(size_t size)
{
 800ba00:	b580      	push	{r7, lr}
 800ba02:	b084      	sub	sp, #16
 800ba04:	af00      	add	r7, sp, #0
 800ba06:	6078      	str	r0, [r7, #4]
   void *p;

   //Allocate a memory block
   p = malloc(size);
 800ba08:	6878      	ldr	r0, [r7, #4]
 800ba0a:	f002 fd4d 	bl	800e4a8 <malloc>
 800ba0e:	4603      	mov	r3, r0
 800ba10:	60fb      	str	r3, [r7, #12]
   //Debug message
   TRACE_DEBUG("Allocating %" PRIuSIZE " bytes at 0x%08" PRIXPTR "\r\n",
      size, (uintptr_t) p);

   //Return a pointer to the newly allocated memory block
   return p;
 800ba12:	68fb      	ldr	r3, [r7, #12]
}
 800ba14:	4618      	mov	r0, r3
 800ba16:	3710      	adds	r7, #16
 800ba18:	46bd      	mov	sp, r7
 800ba1a:	bd80      	pop	{r7, pc}

0800ba1c <osFreeMem>:
 * @brief Release a previously allocated memory block
 * @param[in] p Previously allocated memory block to be freed
 **/

__weak_func void osFreeMem(void *p)
{
 800ba1c:	b580      	push	{r7, lr}
 800ba1e:	b082      	sub	sp, #8
 800ba20:	af00      	add	r7, sp, #0
 800ba22:	6078      	str	r0, [r7, #4]
   //Make sure the pointer is valid
   if(p != NULL)
 800ba24:	687b      	ldr	r3, [r7, #4]
 800ba26:	2b00      	cmp	r3, #0
 800ba28:	d002      	beq.n	800ba30 <osFreeMem+0x14>
   {
      //Debug message
      TRACE_DEBUG("Freeing memory at 0x%08" PRIXPTR "\r\n", (uintptr_t) p);

      //Free memory block
      free(p);
 800ba2a:	6878      	ldr	r0, [r7, #4]
 800ba2c:	f002 fd44 	bl	800e4b8 <free>
   }
}
 800ba30:	bf00      	nop
 800ba32:	3708      	adds	r7, #8
 800ba34:	46bd      	mov	sp, r7
 800ba36:	bd80      	pop	{r7, pc}

0800ba38 <PrintInfo>:
		HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
	}
}

void PrintInfo(const uint8_t* cryptoName, uint32_t dataLength, uint16_t keySize, const uint8_t* hashName)
{
 800ba38:	b580      	push	{r7, lr}
 800ba3a:	b08a      	sub	sp, #40	; 0x28
 800ba3c:	af00      	add	r7, sp, #0
 800ba3e:	60f8      	str	r0, [r7, #12]
 800ba40:	60b9      	str	r1, [r7, #8]
 800ba42:	603b      	str	r3, [r7, #0]
 800ba44:	4613      	mov	r3, r2
 800ba46:	80fb      	strh	r3, [r7, #6]
	uint8_t keySizeTab[5];
	uint8_t dataLengthTab[10];

	itoa(keySize, (char*)keySizeTab, 10);
 800ba48:	88fb      	ldrh	r3, [r7, #6]
 800ba4a:	f107 0120 	add.w	r1, r7, #32
 800ba4e:	220a      	movs	r2, #10
 800ba50:	4618      	mov	r0, r3
 800ba52:	f002 fd25 	bl	800e4a0 <itoa>
	itoa(dataLength, (char*)dataLengthTab, 10);
 800ba56:	f107 0314 	add.w	r3, r7, #20
 800ba5a:	220a      	movs	r2, #10
 800ba5c:	4619      	mov	r1, r3
 800ba5e:	68b8      	ldr	r0, [r7, #8]
 800ba60:	f002 fd1e 	bl	800e4a0 <itoa>
	// Algorithm name
	HAL_UART_Transmit(&huart2, cryptoName, strlen((const char *)cryptoName), HAL_MAX_DELAY);
 800ba64:	68f8      	ldr	r0, [r7, #12]
 800ba66:	f7f4 fbcf 	bl	8000208 <strlen>
 800ba6a:	4603      	mov	r3, r0
 800ba6c:	b29a      	uxth	r2, r3
 800ba6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba72:	68f9      	ldr	r1, [r7, #12]
 800ba74:	482d      	ldr	r0, [pc, #180]	; (800bb2c <PrintInfo+0xf4>)
 800ba76:	f002 f95c 	bl	800dd32 <HAL_UART_Transmit>
	// Key size
	HAL_UART_Transmit(&huart2, keySizeName, sizeof(keySizeName), HAL_MAX_DELAY);
 800ba7a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba7e:	220e      	movs	r2, #14
 800ba80:	492b      	ldr	r1, [pc, #172]	; (800bb30 <PrintInfo+0xf8>)
 800ba82:	482a      	ldr	r0, [pc, #168]	; (800bb2c <PrintInfo+0xf4>)
 800ba84:	f002 f955 	bl	800dd32 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart2, keySizeTab, strlen((const char *)keySizeTab), HAL_MAX_DELAY);
 800ba88:	f107 0320 	add.w	r3, r7, #32
 800ba8c:	4618      	mov	r0, r3
 800ba8e:	f7f4 fbbb 	bl	8000208 <strlen>
 800ba92:	4603      	mov	r3, r0
 800ba94:	b29a      	uxth	r2, r3
 800ba96:	f107 0120 	add.w	r1, r7, #32
 800ba9a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba9e:	4823      	ldr	r0, [pc, #140]	; (800bb2c <PrintInfo+0xf4>)
 800baa0:	f002 f947 	bl	800dd32 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
 800baa4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800baa8:	2201      	movs	r2, #1
 800baaa:	4922      	ldr	r1, [pc, #136]	; (800bb34 <PrintInfo+0xfc>)
 800baac:	481f      	ldr	r0, [pc, #124]	; (800bb2c <PrintInfo+0xf4>)
 800baae:	f002 f940 	bl	800dd32 <HAL_UART_Transmit>
	// Data length
	HAL_UART_Transmit(&huart2, dataLengthName, sizeof(dataLengthName), HAL_MAX_DELAY);
 800bab2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bab6:	2218      	movs	r2, #24
 800bab8:	491f      	ldr	r1, [pc, #124]	; (800bb38 <PrintInfo+0x100>)
 800baba:	481c      	ldr	r0, [pc, #112]	; (800bb2c <PrintInfo+0xf4>)
 800babc:	f002 f939 	bl	800dd32 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart2, dataLengthTab, strlen((const char *)dataLengthTab), HAL_MAX_DELAY);
 800bac0:	f107 0314 	add.w	r3, r7, #20
 800bac4:	4618      	mov	r0, r3
 800bac6:	f7f4 fb9f 	bl	8000208 <strlen>
 800baca:	4603      	mov	r3, r0
 800bacc:	b29a      	uxth	r2, r3
 800bace:	f107 0114 	add.w	r1, r7, #20
 800bad2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bad6:	4815      	ldr	r0, [pc, #84]	; (800bb2c <PrintInfo+0xf4>)
 800bad8:	f002 f92b 	bl	800dd32 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
 800badc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bae0:	2201      	movs	r2, #1
 800bae2:	4914      	ldr	r1, [pc, #80]	; (800bb34 <PrintInfo+0xfc>)
 800bae4:	4811      	ldr	r0, [pc, #68]	; (800bb2c <PrintInfo+0xf4>)
 800bae6:	f002 f924 	bl	800dd32 <HAL_UART_Transmit>
	if ( hashName != NULL ) {
 800baea:	683b      	ldr	r3, [r7, #0]
 800baec:	2b00      	cmp	r3, #0
 800baee:	d018      	beq.n	800bb22 <PrintInfo+0xea>
		HAL_UART_Transmit(&huart2, hashName, strlen((const char *)hashName), HAL_MAX_DELAY);
 800baf0:	6838      	ldr	r0, [r7, #0]
 800baf2:	f7f4 fb89 	bl	8000208 <strlen>
 800baf6:	4603      	mov	r3, r0
 800baf8:	b29a      	uxth	r2, r3
 800bafa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bafe:	6839      	ldr	r1, [r7, #0]
 800bb00:	480a      	ldr	r0, [pc, #40]	; (800bb2c <PrintInfo+0xf4>)
 800bb02:	f002 f916 	bl	800dd32 <HAL_UART_Transmit>
		HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
 800bb06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb0a:	2201      	movs	r2, #1
 800bb0c:	4909      	ldr	r1, [pc, #36]	; (800bb34 <PrintInfo+0xfc>)
 800bb0e:	4807      	ldr	r0, [pc, #28]	; (800bb2c <PrintInfo+0xf4>)
 800bb10:	f002 f90f 	bl	800dd32 <HAL_UART_Transmit>
		HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
 800bb14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb18:	2201      	movs	r2, #1
 800bb1a:	4906      	ldr	r1, [pc, #24]	; (800bb34 <PrintInfo+0xfc>)
 800bb1c:	4803      	ldr	r0, [pc, #12]	; (800bb2c <PrintInfo+0xf4>)
 800bb1e:	f002 f908 	bl	800dd32 <HAL_UART_Transmit>
	}
}
 800bb22:	bf00      	nop
 800bb24:	3728      	adds	r7, #40	; 0x28
 800bb26:	46bd      	mov	sp, r7
 800bb28:	bd80      	pop	{r7, pc}
 800bb2a:	bf00      	nop
 800bb2c:	20001764 	.word	0x20001764
 800bb30:	0801065c 	.word	0x0801065c
 800bb34:	0800e850 	.word	0x0800e850
 800bb38:	0801066c 	.word	0x0801066c

0800bb3c <PrintTime>:

void PrintTime(TIM_HandleTypeDef *htim)
{
 800bb3c:	b580      	push	{r7, lr}
 800bb3e:	b086      	sub	sp, #24
 800bb40:	af00      	add	r7, sp, #0
 800bb42:	6078      	str	r0, [r7, #4]
	uint8_t time_tab[15];

	itoa(htim->Instance->CNT, (char*)time_tab, 10);
 800bb44:	687b      	ldr	r3, [r7, #4]
 800bb46:	681b      	ldr	r3, [r3, #0]
 800bb48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bb4a:	f107 0108 	add.w	r1, r7, #8
 800bb4e:	220a      	movs	r2, #10
 800bb50:	4618      	mov	r0, r3
 800bb52:	f002 fca5 	bl	800e4a0 <itoa>

	htim->Instance->CNT = 0;
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	681b      	ldr	r3, [r3, #0]
 800bb5a:	2200      	movs	r2, #0
 800bb5c:	625a      	str	r2, [r3, #36]	; 0x24

	HAL_UART_Transmit(&huart2, (uint8_t*)time_tab, strlen((const char *)time_tab), HAL_MAX_DELAY);
 800bb5e:	f107 0308 	add.w	r3, r7, #8
 800bb62:	4618      	mov	r0, r3
 800bb64:	f7f4 fb50 	bl	8000208 <strlen>
 800bb68:	4603      	mov	r3, r0
 800bb6a:	b29a      	uxth	r2, r3
 800bb6c:	f107 0108 	add.w	r1, r7, #8
 800bb70:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb74:	4806      	ldr	r0, [pc, #24]	; (800bb90 <PrintTime+0x54>)
 800bb76:	f002 f8dc 	bl	800dd32 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), HAL_MAX_DELAY);
 800bb7a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bb7e:	2201      	movs	r2, #1
 800bb80:	4904      	ldr	r1, [pc, #16]	; (800bb94 <PrintTime+0x58>)
 800bb82:	4803      	ldr	r0, [pc, #12]	; (800bb90 <PrintTime+0x54>)
 800bb84:	f002 f8d5 	bl	800dd32 <HAL_UART_Transmit>

}
 800bb88:	bf00      	nop
 800bb8a:	3718      	adds	r7, #24
 800bb8c:	46bd      	mov	sp, r7
 800bb8e:	bd80      	pop	{r7, pc}
 800bb90:	20001764 	.word	0x20001764
 800bb94:	0800e850 	.word	0x0800e850

0800bb98 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800bb98:	b580      	push	{r7, lr}
 800bb9a:	b082      	sub	sp, #8
 800bb9c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800bb9e:	2300      	movs	r3, #0
 800bba0:	607b      	str	r3, [r7, #4]
 800bba2:	4b10      	ldr	r3, [pc, #64]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bba4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800bba6:	4a0f      	ldr	r2, [pc, #60]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bba8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800bbac:	6453      	str	r3, [r2, #68]	; 0x44
 800bbae:	4b0d      	ldr	r3, [pc, #52]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bbb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800bbb2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800bbb6:	607b      	str	r3, [r7, #4]
 800bbb8:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800bbba:	2300      	movs	r3, #0
 800bbbc:	603b      	str	r3, [r7, #0]
 800bbbe:	4b09      	ldr	r3, [pc, #36]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bbc0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bbc2:	4a08      	ldr	r2, [pc, #32]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bbc4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800bbc8:	6413      	str	r3, [r2, #64]	; 0x40
 800bbca:	4b06      	ldr	r3, [pc, #24]	; (800bbe4 <HAL_MspInit+0x4c>)
 800bbcc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bbce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800bbd2:	603b      	str	r3, [r7, #0]
 800bbd4:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 800bbd6:	2007      	movs	r0, #7
 800bbd8:	f000 fce8 	bl	800c5ac <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800bbdc:	bf00      	nop
 800bbde:	3708      	adds	r7, #8
 800bbe0:	46bd      	mov	sp, r7
 800bbe2:	bd80      	pop	{r7, pc}
 800bbe4:	40023800 	.word	0x40023800

0800bbe8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800bbe8:	b480      	push	{r7}
 800bbea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800bbec:	e7fe      	b.n	800bbec <NMI_Handler+0x4>

0800bbee <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800bbee:	b480      	push	{r7}
 800bbf0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800bbf2:	e7fe      	b.n	800bbf2 <HardFault_Handler+0x4>

0800bbf4 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800bbf4:	b480      	push	{r7}
 800bbf6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800bbf8:	e7fe      	b.n	800bbf8 <MemManage_Handler+0x4>

0800bbfa <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800bbfa:	b480      	push	{r7}
 800bbfc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800bbfe:	e7fe      	b.n	800bbfe <BusFault_Handler+0x4>

0800bc00 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800bc00:	b480      	push	{r7}
 800bc02:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800bc04:	e7fe      	b.n	800bc04 <UsageFault_Handler+0x4>

0800bc06 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800bc06:	b480      	push	{r7}
 800bc08:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800bc0a:	bf00      	nop
 800bc0c:	46bd      	mov	sp, r7
 800bc0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc12:	4770      	bx	lr

0800bc14 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800bc14:	b480      	push	{r7}
 800bc16:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800bc18:	bf00      	nop
 800bc1a:	46bd      	mov	sp, r7
 800bc1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc20:	4770      	bx	lr

0800bc22 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800bc22:	b480      	push	{r7}
 800bc24:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800bc26:	bf00      	nop
 800bc28:	46bd      	mov	sp, r7
 800bc2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc2e:	4770      	bx	lr

0800bc30 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800bc30:	b580      	push	{r7, lr}
 800bc32:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800bc34:	f000 fbe8 	bl	800c408 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800bc38:	bf00      	nop
 800bc3a:	bd80      	pop	{r7, pc}

0800bc3c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800bc3c:	b580      	push	{r7, lr}
 800bc3e:	b086      	sub	sp, #24
 800bc40:	af00      	add	r7, sp, #0
 800bc42:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800bc44:	4a14      	ldr	r2, [pc, #80]	; (800bc98 <_sbrk+0x5c>)
 800bc46:	4b15      	ldr	r3, [pc, #84]	; (800bc9c <_sbrk+0x60>)
 800bc48:	1ad3      	subs	r3, r2, r3
 800bc4a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800bc4c:	697b      	ldr	r3, [r7, #20]
 800bc4e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800bc50:	4b13      	ldr	r3, [pc, #76]	; (800bca0 <_sbrk+0x64>)
 800bc52:	681b      	ldr	r3, [r3, #0]
 800bc54:	2b00      	cmp	r3, #0
 800bc56:	d102      	bne.n	800bc5e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800bc58:	4b11      	ldr	r3, [pc, #68]	; (800bca0 <_sbrk+0x64>)
 800bc5a:	4a12      	ldr	r2, [pc, #72]	; (800bca4 <_sbrk+0x68>)
 800bc5c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800bc5e:	4b10      	ldr	r3, [pc, #64]	; (800bca0 <_sbrk+0x64>)
 800bc60:	681a      	ldr	r2, [r3, #0]
 800bc62:	687b      	ldr	r3, [r7, #4]
 800bc64:	4413      	add	r3, r2
 800bc66:	693a      	ldr	r2, [r7, #16]
 800bc68:	429a      	cmp	r2, r3
 800bc6a:	d207      	bcs.n	800bc7c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800bc6c:	f002 fbd6 	bl	800e41c <__errno>
 800bc70:	4603      	mov	r3, r0
 800bc72:	220c      	movs	r2, #12
 800bc74:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800bc76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bc7a:	e009      	b.n	800bc90 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800bc7c:	4b08      	ldr	r3, [pc, #32]	; (800bca0 <_sbrk+0x64>)
 800bc7e:	681b      	ldr	r3, [r3, #0]
 800bc80:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800bc82:	4b07      	ldr	r3, [pc, #28]	; (800bca0 <_sbrk+0x64>)
 800bc84:	681a      	ldr	r2, [r3, #0]
 800bc86:	687b      	ldr	r3, [r7, #4]
 800bc88:	4413      	add	r3, r2
 800bc8a:	4a05      	ldr	r2, [pc, #20]	; (800bca0 <_sbrk+0x64>)
 800bc8c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800bc8e:	68fb      	ldr	r3, [r7, #12]
}
 800bc90:	4618      	mov	r0, r3
 800bc92:	3718      	adds	r7, #24
 800bc94:	46bd      	mov	sp, r7
 800bc96:	bd80      	pop	{r7, pc}
 800bc98:	20020000 	.word	0x20020000
 800bc9c:	00000400 	.word	0x00000400
 800bca0:	20001718 	.word	0x20001718
 800bca4:	200017c0 	.word	0x200017c0

0800bca8 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800bca8:	b480      	push	{r7}
 800bcaa:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800bcac:	4b06      	ldr	r3, [pc, #24]	; (800bcc8 <SystemInit+0x20>)
 800bcae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bcb2:	4a05      	ldr	r2, [pc, #20]	; (800bcc8 <SystemInit+0x20>)
 800bcb4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800bcb8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800bcbc:	bf00      	nop
 800bcbe:	46bd      	mov	sp, r7
 800bcc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcc4:	4770      	bx	lr
 800bcc6:	bf00      	nop
 800bcc8:	e000ed00 	.word	0xe000ed00

0800bccc <MX_TIM2_Init>:

TIM_HandleTypeDef htim2;

/* TIM2 init function */
void MX_TIM2_Init(void)
{
 800bccc:	b580      	push	{r7, lr}
 800bcce:	b086      	sub	sp, #24
 800bcd0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800bcd2:	f107 0308 	add.w	r3, r7, #8
 800bcd6:	2200      	movs	r2, #0
 800bcd8:	601a      	str	r2, [r3, #0]
 800bcda:	605a      	str	r2, [r3, #4]
 800bcdc:	609a      	str	r2, [r3, #8]
 800bcde:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800bce0:	463b      	mov	r3, r7
 800bce2:	2200      	movs	r2, #0
 800bce4:	601a      	str	r2, [r3, #0]
 800bce6:	605a      	str	r2, [r3, #4]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 800bce8:	4b1d      	ldr	r3, [pc, #116]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bcea:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800bcee:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 90-1;
 800bcf0:	4b1b      	ldr	r3, [pc, #108]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bcf2:	2259      	movs	r2, #89	; 0x59
 800bcf4:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800bcf6:	4b1a      	ldr	r3, [pc, #104]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bcf8:	2200      	movs	r2, #0
 800bcfa:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 4294967295;
 800bcfc:	4b18      	ldr	r3, [pc, #96]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bcfe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800bd02:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800bd04:	4b16      	ldr	r3, [pc, #88]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bd06:	2200      	movs	r2, #0
 800bd08:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800bd0a:	4b15      	ldr	r3, [pc, #84]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bd0c:	2200      	movs	r2, #0
 800bd0e:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 800bd10:	4813      	ldr	r0, [pc, #76]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bd12:	f001 fc65 	bl	800d5e0 <HAL_TIM_Base_Init>
 800bd16:	4603      	mov	r3, r0
 800bd18:	2b00      	cmp	r3, #0
 800bd1a:	d001      	beq.n	800bd20 <MX_TIM2_Init+0x54>
  {
    Error_Handler();
 800bd1c:	f7ff fe42 	bl	800b9a4 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800bd20:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bd24:	60bb      	str	r3, [r7, #8]
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 800bd26:	f107 0308 	add.w	r3, r7, #8
 800bd2a:	4619      	mov	r1, r3
 800bd2c:	480c      	ldr	r0, [pc, #48]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bd2e:	f001 fd36 	bl	800d79e <HAL_TIM_ConfigClockSource>
 800bd32:	4603      	mov	r3, r0
 800bd34:	2b00      	cmp	r3, #0
 800bd36:	d001      	beq.n	800bd3c <MX_TIM2_Init+0x70>
  {
    Error_Handler();
 800bd38:	f7ff fe34 	bl	800b9a4 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800bd3c:	2300      	movs	r3, #0
 800bd3e:	603b      	str	r3, [r7, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800bd40:	2300      	movs	r3, #0
 800bd42:	607b      	str	r3, [r7, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800bd44:	463b      	mov	r3, r7
 800bd46:	4619      	mov	r1, r3
 800bd48:	4805      	ldr	r0, [pc, #20]	; (800bd60 <MX_TIM2_Init+0x94>)
 800bd4a:	f001 ff29 	bl	800dba0 <HAL_TIMEx_MasterConfigSynchronization>
 800bd4e:	4603      	mov	r3, r0
 800bd50:	2b00      	cmp	r3, #0
 800bd52:	d001      	beq.n	800bd58 <MX_TIM2_Init+0x8c>
  {
    Error_Handler();
 800bd54:	f7ff fe26 	bl	800b9a4 <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 800bd58:	bf00      	nop
 800bd5a:	3718      	adds	r7, #24
 800bd5c:	46bd      	mov	sp, r7
 800bd5e:	bd80      	pop	{r7, pc}
 800bd60:	2000171c 	.word	0x2000171c

0800bd64 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 800bd64:	b480      	push	{r7}
 800bd66:	b085      	sub	sp, #20
 800bd68:	af00      	add	r7, sp, #0
 800bd6a:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM2)
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	681b      	ldr	r3, [r3, #0]
 800bd70:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800bd74:	d10d      	bne.n	800bd92 <HAL_TIM_Base_MspInit+0x2e>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 800bd76:	2300      	movs	r3, #0
 800bd78:	60fb      	str	r3, [r7, #12]
 800bd7a:	4b09      	ldr	r3, [pc, #36]	; (800bda0 <HAL_TIM_Base_MspInit+0x3c>)
 800bd7c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bd7e:	4a08      	ldr	r2, [pc, #32]	; (800bda0 <HAL_TIM_Base_MspInit+0x3c>)
 800bd80:	f043 0301 	orr.w	r3, r3, #1
 800bd84:	6413      	str	r3, [r2, #64]	; 0x40
 800bd86:	4b06      	ldr	r3, [pc, #24]	; (800bda0 <HAL_TIM_Base_MspInit+0x3c>)
 800bd88:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bd8a:	f003 0301 	and.w	r3, r3, #1
 800bd8e:	60fb      	str	r3, [r7, #12]
 800bd90:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}
 800bd92:	bf00      	nop
 800bd94:	3714      	adds	r7, #20
 800bd96:	46bd      	mov	sp, r7
 800bd98:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd9c:	4770      	bx	lr
 800bd9e:	bf00      	nop
 800bda0:	40023800 	.word	0x40023800

0800bda4 <MX_USART2_UART_Init>:
UART_HandleTypeDef huart2;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 800bda4:	b580      	push	{r7, lr}
 800bda6:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 800bda8:	4b11      	ldr	r3, [pc, #68]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdaa:	4a12      	ldr	r2, [pc, #72]	; (800bdf4 <MX_USART2_UART_Init+0x50>)
 800bdac:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 800bdae:	4b10      	ldr	r3, [pc, #64]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdb0:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800bdb4:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800bdb6:	4b0e      	ldr	r3, [pc, #56]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdb8:	2200      	movs	r2, #0
 800bdba:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800bdbc:	4b0c      	ldr	r3, [pc, #48]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdbe:	2200      	movs	r2, #0
 800bdc0:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800bdc2:	4b0b      	ldr	r3, [pc, #44]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdc4:	2200      	movs	r2, #0
 800bdc6:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800bdc8:	4b09      	ldr	r3, [pc, #36]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdca:	220c      	movs	r2, #12
 800bdcc:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800bdce:	4b08      	ldr	r3, [pc, #32]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdd0:	2200      	movs	r2, #0
 800bdd2:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800bdd4:	4b06      	ldr	r3, [pc, #24]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bdd6:	2200      	movs	r2, #0
 800bdd8:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800bdda:	4805      	ldr	r0, [pc, #20]	; (800bdf0 <MX_USART2_UART_Init+0x4c>)
 800bddc:	f001 ff5c 	bl	800dc98 <HAL_UART_Init>
 800bde0:	4603      	mov	r3, r0
 800bde2:	2b00      	cmp	r3, #0
 800bde4:	d001      	beq.n	800bdea <MX_USART2_UART_Init+0x46>
  {
    Error_Handler();
 800bde6:	f7ff fddd 	bl	800b9a4 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800bdea:	bf00      	nop
 800bdec:	bd80      	pop	{r7, pc}
 800bdee:	bf00      	nop
 800bdf0:	20001764 	.word	0x20001764
 800bdf4:	40004400 	.word	0x40004400

0800bdf8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800bdf8:	b580      	push	{r7, lr}
 800bdfa:	b08a      	sub	sp, #40	; 0x28
 800bdfc:	af00      	add	r7, sp, #0
 800bdfe:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800be00:	f107 0314 	add.w	r3, r7, #20
 800be04:	2200      	movs	r2, #0
 800be06:	601a      	str	r2, [r3, #0]
 800be08:	605a      	str	r2, [r3, #4]
 800be0a:	609a      	str	r2, [r3, #8]
 800be0c:	60da      	str	r2, [r3, #12]
 800be0e:	611a      	str	r2, [r3, #16]
  if(uartHandle->Instance==USART2)
 800be10:	687b      	ldr	r3, [r7, #4]
 800be12:	681b      	ldr	r3, [r3, #0]
 800be14:	4a19      	ldr	r2, [pc, #100]	; (800be7c <HAL_UART_MspInit+0x84>)
 800be16:	4293      	cmp	r3, r2
 800be18:	d12b      	bne.n	800be72 <HAL_UART_MspInit+0x7a>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* USART2 clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 800be1a:	2300      	movs	r3, #0
 800be1c:	613b      	str	r3, [r7, #16]
 800be1e:	4b18      	ldr	r3, [pc, #96]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be20:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800be22:	4a17      	ldr	r2, [pc, #92]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be24:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800be28:	6413      	str	r3, [r2, #64]	; 0x40
 800be2a:	4b15      	ldr	r3, [pc, #84]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800be2e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800be32:	613b      	str	r3, [r7, #16]
 800be34:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800be36:	2300      	movs	r3, #0
 800be38:	60fb      	str	r3, [r7, #12]
 800be3a:	4b11      	ldr	r3, [pc, #68]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be3c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be3e:	4a10      	ldr	r2, [pc, #64]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be40:	f043 0301 	orr.w	r3, r3, #1
 800be44:	6313      	str	r3, [r2, #48]	; 0x30
 800be46:	4b0e      	ldr	r3, [pc, #56]	; (800be80 <HAL_UART_MspInit+0x88>)
 800be48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be4a:	f003 0301 	and.w	r3, r3, #1
 800be4e:	60fb      	str	r3, [r7, #12]
 800be50:	68fb      	ldr	r3, [r7, #12]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 800be52:	230c      	movs	r3, #12
 800be54:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800be56:	2302      	movs	r3, #2
 800be58:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800be5a:	2300      	movs	r3, #0
 800be5c:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800be5e:	2303      	movs	r3, #3
 800be60:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 800be62:	2307      	movs	r3, #7
 800be64:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800be66:	f107 0314 	add.w	r3, r7, #20
 800be6a:	4619      	mov	r1, r3
 800be6c:	4805      	ldr	r0, [pc, #20]	; (800be84 <HAL_UART_MspInit+0x8c>)
 800be6e:	f000 fbd1 	bl	800c614 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 800be72:	bf00      	nop
 800be74:	3728      	adds	r7, #40	; 0x28
 800be76:	46bd      	mov	sp, r7
 800be78:	bd80      	pop	{r7, pc}
 800be7a:	bf00      	nop
 800be7c:	40004400 	.word	0x40004400
 800be80:	40023800 	.word	0x40023800
 800be84:	40020000 	.word	0x40020000

0800be88 <yarrowInit>:
 * @param[in] context Pointer to the PRNG context to initialize
 * @return Error code
 **/

error_t yarrowInit(YarrowContext *context)
{
 800be88:	b580      	push	{r7, lr}
 800be8a:	b082      	sub	sp, #8
 800be8c:	af00      	add	r7, sp, #0
 800be8e:	6078      	str	r0, [r7, #4]
   //Clear PRNG state
   osMemset(context, 0, sizeof(YarrowContext));
 800be90:	f44f 724c 	mov.w	r2, #816	; 0x330
 800be94:	2100      	movs	r1, #0
 800be96:	6878      	ldr	r0, [r7, #4]
 800be98:	f002 fb24 	bl	800e4e4 <memset>

   //Create a mutex to prevent simultaneous access to the PRNG state
   if(!osCreateMutex(&context->mutex))
 800be9c:	687b      	ldr	r3, [r7, #4]
 800be9e:	4618      	mov	r0, r3
 800bea0:	f7ff fd85 	bl	800b9ae <osCreateMutex>
 800bea4:	4603      	mov	r3, r0
 800bea6:	2b00      	cmp	r3, #0
 800bea8:	d101      	bne.n	800beae <yarrowInit+0x26>
   {
      //Failed to create mutex
      return ERROR_OUT_OF_RESOURCES;
 800beaa:	2365      	movs	r3, #101	; 0x65
 800beac:	e00d      	b.n	800beca <yarrowInit+0x42>
   }

   //Initialize hash contexts
   sha256Init(&context->fastPool);
 800beae:	687b      	ldr	r3, [r7, #4]
 800beb0:	3318      	adds	r3, #24
 800beb2:	4618      	mov	r0, r3
 800beb4:	f7fe f8e2 	bl	800a07c <sha256Init>
   sha256Init(&context->slowPool);
 800beb8:	687b      	ldr	r3, [r7, #4]
 800beba:	3398      	adds	r3, #152	; 0x98
 800bebc:	4618      	mov	r0, r3
 800bebe:	f7fe f8dd 	bl	800a07c <sha256Init>

   //The PRNG is not ready to generate random data
   context->ready = FALSE;
 800bec2:	687b      	ldr	r3, [r7, #4]
 800bec4:	2200      	movs	r2, #0
 800bec6:	605a      	str	r2, [r3, #4]

   //Successful initialization
   return NO_ERROR;
 800bec8:	2300      	movs	r3, #0
}
 800beca:	4618      	mov	r0, r3
 800becc:	3708      	adds	r7, #8
 800bece:	46bd      	mov	sp, r7
 800bed0:	bd80      	pop	{r7, pc}

0800bed2 <yarrowSeed>:
 * @param[in] length Length of the input data
 * @return Error code
 **/

error_t yarrowSeed(YarrowContext *context, const uint8_t *input, size_t length)
{
 800bed2:	b580      	push	{r7, lr}
 800bed4:	b084      	sub	sp, #16
 800bed6:	af00      	add	r7, sp, #0
 800bed8:	60f8      	str	r0, [r7, #12]
 800beda:	60b9      	str	r1, [r7, #8]
 800bedc:	607a      	str	r2, [r7, #4]
   //Check parameters
   if(length < sizeof(context->key))
 800bede:	687b      	ldr	r3, [r7, #4]
 800bee0:	2b1f      	cmp	r3, #31
 800bee2:	d801      	bhi.n	800bee8 <yarrowSeed+0x16>
      return ERROR_INVALID_PARAMETER;
 800bee4:	2302      	movs	r3, #2
 800bee6:	e00a      	b.n	800befe <yarrowSeed+0x2c>

   //Add entropy to the fast pool
   sha256Update(&context->fastPool, input, length);
 800bee8:	68fb      	ldr	r3, [r7, #12]
 800beea:	3318      	adds	r3, #24
 800beec:	687a      	ldr	r2, [r7, #4]
 800beee:	68b9      	ldr	r1, [r7, #8]
 800bef0:	4618      	mov	r0, r3
 800bef2:	f7fe f8ff 	bl	800a0f4 <sha256Update>
   //Reseed from the fast pool
   yarrowFastReseed(context);
 800bef6:	68f8      	ldr	r0, [r7, #12]
 800bef8:	f000 f91e 	bl	800c138 <yarrowFastReseed>

   //Successful processing
   return NO_ERROR;
 800befc:	2300      	movs	r3, #0
}
 800befe:	4618      	mov	r0, r3
 800bf00:	3710      	adds	r7, #16
 800bf02:	46bd      	mov	sp, r7
 800bf04:	bd80      	pop	{r7, pc}

0800bf06 <yarrowAddEntropy>:
 * @return Error code
 **/

error_t yarrowAddEntropy(YarrowContext *context, uint_t source,
   const uint8_t *input, size_t length, size_t entropy)
{
 800bf06:	b580      	push	{r7, lr}
 800bf08:	b086      	sub	sp, #24
 800bf0a:	af00      	add	r7, sp, #0
 800bf0c:	60f8      	str	r0, [r7, #12]
 800bf0e:	60b9      	str	r1, [r7, #8]
 800bf10:	607a      	str	r2, [r7, #4]
 800bf12:	603b      	str	r3, [r7, #0]
   uint_t i;
   uint_t k;

   //Check parameters
   if(source >= YARROW_N)
 800bf14:	68bb      	ldr	r3, [r7, #8]
 800bf16:	2b02      	cmp	r3, #2
 800bf18:	d901      	bls.n	800bf1e <yarrowAddEntropy+0x18>
      return ERROR_INVALID_PARAMETER;
 800bf1a:	2302      	movs	r3, #2
 800bf1c:	e074      	b.n	800c008 <yarrowAddEntropy+0x102>

   //Acquire exclusive access to the PRNG state
   osAcquireMutex(&context->mutex);
 800bf1e:	68fb      	ldr	r3, [r7, #12]
 800bf20:	4618      	mov	r0, r3
 800bf22:	f7ff fd59 	bl	800b9d8 <osAcquireMutex>

   //Entropy from samples are collected into two pools
   if(context->currentPool[source] == YARROW_FAST_POOL_ID)
 800bf26:	68fb      	ldr	r3, [r7, #12]
 800bf28:	68ba      	ldr	r2, [r7, #8]
 800bf2a:	3202      	adds	r2, #2
 800bf2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf30:	2b00      	cmp	r3, #0
 800bf32:	d123      	bne.n	800bf7c <yarrowAddEntropy+0x76>
   {
      //Each pool contains running hash of all inputs since last reseed
      sha256Update(&context->fastPool, input, length);
 800bf34:	68fb      	ldr	r3, [r7, #12]
 800bf36:	3318      	adds	r3, #24
 800bf38:	683a      	ldr	r2, [r7, #0]
 800bf3a:	6879      	ldr	r1, [r7, #4]
 800bf3c:	4618      	mov	r0, r3
 800bf3e:	f7fe f8d9 	bl	800a0f4 <sha256Update>
      //Estimate the amount of entropy we have collected thus far
      context->fastPoolEntropy[source] += entropy;
 800bf42:	68fb      	ldr	r3, [r7, #12]
 800bf44:	68ba      	ldr	r2, [r7, #8]
 800bf46:	3222      	adds	r2, #34	; 0x22
 800bf48:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800bf4c:	6a3b      	ldr	r3, [r7, #32]
 800bf4e:	18d1      	adds	r1, r2, r3
 800bf50:	68fb      	ldr	r3, [r7, #12]
 800bf52:	68ba      	ldr	r2, [r7, #8]
 800bf54:	3222      	adds	r2, #34	; 0x22
 800bf56:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      //Reseed when any source estimate reaches 100 bits
      if(context->fastPoolEntropy[source] >= YARROW_FAST_THRESHOLD)
 800bf5a:	68fb      	ldr	r3, [r7, #12]
 800bf5c:	68ba      	ldr	r2, [r7, #8]
 800bf5e:	3222      	adds	r2, #34	; 0x22
 800bf60:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf64:	2b63      	cmp	r3, #99	; 0x63
 800bf66:	d902      	bls.n	800bf6e <yarrowAddEntropy+0x68>
      {
         yarrowFastReseed(context);
 800bf68:	68f8      	ldr	r0, [r7, #12]
 800bf6a:	f000 f8e5 	bl	800c138 <yarrowFastReseed>
      }

      //The samples from each source alternate between the two pools
      context->currentPool[source] = YARROW_SLOW_POOL_ID;
 800bf6e:	68fb      	ldr	r3, [r7, #12]
 800bf70:	68ba      	ldr	r2, [r7, #8]
 800bf72:	3202      	adds	r2, #2
 800bf74:	2101      	movs	r1, #1
 800bf76:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800bf7a:	e040      	b.n	800bffe <yarrowAddEntropy+0xf8>
   }
   else
   {
      //Each pool contains running hash of all inputs since last reseed
      sha256Update(&context->slowPool, input, length);
 800bf7c:	68fb      	ldr	r3, [r7, #12]
 800bf7e:	3398      	adds	r3, #152	; 0x98
 800bf80:	683a      	ldr	r2, [r7, #0]
 800bf82:	6879      	ldr	r1, [r7, #4]
 800bf84:	4618      	mov	r0, r3
 800bf86:	f7fe f8b5 	bl	800a0f4 <sha256Update>
      //Estimate the amount of entropy we have collected thus far
      context->slowPoolEntropy[source] += entropy;
 800bf8a:	68fb      	ldr	r3, [r7, #12]
 800bf8c:	68ba      	ldr	r2, [r7, #8]
 800bf8e:	3242      	adds	r2, #66	; 0x42
 800bf90:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800bf94:	6a3b      	ldr	r3, [r7, #32]
 800bf96:	18d1      	adds	r1, r2, r3
 800bf98:	68fb      	ldr	r3, [r7, #12]
 800bf9a:	68ba      	ldr	r2, [r7, #8]
 800bf9c:	3242      	adds	r2, #66	; 0x42
 800bf9e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      //Prevent overflows while adding up the entropy estimate
      if(context->slowPoolEntropy[source] >= YARROW_SLOW_THRESHOLD)
 800bfa2:	68fb      	ldr	r3, [r7, #12]
 800bfa4:	68ba      	ldr	r2, [r7, #8]
 800bfa6:	3242      	adds	r2, #66	; 0x42
 800bfa8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bfac:	2b9f      	cmp	r3, #159	; 0x9f
 800bfae:	d905      	bls.n	800bfbc <yarrowAddEntropy+0xb6>
      {
         context->slowPoolEntropy[source] = YARROW_SLOW_THRESHOLD;
 800bfb0:	68fb      	ldr	r3, [r7, #12]
 800bfb2:	68ba      	ldr	r2, [r7, #8]
 800bfb4:	3242      	adds	r2, #66	; 0x42
 800bfb6:	21a0      	movs	r1, #160	; 0xa0
 800bfb8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      //At least two different sources must be over 160 bits in the slow
      //pool before the slow pool reseeds
      for(k = 0, i = 0; i < YARROW_N; i++)
 800bfbc:	2300      	movs	r3, #0
 800bfbe:	613b      	str	r3, [r7, #16]
 800bfc0:	2300      	movs	r3, #0
 800bfc2:	617b      	str	r3, [r7, #20]
 800bfc4:	e00c      	b.n	800bfe0 <yarrowAddEntropy+0xda>
      {
         //Check whether the current source has hit the threshold
         if(context->slowPoolEntropy[i] >= YARROW_SLOW_THRESHOLD)
 800bfc6:	68fb      	ldr	r3, [r7, #12]
 800bfc8:	697a      	ldr	r2, [r7, #20]
 800bfca:	3242      	adds	r2, #66	; 0x42
 800bfcc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bfd0:	2b9f      	cmp	r3, #159	; 0x9f
 800bfd2:	d902      	bls.n	800bfda <yarrowAddEntropy+0xd4>
         {
            k++;
 800bfd4:	693b      	ldr	r3, [r7, #16]
 800bfd6:	3301      	adds	r3, #1
 800bfd8:	613b      	str	r3, [r7, #16]
      for(k = 0, i = 0; i < YARROW_N; i++)
 800bfda:	697b      	ldr	r3, [r7, #20]
 800bfdc:	3301      	adds	r3, #1
 800bfde:	617b      	str	r3, [r7, #20]
 800bfe0:	697b      	ldr	r3, [r7, #20]
 800bfe2:	2b02      	cmp	r3, #2
 800bfe4:	d9ef      	bls.n	800bfc6 <yarrowAddEntropy+0xc0>
         }
      }

      //Reseed from the slow pool?
      if(k >= YARROW_K)
 800bfe6:	693b      	ldr	r3, [r7, #16]
 800bfe8:	2b01      	cmp	r3, #1
 800bfea:	d902      	bls.n	800bff2 <yarrowAddEntropy+0xec>
      {
         yarrowSlowReseed(context);
 800bfec:	68f8      	ldr	r0, [r7, #12]
 800bfee:	f000 f8fe 	bl	800c1ee <yarrowSlowReseed>
      }

      //The samples from each source alternate between the two pools
      context->currentPool[source] = YARROW_FAST_POOL_ID;
 800bff2:	68fb      	ldr	r3, [r7, #12]
 800bff4:	68ba      	ldr	r2, [r7, #8]
 800bff6:	3202      	adds	r2, #2
 800bff8:	2100      	movs	r1, #0
 800bffa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   }

   //Release exclusive access to the PRNG state
   osReleaseMutex(&context->mutex);
 800bffe:	68fb      	ldr	r3, [r7, #12]
 800c000:	4618      	mov	r0, r3
 800c002:	f7ff fcf3 	bl	800b9ec <osReleaseMutex>

   //Successful processing
   return NO_ERROR;
 800c006:	2300      	movs	r3, #0
}
 800c008:	4618      	mov	r0, r3
 800c00a:	3718      	adds	r7, #24
 800c00c:	46bd      	mov	sp, r7
 800c00e:	bd80      	pop	{r7, pc}

0800c010 <yarrowRead>:
 * @param[in] length Desired length in bytes
 * @return Error code
 **/

error_t yarrowRead(YarrowContext *context, uint8_t *output, size_t length)
{
 800c010:	b580      	push	{r7, lr}
 800c012:	b08a      	sub	sp, #40	; 0x28
 800c014:	af00      	add	r7, sp, #0
 800c016:	60f8      	str	r0, [r7, #12]
 800c018:	60b9      	str	r1, [r7, #8]
 800c01a:	607a      	str	r2, [r7, #4]
   size_t n;
   uint8_t buffer[AES_BLOCK_SIZE];

   //Make sure that the PRNG has been properly seeded
   if(!context->ready)
 800c01c:	68fb      	ldr	r3, [r7, #12]
 800c01e:	685b      	ldr	r3, [r3, #4]
 800c020:	2b00      	cmp	r3, #0
 800c022:	d102      	bne.n	800c02a <yarrowRead+0x1a>
      return ERROR_PRNG_NOT_READY;
 800c024:	f240 2323 	movw	r3, #547	; 0x223
 800c028:	e04d      	b.n	800c0c6 <yarrowRead+0xb6>

   //Acquire exclusive access to the PRNG state
   osAcquireMutex(&context->mutex);
 800c02a:	68fb      	ldr	r3, [r7, #12]
 800c02c:	4618      	mov	r0, r3
 800c02e:	f7ff fcd3 	bl	800b9d8 <osAcquireMutex>

   //Generate random data in a block-by-block fashion
   while(length > 0)
 800c032:	e020      	b.n	800c076 <yarrowRead+0x66>
   {
      //Number of bytes to process at a time
      n = MIN(length, AES_BLOCK_SIZE);
 800c034:	687b      	ldr	r3, [r7, #4]
 800c036:	2b10      	cmp	r3, #16
 800c038:	bf28      	it	cs
 800c03a:	2310      	movcs	r3, #16
 800c03c:	627b      	str	r3, [r7, #36]	; 0x24

      //Generate a random block
      yarrowGenerateBlock(context, buffer);
 800c03e:	f107 0314 	add.w	r3, r7, #20
 800c042:	4619      	mov	r1, r3
 800c044:	68f8      	ldr	r0, [r7, #12]
 800c046:	f000 f842 	bl	800c0ce <yarrowGenerateBlock>
      //Copy data to the output buffer
      osMemcpy(output, buffer, n);
 800c04a:	f107 0314 	add.w	r3, r7, #20
 800c04e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c050:	4619      	mov	r1, r3
 800c052:	68b8      	ldr	r0, [r7, #8]
 800c054:	f002 fa38 	bl	800e4c8 <memcpy>

      //We keep track of how many blocks we have output
      context->blockCount++;
 800c058:	68fb      	ldr	r3, [r7, #12]
 800c05a:	f8d3 3328 	ldr.w	r3, [r3, #808]	; 0x328
 800c05e:	1c5a      	adds	r2, r3, #1
 800c060:	68fb      	ldr	r3, [r7, #12]
 800c062:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328

      //Next block
      output += n;
 800c066:	68ba      	ldr	r2, [r7, #8]
 800c068:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c06a:	4413      	add	r3, r2
 800c06c:	60bb      	str	r3, [r7, #8]
      length -= n;
 800c06e:	687a      	ldr	r2, [r7, #4]
 800c070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c072:	1ad3      	subs	r3, r2, r3
 800c074:	607b      	str	r3, [r7, #4]
   while(length > 0)
 800c076:	687b      	ldr	r3, [r7, #4]
 800c078:	2b00      	cmp	r3, #0
 800c07a:	d1db      	bne.n	800c034 <yarrowRead+0x24>
   }

   //Apply generator gate?
   if(context->blockCount >= YARROW_PG)
 800c07c:	68fb      	ldr	r3, [r7, #12]
 800c07e:	f8d3 3328 	ldr.w	r3, [r3, #808]	; 0x328
 800c082:	2b09      	cmp	r3, #9
 800c084:	d91a      	bls.n	800c0bc <yarrowRead+0xac>
   {
      //Generate some random bytes
      yarrowGenerateBlock(context, context->key);
 800c086:	68fb      	ldr	r3, [r7, #12]
 800c088:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c08c:	4619      	mov	r1, r3
 800c08e:	68f8      	ldr	r0, [r7, #12]
 800c090:	f000 f81d 	bl	800c0ce <yarrowGenerateBlock>

      //Use them as the new key
      aesDeinit(&context->cipherContext);
 800c094:	68fb      	ldr	r3, [r7, #12]
 800c096:	f503 738a 	add.w	r3, r3, #276	; 0x114
 800c09a:	4618      	mov	r0, r3
 800c09c:	f7ff faae 	bl	800b5fc <aesDeinit>
      aesInit(&context->cipherContext, context->key, sizeof(context->key));
 800c0a0:	68fb      	ldr	r3, [r7, #12]
 800c0a2:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c0a6:	68fb      	ldr	r3, [r7, #12]
 800c0a8:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c0ac:	2220      	movs	r2, #32
 800c0ae:	4619      	mov	r1, r3
 800c0b0:	f7fe fe70 	bl	800ad94 <aesInit>

      //Reset block counter
      context->blockCount = 0;
 800c0b4:	68fb      	ldr	r3, [r7, #12]
 800c0b6:	2200      	movs	r2, #0
 800c0b8:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
   }

   //Release exclusive access to the PRNG state
   osReleaseMutex(&context->mutex);
 800c0bc:	68fb      	ldr	r3, [r7, #12]
 800c0be:	4618      	mov	r0, r3
 800c0c0:	f7ff fc94 	bl	800b9ec <osReleaseMutex>

   //Successful processing
   return NO_ERROR;
 800c0c4:	2300      	movs	r3, #0
}
 800c0c6:	4618      	mov	r0, r3
 800c0c8:	3728      	adds	r7, #40	; 0x28
 800c0ca:	46bd      	mov	sp, r7
 800c0cc:	bd80      	pop	{r7, pc}

0800c0ce <yarrowGenerateBlock>:
 * @param[in] context Pointer to the PRNG context
 * @param[out] output Buffer where to store the output block
 **/

void yarrowGenerateBlock(YarrowContext *context, uint8_t *output)
{
 800c0ce:	b580      	push	{r7, lr}
 800c0d0:	b084      	sub	sp, #16
 800c0d2:	af00      	add	r7, sp, #0
 800c0d4:	6078      	str	r0, [r7, #4]
 800c0d6:	6039      	str	r1, [r7, #0]
   int_t i;

   //Encrypt counter block
   aesEncryptBlock(&context->cipherContext, context->counter, output);
 800c0d8:	687b      	ldr	r3, [r7, #4]
 800c0da:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c0de:	687b      	ldr	r3, [r7, #4]
 800c0e0:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c0e4:	683a      	ldr	r2, [r7, #0]
 800c0e6:	4619      	mov	r1, r3
 800c0e8:	f7ff f816 	bl	800b118 <aesEncryptBlock>

   //Increment counter value
   for(i = AES_BLOCK_SIZE - 1; i >= 0; i--)
 800c0ec:	230f      	movs	r3, #15
 800c0ee:	60fb      	str	r3, [r7, #12]
 800c0f0:	e019      	b.n	800c126 <yarrowGenerateBlock+0x58>
   {
      //Increment the current byte and propagate the carry if necessary
      if(++(context->counter[i]) != 0)
 800c0f2:	687a      	ldr	r2, [r7, #4]
 800c0f4:	68fb      	ldr	r3, [r7, #12]
 800c0f6:	4413      	add	r3, r2
 800c0f8:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c0fc:	781b      	ldrb	r3, [r3, #0]
 800c0fe:	3301      	adds	r3, #1
 800c100:	b2d9      	uxtb	r1, r3
 800c102:	687a      	ldr	r2, [r7, #4]
 800c104:	68fb      	ldr	r3, [r7, #12]
 800c106:	4413      	add	r3, r2
 800c108:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c10c:	460a      	mov	r2, r1
 800c10e:	701a      	strb	r2, [r3, #0]
 800c110:	687a      	ldr	r2, [r7, #4]
 800c112:	68fb      	ldr	r3, [r7, #12]
 800c114:	4413      	add	r3, r2
 800c116:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c11a:	781b      	ldrb	r3, [r3, #0]
 800c11c:	2b00      	cmp	r3, #0
 800c11e:	d106      	bne.n	800c12e <yarrowGenerateBlock+0x60>
   for(i = AES_BLOCK_SIZE - 1; i >= 0; i--)
 800c120:	68fb      	ldr	r3, [r7, #12]
 800c122:	3b01      	subs	r3, #1
 800c124:	60fb      	str	r3, [r7, #12]
 800c126:	68fb      	ldr	r3, [r7, #12]
 800c128:	2b00      	cmp	r3, #0
 800c12a:	dae2      	bge.n	800c0f2 <yarrowGenerateBlock+0x24>
      {
         break;
      }
   }
}
 800c12c:	e000      	b.n	800c130 <yarrowGenerateBlock+0x62>
         break;
 800c12e:	bf00      	nop
}
 800c130:	bf00      	nop
 800c132:	3710      	adds	r7, #16
 800c134:	46bd      	mov	sp, r7
 800c136:	bd80      	pop	{r7, pc}

0800c138 <yarrowFastReseed>:
 * @brief Reseed from the fast pool
 * @param[in] context Pointer to the PRNG context
 **/

void yarrowFastReseed(YarrowContext *context)
{
 800c138:	b580      	push	{r7, lr}
 800c13a:	b084      	sub	sp, #16
 800c13c:	af00      	add	r7, sp, #0
 800c13e:	6078      	str	r0, [r7, #4]
   size_t i;

   //Erase AES context
   if(context->ready)
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	685b      	ldr	r3, [r3, #4]
 800c144:	2b00      	cmp	r3, #0
 800c146:	d005      	beq.n	800c154 <yarrowFastReseed+0x1c>
   {
      aesDeinit(&context->cipherContext);
 800c148:	687b      	ldr	r3, [r7, #4]
 800c14a:	f503 738a 	add.w	r3, r3, #276	; 0x114
 800c14e:	4618      	mov	r0, r3
 800c150:	f7ff fa54 	bl	800b5fc <aesDeinit>
   }

   //Reseeding from the fast pool use the current key and the hash of all
   //inputs to the fast pool since the last reseed, to generate a new key
   sha256Update(&context->fastPool, context->key, sizeof(context->key));
 800c154:	687b      	ldr	r3, [r7, #4]
 800c156:	f103 0018 	add.w	r0, r3, #24
 800c15a:	687b      	ldr	r3, [r7, #4]
 800c15c:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c160:	2220      	movs	r2, #32
 800c162:	4619      	mov	r1, r3
 800c164:	f7fd ffc6 	bl	800a0f4 <sha256Update>
   sha256Final(&context->fastPool, context->key);
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	f103 0218 	add.w	r2, r3, #24
 800c16e:	687b      	ldr	r3, [r7, #4]
 800c170:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c174:	4619      	mov	r1, r3
 800c176:	4610      	mov	r0, r2
 800c178:	f7fe f808 	bl	800a18c <sha256Final>

   //Set the new key
   aesInit(&context->cipherContext, context->key, sizeof(context->key));
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c188:	2220      	movs	r2, #32
 800c18a:	4619      	mov	r1, r3
 800c18c:	f7fe fe02 	bl	800ad94 <aesInit>

   //Define the new value of the counter
   osMemset(context->counter, 0, sizeof(context->counter));
 800c190:	687b      	ldr	r3, [r7, #4]
 800c192:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c196:	2210      	movs	r2, #16
 800c198:	2100      	movs	r1, #0
 800c19a:	4618      	mov	r0, r3
 800c19c:	f002 f9a2 	bl	800e4e4 <memset>
   aesEncryptBlock(&context->cipherContext, context->counter, context->counter);
 800c1a0:	687b      	ldr	r3, [r7, #4]
 800c1a2:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	f503 7146 	add.w	r1, r3, #792	; 0x318
 800c1ac:	687b      	ldr	r3, [r7, #4]
 800c1ae:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c1b2:	461a      	mov	r2, r3
 800c1b4:	f7fe ffb0 	bl	800b118 <aesEncryptBlock>

   //Reset the hash context
   sha256Init(&context->fastPool);
 800c1b8:	687b      	ldr	r3, [r7, #4]
 800c1ba:	3318      	adds	r3, #24
 800c1bc:	4618      	mov	r0, r3
 800c1be:	f7fd ff5d 	bl	800a07c <sha256Init>

   //The entropy estimates for the fast pool are all reset to zero
   for(i = 0; i < YARROW_N; i++)
 800c1c2:	2300      	movs	r3, #0
 800c1c4:	60fb      	str	r3, [r7, #12]
 800c1c6:	e008      	b.n	800c1da <yarrowFastReseed+0xa2>
   {
      context->fastPoolEntropy[i] = 0;
 800c1c8:	687b      	ldr	r3, [r7, #4]
 800c1ca:	68fa      	ldr	r2, [r7, #12]
 800c1cc:	3222      	adds	r2, #34	; 0x22
 800c1ce:	2100      	movs	r1, #0
 800c1d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   for(i = 0; i < YARROW_N; i++)
 800c1d4:	68fb      	ldr	r3, [r7, #12]
 800c1d6:	3301      	adds	r3, #1
 800c1d8:	60fb      	str	r3, [r7, #12]
 800c1da:	68fb      	ldr	r3, [r7, #12]
 800c1dc:	2b02      	cmp	r3, #2
 800c1de:	d9f3      	bls.n	800c1c8 <yarrowFastReseed+0x90>
   }

   //The PRNG is ready to generate random data
   context->ready = TRUE;
 800c1e0:	687b      	ldr	r3, [r7, #4]
 800c1e2:	2201      	movs	r2, #1
 800c1e4:	605a      	str	r2, [r3, #4]
}
 800c1e6:	bf00      	nop
 800c1e8:	3710      	adds	r7, #16
 800c1ea:	46bd      	mov	sp, r7
 800c1ec:	bd80      	pop	{r7, pc}

0800c1ee <yarrowSlowReseed>:
 * @brief Reseed from the slow pool
 * @param[in] context Pointer to the PRNG context
 **/

void yarrowSlowReseed(YarrowContext *context)
{
 800c1ee:	b580      	push	{r7, lr}
 800c1f0:	b084      	sub	sp, #16
 800c1f2:	af00      	add	r7, sp, #0
 800c1f4:	6078      	str	r0, [r7, #4]
   size_t i;

   //Erase AES context
   if(context->ready)
 800c1f6:	687b      	ldr	r3, [r7, #4]
 800c1f8:	685b      	ldr	r3, [r3, #4]
 800c1fa:	2b00      	cmp	r3, #0
 800c1fc:	d005      	beq.n	800c20a <yarrowSlowReseed+0x1c>
   {
      aesDeinit(&context->cipherContext);
 800c1fe:	687b      	ldr	r3, [r7, #4]
 800c200:	f503 738a 	add.w	r3, r3, #276	; 0x114
 800c204:	4618      	mov	r0, r3
 800c206:	f7ff f9f9 	bl	800b5fc <aesDeinit>
   }

   //Compute the hash of all inputs to the fast pool
   sha256Final(&context->fastPool, NULL);
 800c20a:	687b      	ldr	r3, [r7, #4]
 800c20c:	3318      	adds	r3, #24
 800c20e:	2100      	movs	r1, #0
 800c210:	4618      	mov	r0, r3
 800c212:	f7fd ffbb 	bl	800a18c <sha256Final>

   //Reseeding from the slow pool use the current key, the hash of all inputs to the
   //fast pool and the hash of all inputs to the slow pool, to generate a new key
   sha256Update(&context->slowPool, context->key, sizeof(context->key));
 800c216:	687b      	ldr	r3, [r7, #4]
 800c218:	f103 0098 	add.w	r0, r3, #152	; 0x98
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c222:	2220      	movs	r2, #32
 800c224:	4619      	mov	r1, r3
 800c226:	f7fd ff65 	bl	800a0f4 <sha256Update>
   sha256Update(&context->slowPool, context->fastPool.digest, SHA256_DIGEST_SIZE);
 800c22a:	687b      	ldr	r3, [r7, #4]
 800c22c:	f103 0098 	add.w	r0, r3, #152	; 0x98
 800c230:	687b      	ldr	r3, [r7, #4]
 800c232:	3318      	adds	r3, #24
 800c234:	2220      	movs	r2, #32
 800c236:	4619      	mov	r1, r3
 800c238:	f7fd ff5c 	bl	800a0f4 <sha256Update>
   sha256Final(&context->slowPool, context->key);
 800c23c:	687b      	ldr	r3, [r7, #4]
 800c23e:	f103 0298 	add.w	r2, r3, #152	; 0x98
 800c242:	687b      	ldr	r3, [r7, #4]
 800c244:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c248:	4619      	mov	r1, r3
 800c24a:	4610      	mov	r0, r2
 800c24c:	f7fd ff9e 	bl	800a18c <sha256Final>

   //Set the new key
   aesInit(&context->cipherContext, context->key, sizeof(context->key));
 800c250:	687b      	ldr	r3, [r7, #4]
 800c252:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c256:	687b      	ldr	r3, [r7, #4]
 800c258:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
 800c25c:	2220      	movs	r2, #32
 800c25e:	4619      	mov	r1, r3
 800c260:	f7fe fd98 	bl	800ad94 <aesInit>

   //Define the new value of the counter
   osMemset(context->counter, 0, sizeof(context->counter));
 800c264:	687b      	ldr	r3, [r7, #4]
 800c266:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c26a:	2210      	movs	r2, #16
 800c26c:	2100      	movs	r1, #0
 800c26e:	4618      	mov	r0, r3
 800c270:	f002 f938 	bl	800e4e4 <memset>
   aesEncryptBlock(&context->cipherContext, context->counter, context->counter);
 800c274:	687b      	ldr	r3, [r7, #4]
 800c276:	f503 708a 	add.w	r0, r3, #276	; 0x114
 800c27a:	687b      	ldr	r3, [r7, #4]
 800c27c:	f503 7146 	add.w	r1, r3, #792	; 0x318
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	f503 7346 	add.w	r3, r3, #792	; 0x318
 800c286:	461a      	mov	r2, r3
 800c288:	f7fe ff46 	bl	800b118 <aesEncryptBlock>

   //Reset the hash contexts
   sha256Init(&context->fastPool);
 800c28c:	687b      	ldr	r3, [r7, #4]
 800c28e:	3318      	adds	r3, #24
 800c290:	4618      	mov	r0, r3
 800c292:	f7fd fef3 	bl	800a07c <sha256Init>
   sha256Init(&context->slowPool);
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	3398      	adds	r3, #152	; 0x98
 800c29a:	4618      	mov	r0, r3
 800c29c:	f7fd feee 	bl	800a07c <sha256Init>

   //The entropy estimates for both pools are reset to zero
   for(i = 0; i < YARROW_N; i++)
 800c2a0:	2300      	movs	r3, #0
 800c2a2:	60fb      	str	r3, [r7, #12]
 800c2a4:	e00e      	b.n	800c2c4 <yarrowSlowReseed+0xd6>
   {
      context->fastPoolEntropy[i] = 0;
 800c2a6:	687b      	ldr	r3, [r7, #4]
 800c2a8:	68fa      	ldr	r2, [r7, #12]
 800c2aa:	3222      	adds	r2, #34	; 0x22
 800c2ac:	2100      	movs	r1, #0
 800c2ae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      context->slowPoolEntropy[i] = 0;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	68fa      	ldr	r2, [r7, #12]
 800c2b6:	3242      	adds	r2, #66	; 0x42
 800c2b8:	2100      	movs	r1, #0
 800c2ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   for(i = 0; i < YARROW_N; i++)
 800c2be:	68fb      	ldr	r3, [r7, #12]
 800c2c0:	3301      	adds	r3, #1
 800c2c2:	60fb      	str	r3, [r7, #12]
 800c2c4:	68fb      	ldr	r3, [r7, #12]
 800c2c6:	2b02      	cmp	r3, #2
 800c2c8:	d9ed      	bls.n	800c2a6 <yarrowSlowReseed+0xb8>
   }

   //The PRNG is ready to generate random data
   context->ready = TRUE;
 800c2ca:	687b      	ldr	r3, [r7, #4]
 800c2cc:	2201      	movs	r2, #1
 800c2ce:	605a      	str	r2, [r3, #4]
}
 800c2d0:	bf00      	nop
 800c2d2:	3710      	adds	r7, #16
 800c2d4:	46bd      	mov	sp, r7
 800c2d6:	bd80      	pop	{r7, pc}

0800c2d8 <yarrowDeinit>:
 * @brief Release PRNG context
 * @param[in] context Pointer to the PRNG context
 **/

void yarrowDeinit(YarrowContext *context)
{
 800c2d8:	b580      	push	{r7, lr}
 800c2da:	b082      	sub	sp, #8
 800c2dc:	af00      	add	r7, sp, #0
 800c2de:	6078      	str	r0, [r7, #4]
   //Erase AES context
   if(context->ready)
 800c2e0:	687b      	ldr	r3, [r7, #4]
 800c2e2:	685b      	ldr	r3, [r3, #4]
 800c2e4:	2b00      	cmp	r3, #0
 800c2e6:	d005      	beq.n	800c2f4 <yarrowDeinit+0x1c>
   {
      aesDeinit(&context->cipherContext);
 800c2e8:	687b      	ldr	r3, [r7, #4]
 800c2ea:	f503 738a 	add.w	r3, r3, #276	; 0x114
 800c2ee:	4618      	mov	r0, r3
 800c2f0:	f7ff f984 	bl	800b5fc <aesDeinit>
   }

   //Free previously allocated resources
   osDeleteMutex(&context->mutex);
 800c2f4:	687b      	ldr	r3, [r7, #4]
 800c2f6:	4618      	mov	r0, r3
 800c2f8:	f7ff fb64 	bl	800b9c4 <osDeleteMutex>

   //Clear PRNG state
   osMemset(context, 0, sizeof(YarrowContext));
 800c2fc:	f44f 724c 	mov.w	r2, #816	; 0x330
 800c300:	2100      	movs	r1, #0
 800c302:	6878      	ldr	r0, [r7, #4]
 800c304:	f002 f8ee 	bl	800e4e4 <memset>
}
 800c308:	bf00      	nop
 800c30a:	3708      	adds	r7, #8
 800c30c:	46bd      	mov	sp, r7
 800c30e:	bd80      	pop	{r7, pc}

0800c310 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
 ldr   sp, =_estack      /* set stack pointer */
 800c310:	f8df d034 	ldr.w	sp, [pc, #52]	; 800c348 <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 800c314:	480d      	ldr	r0, [pc, #52]	; (800c34c <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 800c316:	490e      	ldr	r1, [pc, #56]	; (800c350 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 800c318:	4a0e      	ldr	r2, [pc, #56]	; (800c354 <LoopFillZerobss+0x1e>)
  movs r3, #0
 800c31a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800c31c:	e002      	b.n	800c324 <LoopCopyDataInit>

0800c31e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800c31e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800c320:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800c322:	3304      	adds	r3, #4

0800c324 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800c324:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800c326:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800c328:	d3f9      	bcc.n	800c31e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800c32a:	4a0b      	ldr	r2, [pc, #44]	; (800c358 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 800c32c:	4c0b      	ldr	r4, [pc, #44]	; (800c35c <LoopFillZerobss+0x26>)
  movs r3, #0
 800c32e:	2300      	movs	r3, #0
  b LoopFillZerobss
 800c330:	e001      	b.n	800c336 <LoopFillZerobss>

0800c332 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800c332:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800c334:	3204      	adds	r2, #4

0800c336 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800c336:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800c338:	d3fb      	bcc.n	800c332 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800c33a:	f7ff fcb5 	bl	800bca8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800c33e:	f002 f873 	bl	800e428 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800c342:	f7ff faad 	bl	800b8a0 <main>
  bx  lr    
 800c346:	4770      	bx	lr
 ldr   sp, =_estack      /* set stack pointer */
 800c348:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800c34c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800c350:	200000b0 	.word	0x200000b0
  ldr r2, =_sidata
 800c354:	08010750 	.word	0x08010750
  ldr r2, =_sbss
 800c358:	200000b0 	.word	0x200000b0
  ldr r4, =_ebss
 800c35c:	200017bc 	.word	0x200017bc

0800c360 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800c360:	e7fe      	b.n	800c360 <ADC_IRQHandler>
	...

0800c364 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800c364:	b580      	push	{r7, lr}
 800c366:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800c368:	4b0e      	ldr	r3, [pc, #56]	; (800c3a4 <HAL_Init+0x40>)
 800c36a:	681b      	ldr	r3, [r3, #0]
 800c36c:	4a0d      	ldr	r2, [pc, #52]	; (800c3a4 <HAL_Init+0x40>)
 800c36e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800c372:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 800c374:	4b0b      	ldr	r3, [pc, #44]	; (800c3a4 <HAL_Init+0x40>)
 800c376:	681b      	ldr	r3, [r3, #0]
 800c378:	4a0a      	ldr	r2, [pc, #40]	; (800c3a4 <HAL_Init+0x40>)
 800c37a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800c37e:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800c380:	4b08      	ldr	r3, [pc, #32]	; (800c3a4 <HAL_Init+0x40>)
 800c382:	681b      	ldr	r3, [r3, #0]
 800c384:	4a07      	ldr	r2, [pc, #28]	; (800c3a4 <HAL_Init+0x40>)
 800c386:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c38a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800c38c:	2003      	movs	r0, #3
 800c38e:	f000 f90d 	bl	800c5ac <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800c392:	2000      	movs	r0, #0
 800c394:	f000 f808 	bl	800c3a8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800c398:	f7ff fbfe 	bl	800bb98 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800c39c:	2300      	movs	r3, #0
}
 800c39e:	4618      	mov	r0, r3
 800c3a0:	bd80      	pop	{r7, pc}
 800c3a2:	bf00      	nop
 800c3a4:	40023c00 	.word	0x40023c00

0800c3a8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800c3a8:	b580      	push	{r7, lr}
 800c3aa:	b082      	sub	sp, #8
 800c3ac:	af00      	add	r7, sp, #0
 800c3ae:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800c3b0:	4b12      	ldr	r3, [pc, #72]	; (800c3fc <HAL_InitTick+0x54>)
 800c3b2:	681a      	ldr	r2, [r3, #0]
 800c3b4:	4b12      	ldr	r3, [pc, #72]	; (800c400 <HAL_InitTick+0x58>)
 800c3b6:	781b      	ldrb	r3, [r3, #0]
 800c3b8:	4619      	mov	r1, r3
 800c3ba:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800c3be:	fbb3 f3f1 	udiv	r3, r3, r1
 800c3c2:	fbb2 f3f3 	udiv	r3, r2, r3
 800c3c6:	4618      	mov	r0, r3
 800c3c8:	f000 f917 	bl	800c5fa <HAL_SYSTICK_Config>
 800c3cc:	4603      	mov	r3, r0
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	d001      	beq.n	800c3d6 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800c3d2:	2301      	movs	r3, #1
 800c3d4:	e00e      	b.n	800c3f4 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800c3d6:	687b      	ldr	r3, [r7, #4]
 800c3d8:	2b0f      	cmp	r3, #15
 800c3da:	d80a      	bhi.n	800c3f2 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800c3dc:	2200      	movs	r2, #0
 800c3de:	6879      	ldr	r1, [r7, #4]
 800c3e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800c3e4:	f000 f8ed 	bl	800c5c2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800c3e8:	4a06      	ldr	r2, [pc, #24]	; (800c404 <HAL_InitTick+0x5c>)
 800c3ea:	687b      	ldr	r3, [r7, #4]
 800c3ec:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800c3ee:	2300      	movs	r3, #0
 800c3f0:	e000      	b.n	800c3f4 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800c3f2:	2301      	movs	r3, #1
}
 800c3f4:	4618      	mov	r0, r3
 800c3f6:	3708      	adds	r7, #8
 800c3f8:	46bd      	mov	sp, r7
 800c3fa:	bd80      	pop	{r7, pc}
 800c3fc:	20000040 	.word	0x20000040
 800c400:	20000048 	.word	0x20000048
 800c404:	20000044 	.word	0x20000044

0800c408 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800c408:	b480      	push	{r7}
 800c40a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800c40c:	4b06      	ldr	r3, [pc, #24]	; (800c428 <HAL_IncTick+0x20>)
 800c40e:	781b      	ldrb	r3, [r3, #0]
 800c410:	461a      	mov	r2, r3
 800c412:	4b06      	ldr	r3, [pc, #24]	; (800c42c <HAL_IncTick+0x24>)
 800c414:	681b      	ldr	r3, [r3, #0]
 800c416:	4413      	add	r3, r2
 800c418:	4a04      	ldr	r2, [pc, #16]	; (800c42c <HAL_IncTick+0x24>)
 800c41a:	6013      	str	r3, [r2, #0]
}
 800c41c:	bf00      	nop
 800c41e:	46bd      	mov	sp, r7
 800c420:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c424:	4770      	bx	lr
 800c426:	bf00      	nop
 800c428:	20000048 	.word	0x20000048
 800c42c:	200017a8 	.word	0x200017a8

0800c430 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800c430:	b480      	push	{r7}
 800c432:	af00      	add	r7, sp, #0
  return uwTick;
 800c434:	4b03      	ldr	r3, [pc, #12]	; (800c444 <HAL_GetTick+0x14>)
 800c436:	681b      	ldr	r3, [r3, #0]
}
 800c438:	4618      	mov	r0, r3
 800c43a:	46bd      	mov	sp, r7
 800c43c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c440:	4770      	bx	lr
 800c442:	bf00      	nop
 800c444:	200017a8 	.word	0x200017a8

0800c448 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800c448:	b480      	push	{r7}
 800c44a:	b085      	sub	sp, #20
 800c44c:	af00      	add	r7, sp, #0
 800c44e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800c450:	687b      	ldr	r3, [r7, #4]
 800c452:	f003 0307 	and.w	r3, r3, #7
 800c456:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800c458:	4b0c      	ldr	r3, [pc, #48]	; (800c48c <__NVIC_SetPriorityGrouping+0x44>)
 800c45a:	68db      	ldr	r3, [r3, #12]
 800c45c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800c45e:	68ba      	ldr	r2, [r7, #8]
 800c460:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800c464:	4013      	ands	r3, r2
 800c466:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800c468:	68fb      	ldr	r3, [r7, #12]
 800c46a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800c46c:	68bb      	ldr	r3, [r7, #8]
 800c46e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800c470:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800c474:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c478:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800c47a:	4a04      	ldr	r2, [pc, #16]	; (800c48c <__NVIC_SetPriorityGrouping+0x44>)
 800c47c:	68bb      	ldr	r3, [r7, #8]
 800c47e:	60d3      	str	r3, [r2, #12]
}
 800c480:	bf00      	nop
 800c482:	3714      	adds	r7, #20
 800c484:	46bd      	mov	sp, r7
 800c486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c48a:	4770      	bx	lr
 800c48c:	e000ed00 	.word	0xe000ed00

0800c490 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800c490:	b480      	push	{r7}
 800c492:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800c494:	4b04      	ldr	r3, [pc, #16]	; (800c4a8 <__NVIC_GetPriorityGrouping+0x18>)
 800c496:	68db      	ldr	r3, [r3, #12]
 800c498:	0a1b      	lsrs	r3, r3, #8
 800c49a:	f003 0307 	and.w	r3, r3, #7
}
 800c49e:	4618      	mov	r0, r3
 800c4a0:	46bd      	mov	sp, r7
 800c4a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4a6:	4770      	bx	lr
 800c4a8:	e000ed00 	.word	0xe000ed00

0800c4ac <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800c4ac:	b480      	push	{r7}
 800c4ae:	b083      	sub	sp, #12
 800c4b0:	af00      	add	r7, sp, #0
 800c4b2:	4603      	mov	r3, r0
 800c4b4:	6039      	str	r1, [r7, #0]
 800c4b6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800c4b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c4bc:	2b00      	cmp	r3, #0
 800c4be:	db0a      	blt.n	800c4d6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c4c0:	683b      	ldr	r3, [r7, #0]
 800c4c2:	b2da      	uxtb	r2, r3
 800c4c4:	490c      	ldr	r1, [pc, #48]	; (800c4f8 <__NVIC_SetPriority+0x4c>)
 800c4c6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c4ca:	0112      	lsls	r2, r2, #4
 800c4cc:	b2d2      	uxtb	r2, r2
 800c4ce:	440b      	add	r3, r1
 800c4d0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800c4d4:	e00a      	b.n	800c4ec <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c4d6:	683b      	ldr	r3, [r7, #0]
 800c4d8:	b2da      	uxtb	r2, r3
 800c4da:	4908      	ldr	r1, [pc, #32]	; (800c4fc <__NVIC_SetPriority+0x50>)
 800c4dc:	79fb      	ldrb	r3, [r7, #7]
 800c4de:	f003 030f 	and.w	r3, r3, #15
 800c4e2:	3b04      	subs	r3, #4
 800c4e4:	0112      	lsls	r2, r2, #4
 800c4e6:	b2d2      	uxtb	r2, r2
 800c4e8:	440b      	add	r3, r1
 800c4ea:	761a      	strb	r2, [r3, #24]
}
 800c4ec:	bf00      	nop
 800c4ee:	370c      	adds	r7, #12
 800c4f0:	46bd      	mov	sp, r7
 800c4f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4f6:	4770      	bx	lr
 800c4f8:	e000e100 	.word	0xe000e100
 800c4fc:	e000ed00 	.word	0xe000ed00

0800c500 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800c500:	b480      	push	{r7}
 800c502:	b089      	sub	sp, #36	; 0x24
 800c504:	af00      	add	r7, sp, #0
 800c506:	60f8      	str	r0, [r7, #12]
 800c508:	60b9      	str	r1, [r7, #8]
 800c50a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800c50c:	68fb      	ldr	r3, [r7, #12]
 800c50e:	f003 0307 	and.w	r3, r3, #7
 800c512:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800c514:	69fb      	ldr	r3, [r7, #28]
 800c516:	f1c3 0307 	rsb	r3, r3, #7
 800c51a:	2b04      	cmp	r3, #4
 800c51c:	bf28      	it	cs
 800c51e:	2304      	movcs	r3, #4
 800c520:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800c522:	69fb      	ldr	r3, [r7, #28]
 800c524:	3304      	adds	r3, #4
 800c526:	2b06      	cmp	r3, #6
 800c528:	d902      	bls.n	800c530 <NVIC_EncodePriority+0x30>
 800c52a:	69fb      	ldr	r3, [r7, #28]
 800c52c:	3b03      	subs	r3, #3
 800c52e:	e000      	b.n	800c532 <NVIC_EncodePriority+0x32>
 800c530:	2300      	movs	r3, #0
 800c532:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800c534:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c538:	69bb      	ldr	r3, [r7, #24]
 800c53a:	fa02 f303 	lsl.w	r3, r2, r3
 800c53e:	43da      	mvns	r2, r3
 800c540:	68bb      	ldr	r3, [r7, #8]
 800c542:	401a      	ands	r2, r3
 800c544:	697b      	ldr	r3, [r7, #20]
 800c546:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800c548:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c54c:	697b      	ldr	r3, [r7, #20]
 800c54e:	fa01 f303 	lsl.w	r3, r1, r3
 800c552:	43d9      	mvns	r1, r3
 800c554:	687b      	ldr	r3, [r7, #4]
 800c556:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800c558:	4313      	orrs	r3, r2
         );
}
 800c55a:	4618      	mov	r0, r3
 800c55c:	3724      	adds	r7, #36	; 0x24
 800c55e:	46bd      	mov	sp, r7
 800c560:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c564:	4770      	bx	lr
	...

0800c568 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800c568:	b580      	push	{r7, lr}
 800c56a:	b082      	sub	sp, #8
 800c56c:	af00      	add	r7, sp, #0
 800c56e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800c570:	687b      	ldr	r3, [r7, #4]
 800c572:	3b01      	subs	r3, #1
 800c574:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800c578:	d301      	bcc.n	800c57e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800c57a:	2301      	movs	r3, #1
 800c57c:	e00f      	b.n	800c59e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800c57e:	4a0a      	ldr	r2, [pc, #40]	; (800c5a8 <SysTick_Config+0x40>)
 800c580:	687b      	ldr	r3, [r7, #4]
 800c582:	3b01      	subs	r3, #1
 800c584:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800c586:	210f      	movs	r1, #15
 800c588:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800c58c:	f7ff ff8e 	bl	800c4ac <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800c590:	4b05      	ldr	r3, [pc, #20]	; (800c5a8 <SysTick_Config+0x40>)
 800c592:	2200      	movs	r2, #0
 800c594:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800c596:	4b04      	ldr	r3, [pc, #16]	; (800c5a8 <SysTick_Config+0x40>)
 800c598:	2207      	movs	r2, #7
 800c59a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800c59c:	2300      	movs	r3, #0
}
 800c59e:	4618      	mov	r0, r3
 800c5a0:	3708      	adds	r7, #8
 800c5a2:	46bd      	mov	sp, r7
 800c5a4:	bd80      	pop	{r7, pc}
 800c5a6:	bf00      	nop
 800c5a8:	e000e010 	.word	0xe000e010

0800c5ac <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800c5ac:	b580      	push	{r7, lr}
 800c5ae:	b082      	sub	sp, #8
 800c5b0:	af00      	add	r7, sp, #0
 800c5b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800c5b4:	6878      	ldr	r0, [r7, #4]
 800c5b6:	f7ff ff47 	bl	800c448 <__NVIC_SetPriorityGrouping>
}
 800c5ba:	bf00      	nop
 800c5bc:	3708      	adds	r7, #8
 800c5be:	46bd      	mov	sp, r7
 800c5c0:	bd80      	pop	{r7, pc}

0800c5c2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800c5c2:	b580      	push	{r7, lr}
 800c5c4:	b086      	sub	sp, #24
 800c5c6:	af00      	add	r7, sp, #0
 800c5c8:	4603      	mov	r3, r0
 800c5ca:	60b9      	str	r1, [r7, #8]
 800c5cc:	607a      	str	r2, [r7, #4]
 800c5ce:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 800c5d0:	2300      	movs	r3, #0
 800c5d2:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800c5d4:	f7ff ff5c 	bl	800c490 <__NVIC_GetPriorityGrouping>
 800c5d8:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800c5da:	687a      	ldr	r2, [r7, #4]
 800c5dc:	68b9      	ldr	r1, [r7, #8]
 800c5de:	6978      	ldr	r0, [r7, #20]
 800c5e0:	f7ff ff8e 	bl	800c500 <NVIC_EncodePriority>
 800c5e4:	4602      	mov	r2, r0
 800c5e6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800c5ea:	4611      	mov	r1, r2
 800c5ec:	4618      	mov	r0, r3
 800c5ee:	f7ff ff5d 	bl	800c4ac <__NVIC_SetPriority>
}
 800c5f2:	bf00      	nop
 800c5f4:	3718      	adds	r7, #24
 800c5f6:	46bd      	mov	sp, r7
 800c5f8:	bd80      	pop	{r7, pc}

0800c5fa <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800c5fa:	b580      	push	{r7, lr}
 800c5fc:	b082      	sub	sp, #8
 800c5fe:	af00      	add	r7, sp, #0
 800c600:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800c602:	6878      	ldr	r0, [r7, #4]
 800c604:	f7ff ffb0 	bl	800c568 <SysTick_Config>
 800c608:	4603      	mov	r3, r0
}
 800c60a:	4618      	mov	r0, r3
 800c60c:	3708      	adds	r7, #8
 800c60e:	46bd      	mov	sp, r7
 800c610:	bd80      	pop	{r7, pc}
	...

0800c614 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800c614:	b480      	push	{r7}
 800c616:	b089      	sub	sp, #36	; 0x24
 800c618:	af00      	add	r7, sp, #0
 800c61a:	6078      	str	r0, [r7, #4]
 800c61c:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800c61e:	2300      	movs	r3, #0
 800c620:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800c622:	2300      	movs	r3, #0
 800c624:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 800c626:	2300      	movs	r3, #0
 800c628:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800c62a:	2300      	movs	r3, #0
 800c62c:	61fb      	str	r3, [r7, #28]
 800c62e:	e165      	b.n	800c8fc <HAL_GPIO_Init+0x2e8>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800c630:	2201      	movs	r2, #1
 800c632:	69fb      	ldr	r3, [r7, #28]
 800c634:	fa02 f303 	lsl.w	r3, r2, r3
 800c638:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800c63a:	683b      	ldr	r3, [r7, #0]
 800c63c:	681b      	ldr	r3, [r3, #0]
 800c63e:	697a      	ldr	r2, [r7, #20]
 800c640:	4013      	ands	r3, r2
 800c642:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800c644:	693a      	ldr	r2, [r7, #16]
 800c646:	697b      	ldr	r3, [r7, #20]
 800c648:	429a      	cmp	r2, r3
 800c64a:	f040 8154 	bne.w	800c8f6 <HAL_GPIO_Init+0x2e2>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800c64e:	683b      	ldr	r3, [r7, #0]
 800c650:	685b      	ldr	r3, [r3, #4]
 800c652:	f003 0303 	and.w	r3, r3, #3
 800c656:	2b01      	cmp	r3, #1
 800c658:	d005      	beq.n	800c666 <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800c65a:	683b      	ldr	r3, [r7, #0]
 800c65c:	685b      	ldr	r3, [r3, #4]
 800c65e:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800c662:	2b02      	cmp	r3, #2
 800c664:	d130      	bne.n	800c6c8 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800c666:	687b      	ldr	r3, [r7, #4]
 800c668:	689b      	ldr	r3, [r3, #8]
 800c66a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800c66c:	69fb      	ldr	r3, [r7, #28]
 800c66e:	005b      	lsls	r3, r3, #1
 800c670:	2203      	movs	r2, #3
 800c672:	fa02 f303 	lsl.w	r3, r2, r3
 800c676:	43db      	mvns	r3, r3
 800c678:	69ba      	ldr	r2, [r7, #24]
 800c67a:	4013      	ands	r3, r2
 800c67c:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800c67e:	683b      	ldr	r3, [r7, #0]
 800c680:	68da      	ldr	r2, [r3, #12]
 800c682:	69fb      	ldr	r3, [r7, #28]
 800c684:	005b      	lsls	r3, r3, #1
 800c686:	fa02 f303 	lsl.w	r3, r2, r3
 800c68a:	69ba      	ldr	r2, [r7, #24]
 800c68c:	4313      	orrs	r3, r2
 800c68e:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800c690:	687b      	ldr	r3, [r7, #4]
 800c692:	69ba      	ldr	r2, [r7, #24]
 800c694:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800c696:	687b      	ldr	r3, [r7, #4]
 800c698:	685b      	ldr	r3, [r3, #4]
 800c69a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800c69c:	2201      	movs	r2, #1
 800c69e:	69fb      	ldr	r3, [r7, #28]
 800c6a0:	fa02 f303 	lsl.w	r3, r2, r3
 800c6a4:	43db      	mvns	r3, r3
 800c6a6:	69ba      	ldr	r2, [r7, #24]
 800c6a8:	4013      	ands	r3, r2
 800c6aa:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800c6ac:	683b      	ldr	r3, [r7, #0]
 800c6ae:	685b      	ldr	r3, [r3, #4]
 800c6b0:	091b      	lsrs	r3, r3, #4
 800c6b2:	f003 0201 	and.w	r2, r3, #1
 800c6b6:	69fb      	ldr	r3, [r7, #28]
 800c6b8:	fa02 f303 	lsl.w	r3, r2, r3
 800c6bc:	69ba      	ldr	r2, [r7, #24]
 800c6be:	4313      	orrs	r3, r2
 800c6c0:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800c6c2:	687b      	ldr	r3, [r7, #4]
 800c6c4:	69ba      	ldr	r2, [r7, #24]
 800c6c6:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800c6c8:	683b      	ldr	r3, [r7, #0]
 800c6ca:	685b      	ldr	r3, [r3, #4]
 800c6cc:	f003 0303 	and.w	r3, r3, #3
 800c6d0:	2b03      	cmp	r3, #3
 800c6d2:	d017      	beq.n	800c704 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800c6d4:	687b      	ldr	r3, [r7, #4]
 800c6d6:	68db      	ldr	r3, [r3, #12]
 800c6d8:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800c6da:	69fb      	ldr	r3, [r7, #28]
 800c6dc:	005b      	lsls	r3, r3, #1
 800c6de:	2203      	movs	r2, #3
 800c6e0:	fa02 f303 	lsl.w	r3, r2, r3
 800c6e4:	43db      	mvns	r3, r3
 800c6e6:	69ba      	ldr	r2, [r7, #24]
 800c6e8:	4013      	ands	r3, r2
 800c6ea:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800c6ec:	683b      	ldr	r3, [r7, #0]
 800c6ee:	689a      	ldr	r2, [r3, #8]
 800c6f0:	69fb      	ldr	r3, [r7, #28]
 800c6f2:	005b      	lsls	r3, r3, #1
 800c6f4:	fa02 f303 	lsl.w	r3, r2, r3
 800c6f8:	69ba      	ldr	r2, [r7, #24]
 800c6fa:	4313      	orrs	r3, r2
 800c6fc:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	69ba      	ldr	r2, [r7, #24]
 800c702:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800c704:	683b      	ldr	r3, [r7, #0]
 800c706:	685b      	ldr	r3, [r3, #4]
 800c708:	f003 0303 	and.w	r3, r3, #3
 800c70c:	2b02      	cmp	r3, #2
 800c70e:	d123      	bne.n	800c758 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800c710:	69fb      	ldr	r3, [r7, #28]
 800c712:	08da      	lsrs	r2, r3, #3
 800c714:	687b      	ldr	r3, [r7, #4]
 800c716:	3208      	adds	r2, #8
 800c718:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c71c:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800c71e:	69fb      	ldr	r3, [r7, #28]
 800c720:	f003 0307 	and.w	r3, r3, #7
 800c724:	009b      	lsls	r3, r3, #2
 800c726:	220f      	movs	r2, #15
 800c728:	fa02 f303 	lsl.w	r3, r2, r3
 800c72c:	43db      	mvns	r3, r3
 800c72e:	69ba      	ldr	r2, [r7, #24]
 800c730:	4013      	ands	r3, r2
 800c732:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800c734:	683b      	ldr	r3, [r7, #0]
 800c736:	691a      	ldr	r2, [r3, #16]
 800c738:	69fb      	ldr	r3, [r7, #28]
 800c73a:	f003 0307 	and.w	r3, r3, #7
 800c73e:	009b      	lsls	r3, r3, #2
 800c740:	fa02 f303 	lsl.w	r3, r2, r3
 800c744:	69ba      	ldr	r2, [r7, #24]
 800c746:	4313      	orrs	r3, r2
 800c748:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 800c74a:	69fb      	ldr	r3, [r7, #28]
 800c74c:	08da      	lsrs	r2, r3, #3
 800c74e:	687b      	ldr	r3, [r7, #4]
 800c750:	3208      	adds	r2, #8
 800c752:	69b9      	ldr	r1, [r7, #24]
 800c754:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800c758:	687b      	ldr	r3, [r7, #4]
 800c75a:	681b      	ldr	r3, [r3, #0]
 800c75c:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800c75e:	69fb      	ldr	r3, [r7, #28]
 800c760:	005b      	lsls	r3, r3, #1
 800c762:	2203      	movs	r2, #3
 800c764:	fa02 f303 	lsl.w	r3, r2, r3
 800c768:	43db      	mvns	r3, r3
 800c76a:	69ba      	ldr	r2, [r7, #24]
 800c76c:	4013      	ands	r3, r2
 800c76e:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800c770:	683b      	ldr	r3, [r7, #0]
 800c772:	685b      	ldr	r3, [r3, #4]
 800c774:	f003 0203 	and.w	r2, r3, #3
 800c778:	69fb      	ldr	r3, [r7, #28]
 800c77a:	005b      	lsls	r3, r3, #1
 800c77c:	fa02 f303 	lsl.w	r3, r2, r3
 800c780:	69ba      	ldr	r2, [r7, #24]
 800c782:	4313      	orrs	r3, r2
 800c784:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 800c786:	687b      	ldr	r3, [r7, #4]
 800c788:	69ba      	ldr	r2, [r7, #24]
 800c78a:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800c78c:	683b      	ldr	r3, [r7, #0]
 800c78e:	685b      	ldr	r3, [r3, #4]
 800c790:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800c794:	2b00      	cmp	r3, #0
 800c796:	f000 80ae 	beq.w	800c8f6 <HAL_GPIO_Init+0x2e2>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800c79a:	2300      	movs	r3, #0
 800c79c:	60fb      	str	r3, [r7, #12]
 800c79e:	4b5d      	ldr	r3, [pc, #372]	; (800c914 <HAL_GPIO_Init+0x300>)
 800c7a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c7a2:	4a5c      	ldr	r2, [pc, #368]	; (800c914 <HAL_GPIO_Init+0x300>)
 800c7a4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800c7a8:	6453      	str	r3, [r2, #68]	; 0x44
 800c7aa:	4b5a      	ldr	r3, [pc, #360]	; (800c914 <HAL_GPIO_Init+0x300>)
 800c7ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c7ae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800c7b2:	60fb      	str	r3, [r7, #12]
 800c7b4:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 800c7b6:	4a58      	ldr	r2, [pc, #352]	; (800c918 <HAL_GPIO_Init+0x304>)
 800c7b8:	69fb      	ldr	r3, [r7, #28]
 800c7ba:	089b      	lsrs	r3, r3, #2
 800c7bc:	3302      	adds	r3, #2
 800c7be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c7c2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800c7c4:	69fb      	ldr	r3, [r7, #28]
 800c7c6:	f003 0303 	and.w	r3, r3, #3
 800c7ca:	009b      	lsls	r3, r3, #2
 800c7cc:	220f      	movs	r2, #15
 800c7ce:	fa02 f303 	lsl.w	r3, r2, r3
 800c7d2:	43db      	mvns	r3, r3
 800c7d4:	69ba      	ldr	r2, [r7, #24]
 800c7d6:	4013      	ands	r3, r2
 800c7d8:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	4a4f      	ldr	r2, [pc, #316]	; (800c91c <HAL_GPIO_Init+0x308>)
 800c7de:	4293      	cmp	r3, r2
 800c7e0:	d025      	beq.n	800c82e <HAL_GPIO_Init+0x21a>
 800c7e2:	687b      	ldr	r3, [r7, #4]
 800c7e4:	4a4e      	ldr	r2, [pc, #312]	; (800c920 <HAL_GPIO_Init+0x30c>)
 800c7e6:	4293      	cmp	r3, r2
 800c7e8:	d01f      	beq.n	800c82a <HAL_GPIO_Init+0x216>
 800c7ea:	687b      	ldr	r3, [r7, #4]
 800c7ec:	4a4d      	ldr	r2, [pc, #308]	; (800c924 <HAL_GPIO_Init+0x310>)
 800c7ee:	4293      	cmp	r3, r2
 800c7f0:	d019      	beq.n	800c826 <HAL_GPIO_Init+0x212>
 800c7f2:	687b      	ldr	r3, [r7, #4]
 800c7f4:	4a4c      	ldr	r2, [pc, #304]	; (800c928 <HAL_GPIO_Init+0x314>)
 800c7f6:	4293      	cmp	r3, r2
 800c7f8:	d013      	beq.n	800c822 <HAL_GPIO_Init+0x20e>
 800c7fa:	687b      	ldr	r3, [r7, #4]
 800c7fc:	4a4b      	ldr	r2, [pc, #300]	; (800c92c <HAL_GPIO_Init+0x318>)
 800c7fe:	4293      	cmp	r3, r2
 800c800:	d00d      	beq.n	800c81e <HAL_GPIO_Init+0x20a>
 800c802:	687b      	ldr	r3, [r7, #4]
 800c804:	4a4a      	ldr	r2, [pc, #296]	; (800c930 <HAL_GPIO_Init+0x31c>)
 800c806:	4293      	cmp	r3, r2
 800c808:	d007      	beq.n	800c81a <HAL_GPIO_Init+0x206>
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	4a49      	ldr	r2, [pc, #292]	; (800c934 <HAL_GPIO_Init+0x320>)
 800c80e:	4293      	cmp	r3, r2
 800c810:	d101      	bne.n	800c816 <HAL_GPIO_Init+0x202>
 800c812:	2306      	movs	r3, #6
 800c814:	e00c      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c816:	2307      	movs	r3, #7
 800c818:	e00a      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c81a:	2305      	movs	r3, #5
 800c81c:	e008      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c81e:	2304      	movs	r3, #4
 800c820:	e006      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c822:	2303      	movs	r3, #3
 800c824:	e004      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c826:	2302      	movs	r3, #2
 800c828:	e002      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c82a:	2301      	movs	r3, #1
 800c82c:	e000      	b.n	800c830 <HAL_GPIO_Init+0x21c>
 800c82e:	2300      	movs	r3, #0
 800c830:	69fa      	ldr	r2, [r7, #28]
 800c832:	f002 0203 	and.w	r2, r2, #3
 800c836:	0092      	lsls	r2, r2, #2
 800c838:	4093      	lsls	r3, r2
 800c83a:	69ba      	ldr	r2, [r7, #24]
 800c83c:	4313      	orrs	r3, r2
 800c83e:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800c840:	4935      	ldr	r1, [pc, #212]	; (800c918 <HAL_GPIO_Init+0x304>)
 800c842:	69fb      	ldr	r3, [r7, #28]
 800c844:	089b      	lsrs	r3, r3, #2
 800c846:	3302      	adds	r3, #2
 800c848:	69ba      	ldr	r2, [r7, #24]
 800c84a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800c84e:	4b3a      	ldr	r3, [pc, #232]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c850:	689b      	ldr	r3, [r3, #8]
 800c852:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800c854:	693b      	ldr	r3, [r7, #16]
 800c856:	43db      	mvns	r3, r3
 800c858:	69ba      	ldr	r2, [r7, #24]
 800c85a:	4013      	ands	r3, r2
 800c85c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800c85e:	683b      	ldr	r3, [r7, #0]
 800c860:	685b      	ldr	r3, [r3, #4]
 800c862:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800c866:	2b00      	cmp	r3, #0
 800c868:	d003      	beq.n	800c872 <HAL_GPIO_Init+0x25e>
        {
          temp |= iocurrent;
 800c86a:	69ba      	ldr	r2, [r7, #24]
 800c86c:	693b      	ldr	r3, [r7, #16]
 800c86e:	4313      	orrs	r3, r2
 800c870:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800c872:	4a31      	ldr	r2, [pc, #196]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c874:	69bb      	ldr	r3, [r7, #24]
 800c876:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800c878:	4b2f      	ldr	r3, [pc, #188]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c87a:	68db      	ldr	r3, [r3, #12]
 800c87c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800c87e:	693b      	ldr	r3, [r7, #16]
 800c880:	43db      	mvns	r3, r3
 800c882:	69ba      	ldr	r2, [r7, #24]
 800c884:	4013      	ands	r3, r2
 800c886:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800c888:	683b      	ldr	r3, [r7, #0]
 800c88a:	685b      	ldr	r3, [r3, #4]
 800c88c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800c890:	2b00      	cmp	r3, #0
 800c892:	d003      	beq.n	800c89c <HAL_GPIO_Init+0x288>
        {
          temp |= iocurrent;
 800c894:	69ba      	ldr	r2, [r7, #24]
 800c896:	693b      	ldr	r3, [r7, #16]
 800c898:	4313      	orrs	r3, r2
 800c89a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800c89c:	4a26      	ldr	r2, [pc, #152]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c89e:	69bb      	ldr	r3, [r7, #24]
 800c8a0:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800c8a2:	4b25      	ldr	r3, [pc, #148]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c8a4:	685b      	ldr	r3, [r3, #4]
 800c8a6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800c8a8:	693b      	ldr	r3, [r7, #16]
 800c8aa:	43db      	mvns	r3, r3
 800c8ac:	69ba      	ldr	r2, [r7, #24]
 800c8ae:	4013      	ands	r3, r2
 800c8b0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800c8b2:	683b      	ldr	r3, [r7, #0]
 800c8b4:	685b      	ldr	r3, [r3, #4]
 800c8b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c8ba:	2b00      	cmp	r3, #0
 800c8bc:	d003      	beq.n	800c8c6 <HAL_GPIO_Init+0x2b2>
        {
          temp |= iocurrent;
 800c8be:	69ba      	ldr	r2, [r7, #24]
 800c8c0:	693b      	ldr	r3, [r7, #16]
 800c8c2:	4313      	orrs	r3, r2
 800c8c4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800c8c6:	4a1c      	ldr	r2, [pc, #112]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c8c8:	69bb      	ldr	r3, [r7, #24]
 800c8ca:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800c8cc:	4b1a      	ldr	r3, [pc, #104]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c8ce:	681b      	ldr	r3, [r3, #0]
 800c8d0:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800c8d2:	693b      	ldr	r3, [r7, #16]
 800c8d4:	43db      	mvns	r3, r3
 800c8d6:	69ba      	ldr	r2, [r7, #24]
 800c8d8:	4013      	ands	r3, r2
 800c8da:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800c8dc:	683b      	ldr	r3, [r7, #0]
 800c8de:	685b      	ldr	r3, [r3, #4]
 800c8e0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c8e4:	2b00      	cmp	r3, #0
 800c8e6:	d003      	beq.n	800c8f0 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 800c8e8:	69ba      	ldr	r2, [r7, #24]
 800c8ea:	693b      	ldr	r3, [r7, #16]
 800c8ec:	4313      	orrs	r3, r2
 800c8ee:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800c8f0:	4a11      	ldr	r2, [pc, #68]	; (800c938 <HAL_GPIO_Init+0x324>)
 800c8f2:	69bb      	ldr	r3, [r7, #24]
 800c8f4:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800c8f6:	69fb      	ldr	r3, [r7, #28]
 800c8f8:	3301      	adds	r3, #1
 800c8fa:	61fb      	str	r3, [r7, #28]
 800c8fc:	69fb      	ldr	r3, [r7, #28]
 800c8fe:	2b0f      	cmp	r3, #15
 800c900:	f67f ae96 	bls.w	800c630 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800c904:	bf00      	nop
 800c906:	bf00      	nop
 800c908:	3724      	adds	r7, #36	; 0x24
 800c90a:	46bd      	mov	sp, r7
 800c90c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c910:	4770      	bx	lr
 800c912:	bf00      	nop
 800c914:	40023800 	.word	0x40023800
 800c918:	40013800 	.word	0x40013800
 800c91c:	40020000 	.word	0x40020000
 800c920:	40020400 	.word	0x40020400
 800c924:	40020800 	.word	0x40020800
 800c928:	40020c00 	.word	0x40020c00
 800c92c:	40021000 	.word	0x40021000
 800c930:	40021400 	.word	0x40021400
 800c934:	40021800 	.word	0x40021800
 800c938:	40013c00 	.word	0x40013c00

0800c93c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800c93c:	b480      	push	{r7}
 800c93e:	b083      	sub	sp, #12
 800c940:	af00      	add	r7, sp, #0
 800c942:	6078      	str	r0, [r7, #4]
 800c944:	460b      	mov	r3, r1
 800c946:	807b      	strh	r3, [r7, #2]
 800c948:	4613      	mov	r3, r2
 800c94a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800c94c:	787b      	ldrb	r3, [r7, #1]
 800c94e:	2b00      	cmp	r3, #0
 800c950:	d003      	beq.n	800c95a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800c952:	887a      	ldrh	r2, [r7, #2]
 800c954:	687b      	ldr	r3, [r7, #4]
 800c956:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 800c958:	e003      	b.n	800c962 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800c95a:	887b      	ldrh	r3, [r7, #2]
 800c95c:	041a      	lsls	r2, r3, #16
 800c95e:	687b      	ldr	r3, [r7, #4]
 800c960:	619a      	str	r2, [r3, #24]
}
 800c962:	bf00      	nop
 800c964:	370c      	adds	r7, #12
 800c966:	46bd      	mov	sp, r7
 800c968:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c96c:	4770      	bx	lr
	...

0800c970 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800c970:	b580      	push	{r7, lr}
 800c972:	b082      	sub	sp, #8
 800c974:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0U;
 800c976:	2300      	movs	r3, #0
 800c978:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 800c97a:	2300      	movs	r3, #0
 800c97c:	603b      	str	r3, [r7, #0]
 800c97e:	4b20      	ldr	r3, [pc, #128]	; (800ca00 <HAL_PWREx_EnableOverDrive+0x90>)
 800c980:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c982:	4a1f      	ldr	r2, [pc, #124]	; (800ca00 <HAL_PWREx_EnableOverDrive+0x90>)
 800c984:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c988:	6413      	str	r3, [r2, #64]	; 0x40
 800c98a:	4b1d      	ldr	r3, [pc, #116]	; (800ca00 <HAL_PWREx_EnableOverDrive+0x90>)
 800c98c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c98e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800c992:	603b      	str	r3, [r7, #0]
 800c994:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800c996:	4b1b      	ldr	r3, [pc, #108]	; (800ca04 <HAL_PWREx_EnableOverDrive+0x94>)
 800c998:	2201      	movs	r2, #1
 800c99a:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800c99c:	f7ff fd48 	bl	800c430 <HAL_GetTick>
 800c9a0:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800c9a2:	e009      	b.n	800c9b8 <HAL_PWREx_EnableOverDrive+0x48>
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800c9a4:	f7ff fd44 	bl	800c430 <HAL_GetTick>
 800c9a8:	4602      	mov	r2, r0
 800c9aa:	687b      	ldr	r3, [r7, #4]
 800c9ac:	1ad3      	subs	r3, r2, r3
 800c9ae:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800c9b2:	d901      	bls.n	800c9b8 <HAL_PWREx_EnableOverDrive+0x48>
    {
      return HAL_TIMEOUT;
 800c9b4:	2303      	movs	r3, #3
 800c9b6:	e01f      	b.n	800c9f8 <HAL_PWREx_EnableOverDrive+0x88>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800c9b8:	4b13      	ldr	r3, [pc, #76]	; (800ca08 <HAL_PWREx_EnableOverDrive+0x98>)
 800c9ba:	685b      	ldr	r3, [r3, #4]
 800c9bc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c9c0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c9c4:	d1ee      	bne.n	800c9a4 <HAL_PWREx_EnableOverDrive+0x34>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800c9c6:	4b11      	ldr	r3, [pc, #68]	; (800ca0c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c9c8:	2201      	movs	r2, #1
 800c9ca:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800c9cc:	f7ff fd30 	bl	800c430 <HAL_GetTick>
 800c9d0:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800c9d2:	e009      	b.n	800c9e8 <HAL_PWREx_EnableOverDrive+0x78>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800c9d4:	f7ff fd2c 	bl	800c430 <HAL_GetTick>
 800c9d8:	4602      	mov	r2, r0
 800c9da:	687b      	ldr	r3, [r7, #4]
 800c9dc:	1ad3      	subs	r3, r2, r3
 800c9de:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800c9e2:	d901      	bls.n	800c9e8 <HAL_PWREx_EnableOverDrive+0x78>
    {
      return HAL_TIMEOUT;
 800c9e4:	2303      	movs	r3, #3
 800c9e6:	e007      	b.n	800c9f8 <HAL_PWREx_EnableOverDrive+0x88>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800c9e8:	4b07      	ldr	r3, [pc, #28]	; (800ca08 <HAL_PWREx_EnableOverDrive+0x98>)
 800c9ea:	685b      	ldr	r3, [r3, #4]
 800c9ec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c9f0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800c9f4:	d1ee      	bne.n	800c9d4 <HAL_PWREx_EnableOverDrive+0x64>
    }
  } 
  return HAL_OK;
 800c9f6:	2300      	movs	r3, #0
}
 800c9f8:	4618      	mov	r0, r3
 800c9fa:	3708      	adds	r7, #8
 800c9fc:	46bd      	mov	sp, r7
 800c9fe:	bd80      	pop	{r7, pc}
 800ca00:	40023800 	.word	0x40023800
 800ca04:	420e0040 	.word	0x420e0040
 800ca08:	40007000 	.word	0x40007000
 800ca0c:	420e0044 	.word	0x420e0044

0800ca10 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800ca10:	b580      	push	{r7, lr}
 800ca12:	b084      	sub	sp, #16
 800ca14:	af00      	add	r7, sp, #0
 800ca16:	6078      	str	r0, [r7, #4]
 800ca18:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800ca1a:	687b      	ldr	r3, [r7, #4]
 800ca1c:	2b00      	cmp	r3, #0
 800ca1e:	d101      	bne.n	800ca24 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800ca20:	2301      	movs	r3, #1
 800ca22:	e0cc      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800ca24:	4b68      	ldr	r3, [pc, #416]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800ca26:	681b      	ldr	r3, [r3, #0]
 800ca28:	f003 030f 	and.w	r3, r3, #15
 800ca2c:	683a      	ldr	r2, [r7, #0]
 800ca2e:	429a      	cmp	r2, r3
 800ca30:	d90c      	bls.n	800ca4c <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800ca32:	4b65      	ldr	r3, [pc, #404]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800ca34:	683a      	ldr	r2, [r7, #0]
 800ca36:	b2d2      	uxtb	r2, r2
 800ca38:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800ca3a:	4b63      	ldr	r3, [pc, #396]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800ca3c:	681b      	ldr	r3, [r3, #0]
 800ca3e:	f003 030f 	and.w	r3, r3, #15
 800ca42:	683a      	ldr	r2, [r7, #0]
 800ca44:	429a      	cmp	r2, r3
 800ca46:	d001      	beq.n	800ca4c <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 800ca48:	2301      	movs	r3, #1
 800ca4a:	e0b8      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800ca4c:	687b      	ldr	r3, [r7, #4]
 800ca4e:	681b      	ldr	r3, [r3, #0]
 800ca50:	f003 0302 	and.w	r3, r3, #2
 800ca54:	2b00      	cmp	r3, #0
 800ca56:	d020      	beq.n	800ca9a <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800ca58:	687b      	ldr	r3, [r7, #4]
 800ca5a:	681b      	ldr	r3, [r3, #0]
 800ca5c:	f003 0304 	and.w	r3, r3, #4
 800ca60:	2b00      	cmp	r3, #0
 800ca62:	d005      	beq.n	800ca70 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800ca64:	4b59      	ldr	r3, [pc, #356]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca66:	689b      	ldr	r3, [r3, #8]
 800ca68:	4a58      	ldr	r2, [pc, #352]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca6a:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800ca6e:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800ca70:	687b      	ldr	r3, [r7, #4]
 800ca72:	681b      	ldr	r3, [r3, #0]
 800ca74:	f003 0308 	and.w	r3, r3, #8
 800ca78:	2b00      	cmp	r3, #0
 800ca7a:	d005      	beq.n	800ca88 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800ca7c:	4b53      	ldr	r3, [pc, #332]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca7e:	689b      	ldr	r3, [r3, #8]
 800ca80:	4a52      	ldr	r2, [pc, #328]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca82:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800ca86:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800ca88:	4b50      	ldr	r3, [pc, #320]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca8a:	689b      	ldr	r3, [r3, #8]
 800ca8c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800ca90:	687b      	ldr	r3, [r7, #4]
 800ca92:	689b      	ldr	r3, [r3, #8]
 800ca94:	494d      	ldr	r1, [pc, #308]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800ca96:	4313      	orrs	r3, r2
 800ca98:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800ca9a:	687b      	ldr	r3, [r7, #4]
 800ca9c:	681b      	ldr	r3, [r3, #0]
 800ca9e:	f003 0301 	and.w	r3, r3, #1
 800caa2:	2b00      	cmp	r3, #0
 800caa4:	d044      	beq.n	800cb30 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800caa6:	687b      	ldr	r3, [r7, #4]
 800caa8:	685b      	ldr	r3, [r3, #4]
 800caaa:	2b01      	cmp	r3, #1
 800caac:	d107      	bne.n	800cabe <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800caae:	4b47      	ldr	r3, [pc, #284]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cab0:	681b      	ldr	r3, [r3, #0]
 800cab2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	d119      	bne.n	800caee <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800caba:	2301      	movs	r3, #1
 800cabc:	e07f      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800cabe:	687b      	ldr	r3, [r7, #4]
 800cac0:	685b      	ldr	r3, [r3, #4]
 800cac2:	2b02      	cmp	r3, #2
 800cac4:	d003      	beq.n	800cace <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 800cac6:	687b      	ldr	r3, [r7, #4]
 800cac8:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800caca:	2b03      	cmp	r3, #3
 800cacc:	d107      	bne.n	800cade <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800cace:	4b3f      	ldr	r3, [pc, #252]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cad0:	681b      	ldr	r3, [r3, #0]
 800cad2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800cad6:	2b00      	cmp	r3, #0
 800cad8:	d109      	bne.n	800caee <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800cada:	2301      	movs	r3, #1
 800cadc:	e06f      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800cade:	4b3b      	ldr	r3, [pc, #236]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cae0:	681b      	ldr	r3, [r3, #0]
 800cae2:	f003 0302 	and.w	r3, r3, #2
 800cae6:	2b00      	cmp	r3, #0
 800cae8:	d101      	bne.n	800caee <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800caea:	2301      	movs	r3, #1
 800caec:	e067      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800caee:	4b37      	ldr	r3, [pc, #220]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800caf0:	689b      	ldr	r3, [r3, #8]
 800caf2:	f023 0203 	bic.w	r2, r3, #3
 800caf6:	687b      	ldr	r3, [r7, #4]
 800caf8:	685b      	ldr	r3, [r3, #4]
 800cafa:	4934      	ldr	r1, [pc, #208]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cafc:	4313      	orrs	r3, r2
 800cafe:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800cb00:	f7ff fc96 	bl	800c430 <HAL_GetTick>
 800cb04:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800cb06:	e00a      	b.n	800cb1e <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800cb08:	f7ff fc92 	bl	800c430 <HAL_GetTick>
 800cb0c:	4602      	mov	r2, r0
 800cb0e:	68fb      	ldr	r3, [r7, #12]
 800cb10:	1ad3      	subs	r3, r2, r3
 800cb12:	f241 3288 	movw	r2, #5000	; 0x1388
 800cb16:	4293      	cmp	r3, r2
 800cb18:	d901      	bls.n	800cb1e <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 800cb1a:	2303      	movs	r3, #3
 800cb1c:	e04f      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800cb1e:	4b2b      	ldr	r3, [pc, #172]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb20:	689b      	ldr	r3, [r3, #8]
 800cb22:	f003 020c 	and.w	r2, r3, #12
 800cb26:	687b      	ldr	r3, [r7, #4]
 800cb28:	685b      	ldr	r3, [r3, #4]
 800cb2a:	009b      	lsls	r3, r3, #2
 800cb2c:	429a      	cmp	r2, r3
 800cb2e:	d1eb      	bne.n	800cb08 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800cb30:	4b25      	ldr	r3, [pc, #148]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800cb32:	681b      	ldr	r3, [r3, #0]
 800cb34:	f003 030f 	and.w	r3, r3, #15
 800cb38:	683a      	ldr	r2, [r7, #0]
 800cb3a:	429a      	cmp	r2, r3
 800cb3c:	d20c      	bcs.n	800cb58 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800cb3e:	4b22      	ldr	r3, [pc, #136]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800cb40:	683a      	ldr	r2, [r7, #0]
 800cb42:	b2d2      	uxtb	r2, r2
 800cb44:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800cb46:	4b20      	ldr	r3, [pc, #128]	; (800cbc8 <HAL_RCC_ClockConfig+0x1b8>)
 800cb48:	681b      	ldr	r3, [r3, #0]
 800cb4a:	f003 030f 	and.w	r3, r3, #15
 800cb4e:	683a      	ldr	r2, [r7, #0]
 800cb50:	429a      	cmp	r2, r3
 800cb52:	d001      	beq.n	800cb58 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 800cb54:	2301      	movs	r3, #1
 800cb56:	e032      	b.n	800cbbe <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800cb58:	687b      	ldr	r3, [r7, #4]
 800cb5a:	681b      	ldr	r3, [r3, #0]
 800cb5c:	f003 0304 	and.w	r3, r3, #4
 800cb60:	2b00      	cmp	r3, #0
 800cb62:	d008      	beq.n	800cb76 <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800cb64:	4b19      	ldr	r3, [pc, #100]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb66:	689b      	ldr	r3, [r3, #8]
 800cb68:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	68db      	ldr	r3, [r3, #12]
 800cb70:	4916      	ldr	r1, [pc, #88]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb72:	4313      	orrs	r3, r2
 800cb74:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800cb76:	687b      	ldr	r3, [r7, #4]
 800cb78:	681b      	ldr	r3, [r3, #0]
 800cb7a:	f003 0308 	and.w	r3, r3, #8
 800cb7e:	2b00      	cmp	r3, #0
 800cb80:	d009      	beq.n	800cb96 <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800cb82:	4b12      	ldr	r3, [pc, #72]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb84:	689b      	ldr	r3, [r3, #8]
 800cb86:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800cb8a:	687b      	ldr	r3, [r7, #4]
 800cb8c:	691b      	ldr	r3, [r3, #16]
 800cb8e:	00db      	lsls	r3, r3, #3
 800cb90:	490e      	ldr	r1, [pc, #56]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb92:	4313      	orrs	r3, r2
 800cb94:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800cb96:	f000 f855 	bl	800cc44 <HAL_RCC_GetSysClockFreq>
 800cb9a:	4602      	mov	r2, r0
 800cb9c:	4b0b      	ldr	r3, [pc, #44]	; (800cbcc <HAL_RCC_ClockConfig+0x1bc>)
 800cb9e:	689b      	ldr	r3, [r3, #8]
 800cba0:	091b      	lsrs	r3, r3, #4
 800cba2:	f003 030f 	and.w	r3, r3, #15
 800cba6:	490a      	ldr	r1, [pc, #40]	; (800cbd0 <HAL_RCC_ClockConfig+0x1c0>)
 800cba8:	5ccb      	ldrb	r3, [r1, r3]
 800cbaa:	fa22 f303 	lsr.w	r3, r2, r3
 800cbae:	4a09      	ldr	r2, [pc, #36]	; (800cbd4 <HAL_RCC_ClockConfig+0x1c4>)
 800cbb0:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 800cbb2:	4b09      	ldr	r3, [pc, #36]	; (800cbd8 <HAL_RCC_ClockConfig+0x1c8>)
 800cbb4:	681b      	ldr	r3, [r3, #0]
 800cbb6:	4618      	mov	r0, r3
 800cbb8:	f7ff fbf6 	bl	800c3a8 <HAL_InitTick>

  return HAL_OK;
 800cbbc:	2300      	movs	r3, #0
}
 800cbbe:	4618      	mov	r0, r3
 800cbc0:	3710      	adds	r7, #16
 800cbc2:	46bd      	mov	sp, r7
 800cbc4:	bd80      	pop	{r7, pc}
 800cbc6:	bf00      	nop
 800cbc8:	40023c00 	.word	0x40023c00
 800cbcc:	40023800 	.word	0x40023800
 800cbd0:	08010684 	.word	0x08010684
 800cbd4:	20000040 	.word	0x20000040
 800cbd8:	20000044 	.word	0x20000044

0800cbdc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800cbdc:	b480      	push	{r7}
 800cbde:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800cbe0:	4b03      	ldr	r3, [pc, #12]	; (800cbf0 <HAL_RCC_GetHCLKFreq+0x14>)
 800cbe2:	681b      	ldr	r3, [r3, #0]
}
 800cbe4:	4618      	mov	r0, r3
 800cbe6:	46bd      	mov	sp, r7
 800cbe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbec:	4770      	bx	lr
 800cbee:	bf00      	nop
 800cbf0:	20000040 	.word	0x20000040

0800cbf4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800cbf4:	b580      	push	{r7, lr}
 800cbf6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800cbf8:	f7ff fff0 	bl	800cbdc <HAL_RCC_GetHCLKFreq>
 800cbfc:	4602      	mov	r2, r0
 800cbfe:	4b05      	ldr	r3, [pc, #20]	; (800cc14 <HAL_RCC_GetPCLK1Freq+0x20>)
 800cc00:	689b      	ldr	r3, [r3, #8]
 800cc02:	0a9b      	lsrs	r3, r3, #10
 800cc04:	f003 0307 	and.w	r3, r3, #7
 800cc08:	4903      	ldr	r1, [pc, #12]	; (800cc18 <HAL_RCC_GetPCLK1Freq+0x24>)
 800cc0a:	5ccb      	ldrb	r3, [r1, r3]
 800cc0c:	fa22 f303 	lsr.w	r3, r2, r3
}
 800cc10:	4618      	mov	r0, r3
 800cc12:	bd80      	pop	{r7, pc}
 800cc14:	40023800 	.word	0x40023800
 800cc18:	08010694 	.word	0x08010694

0800cc1c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800cc1c:	b580      	push	{r7, lr}
 800cc1e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 800cc20:	f7ff ffdc 	bl	800cbdc <HAL_RCC_GetHCLKFreq>
 800cc24:	4602      	mov	r2, r0
 800cc26:	4b05      	ldr	r3, [pc, #20]	; (800cc3c <HAL_RCC_GetPCLK2Freq+0x20>)
 800cc28:	689b      	ldr	r3, [r3, #8]
 800cc2a:	0b5b      	lsrs	r3, r3, #13
 800cc2c:	f003 0307 	and.w	r3, r3, #7
 800cc30:	4903      	ldr	r1, [pc, #12]	; (800cc40 <HAL_RCC_GetPCLK2Freq+0x24>)
 800cc32:	5ccb      	ldrb	r3, [r1, r3]
 800cc34:	fa22 f303 	lsr.w	r3, r2, r3
}
 800cc38:	4618      	mov	r0, r3
 800cc3a:	bd80      	pop	{r7, pc}
 800cc3c:	40023800 	.word	0x40023800
 800cc40:	08010694 	.word	0x08010694

0800cc44 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800cc44:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800cc48:	b0ae      	sub	sp, #184	; 0xb8
 800cc4a:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U;
 800cc4c:	2300      	movs	r3, #0
 800cc4e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  uint32_t pllvco = 0U;
 800cc52:	2300      	movs	r3, #0
 800cc54:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  uint32_t pllp = 0U;
 800cc58:	2300      	movs	r3, #0
 800cc5a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  uint32_t pllr = 0U;
 800cc5e:	2300      	movs	r3, #0
 800cc60:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  uint32_t sysclockfreq = 0U;
 800cc64:	2300      	movs	r3, #0
 800cc66:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800cc6a:	4bcb      	ldr	r3, [pc, #812]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800cc6c:	689b      	ldr	r3, [r3, #8]
 800cc6e:	f003 030c 	and.w	r3, r3, #12
 800cc72:	2b0c      	cmp	r3, #12
 800cc74:	f200 8206 	bhi.w	800d084 <HAL_RCC_GetSysClockFreq+0x440>
 800cc78:	a201      	add	r2, pc, #4	; (adr r2, 800cc80 <HAL_RCC_GetSysClockFreq+0x3c>)
 800cc7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cc7e:	bf00      	nop
 800cc80:	0800ccb5 	.word	0x0800ccb5
 800cc84:	0800d085 	.word	0x0800d085
 800cc88:	0800d085 	.word	0x0800d085
 800cc8c:	0800d085 	.word	0x0800d085
 800cc90:	0800ccbd 	.word	0x0800ccbd
 800cc94:	0800d085 	.word	0x0800d085
 800cc98:	0800d085 	.word	0x0800d085
 800cc9c:	0800d085 	.word	0x0800d085
 800cca0:	0800ccc5 	.word	0x0800ccc5
 800cca4:	0800d085 	.word	0x0800d085
 800cca8:	0800d085 	.word	0x0800d085
 800ccac:	0800d085 	.word	0x0800d085
 800ccb0:	0800ceb5 	.word	0x0800ceb5
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800ccb4:	4bb9      	ldr	r3, [pc, #740]	; (800cf9c <HAL_RCC_GetSysClockFreq+0x358>)
 800ccb6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
       break;
 800ccba:	e1e7      	b.n	800d08c <HAL_RCC_GetSysClockFreq+0x448>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800ccbc:	4bb8      	ldr	r3, [pc, #736]	; (800cfa0 <HAL_RCC_GetSysClockFreq+0x35c>)
 800ccbe:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      break;
 800ccc2:	e1e3      	b.n	800d08c <HAL_RCC_GetSysClockFreq+0x448>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL/PLLP used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800ccc4:	4bb4      	ldr	r3, [pc, #720]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800ccc6:	685b      	ldr	r3, [r3, #4]
 800ccc8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800cccc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800ccd0:	4bb1      	ldr	r3, [pc, #708]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800ccd2:	685b      	ldr	r3, [r3, #4]
 800ccd4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800ccd8:	2b00      	cmp	r3, #0
 800ccda:	d071      	beq.n	800cdc0 <HAL_RCC_GetSysClockFreq+0x17c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800ccdc:	4bae      	ldr	r3, [pc, #696]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800ccde:	685b      	ldr	r3, [r3, #4]
 800cce0:	099b      	lsrs	r3, r3, #6
 800cce2:	2200      	movs	r2, #0
 800cce4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800cce8:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
 800ccec:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800ccf0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ccf4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800ccf8:	2300      	movs	r3, #0
 800ccfa:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800ccfe:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	; 0x90
 800cd02:	4622      	mov	r2, r4
 800cd04:	462b      	mov	r3, r5
 800cd06:	f04f 0000 	mov.w	r0, #0
 800cd0a:	f04f 0100 	mov.w	r1, #0
 800cd0e:	0159      	lsls	r1, r3, #5
 800cd10:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800cd14:	0150      	lsls	r0, r2, #5
 800cd16:	4602      	mov	r2, r0
 800cd18:	460b      	mov	r3, r1
 800cd1a:	4621      	mov	r1, r4
 800cd1c:	1a51      	subs	r1, r2, r1
 800cd1e:	6439      	str	r1, [r7, #64]	; 0x40
 800cd20:	4629      	mov	r1, r5
 800cd22:	eb63 0301 	sbc.w	r3, r3, r1
 800cd26:	647b      	str	r3, [r7, #68]	; 0x44
 800cd28:	f04f 0200 	mov.w	r2, #0
 800cd2c:	f04f 0300 	mov.w	r3, #0
 800cd30:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	; 0x40
 800cd34:	4649      	mov	r1, r9
 800cd36:	018b      	lsls	r3, r1, #6
 800cd38:	4641      	mov	r1, r8
 800cd3a:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 800cd3e:	4641      	mov	r1, r8
 800cd40:	018a      	lsls	r2, r1, #6
 800cd42:	4641      	mov	r1, r8
 800cd44:	1a51      	subs	r1, r2, r1
 800cd46:	63b9      	str	r1, [r7, #56]	; 0x38
 800cd48:	4649      	mov	r1, r9
 800cd4a:	eb63 0301 	sbc.w	r3, r3, r1
 800cd4e:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cd50:	f04f 0200 	mov.w	r2, #0
 800cd54:	f04f 0300 	mov.w	r3, #0
 800cd58:	e9d7 890e 	ldrd	r8, r9, [r7, #56]	; 0x38
 800cd5c:	4649      	mov	r1, r9
 800cd5e:	00cb      	lsls	r3, r1, #3
 800cd60:	4641      	mov	r1, r8
 800cd62:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800cd66:	4641      	mov	r1, r8
 800cd68:	00ca      	lsls	r2, r1, #3
 800cd6a:	4610      	mov	r0, r2
 800cd6c:	4619      	mov	r1, r3
 800cd6e:	4603      	mov	r3, r0
 800cd70:	4622      	mov	r2, r4
 800cd72:	189b      	adds	r3, r3, r2
 800cd74:	633b      	str	r3, [r7, #48]	; 0x30
 800cd76:	462b      	mov	r3, r5
 800cd78:	460a      	mov	r2, r1
 800cd7a:	eb42 0303 	adc.w	r3, r2, r3
 800cd7e:	637b      	str	r3, [r7, #52]	; 0x34
 800cd80:	f04f 0200 	mov.w	r2, #0
 800cd84:	f04f 0300 	mov.w	r3, #0
 800cd88:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	; 0x30
 800cd8c:	4629      	mov	r1, r5
 800cd8e:	024b      	lsls	r3, r1, #9
 800cd90:	4621      	mov	r1, r4
 800cd92:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 800cd96:	4621      	mov	r1, r4
 800cd98:	024a      	lsls	r2, r1, #9
 800cd9a:	4610      	mov	r0, r2
 800cd9c:	4619      	mov	r1, r3
 800cd9e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cda2:	2200      	movs	r2, #0
 800cda4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800cda8:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 800cdac:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800cdb0:	f7f3 fa32 	bl	8000218 <__aeabi_uldivmod>
 800cdb4:	4602      	mov	r2, r0
 800cdb6:	460b      	mov	r3, r1
 800cdb8:	4613      	mov	r3, r2
 800cdba:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800cdbe:	e067      	b.n	800ce90 <HAL_RCC_GetSysClockFreq+0x24c>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800cdc0:	4b75      	ldr	r3, [pc, #468]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800cdc2:	685b      	ldr	r3, [r3, #4]
 800cdc4:	099b      	lsrs	r3, r3, #6
 800cdc6:	2200      	movs	r2, #0
 800cdc8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800cdcc:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
 800cdd0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800cdd4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cdd8:	67bb      	str	r3, [r7, #120]	; 0x78
 800cdda:	2300      	movs	r3, #0
 800cddc:	67fb      	str	r3, [r7, #124]	; 0x7c
 800cdde:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	; 0x78
 800cde2:	4622      	mov	r2, r4
 800cde4:	462b      	mov	r3, r5
 800cde6:	f04f 0000 	mov.w	r0, #0
 800cdea:	f04f 0100 	mov.w	r1, #0
 800cdee:	0159      	lsls	r1, r3, #5
 800cdf0:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800cdf4:	0150      	lsls	r0, r2, #5
 800cdf6:	4602      	mov	r2, r0
 800cdf8:	460b      	mov	r3, r1
 800cdfa:	4621      	mov	r1, r4
 800cdfc:	1a51      	subs	r1, r2, r1
 800cdfe:	62b9      	str	r1, [r7, #40]	; 0x28
 800ce00:	4629      	mov	r1, r5
 800ce02:	eb63 0301 	sbc.w	r3, r3, r1
 800ce06:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ce08:	f04f 0200 	mov.w	r2, #0
 800ce0c:	f04f 0300 	mov.w	r3, #0
 800ce10:	e9d7 890a 	ldrd	r8, r9, [r7, #40]	; 0x28
 800ce14:	4649      	mov	r1, r9
 800ce16:	018b      	lsls	r3, r1, #6
 800ce18:	4641      	mov	r1, r8
 800ce1a:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 800ce1e:	4641      	mov	r1, r8
 800ce20:	018a      	lsls	r2, r1, #6
 800ce22:	4641      	mov	r1, r8
 800ce24:	ebb2 0a01 	subs.w	sl, r2, r1
 800ce28:	4649      	mov	r1, r9
 800ce2a:	eb63 0b01 	sbc.w	fp, r3, r1
 800ce2e:	f04f 0200 	mov.w	r2, #0
 800ce32:	f04f 0300 	mov.w	r3, #0
 800ce36:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 800ce3a:	ea43 735a 	orr.w	r3, r3, sl, lsr #29
 800ce3e:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800ce42:	4692      	mov	sl, r2
 800ce44:	469b      	mov	fp, r3
 800ce46:	4623      	mov	r3, r4
 800ce48:	eb1a 0303 	adds.w	r3, sl, r3
 800ce4c:	623b      	str	r3, [r7, #32]
 800ce4e:	462b      	mov	r3, r5
 800ce50:	eb4b 0303 	adc.w	r3, fp, r3
 800ce54:	627b      	str	r3, [r7, #36]	; 0x24
 800ce56:	f04f 0200 	mov.w	r2, #0
 800ce5a:	f04f 0300 	mov.w	r3, #0
 800ce5e:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 800ce62:	4629      	mov	r1, r5
 800ce64:	028b      	lsls	r3, r1, #10
 800ce66:	4621      	mov	r1, r4
 800ce68:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 800ce6c:	4621      	mov	r1, r4
 800ce6e:	028a      	lsls	r2, r1, #10
 800ce70:	4610      	mov	r0, r2
 800ce72:	4619      	mov	r1, r3
 800ce74:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800ce78:	2200      	movs	r2, #0
 800ce7a:	673b      	str	r3, [r7, #112]	; 0x70
 800ce7c:	677a      	str	r2, [r7, #116]	; 0x74
 800ce7e:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800ce82:	f7f3 f9c9 	bl	8000218 <__aeabi_uldivmod>
 800ce86:	4602      	mov	r2, r0
 800ce88:	460b      	mov	r3, r1
 800ce8a:	4613      	mov	r3, r2
 800ce8c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800ce90:	4b41      	ldr	r3, [pc, #260]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800ce92:	685b      	ldr	r3, [r3, #4]
 800ce94:	0c1b      	lsrs	r3, r3, #16
 800ce96:	f003 0303 	and.w	r3, r3, #3
 800ce9a:	3301      	adds	r3, #1
 800ce9c:	005b      	lsls	r3, r3, #1
 800ce9e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

      sysclockfreq = pllvco/pllp;
 800cea2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800cea6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800ceaa:	fbb2 f3f3 	udiv	r3, r2, r3
 800ceae:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      break;
 800ceb2:	e0eb      	b.n	800d08c <HAL_RCC_GetSysClockFreq+0x448>
    }
    case RCC_CFGR_SWS_PLLR:  /* PLL/PLLR used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800ceb4:	4b38      	ldr	r3, [pc, #224]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800ceb6:	685b      	ldr	r3, [r3, #4]
 800ceb8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800cebc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800cec0:	4b35      	ldr	r3, [pc, #212]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800cec2:	685b      	ldr	r3, [r3, #4]
 800cec4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800cec8:	2b00      	cmp	r3, #0
 800ceca:	d06b      	beq.n	800cfa4 <HAL_RCC_GetSysClockFreq+0x360>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800cecc:	4b32      	ldr	r3, [pc, #200]	; (800cf98 <HAL_RCC_GetSysClockFreq+0x354>)
 800cece:	685b      	ldr	r3, [r3, #4]
 800ced0:	099b      	lsrs	r3, r3, #6
 800ced2:	2200      	movs	r2, #0
 800ced4:	66bb      	str	r3, [r7, #104]	; 0x68
 800ced6:	66fa      	str	r2, [r7, #108]	; 0x6c
 800ced8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ceda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cede:	663b      	str	r3, [r7, #96]	; 0x60
 800cee0:	2300      	movs	r3, #0
 800cee2:	667b      	str	r3, [r7, #100]	; 0x64
 800cee4:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	; 0x60
 800cee8:	4622      	mov	r2, r4
 800ceea:	462b      	mov	r3, r5
 800ceec:	f04f 0000 	mov.w	r0, #0
 800cef0:	f04f 0100 	mov.w	r1, #0
 800cef4:	0159      	lsls	r1, r3, #5
 800cef6:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800cefa:	0150      	lsls	r0, r2, #5
 800cefc:	4602      	mov	r2, r0
 800cefe:	460b      	mov	r3, r1
 800cf00:	4621      	mov	r1, r4
 800cf02:	1a51      	subs	r1, r2, r1
 800cf04:	61b9      	str	r1, [r7, #24]
 800cf06:	4629      	mov	r1, r5
 800cf08:	eb63 0301 	sbc.w	r3, r3, r1
 800cf0c:	61fb      	str	r3, [r7, #28]
 800cf0e:	f04f 0200 	mov.w	r2, #0
 800cf12:	f04f 0300 	mov.w	r3, #0
 800cf16:	e9d7 ab06 	ldrd	sl, fp, [r7, #24]
 800cf1a:	4659      	mov	r1, fp
 800cf1c:	018b      	lsls	r3, r1, #6
 800cf1e:	4651      	mov	r1, sl
 800cf20:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 800cf24:	4651      	mov	r1, sl
 800cf26:	018a      	lsls	r2, r1, #6
 800cf28:	4651      	mov	r1, sl
 800cf2a:	ebb2 0801 	subs.w	r8, r2, r1
 800cf2e:	4659      	mov	r1, fp
 800cf30:	eb63 0901 	sbc.w	r9, r3, r1
 800cf34:	f04f 0200 	mov.w	r2, #0
 800cf38:	f04f 0300 	mov.w	r3, #0
 800cf3c:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 800cf40:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 800cf44:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 800cf48:	4690      	mov	r8, r2
 800cf4a:	4699      	mov	r9, r3
 800cf4c:	4623      	mov	r3, r4
 800cf4e:	eb18 0303 	adds.w	r3, r8, r3
 800cf52:	613b      	str	r3, [r7, #16]
 800cf54:	462b      	mov	r3, r5
 800cf56:	eb49 0303 	adc.w	r3, r9, r3
 800cf5a:	617b      	str	r3, [r7, #20]
 800cf5c:	f04f 0200 	mov.w	r2, #0
 800cf60:	f04f 0300 	mov.w	r3, #0
 800cf64:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
 800cf68:	4629      	mov	r1, r5
 800cf6a:	024b      	lsls	r3, r1, #9
 800cf6c:	4621      	mov	r1, r4
 800cf6e:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 800cf72:	4621      	mov	r1, r4
 800cf74:	024a      	lsls	r2, r1, #9
 800cf76:	4610      	mov	r0, r2
 800cf78:	4619      	mov	r1, r3
 800cf7a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800cf7e:	2200      	movs	r2, #0
 800cf80:	65bb      	str	r3, [r7, #88]	; 0x58
 800cf82:	65fa      	str	r2, [r7, #92]	; 0x5c
 800cf84:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800cf88:	f7f3 f946 	bl	8000218 <__aeabi_uldivmod>
 800cf8c:	4602      	mov	r2, r0
 800cf8e:	460b      	mov	r3, r1
 800cf90:	4613      	mov	r3, r2
 800cf92:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800cf96:	e065      	b.n	800d064 <HAL_RCC_GetSysClockFreq+0x420>
 800cf98:	40023800 	.word	0x40023800
 800cf9c:	00f42400 	.word	0x00f42400
 800cfa0:	007a1200 	.word	0x007a1200
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800cfa4:	4b3d      	ldr	r3, [pc, #244]	; (800d09c <HAL_RCC_GetSysClockFreq+0x458>)
 800cfa6:	685b      	ldr	r3, [r3, #4]
 800cfa8:	099b      	lsrs	r3, r3, #6
 800cfaa:	2200      	movs	r2, #0
 800cfac:	4618      	mov	r0, r3
 800cfae:	4611      	mov	r1, r2
 800cfb0:	f3c0 0308 	ubfx	r3, r0, #0, #9
 800cfb4:	653b      	str	r3, [r7, #80]	; 0x50
 800cfb6:	2300      	movs	r3, #0
 800cfb8:	657b      	str	r3, [r7, #84]	; 0x54
 800cfba:	e9d7 8914 	ldrd	r8, r9, [r7, #80]	; 0x50
 800cfbe:	4642      	mov	r2, r8
 800cfc0:	464b      	mov	r3, r9
 800cfc2:	f04f 0000 	mov.w	r0, #0
 800cfc6:	f04f 0100 	mov.w	r1, #0
 800cfca:	0159      	lsls	r1, r3, #5
 800cfcc:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800cfd0:	0150      	lsls	r0, r2, #5
 800cfd2:	4602      	mov	r2, r0
 800cfd4:	460b      	mov	r3, r1
 800cfd6:	4641      	mov	r1, r8
 800cfd8:	1a51      	subs	r1, r2, r1
 800cfda:	60b9      	str	r1, [r7, #8]
 800cfdc:	4649      	mov	r1, r9
 800cfde:	eb63 0301 	sbc.w	r3, r3, r1
 800cfe2:	60fb      	str	r3, [r7, #12]
 800cfe4:	f04f 0200 	mov.w	r2, #0
 800cfe8:	f04f 0300 	mov.w	r3, #0
 800cfec:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
 800cff0:	4659      	mov	r1, fp
 800cff2:	018b      	lsls	r3, r1, #6
 800cff4:	4651      	mov	r1, sl
 800cff6:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 800cffa:	4651      	mov	r1, sl
 800cffc:	018a      	lsls	r2, r1, #6
 800cffe:	4651      	mov	r1, sl
 800d000:	1a54      	subs	r4, r2, r1
 800d002:	4659      	mov	r1, fp
 800d004:	eb63 0501 	sbc.w	r5, r3, r1
 800d008:	f04f 0200 	mov.w	r2, #0
 800d00c:	f04f 0300 	mov.w	r3, #0
 800d010:	00eb      	lsls	r3, r5, #3
 800d012:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 800d016:	00e2      	lsls	r2, r4, #3
 800d018:	4614      	mov	r4, r2
 800d01a:	461d      	mov	r5, r3
 800d01c:	4643      	mov	r3, r8
 800d01e:	18e3      	adds	r3, r4, r3
 800d020:	603b      	str	r3, [r7, #0]
 800d022:	464b      	mov	r3, r9
 800d024:	eb45 0303 	adc.w	r3, r5, r3
 800d028:	607b      	str	r3, [r7, #4]
 800d02a:	f04f 0200 	mov.w	r2, #0
 800d02e:	f04f 0300 	mov.w	r3, #0
 800d032:	e9d7 4500 	ldrd	r4, r5, [r7]
 800d036:	4629      	mov	r1, r5
 800d038:	028b      	lsls	r3, r1, #10
 800d03a:	4621      	mov	r1, r4
 800d03c:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 800d040:	4621      	mov	r1, r4
 800d042:	028a      	lsls	r2, r1, #10
 800d044:	4610      	mov	r0, r2
 800d046:	4619      	mov	r1, r3
 800d048:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800d04c:	2200      	movs	r2, #0
 800d04e:	64bb      	str	r3, [r7, #72]	; 0x48
 800d050:	64fa      	str	r2, [r7, #76]	; 0x4c
 800d052:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800d056:	f7f3 f8df 	bl	8000218 <__aeabi_uldivmod>
 800d05a:	4602      	mov	r2, r0
 800d05c:	460b      	mov	r3, r1
 800d05e:	4613      	mov	r3, r2
 800d060:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      }
      pllr = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos);
 800d064:	4b0d      	ldr	r3, [pc, #52]	; (800d09c <HAL_RCC_GetSysClockFreq+0x458>)
 800d066:	685b      	ldr	r3, [r3, #4]
 800d068:	0f1b      	lsrs	r3, r3, #28
 800d06a:	f003 0307 	and.w	r3, r3, #7
 800d06e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

      sysclockfreq = pllvco/pllr;
 800d072:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800d076:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800d07a:	fbb2 f3f3 	udiv	r3, r2, r3
 800d07e:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      break;
 800d082:	e003      	b.n	800d08c <HAL_RCC_GetSysClockFreq+0x448>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800d084:	4b06      	ldr	r3, [pc, #24]	; (800d0a0 <HAL_RCC_GetSysClockFreq+0x45c>)
 800d086:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      break;
 800d08a:	bf00      	nop
    }
  }
  return sysclockfreq;
 800d08c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
}
 800d090:	4618      	mov	r0, r3
 800d092:	37b8      	adds	r7, #184	; 0xb8
 800d094:	46bd      	mov	sp, r7
 800d096:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800d09a:	bf00      	nop
 800d09c:	40023800 	.word	0x40023800
 800d0a0:	00f42400 	.word	0x00f42400

0800d0a4 <HAL_RCC_OscConfig>:
  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature
  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800d0a4:	b580      	push	{r7, lr}
 800d0a6:	b086      	sub	sp, #24
 800d0a8:	af00      	add	r7, sp, #0
 800d0aa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800d0ac:	687b      	ldr	r3, [r7, #4]
 800d0ae:	2b00      	cmp	r3, #0
 800d0b0:	d101      	bne.n	800d0b6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800d0b2:	2301      	movs	r3, #1
 800d0b4:	e28d      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800d0b6:	687b      	ldr	r3, [r7, #4]
 800d0b8:	681b      	ldr	r3, [r3, #0]
 800d0ba:	f003 0301 	and.w	r3, r3, #1
 800d0be:	2b00      	cmp	r3, #0
 800d0c0:	f000 8083 	beq.w	800d1ca <HAL_RCC_OscConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 800d0c4:	4b94      	ldr	r3, [pc, #592]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d0c6:	689b      	ldr	r3, [r3, #8]
 800d0c8:	f003 030c 	and.w	r3, r3, #12
 800d0cc:	2b04      	cmp	r3, #4
 800d0ce:	d019      	beq.n	800d104 <HAL_RCC_OscConfig+0x60>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 800d0d0:	4b91      	ldr	r3, [pc, #580]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d0d2:	689b      	ldr	r3, [r3, #8]
 800d0d4:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 800d0d8:	2b08      	cmp	r3, #8
 800d0da:	d106      	bne.n	800d0ea <HAL_RCC_OscConfig+0x46>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 800d0dc:	4b8e      	ldr	r3, [pc, #568]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d0de:	685b      	ldr	r3, [r3, #4]
 800d0e0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d0e4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800d0e8:	d00c      	beq.n	800d104 <HAL_RCC_OscConfig+0x60>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800d0ea:	4b8b      	ldr	r3, [pc, #556]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d0ec:	689b      	ldr	r3, [r3, #8]
 800d0ee:	f003 030c 	and.w	r3, r3, #12
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
 800d0f2:	2b0c      	cmp	r3, #12
 800d0f4:	d112      	bne.n	800d11c <HAL_RCC_OscConfig+0x78>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800d0f6:	4b88      	ldr	r3, [pc, #544]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d0f8:	685b      	ldr	r3, [r3, #4]
 800d0fa:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d0fe:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800d102:	d10b      	bne.n	800d11c <HAL_RCC_OscConfig+0x78>
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#endif /* STM32F446xx */
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d104:	4b84      	ldr	r3, [pc, #528]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d106:	681b      	ldr	r3, [r3, #0]
 800d108:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d10c:	2b00      	cmp	r3, #0
 800d10e:	d05b      	beq.n	800d1c8 <HAL_RCC_OscConfig+0x124>
 800d110:	687b      	ldr	r3, [r7, #4]
 800d112:	685b      	ldr	r3, [r3, #4]
 800d114:	2b00      	cmp	r3, #0
 800d116:	d157      	bne.n	800d1c8 <HAL_RCC_OscConfig+0x124>
      {
        return HAL_ERROR;
 800d118:	2301      	movs	r3, #1
 800d11a:	e25a      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800d11c:	687b      	ldr	r3, [r7, #4]
 800d11e:	685b      	ldr	r3, [r3, #4]
 800d120:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800d124:	d106      	bne.n	800d134 <HAL_RCC_OscConfig+0x90>
 800d126:	4b7c      	ldr	r3, [pc, #496]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d128:	681b      	ldr	r3, [r3, #0]
 800d12a:	4a7b      	ldr	r2, [pc, #492]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d12c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d130:	6013      	str	r3, [r2, #0]
 800d132:	e01d      	b.n	800d170 <HAL_RCC_OscConfig+0xcc>
 800d134:	687b      	ldr	r3, [r7, #4]
 800d136:	685b      	ldr	r3, [r3, #4]
 800d138:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800d13c:	d10c      	bne.n	800d158 <HAL_RCC_OscConfig+0xb4>
 800d13e:	4b76      	ldr	r3, [pc, #472]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d140:	681b      	ldr	r3, [r3, #0]
 800d142:	4a75      	ldr	r2, [pc, #468]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d144:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800d148:	6013      	str	r3, [r2, #0]
 800d14a:	4b73      	ldr	r3, [pc, #460]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d14c:	681b      	ldr	r3, [r3, #0]
 800d14e:	4a72      	ldr	r2, [pc, #456]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d150:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d154:	6013      	str	r3, [r2, #0]
 800d156:	e00b      	b.n	800d170 <HAL_RCC_OscConfig+0xcc>
 800d158:	4b6f      	ldr	r3, [pc, #444]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d15a:	681b      	ldr	r3, [r3, #0]
 800d15c:	4a6e      	ldr	r2, [pc, #440]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d15e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d162:	6013      	str	r3, [r2, #0]
 800d164:	4b6c      	ldr	r3, [pc, #432]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d166:	681b      	ldr	r3, [r3, #0]
 800d168:	4a6b      	ldr	r2, [pc, #428]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d16a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d16e:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800d170:	687b      	ldr	r3, [r7, #4]
 800d172:	685b      	ldr	r3, [r3, #4]
 800d174:	2b00      	cmp	r3, #0
 800d176:	d013      	beq.n	800d1a0 <HAL_RCC_OscConfig+0xfc>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d178:	f7ff f95a 	bl	800c430 <HAL_GetTick>
 800d17c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d17e:	e008      	b.n	800d192 <HAL_RCC_OscConfig+0xee>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d180:	f7ff f956 	bl	800c430 <HAL_GetTick>
 800d184:	4602      	mov	r2, r0
 800d186:	693b      	ldr	r3, [r7, #16]
 800d188:	1ad3      	subs	r3, r2, r3
 800d18a:	2b64      	cmp	r3, #100	; 0x64
 800d18c:	d901      	bls.n	800d192 <HAL_RCC_OscConfig+0xee>
          {
            return HAL_TIMEOUT;
 800d18e:	2303      	movs	r3, #3
 800d190:	e21f      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d192:	4b61      	ldr	r3, [pc, #388]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d194:	681b      	ldr	r3, [r3, #0]
 800d196:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d19a:	2b00      	cmp	r3, #0
 800d19c:	d0f0      	beq.n	800d180 <HAL_RCC_OscConfig+0xdc>
 800d19e:	e014      	b.n	800d1ca <HAL_RCC_OscConfig+0x126>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d1a0:	f7ff f946 	bl	800c430 <HAL_GetTick>
 800d1a4:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d1a6:	e008      	b.n	800d1ba <HAL_RCC_OscConfig+0x116>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800d1a8:	f7ff f942 	bl	800c430 <HAL_GetTick>
 800d1ac:	4602      	mov	r2, r0
 800d1ae:	693b      	ldr	r3, [r7, #16]
 800d1b0:	1ad3      	subs	r3, r2, r3
 800d1b2:	2b64      	cmp	r3, #100	; 0x64
 800d1b4:	d901      	bls.n	800d1ba <HAL_RCC_OscConfig+0x116>
          {
            return HAL_TIMEOUT;
 800d1b6:	2303      	movs	r3, #3
 800d1b8:	e20b      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d1ba:	4b57      	ldr	r3, [pc, #348]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d1bc:	681b      	ldr	r3, [r3, #0]
 800d1be:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d1c2:	2b00      	cmp	r3, #0
 800d1c4:	d1f0      	bne.n	800d1a8 <HAL_RCC_OscConfig+0x104>
 800d1c6:	e000      	b.n	800d1ca <HAL_RCC_OscConfig+0x126>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d1c8:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800d1ca:	687b      	ldr	r3, [r7, #4]
 800d1cc:	681b      	ldr	r3, [r3, #0]
 800d1ce:	f003 0302 	and.w	r3, r3, #2
 800d1d2:	2b00      	cmp	r3, #0
 800d1d4:	d06f      	beq.n	800d2b6 <HAL_RCC_OscConfig+0x212>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 800d1d6:	4b50      	ldr	r3, [pc, #320]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d1d8:	689b      	ldr	r3, [r3, #8]
 800d1da:	f003 030c 	and.w	r3, r3, #12
 800d1de:	2b00      	cmp	r3, #0
 800d1e0:	d017      	beq.n	800d212 <HAL_RCC_OscConfig+0x16e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 800d1e2:	4b4d      	ldr	r3, [pc, #308]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d1e4:	689b      	ldr	r3, [r3, #8]
 800d1e6:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 800d1ea:	2b08      	cmp	r3, #8
 800d1ec:	d105      	bne.n	800d1fa <HAL_RCC_OscConfig+0x156>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 800d1ee:	4b4a      	ldr	r3, [pc, #296]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d1f0:	685b      	ldr	r3, [r3, #4]
 800d1f2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d1f6:	2b00      	cmp	r3, #0
 800d1f8:	d00b      	beq.n	800d212 <HAL_RCC_OscConfig+0x16e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800d1fa:	4b47      	ldr	r3, [pc, #284]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d1fc:	689b      	ldr	r3, [r3, #8]
 800d1fe:	f003 030c 	and.w	r3, r3, #12
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
 800d202:	2b0c      	cmp	r3, #12
 800d204:	d11c      	bne.n	800d240 <HAL_RCC_OscConfig+0x19c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800d206:	4b44      	ldr	r3, [pc, #272]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d208:	685b      	ldr	r3, [r3, #4]
 800d20a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d20e:	2b00      	cmp	r3, #0
 800d210:	d116      	bne.n	800d240 <HAL_RCC_OscConfig+0x19c>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#endif /* STM32F446xx */
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d212:	4b41      	ldr	r3, [pc, #260]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d214:	681b      	ldr	r3, [r3, #0]
 800d216:	f003 0302 	and.w	r3, r3, #2
 800d21a:	2b00      	cmp	r3, #0
 800d21c:	d005      	beq.n	800d22a <HAL_RCC_OscConfig+0x186>
 800d21e:	687b      	ldr	r3, [r7, #4]
 800d220:	68db      	ldr	r3, [r3, #12]
 800d222:	2b01      	cmp	r3, #1
 800d224:	d001      	beq.n	800d22a <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 800d226:	2301      	movs	r3, #1
 800d228:	e1d3      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d22a:	4b3b      	ldr	r3, [pc, #236]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d22c:	681b      	ldr	r3, [r3, #0]
 800d22e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d232:	687b      	ldr	r3, [r7, #4]
 800d234:	691b      	ldr	r3, [r3, #16]
 800d236:	00db      	lsls	r3, r3, #3
 800d238:	4937      	ldr	r1, [pc, #220]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d23a:	4313      	orrs	r3, r2
 800d23c:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d23e:	e03a      	b.n	800d2b6 <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800d240:	687b      	ldr	r3, [r7, #4]
 800d242:	68db      	ldr	r3, [r3, #12]
 800d244:	2b00      	cmp	r3, #0
 800d246:	d020      	beq.n	800d28a <HAL_RCC_OscConfig+0x1e6>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800d248:	4b34      	ldr	r3, [pc, #208]	; (800d31c <HAL_RCC_OscConfig+0x278>)
 800d24a:	2201      	movs	r2, #1
 800d24c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d24e:	f7ff f8ef 	bl	800c430 <HAL_GetTick>
 800d252:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d254:	e008      	b.n	800d268 <HAL_RCC_OscConfig+0x1c4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d256:	f7ff f8eb 	bl	800c430 <HAL_GetTick>
 800d25a:	4602      	mov	r2, r0
 800d25c:	693b      	ldr	r3, [r7, #16]
 800d25e:	1ad3      	subs	r3, r2, r3
 800d260:	2b02      	cmp	r3, #2
 800d262:	d901      	bls.n	800d268 <HAL_RCC_OscConfig+0x1c4>
          {
            return HAL_TIMEOUT;
 800d264:	2303      	movs	r3, #3
 800d266:	e1b4      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d268:	4b2b      	ldr	r3, [pc, #172]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d26a:	681b      	ldr	r3, [r3, #0]
 800d26c:	f003 0302 	and.w	r3, r3, #2
 800d270:	2b00      	cmp	r3, #0
 800d272:	d0f0      	beq.n	800d256 <HAL_RCC_OscConfig+0x1b2>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d274:	4b28      	ldr	r3, [pc, #160]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d276:	681b      	ldr	r3, [r3, #0]
 800d278:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d27c:	687b      	ldr	r3, [r7, #4]
 800d27e:	691b      	ldr	r3, [r3, #16]
 800d280:	00db      	lsls	r3, r3, #3
 800d282:	4925      	ldr	r1, [pc, #148]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d284:	4313      	orrs	r3, r2
 800d286:	600b      	str	r3, [r1, #0]
 800d288:	e015      	b.n	800d2b6 <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800d28a:	4b24      	ldr	r3, [pc, #144]	; (800d31c <HAL_RCC_OscConfig+0x278>)
 800d28c:	2200      	movs	r2, #0
 800d28e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d290:	f7ff f8ce 	bl	800c430 <HAL_GetTick>
 800d294:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d296:	e008      	b.n	800d2aa <HAL_RCC_OscConfig+0x206>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800d298:	f7ff f8ca 	bl	800c430 <HAL_GetTick>
 800d29c:	4602      	mov	r2, r0
 800d29e:	693b      	ldr	r3, [r7, #16]
 800d2a0:	1ad3      	subs	r3, r2, r3
 800d2a2:	2b02      	cmp	r3, #2
 800d2a4:	d901      	bls.n	800d2aa <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 800d2a6:	2303      	movs	r3, #3
 800d2a8:	e193      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d2aa:	4b1b      	ldr	r3, [pc, #108]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d2ac:	681b      	ldr	r3, [r3, #0]
 800d2ae:	f003 0302 	and.w	r3, r3, #2
 800d2b2:	2b00      	cmp	r3, #0
 800d2b4:	d1f0      	bne.n	800d298 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800d2b6:	687b      	ldr	r3, [r7, #4]
 800d2b8:	681b      	ldr	r3, [r3, #0]
 800d2ba:	f003 0308 	and.w	r3, r3, #8
 800d2be:	2b00      	cmp	r3, #0
 800d2c0:	d036      	beq.n	800d330 <HAL_RCC_OscConfig+0x28c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800d2c2:	687b      	ldr	r3, [r7, #4]
 800d2c4:	695b      	ldr	r3, [r3, #20]
 800d2c6:	2b00      	cmp	r3, #0
 800d2c8:	d016      	beq.n	800d2f8 <HAL_RCC_OscConfig+0x254>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800d2ca:	4b15      	ldr	r3, [pc, #84]	; (800d320 <HAL_RCC_OscConfig+0x27c>)
 800d2cc:	2201      	movs	r2, #1
 800d2ce:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d2d0:	f7ff f8ae 	bl	800c430 <HAL_GetTick>
 800d2d4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d2d6:	e008      	b.n	800d2ea <HAL_RCC_OscConfig+0x246>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d2d8:	f7ff f8aa 	bl	800c430 <HAL_GetTick>
 800d2dc:	4602      	mov	r2, r0
 800d2de:	693b      	ldr	r3, [r7, #16]
 800d2e0:	1ad3      	subs	r3, r2, r3
 800d2e2:	2b02      	cmp	r3, #2
 800d2e4:	d901      	bls.n	800d2ea <HAL_RCC_OscConfig+0x246>
        {
          return HAL_TIMEOUT;
 800d2e6:	2303      	movs	r3, #3
 800d2e8:	e173      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d2ea:	4b0b      	ldr	r3, [pc, #44]	; (800d318 <HAL_RCC_OscConfig+0x274>)
 800d2ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d2ee:	f003 0302 	and.w	r3, r3, #2
 800d2f2:	2b00      	cmp	r3, #0
 800d2f4:	d0f0      	beq.n	800d2d8 <HAL_RCC_OscConfig+0x234>
 800d2f6:	e01b      	b.n	800d330 <HAL_RCC_OscConfig+0x28c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800d2f8:	4b09      	ldr	r3, [pc, #36]	; (800d320 <HAL_RCC_OscConfig+0x27c>)
 800d2fa:	2200      	movs	r2, #0
 800d2fc:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d2fe:	f7ff f897 	bl	800c430 <HAL_GetTick>
 800d302:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d304:	e00e      	b.n	800d324 <HAL_RCC_OscConfig+0x280>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800d306:	f7ff f893 	bl	800c430 <HAL_GetTick>
 800d30a:	4602      	mov	r2, r0
 800d30c:	693b      	ldr	r3, [r7, #16]
 800d30e:	1ad3      	subs	r3, r2, r3
 800d310:	2b02      	cmp	r3, #2
 800d312:	d907      	bls.n	800d324 <HAL_RCC_OscConfig+0x280>
        {
          return HAL_TIMEOUT;
 800d314:	2303      	movs	r3, #3
 800d316:	e15c      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
 800d318:	40023800 	.word	0x40023800
 800d31c:	42470000 	.word	0x42470000
 800d320:	42470e80 	.word	0x42470e80
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d324:	4b8a      	ldr	r3, [pc, #552]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d326:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d328:	f003 0302 	and.w	r3, r3, #2
 800d32c:	2b00      	cmp	r3, #0
 800d32e:	d1ea      	bne.n	800d306 <HAL_RCC_OscConfig+0x262>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800d330:	687b      	ldr	r3, [r7, #4]
 800d332:	681b      	ldr	r3, [r3, #0]
 800d334:	f003 0304 	and.w	r3, r3, #4
 800d338:	2b00      	cmp	r3, #0
 800d33a:	f000 8097 	beq.w	800d46c <HAL_RCC_OscConfig+0x3c8>
  {
    FlagStatus       pwrclkchanged = RESET;
 800d33e:	2300      	movs	r3, #0
 800d340:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800d342:	4b83      	ldr	r3, [pc, #524]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d344:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d346:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d34a:	2b00      	cmp	r3, #0
 800d34c:	d10f      	bne.n	800d36e <HAL_RCC_OscConfig+0x2ca>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800d34e:	2300      	movs	r3, #0
 800d350:	60bb      	str	r3, [r7, #8]
 800d352:	4b7f      	ldr	r3, [pc, #508]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d354:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d356:	4a7e      	ldr	r2, [pc, #504]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d358:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d35c:	6413      	str	r3, [r2, #64]	; 0x40
 800d35e:	4b7c      	ldr	r3, [pc, #496]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d360:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d362:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d366:	60bb      	str	r3, [r7, #8]
 800d368:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800d36a:	2301      	movs	r3, #1
 800d36c:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d36e:	4b79      	ldr	r3, [pc, #484]	; (800d554 <HAL_RCC_OscConfig+0x4b0>)
 800d370:	681b      	ldr	r3, [r3, #0]
 800d372:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d376:	2b00      	cmp	r3, #0
 800d378:	d118      	bne.n	800d3ac <HAL_RCC_OscConfig+0x308>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800d37a:	4b76      	ldr	r3, [pc, #472]	; (800d554 <HAL_RCC_OscConfig+0x4b0>)
 800d37c:	681b      	ldr	r3, [r3, #0]
 800d37e:	4a75      	ldr	r2, [pc, #468]	; (800d554 <HAL_RCC_OscConfig+0x4b0>)
 800d380:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d384:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800d386:	f7ff f853 	bl	800c430 <HAL_GetTick>
 800d38a:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d38c:	e008      	b.n	800d3a0 <HAL_RCC_OscConfig+0x2fc>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800d38e:	f7ff f84f 	bl	800c430 <HAL_GetTick>
 800d392:	4602      	mov	r2, r0
 800d394:	693b      	ldr	r3, [r7, #16]
 800d396:	1ad3      	subs	r3, r2, r3
 800d398:	2b02      	cmp	r3, #2
 800d39a:	d901      	bls.n	800d3a0 <HAL_RCC_OscConfig+0x2fc>
        {
          return HAL_TIMEOUT;
 800d39c:	2303      	movs	r3, #3
 800d39e:	e118      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800d3a0:	4b6c      	ldr	r3, [pc, #432]	; (800d554 <HAL_RCC_OscConfig+0x4b0>)
 800d3a2:	681b      	ldr	r3, [r3, #0]
 800d3a4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d3a8:	2b00      	cmp	r3, #0
 800d3aa:	d0f0      	beq.n	800d38e <HAL_RCC_OscConfig+0x2ea>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800d3ac:	687b      	ldr	r3, [r7, #4]
 800d3ae:	689b      	ldr	r3, [r3, #8]
 800d3b0:	2b01      	cmp	r3, #1
 800d3b2:	d106      	bne.n	800d3c2 <HAL_RCC_OscConfig+0x31e>
 800d3b4:	4b66      	ldr	r3, [pc, #408]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d3b8:	4a65      	ldr	r2, [pc, #404]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3ba:	f043 0301 	orr.w	r3, r3, #1
 800d3be:	6713      	str	r3, [r2, #112]	; 0x70
 800d3c0:	e01c      	b.n	800d3fc <HAL_RCC_OscConfig+0x358>
 800d3c2:	687b      	ldr	r3, [r7, #4]
 800d3c4:	689b      	ldr	r3, [r3, #8]
 800d3c6:	2b05      	cmp	r3, #5
 800d3c8:	d10c      	bne.n	800d3e4 <HAL_RCC_OscConfig+0x340>
 800d3ca:	4b61      	ldr	r3, [pc, #388]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d3ce:	4a60      	ldr	r2, [pc, #384]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3d0:	f043 0304 	orr.w	r3, r3, #4
 800d3d4:	6713      	str	r3, [r2, #112]	; 0x70
 800d3d6:	4b5e      	ldr	r3, [pc, #376]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d3da:	4a5d      	ldr	r2, [pc, #372]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3dc:	f043 0301 	orr.w	r3, r3, #1
 800d3e0:	6713      	str	r3, [r2, #112]	; 0x70
 800d3e2:	e00b      	b.n	800d3fc <HAL_RCC_OscConfig+0x358>
 800d3e4:	4b5a      	ldr	r3, [pc, #360]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d3e8:	4a59      	ldr	r2, [pc, #356]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3ea:	f023 0301 	bic.w	r3, r3, #1
 800d3ee:	6713      	str	r3, [r2, #112]	; 0x70
 800d3f0:	4b57      	ldr	r3, [pc, #348]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3f2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d3f4:	4a56      	ldr	r2, [pc, #344]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d3f6:	f023 0304 	bic.w	r3, r3, #4
 800d3fa:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800d3fc:	687b      	ldr	r3, [r7, #4]
 800d3fe:	689b      	ldr	r3, [r3, #8]
 800d400:	2b00      	cmp	r3, #0
 800d402:	d015      	beq.n	800d430 <HAL_RCC_OscConfig+0x38c>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d404:	f7ff f814 	bl	800c430 <HAL_GetTick>
 800d408:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d40a:	e00a      	b.n	800d422 <HAL_RCC_OscConfig+0x37e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d40c:	f7ff f810 	bl	800c430 <HAL_GetTick>
 800d410:	4602      	mov	r2, r0
 800d412:	693b      	ldr	r3, [r7, #16]
 800d414:	1ad3      	subs	r3, r2, r3
 800d416:	f241 3288 	movw	r2, #5000	; 0x1388
 800d41a:	4293      	cmp	r3, r2
 800d41c:	d901      	bls.n	800d422 <HAL_RCC_OscConfig+0x37e>
        {
          return HAL_TIMEOUT;
 800d41e:	2303      	movs	r3, #3
 800d420:	e0d7      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d422:	4b4b      	ldr	r3, [pc, #300]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d424:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d426:	f003 0302 	and.w	r3, r3, #2
 800d42a:	2b00      	cmp	r3, #0
 800d42c:	d0ee      	beq.n	800d40c <HAL_RCC_OscConfig+0x368>
 800d42e:	e014      	b.n	800d45a <HAL_RCC_OscConfig+0x3b6>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d430:	f7fe fffe 	bl	800c430 <HAL_GetTick>
 800d434:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d436:	e00a      	b.n	800d44e <HAL_RCC_OscConfig+0x3aa>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800d438:	f7fe fffa 	bl	800c430 <HAL_GetTick>
 800d43c:	4602      	mov	r2, r0
 800d43e:	693b      	ldr	r3, [r7, #16]
 800d440:	1ad3      	subs	r3, r2, r3
 800d442:	f241 3288 	movw	r2, #5000	; 0x1388
 800d446:	4293      	cmp	r3, r2
 800d448:	d901      	bls.n	800d44e <HAL_RCC_OscConfig+0x3aa>
        {
          return HAL_TIMEOUT;
 800d44a:	2303      	movs	r3, #3
 800d44c:	e0c1      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d44e:	4b40      	ldr	r3, [pc, #256]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d450:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d452:	f003 0302 	and.w	r3, r3, #2
 800d456:	2b00      	cmp	r3, #0
 800d458:	d1ee      	bne.n	800d438 <HAL_RCC_OscConfig+0x394>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800d45a:	7dfb      	ldrb	r3, [r7, #23]
 800d45c:	2b01      	cmp	r3, #1
 800d45e:	d105      	bne.n	800d46c <HAL_RCC_OscConfig+0x3c8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800d460:	4b3b      	ldr	r3, [pc, #236]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d462:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d464:	4a3a      	ldr	r2, [pc, #232]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d466:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800d46a:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800d46c:	687b      	ldr	r3, [r7, #4]
 800d46e:	699b      	ldr	r3, [r3, #24]
 800d470:	2b00      	cmp	r3, #0
 800d472:	f000 80ad 	beq.w	800d5d0 <HAL_RCC_OscConfig+0x52c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800d476:	4b36      	ldr	r3, [pc, #216]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d478:	689b      	ldr	r3, [r3, #8]
 800d47a:	f003 030c 	and.w	r3, r3, #12
 800d47e:	2b08      	cmp	r3, #8
 800d480:	d060      	beq.n	800d544 <HAL_RCC_OscConfig+0x4a0>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800d482:	687b      	ldr	r3, [r7, #4]
 800d484:	699b      	ldr	r3, [r3, #24]
 800d486:	2b02      	cmp	r3, #2
 800d488:	d145      	bne.n	800d516 <HAL_RCC_OscConfig+0x472>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d48a:	4b33      	ldr	r3, [pc, #204]	; (800d558 <HAL_RCC_OscConfig+0x4b4>)
 800d48c:	2200      	movs	r2, #0
 800d48e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d490:	f7fe ffce 	bl	800c430 <HAL_GetTick>
 800d494:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d496:	e008      	b.n	800d4aa <HAL_RCC_OscConfig+0x406>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d498:	f7fe ffca 	bl	800c430 <HAL_GetTick>
 800d49c:	4602      	mov	r2, r0
 800d49e:	693b      	ldr	r3, [r7, #16]
 800d4a0:	1ad3      	subs	r3, r2, r3
 800d4a2:	2b02      	cmp	r3, #2
 800d4a4:	d901      	bls.n	800d4aa <HAL_RCC_OscConfig+0x406>
          {
            return HAL_TIMEOUT;
 800d4a6:	2303      	movs	r3, #3
 800d4a8:	e093      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d4aa:	4b29      	ldr	r3, [pc, #164]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d4ac:	681b      	ldr	r3, [r3, #0]
 800d4ae:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d4b2:	2b00      	cmp	r3, #0
 800d4b4:	d1f0      	bne.n	800d498 <HAL_RCC_OscConfig+0x3f4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800d4b6:	687b      	ldr	r3, [r7, #4]
 800d4b8:	69da      	ldr	r2, [r3, #28]
 800d4ba:	687b      	ldr	r3, [r7, #4]
 800d4bc:	6a1b      	ldr	r3, [r3, #32]
 800d4be:	431a      	orrs	r2, r3
 800d4c0:	687b      	ldr	r3, [r7, #4]
 800d4c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d4c4:	019b      	lsls	r3, r3, #6
 800d4c6:	431a      	orrs	r2, r3
 800d4c8:	687b      	ldr	r3, [r7, #4]
 800d4ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d4cc:	085b      	lsrs	r3, r3, #1
 800d4ce:	3b01      	subs	r3, #1
 800d4d0:	041b      	lsls	r3, r3, #16
 800d4d2:	431a      	orrs	r2, r3
 800d4d4:	687b      	ldr	r3, [r7, #4]
 800d4d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d4d8:	061b      	lsls	r3, r3, #24
 800d4da:	431a      	orrs	r2, r3
 800d4dc:	687b      	ldr	r3, [r7, #4]
 800d4de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d4e0:	071b      	lsls	r3, r3, #28
 800d4e2:	491b      	ldr	r1, [pc, #108]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d4e4:	4313      	orrs	r3, r2
 800d4e6:	604b      	str	r3, [r1, #4]
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)                       | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)        | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)                       | \
                                 (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800d4e8:	4b1b      	ldr	r3, [pc, #108]	; (800d558 <HAL_RCC_OscConfig+0x4b4>)
 800d4ea:	2201      	movs	r2, #1
 800d4ec:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d4ee:	f7fe ff9f 	bl	800c430 <HAL_GetTick>
 800d4f2:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d4f4:	e008      	b.n	800d508 <HAL_RCC_OscConfig+0x464>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d4f6:	f7fe ff9b 	bl	800c430 <HAL_GetTick>
 800d4fa:	4602      	mov	r2, r0
 800d4fc:	693b      	ldr	r3, [r7, #16]
 800d4fe:	1ad3      	subs	r3, r2, r3
 800d500:	2b02      	cmp	r3, #2
 800d502:	d901      	bls.n	800d508 <HAL_RCC_OscConfig+0x464>
          {
            return HAL_TIMEOUT;
 800d504:	2303      	movs	r3, #3
 800d506:	e064      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d508:	4b11      	ldr	r3, [pc, #68]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d50a:	681b      	ldr	r3, [r3, #0]
 800d50c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d510:	2b00      	cmp	r3, #0
 800d512:	d0f0      	beq.n	800d4f6 <HAL_RCC_OscConfig+0x452>
 800d514:	e05c      	b.n	800d5d0 <HAL_RCC_OscConfig+0x52c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d516:	4b10      	ldr	r3, [pc, #64]	; (800d558 <HAL_RCC_OscConfig+0x4b4>)
 800d518:	2200      	movs	r2, #0
 800d51a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d51c:	f7fe ff88 	bl	800c430 <HAL_GetTick>
 800d520:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d522:	e008      	b.n	800d536 <HAL_RCC_OscConfig+0x492>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800d524:	f7fe ff84 	bl	800c430 <HAL_GetTick>
 800d528:	4602      	mov	r2, r0
 800d52a:	693b      	ldr	r3, [r7, #16]
 800d52c:	1ad3      	subs	r3, r2, r3
 800d52e:	2b02      	cmp	r3, #2
 800d530:	d901      	bls.n	800d536 <HAL_RCC_OscConfig+0x492>
          {
            return HAL_TIMEOUT;
 800d532:	2303      	movs	r3, #3
 800d534:	e04d      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d536:	4b06      	ldr	r3, [pc, #24]	; (800d550 <HAL_RCC_OscConfig+0x4ac>)
 800d538:	681b      	ldr	r3, [r3, #0]
 800d53a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d53e:	2b00      	cmp	r3, #0
 800d540:	d1f0      	bne.n	800d524 <HAL_RCC_OscConfig+0x480>
 800d542:	e045      	b.n	800d5d0 <HAL_RCC_OscConfig+0x52c>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800d544:	687b      	ldr	r3, [r7, #4]
 800d546:	699b      	ldr	r3, [r3, #24]
 800d548:	2b01      	cmp	r3, #1
 800d54a:	d107      	bne.n	800d55c <HAL_RCC_OscConfig+0x4b8>
      {
        return HAL_ERROR;
 800d54c:	2301      	movs	r3, #1
 800d54e:	e040      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
 800d550:	40023800 	.word	0x40023800
 800d554:	40007000 	.word	0x40007000
 800d558:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 800d55c:	4b1f      	ldr	r3, [pc, #124]	; (800d5dc <HAL_RCC_OscConfig+0x538>)
 800d55e:	685b      	ldr	r3, [r3, #4]
 800d560:	60fb      	str	r3, [r7, #12]
#if defined (RCC_PLLCFGR_PLLR)
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800d562:	687b      	ldr	r3, [r7, #4]
 800d564:	699b      	ldr	r3, [r3, #24]
 800d566:	2b01      	cmp	r3, #1
 800d568:	d030      	beq.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800d56a:	68fb      	ldr	r3, [r7, #12]
 800d56c:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 800d570:	687b      	ldr	r3, [r7, #4]
 800d572:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800d574:	429a      	cmp	r2, r3
 800d576:	d129      	bne.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800d578:	68fb      	ldr	r3, [r7, #12]
 800d57a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800d57e:	687b      	ldr	r3, [r7, #4]
 800d580:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800d582:	429a      	cmp	r2, r3
 800d584:	d122      	bne.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800d586:	68fa      	ldr	r2, [r7, #12]
 800d588:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800d58c:	4013      	ands	r3, r2
 800d58e:	687a      	ldr	r2, [r7, #4]
 800d590:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800d592:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800d594:	4293      	cmp	r3, r2
 800d596:	d119      	bne.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800d598:	68fb      	ldr	r3, [r7, #12]
 800d59a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800d59e:	687b      	ldr	r3, [r7, #4]
 800d5a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d5a2:	085b      	lsrs	r3, r3, #1
 800d5a4:	3b01      	subs	r3, #1
 800d5a6:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800d5a8:	429a      	cmp	r2, r3
 800d5aa:	d10f      	bne.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800d5ac:	68fb      	ldr	r3, [r7, #12]
 800d5ae:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 800d5b2:	687b      	ldr	r3, [r7, #4]
 800d5b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d5b6:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800d5b8:	429a      	cmp	r2, r3
 800d5ba:	d107      	bne.n	800d5cc <HAL_RCC_OscConfig+0x528>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
 800d5bc:	68fb      	ldr	r3, [r7, #12]
 800d5be:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 800d5c2:	687b      	ldr	r3, [r7, #4]
 800d5c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d5c6:	071b      	lsls	r3, r3, #28
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800d5c8:	429a      	cmp	r2, r3
 800d5ca:	d001      	beq.n	800d5d0 <HAL_RCC_OscConfig+0x52c>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
#endif
        {
          return HAL_ERROR;
 800d5cc:	2301      	movs	r3, #1
 800d5ce:	e000      	b.n	800d5d2 <HAL_RCC_OscConfig+0x52e>
        }
      }
    }
  }
  return HAL_OK;
 800d5d0:	2300      	movs	r3, #0
}
 800d5d2:	4618      	mov	r0, r3
 800d5d4:	3718      	adds	r7, #24
 800d5d6:	46bd      	mov	sp, r7
 800d5d8:	bd80      	pop	{r7, pc}
 800d5da:	bf00      	nop
 800d5dc:	40023800 	.word	0x40023800

0800d5e0 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800d5e0:	b580      	push	{r7, lr}
 800d5e2:	b082      	sub	sp, #8
 800d5e4:	af00      	add	r7, sp, #0
 800d5e6:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800d5e8:	687b      	ldr	r3, [r7, #4]
 800d5ea:	2b00      	cmp	r3, #0
 800d5ec:	d101      	bne.n	800d5f2 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800d5ee:	2301      	movs	r3, #1
 800d5f0:	e041      	b.n	800d676 <HAL_TIM_Base_Init+0x96>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800d5f2:	687b      	ldr	r3, [r7, #4]
 800d5f4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800d5f8:	b2db      	uxtb	r3, r3
 800d5fa:	2b00      	cmp	r3, #0
 800d5fc:	d106      	bne.n	800d60c <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800d5fe:	687b      	ldr	r3, [r7, #4]
 800d600:	2200      	movs	r2, #0
 800d602:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800d606:	6878      	ldr	r0, [r7, #4]
 800d608:	f7fe fbac 	bl	800bd64 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800d60c:	687b      	ldr	r3, [r7, #4]
 800d60e:	2202      	movs	r2, #2
 800d610:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800d614:	687b      	ldr	r3, [r7, #4]
 800d616:	681a      	ldr	r2, [r3, #0]
 800d618:	687b      	ldr	r3, [r7, #4]
 800d61a:	3304      	adds	r3, #4
 800d61c:	4619      	mov	r1, r3
 800d61e:	4610      	mov	r0, r2
 800d620:	f000 f984 	bl	800d92c <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800d624:	687b      	ldr	r3, [r7, #4]
 800d626:	2201      	movs	r2, #1
 800d628:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800d62c:	687b      	ldr	r3, [r7, #4]
 800d62e:	2201      	movs	r2, #1
 800d630:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 800d634:	687b      	ldr	r3, [r7, #4]
 800d636:	2201      	movs	r2, #1
 800d638:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 800d63c:	687b      	ldr	r3, [r7, #4]
 800d63e:	2201      	movs	r2, #1
 800d640:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800d644:	687b      	ldr	r3, [r7, #4]
 800d646:	2201      	movs	r2, #1
 800d648:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800d64c:	687b      	ldr	r3, [r7, #4]
 800d64e:	2201      	movs	r2, #1
 800d650:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800d654:	687b      	ldr	r3, [r7, #4]
 800d656:	2201      	movs	r2, #1
 800d658:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 800d65c:	687b      	ldr	r3, [r7, #4]
 800d65e:	2201      	movs	r2, #1
 800d660:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800d664:	687b      	ldr	r3, [r7, #4]
 800d666:	2201      	movs	r2, #1
 800d668:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800d66c:	687b      	ldr	r3, [r7, #4]
 800d66e:	2201      	movs	r2, #1
 800d670:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 800d674:	2300      	movs	r3, #0
}
 800d676:	4618      	mov	r0, r3
 800d678:	3708      	adds	r7, #8
 800d67a:	46bd      	mov	sp, r7
 800d67c:	bd80      	pop	{r7, pc}
	...

0800d680 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800d680:	b480      	push	{r7}
 800d682:	b085      	sub	sp, #20
 800d684:	af00      	add	r7, sp, #0
 800d686:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800d688:	687b      	ldr	r3, [r7, #4]
 800d68a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800d68e:	b2db      	uxtb	r3, r3
 800d690:	2b01      	cmp	r3, #1
 800d692:	d001      	beq.n	800d698 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
 800d694:	2301      	movs	r3, #1
 800d696:	e046      	b.n	800d726 <HAL_TIM_Base_Start+0xa6>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800d698:	687b      	ldr	r3, [r7, #4]
 800d69a:	2202      	movs	r2, #2
 800d69c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800d6a0:	687b      	ldr	r3, [r7, #4]
 800d6a2:	681b      	ldr	r3, [r3, #0]
 800d6a4:	4a23      	ldr	r2, [pc, #140]	; (800d734 <HAL_TIM_Base_Start+0xb4>)
 800d6a6:	4293      	cmp	r3, r2
 800d6a8:	d022      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6aa:	687b      	ldr	r3, [r7, #4]
 800d6ac:	681b      	ldr	r3, [r3, #0]
 800d6ae:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d6b2:	d01d      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6b4:	687b      	ldr	r3, [r7, #4]
 800d6b6:	681b      	ldr	r3, [r3, #0]
 800d6b8:	4a1f      	ldr	r2, [pc, #124]	; (800d738 <HAL_TIM_Base_Start+0xb8>)
 800d6ba:	4293      	cmp	r3, r2
 800d6bc:	d018      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6be:	687b      	ldr	r3, [r7, #4]
 800d6c0:	681b      	ldr	r3, [r3, #0]
 800d6c2:	4a1e      	ldr	r2, [pc, #120]	; (800d73c <HAL_TIM_Base_Start+0xbc>)
 800d6c4:	4293      	cmp	r3, r2
 800d6c6:	d013      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	681b      	ldr	r3, [r3, #0]
 800d6cc:	4a1c      	ldr	r2, [pc, #112]	; (800d740 <HAL_TIM_Base_Start+0xc0>)
 800d6ce:	4293      	cmp	r3, r2
 800d6d0:	d00e      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6d2:	687b      	ldr	r3, [r7, #4]
 800d6d4:	681b      	ldr	r3, [r3, #0]
 800d6d6:	4a1b      	ldr	r2, [pc, #108]	; (800d744 <HAL_TIM_Base_Start+0xc4>)
 800d6d8:	4293      	cmp	r3, r2
 800d6da:	d009      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6dc:	687b      	ldr	r3, [r7, #4]
 800d6de:	681b      	ldr	r3, [r3, #0]
 800d6e0:	4a19      	ldr	r2, [pc, #100]	; (800d748 <HAL_TIM_Base_Start+0xc8>)
 800d6e2:	4293      	cmp	r3, r2
 800d6e4:	d004      	beq.n	800d6f0 <HAL_TIM_Base_Start+0x70>
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	681b      	ldr	r3, [r3, #0]
 800d6ea:	4a18      	ldr	r2, [pc, #96]	; (800d74c <HAL_TIM_Base_Start+0xcc>)
 800d6ec:	4293      	cmp	r3, r2
 800d6ee:	d111      	bne.n	800d714 <HAL_TIM_Base_Start+0x94>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800d6f0:	687b      	ldr	r3, [r7, #4]
 800d6f2:	681b      	ldr	r3, [r3, #0]
 800d6f4:	689b      	ldr	r3, [r3, #8]
 800d6f6:	f003 0307 	and.w	r3, r3, #7
 800d6fa:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800d6fc:	68fb      	ldr	r3, [r7, #12]
 800d6fe:	2b06      	cmp	r3, #6
 800d700:	d010      	beq.n	800d724 <HAL_TIM_Base_Start+0xa4>
    {
      __HAL_TIM_ENABLE(htim);
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	681b      	ldr	r3, [r3, #0]
 800d706:	681a      	ldr	r2, [r3, #0]
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	681b      	ldr	r3, [r3, #0]
 800d70c:	f042 0201 	orr.w	r2, r2, #1
 800d710:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800d712:	e007      	b.n	800d724 <HAL_TIM_Base_Start+0xa4>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800d714:	687b      	ldr	r3, [r7, #4]
 800d716:	681b      	ldr	r3, [r3, #0]
 800d718:	681a      	ldr	r2, [r3, #0]
 800d71a:	687b      	ldr	r3, [r7, #4]
 800d71c:	681b      	ldr	r3, [r3, #0]
 800d71e:	f042 0201 	orr.w	r2, r2, #1
 800d722:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 800d724:	2300      	movs	r3, #0
}
 800d726:	4618      	mov	r0, r3
 800d728:	3714      	adds	r7, #20
 800d72a:	46bd      	mov	sp, r7
 800d72c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d730:	4770      	bx	lr
 800d732:	bf00      	nop
 800d734:	40010000 	.word	0x40010000
 800d738:	40000400 	.word	0x40000400
 800d73c:	40000800 	.word	0x40000800
 800d740:	40000c00 	.word	0x40000c00
 800d744:	40010400 	.word	0x40010400
 800d748:	40014000 	.word	0x40014000
 800d74c:	40001800 	.word	0x40001800

0800d750 <HAL_TIM_Base_Stop>:
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
{
 800d750:	b480      	push	{r7}
 800d752:	b083      	sub	sp, #12
 800d754:	af00      	add	r7, sp, #0
 800d756:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 800d758:	687b      	ldr	r3, [r7, #4]
 800d75a:	681b      	ldr	r3, [r3, #0]
 800d75c:	6a1a      	ldr	r2, [r3, #32]
 800d75e:	f241 1311 	movw	r3, #4369	; 0x1111
 800d762:	4013      	ands	r3, r2
 800d764:	2b00      	cmp	r3, #0
 800d766:	d10f      	bne.n	800d788 <HAL_TIM_Base_Stop+0x38>
 800d768:	687b      	ldr	r3, [r7, #4]
 800d76a:	681b      	ldr	r3, [r3, #0]
 800d76c:	6a1a      	ldr	r2, [r3, #32]
 800d76e:	f240 4344 	movw	r3, #1092	; 0x444
 800d772:	4013      	ands	r3, r2
 800d774:	2b00      	cmp	r3, #0
 800d776:	d107      	bne.n	800d788 <HAL_TIM_Base_Stop+0x38>
 800d778:	687b      	ldr	r3, [r7, #4]
 800d77a:	681b      	ldr	r3, [r3, #0]
 800d77c:	681a      	ldr	r2, [r3, #0]
 800d77e:	687b      	ldr	r3, [r7, #4]
 800d780:	681b      	ldr	r3, [r3, #0]
 800d782:	f022 0201 	bic.w	r2, r2, #1
 800d786:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
 800d788:	687b      	ldr	r3, [r7, #4]
 800d78a:	2201      	movs	r2, #1
 800d78c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
 800d790:	2300      	movs	r3, #0
}
 800d792:	4618      	mov	r0, r3
 800d794:	370c      	adds	r7, #12
 800d796:	46bd      	mov	sp, r7
 800d798:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d79c:	4770      	bx	lr

0800d79e <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800d79e:	b580      	push	{r7, lr}
 800d7a0:	b084      	sub	sp, #16
 800d7a2:	af00      	add	r7, sp, #0
 800d7a4:	6078      	str	r0, [r7, #4]
 800d7a6:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800d7a8:	2300      	movs	r3, #0
 800d7aa:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800d7ac:	687b      	ldr	r3, [r7, #4]
 800d7ae:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800d7b2:	2b01      	cmp	r3, #1
 800d7b4:	d101      	bne.n	800d7ba <HAL_TIM_ConfigClockSource+0x1c>
 800d7b6:	2302      	movs	r3, #2
 800d7b8:	e0b4      	b.n	800d924 <HAL_TIM_ConfigClockSource+0x186>
 800d7ba:	687b      	ldr	r3, [r7, #4]
 800d7bc:	2201      	movs	r2, #1
 800d7be:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	2202      	movs	r2, #2
 800d7c6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800d7ca:	687b      	ldr	r3, [r7, #4]
 800d7cc:	681b      	ldr	r3, [r3, #0]
 800d7ce:	689b      	ldr	r3, [r3, #8]
 800d7d0:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800d7d2:	68bb      	ldr	r3, [r7, #8]
 800d7d4:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 800d7d8:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800d7da:	68bb      	ldr	r3, [r7, #8]
 800d7dc:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800d7e0:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 800d7e2:	687b      	ldr	r3, [r7, #4]
 800d7e4:	681b      	ldr	r3, [r3, #0]
 800d7e6:	68ba      	ldr	r2, [r7, #8]
 800d7e8:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800d7ea:	683b      	ldr	r3, [r7, #0]
 800d7ec:	681b      	ldr	r3, [r3, #0]
 800d7ee:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800d7f2:	d03e      	beq.n	800d872 <HAL_TIM_ConfigClockSource+0xd4>
 800d7f4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800d7f8:	f200 8087 	bhi.w	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d7fc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800d800:	f000 8086 	beq.w	800d910 <HAL_TIM_ConfigClockSource+0x172>
 800d804:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800d808:	d87f      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d80a:	2b70      	cmp	r3, #112	; 0x70
 800d80c:	d01a      	beq.n	800d844 <HAL_TIM_ConfigClockSource+0xa6>
 800d80e:	2b70      	cmp	r3, #112	; 0x70
 800d810:	d87b      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d812:	2b60      	cmp	r3, #96	; 0x60
 800d814:	d050      	beq.n	800d8b8 <HAL_TIM_ConfigClockSource+0x11a>
 800d816:	2b60      	cmp	r3, #96	; 0x60
 800d818:	d877      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d81a:	2b50      	cmp	r3, #80	; 0x50
 800d81c:	d03c      	beq.n	800d898 <HAL_TIM_ConfigClockSource+0xfa>
 800d81e:	2b50      	cmp	r3, #80	; 0x50
 800d820:	d873      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d822:	2b40      	cmp	r3, #64	; 0x40
 800d824:	d058      	beq.n	800d8d8 <HAL_TIM_ConfigClockSource+0x13a>
 800d826:	2b40      	cmp	r3, #64	; 0x40
 800d828:	d86f      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d82a:	2b30      	cmp	r3, #48	; 0x30
 800d82c:	d064      	beq.n	800d8f8 <HAL_TIM_ConfigClockSource+0x15a>
 800d82e:	2b30      	cmp	r3, #48	; 0x30
 800d830:	d86b      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d832:	2b20      	cmp	r3, #32
 800d834:	d060      	beq.n	800d8f8 <HAL_TIM_ConfigClockSource+0x15a>
 800d836:	2b20      	cmp	r3, #32
 800d838:	d867      	bhi.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
 800d83a:	2b00      	cmp	r3, #0
 800d83c:	d05c      	beq.n	800d8f8 <HAL_TIM_ConfigClockSource+0x15a>
 800d83e:	2b10      	cmp	r3, #16
 800d840:	d05a      	beq.n	800d8f8 <HAL_TIM_ConfigClockSource+0x15a>
 800d842:	e062      	b.n	800d90a <HAL_TIM_ConfigClockSource+0x16c>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800d844:	687b      	ldr	r3, [r7, #4]
 800d846:	6818      	ldr	r0, [r3, #0]
 800d848:	683b      	ldr	r3, [r7, #0]
 800d84a:	6899      	ldr	r1, [r3, #8]
 800d84c:	683b      	ldr	r3, [r7, #0]
 800d84e:	685a      	ldr	r2, [r3, #4]
 800d850:	683b      	ldr	r3, [r7, #0]
 800d852:	68db      	ldr	r3, [r3, #12]
 800d854:	f000 f984 	bl	800db60 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800d858:	687b      	ldr	r3, [r7, #4]
 800d85a:	681b      	ldr	r3, [r3, #0]
 800d85c:	689b      	ldr	r3, [r3, #8]
 800d85e:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800d860:	68bb      	ldr	r3, [r7, #8]
 800d862:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 800d866:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	681b      	ldr	r3, [r3, #0]
 800d86c:	68ba      	ldr	r2, [r7, #8]
 800d86e:	609a      	str	r2, [r3, #8]
      break;
 800d870:	e04f      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800d872:	687b      	ldr	r3, [r7, #4]
 800d874:	6818      	ldr	r0, [r3, #0]
 800d876:	683b      	ldr	r3, [r7, #0]
 800d878:	6899      	ldr	r1, [r3, #8]
 800d87a:	683b      	ldr	r3, [r7, #0]
 800d87c:	685a      	ldr	r2, [r3, #4]
 800d87e:	683b      	ldr	r3, [r7, #0]
 800d880:	68db      	ldr	r3, [r3, #12]
 800d882:	f000 f96d 	bl	800db60 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	681b      	ldr	r3, [r3, #0]
 800d88a:	689a      	ldr	r2, [r3, #8]
 800d88c:	687b      	ldr	r3, [r7, #4]
 800d88e:	681b      	ldr	r3, [r3, #0]
 800d890:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800d894:	609a      	str	r2, [r3, #8]
      break;
 800d896:	e03c      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800d898:	687b      	ldr	r3, [r7, #4]
 800d89a:	6818      	ldr	r0, [r3, #0]
 800d89c:	683b      	ldr	r3, [r7, #0]
 800d89e:	6859      	ldr	r1, [r3, #4]
 800d8a0:	683b      	ldr	r3, [r7, #0]
 800d8a2:	68db      	ldr	r3, [r3, #12]
 800d8a4:	461a      	mov	r2, r3
 800d8a6:	f000 f8e1 	bl	800da6c <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800d8aa:	687b      	ldr	r3, [r7, #4]
 800d8ac:	681b      	ldr	r3, [r3, #0]
 800d8ae:	2150      	movs	r1, #80	; 0x50
 800d8b0:	4618      	mov	r0, r3
 800d8b2:	f000 f93a 	bl	800db2a <TIM_ITRx_SetConfig>
      break;
 800d8b6:	e02c      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800d8b8:	687b      	ldr	r3, [r7, #4]
 800d8ba:	6818      	ldr	r0, [r3, #0]
 800d8bc:	683b      	ldr	r3, [r7, #0]
 800d8be:	6859      	ldr	r1, [r3, #4]
 800d8c0:	683b      	ldr	r3, [r7, #0]
 800d8c2:	68db      	ldr	r3, [r3, #12]
 800d8c4:	461a      	mov	r2, r3
 800d8c6:	f000 f900 	bl	800daca <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800d8ca:	687b      	ldr	r3, [r7, #4]
 800d8cc:	681b      	ldr	r3, [r3, #0]
 800d8ce:	2160      	movs	r1, #96	; 0x60
 800d8d0:	4618      	mov	r0, r3
 800d8d2:	f000 f92a 	bl	800db2a <TIM_ITRx_SetConfig>
      break;
 800d8d6:	e01c      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800d8d8:	687b      	ldr	r3, [r7, #4]
 800d8da:	6818      	ldr	r0, [r3, #0]
 800d8dc:	683b      	ldr	r3, [r7, #0]
 800d8de:	6859      	ldr	r1, [r3, #4]
 800d8e0:	683b      	ldr	r3, [r7, #0]
 800d8e2:	68db      	ldr	r3, [r3, #12]
 800d8e4:	461a      	mov	r2, r3
 800d8e6:	f000 f8c1 	bl	800da6c <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800d8ea:	687b      	ldr	r3, [r7, #4]
 800d8ec:	681b      	ldr	r3, [r3, #0]
 800d8ee:	2140      	movs	r1, #64	; 0x40
 800d8f0:	4618      	mov	r0, r3
 800d8f2:	f000 f91a 	bl	800db2a <TIM_ITRx_SetConfig>
      break;
 800d8f6:	e00c      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>
    case TIM_CLOCKSOURCE_ITR3:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800d8f8:	687b      	ldr	r3, [r7, #4]
 800d8fa:	681a      	ldr	r2, [r3, #0]
 800d8fc:	683b      	ldr	r3, [r7, #0]
 800d8fe:	681b      	ldr	r3, [r3, #0]
 800d900:	4619      	mov	r1, r3
 800d902:	4610      	mov	r0, r2
 800d904:	f000 f911 	bl	800db2a <TIM_ITRx_SetConfig>
      break;
 800d908:	e003      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>
    }

    default:
      status = HAL_ERROR;
 800d90a:	2301      	movs	r3, #1
 800d90c:	73fb      	strb	r3, [r7, #15]
      break;
 800d90e:	e000      	b.n	800d912 <HAL_TIM_ConfigClockSource+0x174>
      break;
 800d910:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800d912:	687b      	ldr	r3, [r7, #4]
 800d914:	2201      	movs	r2, #1
 800d916:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	2200      	movs	r2, #0
 800d91e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 800d922:	7bfb      	ldrb	r3, [r7, #15]
}
 800d924:	4618      	mov	r0, r3
 800d926:	3710      	adds	r7, #16
 800d928:	46bd      	mov	sp, r7
 800d92a:	bd80      	pop	{r7, pc}

0800d92c <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800d92c:	b480      	push	{r7}
 800d92e:	b085      	sub	sp, #20
 800d930:	af00      	add	r7, sp, #0
 800d932:	6078      	str	r0, [r7, #4]
 800d934:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800d936:	687b      	ldr	r3, [r7, #4]
 800d938:	681b      	ldr	r3, [r3, #0]
 800d93a:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800d93c:	687b      	ldr	r3, [r7, #4]
 800d93e:	4a40      	ldr	r2, [pc, #256]	; (800da40 <TIM_Base_SetConfig+0x114>)
 800d940:	4293      	cmp	r3, r2
 800d942:	d013      	beq.n	800d96c <TIM_Base_SetConfig+0x40>
 800d944:	687b      	ldr	r3, [r7, #4]
 800d946:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d94a:	d00f      	beq.n	800d96c <TIM_Base_SetConfig+0x40>
 800d94c:	687b      	ldr	r3, [r7, #4]
 800d94e:	4a3d      	ldr	r2, [pc, #244]	; (800da44 <TIM_Base_SetConfig+0x118>)
 800d950:	4293      	cmp	r3, r2
 800d952:	d00b      	beq.n	800d96c <TIM_Base_SetConfig+0x40>
 800d954:	687b      	ldr	r3, [r7, #4]
 800d956:	4a3c      	ldr	r2, [pc, #240]	; (800da48 <TIM_Base_SetConfig+0x11c>)
 800d958:	4293      	cmp	r3, r2
 800d95a:	d007      	beq.n	800d96c <TIM_Base_SetConfig+0x40>
 800d95c:	687b      	ldr	r3, [r7, #4]
 800d95e:	4a3b      	ldr	r2, [pc, #236]	; (800da4c <TIM_Base_SetConfig+0x120>)
 800d960:	4293      	cmp	r3, r2
 800d962:	d003      	beq.n	800d96c <TIM_Base_SetConfig+0x40>
 800d964:	687b      	ldr	r3, [r7, #4]
 800d966:	4a3a      	ldr	r2, [pc, #232]	; (800da50 <TIM_Base_SetConfig+0x124>)
 800d968:	4293      	cmp	r3, r2
 800d96a:	d108      	bne.n	800d97e <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800d96c:	68fb      	ldr	r3, [r7, #12]
 800d96e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d972:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800d974:	683b      	ldr	r3, [r7, #0]
 800d976:	685b      	ldr	r3, [r3, #4]
 800d978:	68fa      	ldr	r2, [r7, #12]
 800d97a:	4313      	orrs	r3, r2
 800d97c:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800d97e:	687b      	ldr	r3, [r7, #4]
 800d980:	4a2f      	ldr	r2, [pc, #188]	; (800da40 <TIM_Base_SetConfig+0x114>)
 800d982:	4293      	cmp	r3, r2
 800d984:	d02b      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d986:	687b      	ldr	r3, [r7, #4]
 800d988:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d98c:	d027      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d98e:	687b      	ldr	r3, [r7, #4]
 800d990:	4a2c      	ldr	r2, [pc, #176]	; (800da44 <TIM_Base_SetConfig+0x118>)
 800d992:	4293      	cmp	r3, r2
 800d994:	d023      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d996:	687b      	ldr	r3, [r7, #4]
 800d998:	4a2b      	ldr	r2, [pc, #172]	; (800da48 <TIM_Base_SetConfig+0x11c>)
 800d99a:	4293      	cmp	r3, r2
 800d99c:	d01f      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d99e:	687b      	ldr	r3, [r7, #4]
 800d9a0:	4a2a      	ldr	r2, [pc, #168]	; (800da4c <TIM_Base_SetConfig+0x120>)
 800d9a2:	4293      	cmp	r3, r2
 800d9a4:	d01b      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9a6:	687b      	ldr	r3, [r7, #4]
 800d9a8:	4a29      	ldr	r2, [pc, #164]	; (800da50 <TIM_Base_SetConfig+0x124>)
 800d9aa:	4293      	cmp	r3, r2
 800d9ac:	d017      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9ae:	687b      	ldr	r3, [r7, #4]
 800d9b0:	4a28      	ldr	r2, [pc, #160]	; (800da54 <TIM_Base_SetConfig+0x128>)
 800d9b2:	4293      	cmp	r3, r2
 800d9b4:	d013      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9b6:	687b      	ldr	r3, [r7, #4]
 800d9b8:	4a27      	ldr	r2, [pc, #156]	; (800da58 <TIM_Base_SetConfig+0x12c>)
 800d9ba:	4293      	cmp	r3, r2
 800d9bc:	d00f      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9be:	687b      	ldr	r3, [r7, #4]
 800d9c0:	4a26      	ldr	r2, [pc, #152]	; (800da5c <TIM_Base_SetConfig+0x130>)
 800d9c2:	4293      	cmp	r3, r2
 800d9c4:	d00b      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9c6:	687b      	ldr	r3, [r7, #4]
 800d9c8:	4a25      	ldr	r2, [pc, #148]	; (800da60 <TIM_Base_SetConfig+0x134>)
 800d9ca:	4293      	cmp	r3, r2
 800d9cc:	d007      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9ce:	687b      	ldr	r3, [r7, #4]
 800d9d0:	4a24      	ldr	r2, [pc, #144]	; (800da64 <TIM_Base_SetConfig+0x138>)
 800d9d2:	4293      	cmp	r3, r2
 800d9d4:	d003      	beq.n	800d9de <TIM_Base_SetConfig+0xb2>
 800d9d6:	687b      	ldr	r3, [r7, #4]
 800d9d8:	4a23      	ldr	r2, [pc, #140]	; (800da68 <TIM_Base_SetConfig+0x13c>)
 800d9da:	4293      	cmp	r3, r2
 800d9dc:	d108      	bne.n	800d9f0 <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800d9de:	68fb      	ldr	r3, [r7, #12]
 800d9e0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800d9e4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800d9e6:	683b      	ldr	r3, [r7, #0]
 800d9e8:	68db      	ldr	r3, [r3, #12]
 800d9ea:	68fa      	ldr	r2, [r7, #12]
 800d9ec:	4313      	orrs	r3, r2
 800d9ee:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800d9f0:	68fb      	ldr	r3, [r7, #12]
 800d9f2:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800d9f6:	683b      	ldr	r3, [r7, #0]
 800d9f8:	695b      	ldr	r3, [r3, #20]
 800d9fa:	4313      	orrs	r3, r2
 800d9fc:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800d9fe:	687b      	ldr	r3, [r7, #4]
 800da00:	68fa      	ldr	r2, [r7, #12]
 800da02:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800da04:	683b      	ldr	r3, [r7, #0]
 800da06:	689a      	ldr	r2, [r3, #8]
 800da08:	687b      	ldr	r3, [r7, #4]
 800da0a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800da0c:	683b      	ldr	r3, [r7, #0]
 800da0e:	681a      	ldr	r2, [r3, #0]
 800da10:	687b      	ldr	r3, [r7, #4]
 800da12:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800da14:	687b      	ldr	r3, [r7, #4]
 800da16:	4a0a      	ldr	r2, [pc, #40]	; (800da40 <TIM_Base_SetConfig+0x114>)
 800da18:	4293      	cmp	r3, r2
 800da1a:	d003      	beq.n	800da24 <TIM_Base_SetConfig+0xf8>
 800da1c:	687b      	ldr	r3, [r7, #4]
 800da1e:	4a0c      	ldr	r2, [pc, #48]	; (800da50 <TIM_Base_SetConfig+0x124>)
 800da20:	4293      	cmp	r3, r2
 800da22:	d103      	bne.n	800da2c <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800da24:	683b      	ldr	r3, [r7, #0]
 800da26:	691a      	ldr	r2, [r3, #16]
 800da28:	687b      	ldr	r3, [r7, #4]
 800da2a:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800da2c:	687b      	ldr	r3, [r7, #4]
 800da2e:	2201      	movs	r2, #1
 800da30:	615a      	str	r2, [r3, #20]
}
 800da32:	bf00      	nop
 800da34:	3714      	adds	r7, #20
 800da36:	46bd      	mov	sp, r7
 800da38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da3c:	4770      	bx	lr
 800da3e:	bf00      	nop
 800da40:	40010000 	.word	0x40010000
 800da44:	40000400 	.word	0x40000400
 800da48:	40000800 	.word	0x40000800
 800da4c:	40000c00 	.word	0x40000c00
 800da50:	40010400 	.word	0x40010400
 800da54:	40014000 	.word	0x40014000
 800da58:	40014400 	.word	0x40014400
 800da5c:	40014800 	.word	0x40014800
 800da60:	40001800 	.word	0x40001800
 800da64:	40001c00 	.word	0x40001c00
 800da68:	40002000 	.word	0x40002000

0800da6c <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800da6c:	b480      	push	{r7}
 800da6e:	b087      	sub	sp, #28
 800da70:	af00      	add	r7, sp, #0
 800da72:	60f8      	str	r0, [r7, #12]
 800da74:	60b9      	str	r1, [r7, #8]
 800da76:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800da78:	68fb      	ldr	r3, [r7, #12]
 800da7a:	6a1b      	ldr	r3, [r3, #32]
 800da7c:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800da7e:	68fb      	ldr	r3, [r7, #12]
 800da80:	6a1b      	ldr	r3, [r3, #32]
 800da82:	f023 0201 	bic.w	r2, r3, #1
 800da86:	68fb      	ldr	r3, [r7, #12]
 800da88:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800da8a:	68fb      	ldr	r3, [r7, #12]
 800da8c:	699b      	ldr	r3, [r3, #24]
 800da8e:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800da90:	693b      	ldr	r3, [r7, #16]
 800da92:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800da96:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	011b      	lsls	r3, r3, #4
 800da9c:	693a      	ldr	r2, [r7, #16]
 800da9e:	4313      	orrs	r3, r2
 800daa0:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800daa2:	697b      	ldr	r3, [r7, #20]
 800daa4:	f023 030a 	bic.w	r3, r3, #10
 800daa8:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 800daaa:	697a      	ldr	r2, [r7, #20]
 800daac:	68bb      	ldr	r3, [r7, #8]
 800daae:	4313      	orrs	r3, r2
 800dab0:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800dab2:	68fb      	ldr	r3, [r7, #12]
 800dab4:	693a      	ldr	r2, [r7, #16]
 800dab6:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800dab8:	68fb      	ldr	r3, [r7, #12]
 800daba:	697a      	ldr	r2, [r7, #20]
 800dabc:	621a      	str	r2, [r3, #32]
}
 800dabe:	bf00      	nop
 800dac0:	371c      	adds	r7, #28
 800dac2:	46bd      	mov	sp, r7
 800dac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dac8:	4770      	bx	lr

0800daca <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800daca:	b480      	push	{r7}
 800dacc:	b087      	sub	sp, #28
 800dace:	af00      	add	r7, sp, #0
 800dad0:	60f8      	str	r0, [r7, #12]
 800dad2:	60b9      	str	r1, [r7, #8]
 800dad4:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800dad6:	68fb      	ldr	r3, [r7, #12]
 800dad8:	6a1b      	ldr	r3, [r3, #32]
 800dada:	f023 0210 	bic.w	r2, r3, #16
 800dade:	68fb      	ldr	r3, [r7, #12]
 800dae0:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800dae2:	68fb      	ldr	r3, [r7, #12]
 800dae4:	699b      	ldr	r3, [r3, #24]
 800dae6:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 800dae8:	68fb      	ldr	r3, [r7, #12]
 800daea:	6a1b      	ldr	r3, [r3, #32]
 800daec:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800daee:	697b      	ldr	r3, [r7, #20]
 800daf0:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800daf4:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800daf6:	687b      	ldr	r3, [r7, #4]
 800daf8:	031b      	lsls	r3, r3, #12
 800dafa:	697a      	ldr	r2, [r7, #20]
 800dafc:	4313      	orrs	r3, r2
 800dafe:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800db00:	693b      	ldr	r3, [r7, #16]
 800db02:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800db06:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 800db08:	68bb      	ldr	r3, [r7, #8]
 800db0a:	011b      	lsls	r3, r3, #4
 800db0c:	693a      	ldr	r2, [r7, #16]
 800db0e:	4313      	orrs	r3, r2
 800db10:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800db12:	68fb      	ldr	r3, [r7, #12]
 800db14:	697a      	ldr	r2, [r7, #20]
 800db16:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800db18:	68fb      	ldr	r3, [r7, #12]
 800db1a:	693a      	ldr	r2, [r7, #16]
 800db1c:	621a      	str	r2, [r3, #32]
}
 800db1e:	bf00      	nop
 800db20:	371c      	adds	r7, #28
 800db22:	46bd      	mov	sp, r7
 800db24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db28:	4770      	bx	lr

0800db2a <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800db2a:	b480      	push	{r7}
 800db2c:	b085      	sub	sp, #20
 800db2e:	af00      	add	r7, sp, #0
 800db30:	6078      	str	r0, [r7, #4]
 800db32:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800db34:	687b      	ldr	r3, [r7, #4]
 800db36:	689b      	ldr	r3, [r3, #8]
 800db38:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800db3a:	68fb      	ldr	r3, [r7, #12]
 800db3c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800db40:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800db42:	683a      	ldr	r2, [r7, #0]
 800db44:	68fb      	ldr	r3, [r7, #12]
 800db46:	4313      	orrs	r3, r2
 800db48:	f043 0307 	orr.w	r3, r3, #7
 800db4c:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800db4e:	687b      	ldr	r3, [r7, #4]
 800db50:	68fa      	ldr	r2, [r7, #12]
 800db52:	609a      	str	r2, [r3, #8]
}
 800db54:	bf00      	nop
 800db56:	3714      	adds	r7, #20
 800db58:	46bd      	mov	sp, r7
 800db5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db5e:	4770      	bx	lr

0800db60 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800db60:	b480      	push	{r7}
 800db62:	b087      	sub	sp, #28
 800db64:	af00      	add	r7, sp, #0
 800db66:	60f8      	str	r0, [r7, #12]
 800db68:	60b9      	str	r1, [r7, #8]
 800db6a:	607a      	str	r2, [r7, #4]
 800db6c:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800db6e:	68fb      	ldr	r3, [r7, #12]
 800db70:	689b      	ldr	r3, [r3, #8]
 800db72:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800db74:	697b      	ldr	r3, [r7, #20]
 800db76:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800db7a:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800db7c:	683b      	ldr	r3, [r7, #0]
 800db7e:	021a      	lsls	r2, r3, #8
 800db80:	687b      	ldr	r3, [r7, #4]
 800db82:	431a      	orrs	r2, r3
 800db84:	68bb      	ldr	r3, [r7, #8]
 800db86:	4313      	orrs	r3, r2
 800db88:	697a      	ldr	r2, [r7, #20]
 800db8a:	4313      	orrs	r3, r2
 800db8c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800db8e:	68fb      	ldr	r3, [r7, #12]
 800db90:	697a      	ldr	r2, [r7, #20]
 800db92:	609a      	str	r2, [r3, #8]
}
 800db94:	bf00      	nop
 800db96:	371c      	adds	r7, #28
 800db98:	46bd      	mov	sp, r7
 800db9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db9e:	4770      	bx	lr

0800dba0 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800dba0:	b480      	push	{r7}
 800dba2:	b085      	sub	sp, #20
 800dba4:	af00      	add	r7, sp, #0
 800dba6:	6078      	str	r0, [r7, #4]
 800dba8:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800dbaa:	687b      	ldr	r3, [r7, #4]
 800dbac:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800dbb0:	2b01      	cmp	r3, #1
 800dbb2:	d101      	bne.n	800dbb8 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800dbb4:	2302      	movs	r3, #2
 800dbb6:	e05a      	b.n	800dc6e <HAL_TIMEx_MasterConfigSynchronization+0xce>
 800dbb8:	687b      	ldr	r3, [r7, #4]
 800dbba:	2201      	movs	r2, #1
 800dbbc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800dbc0:	687b      	ldr	r3, [r7, #4]
 800dbc2:	2202      	movs	r2, #2
 800dbc4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800dbc8:	687b      	ldr	r3, [r7, #4]
 800dbca:	681b      	ldr	r3, [r3, #0]
 800dbcc:	685b      	ldr	r3, [r3, #4]
 800dbce:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800dbd0:	687b      	ldr	r3, [r7, #4]
 800dbd2:	681b      	ldr	r3, [r3, #0]
 800dbd4:	689b      	ldr	r3, [r3, #8]
 800dbd6:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800dbd8:	68fb      	ldr	r3, [r7, #12]
 800dbda:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800dbde:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800dbe0:	683b      	ldr	r3, [r7, #0]
 800dbe2:	681b      	ldr	r3, [r3, #0]
 800dbe4:	68fa      	ldr	r2, [r7, #12]
 800dbe6:	4313      	orrs	r3, r2
 800dbe8:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800dbea:	687b      	ldr	r3, [r7, #4]
 800dbec:	681b      	ldr	r3, [r3, #0]
 800dbee:	68fa      	ldr	r2, [r7, #12]
 800dbf0:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800dbf2:	687b      	ldr	r3, [r7, #4]
 800dbf4:	681b      	ldr	r3, [r3, #0]
 800dbf6:	4a21      	ldr	r2, [pc, #132]	; (800dc7c <HAL_TIMEx_MasterConfigSynchronization+0xdc>)
 800dbf8:	4293      	cmp	r3, r2
 800dbfa:	d022      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dbfc:	687b      	ldr	r3, [r7, #4]
 800dbfe:	681b      	ldr	r3, [r3, #0]
 800dc00:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800dc04:	d01d      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc06:	687b      	ldr	r3, [r7, #4]
 800dc08:	681b      	ldr	r3, [r3, #0]
 800dc0a:	4a1d      	ldr	r2, [pc, #116]	; (800dc80 <HAL_TIMEx_MasterConfigSynchronization+0xe0>)
 800dc0c:	4293      	cmp	r3, r2
 800dc0e:	d018      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc10:	687b      	ldr	r3, [r7, #4]
 800dc12:	681b      	ldr	r3, [r3, #0]
 800dc14:	4a1b      	ldr	r2, [pc, #108]	; (800dc84 <HAL_TIMEx_MasterConfigSynchronization+0xe4>)
 800dc16:	4293      	cmp	r3, r2
 800dc18:	d013      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc1a:	687b      	ldr	r3, [r7, #4]
 800dc1c:	681b      	ldr	r3, [r3, #0]
 800dc1e:	4a1a      	ldr	r2, [pc, #104]	; (800dc88 <HAL_TIMEx_MasterConfigSynchronization+0xe8>)
 800dc20:	4293      	cmp	r3, r2
 800dc22:	d00e      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc24:	687b      	ldr	r3, [r7, #4]
 800dc26:	681b      	ldr	r3, [r3, #0]
 800dc28:	4a18      	ldr	r2, [pc, #96]	; (800dc8c <HAL_TIMEx_MasterConfigSynchronization+0xec>)
 800dc2a:	4293      	cmp	r3, r2
 800dc2c:	d009      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc2e:	687b      	ldr	r3, [r7, #4]
 800dc30:	681b      	ldr	r3, [r3, #0]
 800dc32:	4a17      	ldr	r2, [pc, #92]	; (800dc90 <HAL_TIMEx_MasterConfigSynchronization+0xf0>)
 800dc34:	4293      	cmp	r3, r2
 800dc36:	d004      	beq.n	800dc42 <HAL_TIMEx_MasterConfigSynchronization+0xa2>
 800dc38:	687b      	ldr	r3, [r7, #4]
 800dc3a:	681b      	ldr	r3, [r3, #0]
 800dc3c:	4a15      	ldr	r2, [pc, #84]	; (800dc94 <HAL_TIMEx_MasterConfigSynchronization+0xf4>)
 800dc3e:	4293      	cmp	r3, r2
 800dc40:	d10c      	bne.n	800dc5c <HAL_TIMEx_MasterConfigSynchronization+0xbc>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800dc42:	68bb      	ldr	r3, [r7, #8]
 800dc44:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800dc48:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800dc4a:	683b      	ldr	r3, [r7, #0]
 800dc4c:	685b      	ldr	r3, [r3, #4]
 800dc4e:	68ba      	ldr	r2, [r7, #8]
 800dc50:	4313      	orrs	r3, r2
 800dc52:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800dc54:	687b      	ldr	r3, [r7, #4]
 800dc56:	681b      	ldr	r3, [r3, #0]
 800dc58:	68ba      	ldr	r2, [r7, #8]
 800dc5a:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800dc5c:	687b      	ldr	r3, [r7, #4]
 800dc5e:	2201      	movs	r2, #1
 800dc60:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 800dc64:	687b      	ldr	r3, [r7, #4]
 800dc66:	2200      	movs	r2, #0
 800dc68:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800dc6c:	2300      	movs	r3, #0
}
 800dc6e:	4618      	mov	r0, r3
 800dc70:	3714      	adds	r7, #20
 800dc72:	46bd      	mov	sp, r7
 800dc74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc78:	4770      	bx	lr
 800dc7a:	bf00      	nop
 800dc7c:	40010000 	.word	0x40010000
 800dc80:	40000400 	.word	0x40000400
 800dc84:	40000800 	.word	0x40000800
 800dc88:	40000c00 	.word	0x40000c00
 800dc8c:	40010400 	.word	0x40010400
 800dc90:	40014000 	.word	0x40014000
 800dc94:	40001800 	.word	0x40001800

0800dc98 <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800dc98:	b580      	push	{r7, lr}
 800dc9a:	b082      	sub	sp, #8
 800dc9c:	af00      	add	r7, sp, #0
 800dc9e:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	2b00      	cmp	r3, #0
 800dca4:	d101      	bne.n	800dcaa <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800dca6:	2301      	movs	r3, #1
 800dca8:	e03f      	b.n	800dd2a <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 800dcaa:	687b      	ldr	r3, [r7, #4]
 800dcac:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800dcb0:	b2db      	uxtb	r3, r3
 800dcb2:	2b00      	cmp	r3, #0
 800dcb4:	d106      	bne.n	800dcc4 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800dcb6:	687b      	ldr	r3, [r7, #4]
 800dcb8:	2200      	movs	r2, #0
 800dcba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800dcbe:	6878      	ldr	r0, [r7, #4]
 800dcc0:	f7fe f89a 	bl	800bdf8 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800dcc4:	687b      	ldr	r3, [r7, #4]
 800dcc6:	2224      	movs	r2, #36	; 0x24
 800dcc8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 800dccc:	687b      	ldr	r3, [r7, #4]
 800dcce:	681b      	ldr	r3, [r3, #0]
 800dcd0:	68da      	ldr	r2, [r3, #12]
 800dcd2:	687b      	ldr	r3, [r7, #4]
 800dcd4:	681b      	ldr	r3, [r3, #0]
 800dcd6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800dcda:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 800dcdc:	6878      	ldr	r0, [r7, #4]
 800dcde:	f000 f929 	bl	800df34 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800dce2:	687b      	ldr	r3, [r7, #4]
 800dce4:	681b      	ldr	r3, [r3, #0]
 800dce6:	691a      	ldr	r2, [r3, #16]
 800dce8:	687b      	ldr	r3, [r7, #4]
 800dcea:	681b      	ldr	r3, [r3, #0]
 800dcec:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800dcf0:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	681b      	ldr	r3, [r3, #0]
 800dcf6:	695a      	ldr	r2, [r3, #20]
 800dcf8:	687b      	ldr	r3, [r7, #4]
 800dcfa:	681b      	ldr	r3, [r3, #0]
 800dcfc:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800dd00:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 800dd02:	687b      	ldr	r3, [r7, #4]
 800dd04:	681b      	ldr	r3, [r3, #0]
 800dd06:	68da      	ldr	r2, [r3, #12]
 800dd08:	687b      	ldr	r3, [r7, #4]
 800dd0a:	681b      	ldr	r3, [r3, #0]
 800dd0c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800dd10:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800dd12:	687b      	ldr	r3, [r7, #4]
 800dd14:	2200      	movs	r2, #0
 800dd16:	641a      	str	r2, [r3, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 800dd18:	687b      	ldr	r3, [r7, #4]
 800dd1a:	2220      	movs	r2, #32
 800dd1c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 800dd20:	687b      	ldr	r3, [r7, #4]
 800dd22:	2220      	movs	r2, #32
 800dd24:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

  return HAL_OK;
 800dd28:	2300      	movs	r3, #0
}
 800dd2a:	4618      	mov	r0, r3
 800dd2c:	3708      	adds	r7, #8
 800dd2e:	46bd      	mov	sp, r7
 800dd30:	bd80      	pop	{r7, pc}

0800dd32 <HAL_UART_Transmit>:
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800dd32:	b580      	push	{r7, lr}
 800dd34:	b08a      	sub	sp, #40	; 0x28
 800dd36:	af02      	add	r7, sp, #8
 800dd38:	60f8      	str	r0, [r7, #12]
 800dd3a:	60b9      	str	r1, [r7, #8]
 800dd3c:	603b      	str	r3, [r7, #0]
 800dd3e:	4613      	mov	r3, r2
 800dd40:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart = 0U;
 800dd42:	2300      	movs	r3, #0
 800dd44:	617b      	str	r3, [r7, #20]

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800dd46:	68fb      	ldr	r3, [r7, #12]
 800dd48:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800dd4c:	b2db      	uxtb	r3, r3
 800dd4e:	2b20      	cmp	r3, #32
 800dd50:	d17c      	bne.n	800de4c <HAL_UART_Transmit+0x11a>
  {
    if ((pData == NULL) || (Size == 0U))
 800dd52:	68bb      	ldr	r3, [r7, #8]
 800dd54:	2b00      	cmp	r3, #0
 800dd56:	d002      	beq.n	800dd5e <HAL_UART_Transmit+0x2c>
 800dd58:	88fb      	ldrh	r3, [r7, #6]
 800dd5a:	2b00      	cmp	r3, #0
 800dd5c:	d101      	bne.n	800dd62 <HAL_UART_Transmit+0x30>
    {
      return  HAL_ERROR;
 800dd5e:	2301      	movs	r3, #1
 800dd60:	e075      	b.n	800de4e <HAL_UART_Transmit+0x11c>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 800dd62:	68fb      	ldr	r3, [r7, #12]
 800dd64:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800dd68:	2b01      	cmp	r3, #1
 800dd6a:	d101      	bne.n	800dd70 <HAL_UART_Transmit+0x3e>
 800dd6c:	2302      	movs	r3, #2
 800dd6e:	e06e      	b.n	800de4e <HAL_UART_Transmit+0x11c>
 800dd70:	68fb      	ldr	r3, [r7, #12]
 800dd72:	2201      	movs	r2, #1
 800dd74:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800dd78:	68fb      	ldr	r3, [r7, #12]
 800dd7a:	2200      	movs	r2, #0
 800dd7c:	641a      	str	r2, [r3, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800dd7e:	68fb      	ldr	r3, [r7, #12]
 800dd80:	2221      	movs	r2, #33	; 0x21
 800dd82:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800dd86:	f7fe fb53 	bl	800c430 <HAL_GetTick>
 800dd8a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize = Size;
 800dd8c:	68fb      	ldr	r3, [r7, #12]
 800dd8e:	88fa      	ldrh	r2, [r7, #6]
 800dd90:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 800dd92:	68fb      	ldr	r3, [r7, #12]
 800dd94:	88fa      	ldrh	r2, [r7, #6]
 800dd96:	84da      	strh	r2, [r3, #38]	; 0x26

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800dd98:	68fb      	ldr	r3, [r7, #12]
 800dd9a:	689b      	ldr	r3, [r3, #8]
 800dd9c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800dda0:	d108      	bne.n	800ddb4 <HAL_UART_Transmit+0x82>
 800dda2:	68fb      	ldr	r3, [r7, #12]
 800dda4:	691b      	ldr	r3, [r3, #16]
 800dda6:	2b00      	cmp	r3, #0
 800dda8:	d104      	bne.n	800ddb4 <HAL_UART_Transmit+0x82>
    {
      pdata8bits  = NULL;
 800ddaa:	2300      	movs	r3, #0
 800ddac:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 800ddae:	68bb      	ldr	r3, [r7, #8]
 800ddb0:	61bb      	str	r3, [r7, #24]
 800ddb2:	e003      	b.n	800ddbc <HAL_UART_Transmit+0x8a>
    }
    else
    {
      pdata8bits  = pData;
 800ddb4:	68bb      	ldr	r3, [r7, #8]
 800ddb6:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800ddb8:	2300      	movs	r3, #0
 800ddba:	61bb      	str	r3, [r7, #24]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800ddbc:	68fb      	ldr	r3, [r7, #12]
 800ddbe:	2200      	movs	r2, #0
 800ddc0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    while (huart->TxXferCount > 0U)
 800ddc4:	e02a      	b.n	800de1c <HAL_UART_Transmit+0xea>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800ddc6:	683b      	ldr	r3, [r7, #0]
 800ddc8:	9300      	str	r3, [sp, #0]
 800ddca:	697b      	ldr	r3, [r7, #20]
 800ddcc:	2200      	movs	r2, #0
 800ddce:	2180      	movs	r1, #128	; 0x80
 800ddd0:	68f8      	ldr	r0, [r7, #12]
 800ddd2:	f000 f840 	bl	800de56 <UART_WaitOnFlagUntilTimeout>
 800ddd6:	4603      	mov	r3, r0
 800ddd8:	2b00      	cmp	r3, #0
 800ddda:	d001      	beq.n	800dde0 <HAL_UART_Transmit+0xae>
      {
        return HAL_TIMEOUT;
 800dddc:	2303      	movs	r3, #3
 800ddde:	e036      	b.n	800de4e <HAL_UART_Transmit+0x11c>
      }
      if (pdata8bits == NULL)
 800dde0:	69fb      	ldr	r3, [r7, #28]
 800dde2:	2b00      	cmp	r3, #0
 800dde4:	d10b      	bne.n	800ddfe <HAL_UART_Transmit+0xcc>
      {
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 800dde6:	69bb      	ldr	r3, [r7, #24]
 800dde8:	881b      	ldrh	r3, [r3, #0]
 800ddea:	461a      	mov	r2, r3
 800ddec:	68fb      	ldr	r3, [r7, #12]
 800ddee:	681b      	ldr	r3, [r3, #0]
 800ddf0:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800ddf4:	605a      	str	r2, [r3, #4]
        pdata16bits++;
 800ddf6:	69bb      	ldr	r3, [r7, #24]
 800ddf8:	3302      	adds	r3, #2
 800ddfa:	61bb      	str	r3, [r7, #24]
 800ddfc:	e007      	b.n	800de0e <HAL_UART_Transmit+0xdc>
      }
      else
      {
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 800ddfe:	69fb      	ldr	r3, [r7, #28]
 800de00:	781a      	ldrb	r2, [r3, #0]
 800de02:	68fb      	ldr	r3, [r7, #12]
 800de04:	681b      	ldr	r3, [r3, #0]
 800de06:	605a      	str	r2, [r3, #4]
        pdata8bits++;
 800de08:	69fb      	ldr	r3, [r7, #28]
 800de0a:	3301      	adds	r3, #1
 800de0c:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800de0e:	68fb      	ldr	r3, [r7, #12]
 800de10:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800de12:	b29b      	uxth	r3, r3
 800de14:	3b01      	subs	r3, #1
 800de16:	b29a      	uxth	r2, r3
 800de18:	68fb      	ldr	r3, [r7, #12]
 800de1a:	84da      	strh	r2, [r3, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 800de1c:	68fb      	ldr	r3, [r7, #12]
 800de1e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800de20:	b29b      	uxth	r3, r3
 800de22:	2b00      	cmp	r3, #0
 800de24:	d1cf      	bne.n	800ddc6 <HAL_UART_Transmit+0x94>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800de26:	683b      	ldr	r3, [r7, #0]
 800de28:	9300      	str	r3, [sp, #0]
 800de2a:	697b      	ldr	r3, [r7, #20]
 800de2c:	2200      	movs	r2, #0
 800de2e:	2140      	movs	r1, #64	; 0x40
 800de30:	68f8      	ldr	r0, [r7, #12]
 800de32:	f000 f810 	bl	800de56 <UART_WaitOnFlagUntilTimeout>
 800de36:	4603      	mov	r3, r0
 800de38:	2b00      	cmp	r3, #0
 800de3a:	d001      	beq.n	800de40 <HAL_UART_Transmit+0x10e>
    {
      return HAL_TIMEOUT;
 800de3c:	2303      	movs	r3, #3
 800de3e:	e006      	b.n	800de4e <HAL_UART_Transmit+0x11c>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800de40:	68fb      	ldr	r3, [r7, #12]
 800de42:	2220      	movs	r2, #32
 800de44:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return HAL_OK;
 800de48:	2300      	movs	r3, #0
 800de4a:	e000      	b.n	800de4e <HAL_UART_Transmit+0x11c>
  }
  else
  {
    return HAL_BUSY;
 800de4c:	2302      	movs	r3, #2
  }
}
 800de4e:	4618      	mov	r0, r3
 800de50:	3720      	adds	r7, #32
 800de52:	46bd      	mov	sp, r7
 800de54:	bd80      	pop	{r7, pc}

0800de56 <UART_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Tickstart, uint32_t Timeout)
{
 800de56:	b580      	push	{r7, lr}
 800de58:	b090      	sub	sp, #64	; 0x40
 800de5a:	af00      	add	r7, sp, #0
 800de5c:	60f8      	str	r0, [r7, #12]
 800de5e:	60b9      	str	r1, [r7, #8]
 800de60:	603b      	str	r3, [r7, #0]
 800de62:	4613      	mov	r3, r2
 800de64:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800de66:	e050      	b.n	800df0a <UART_WaitOnFlagUntilTimeout+0xb4>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800de68:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800de6a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800de6e:	d04c      	beq.n	800df0a <UART_WaitOnFlagUntilTimeout+0xb4>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800de70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800de72:	2b00      	cmp	r3, #0
 800de74:	d007      	beq.n	800de86 <UART_WaitOnFlagUntilTimeout+0x30>
 800de76:	f7fe fadb 	bl	800c430 <HAL_GetTick>
 800de7a:	4602      	mov	r2, r0
 800de7c:	683b      	ldr	r3, [r7, #0]
 800de7e:	1ad3      	subs	r3, r2, r3
 800de80:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800de82:	429a      	cmp	r2, r3
 800de84:	d241      	bcs.n	800df0a <UART_WaitOnFlagUntilTimeout+0xb4>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800de86:	68fb      	ldr	r3, [r7, #12]
 800de88:	681b      	ldr	r3, [r3, #0]
 800de8a:	330c      	adds	r3, #12
 800de8c:	62bb      	str	r3, [r7, #40]	; 0x28
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800de8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800de90:	e853 3f00 	ldrex	r3, [r3]
 800de94:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 800de96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de98:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800de9c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800de9e:	68fb      	ldr	r3, [r7, #12]
 800dea0:	681b      	ldr	r3, [r3, #0]
 800dea2:	330c      	adds	r3, #12
 800dea4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800dea6:	637a      	str	r2, [r7, #52]	; 0x34
 800dea8:	633b      	str	r3, [r7, #48]	; 0x30
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800deaa:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800deac:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800deae:	e841 2300 	strex	r3, r2, [r1]
 800deb2:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 800deb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800deb6:	2b00      	cmp	r3, #0
 800deb8:	d1e5      	bne.n	800de86 <UART_WaitOnFlagUntilTimeout+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800deba:	68fb      	ldr	r3, [r7, #12]
 800debc:	681b      	ldr	r3, [r3, #0]
 800debe:	3314      	adds	r3, #20
 800dec0:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800dec2:	697b      	ldr	r3, [r7, #20]
 800dec4:	e853 3f00 	ldrex	r3, [r3]
 800dec8:	613b      	str	r3, [r7, #16]
   return(result);
 800deca:	693b      	ldr	r3, [r7, #16]
 800decc:	f023 0301 	bic.w	r3, r3, #1
 800ded0:	63bb      	str	r3, [r7, #56]	; 0x38
 800ded2:	68fb      	ldr	r3, [r7, #12]
 800ded4:	681b      	ldr	r3, [r3, #0]
 800ded6:	3314      	adds	r3, #20
 800ded8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800deda:	623a      	str	r2, [r7, #32]
 800dedc:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800dede:	69f9      	ldr	r1, [r7, #28]
 800dee0:	6a3a      	ldr	r2, [r7, #32]
 800dee2:	e841 2300 	strex	r3, r2, [r1]
 800dee6:	61bb      	str	r3, [r7, #24]
   return(result);
 800dee8:	69bb      	ldr	r3, [r7, #24]
 800deea:	2b00      	cmp	r3, #0
 800deec:	d1e5      	bne.n	800deba <UART_WaitOnFlagUntilTimeout+0x64>

        huart->gState  = HAL_UART_STATE_READY;
 800deee:	68fb      	ldr	r3, [r7, #12]
 800def0:	2220      	movs	r2, #32
 800def2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        huart->RxState = HAL_UART_STATE_READY;
 800def6:	68fb      	ldr	r3, [r7, #12]
 800def8:	2220      	movs	r2, #32
 800defa:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 800defe:	68fb      	ldr	r3, [r7, #12]
 800df00:	2200      	movs	r2, #0
 800df02:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        return HAL_TIMEOUT;
 800df06:	2303      	movs	r3, #3
 800df08:	e00f      	b.n	800df2a <UART_WaitOnFlagUntilTimeout+0xd4>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800df0a:	68fb      	ldr	r3, [r7, #12]
 800df0c:	681b      	ldr	r3, [r3, #0]
 800df0e:	681a      	ldr	r2, [r3, #0]
 800df10:	68bb      	ldr	r3, [r7, #8]
 800df12:	4013      	ands	r3, r2
 800df14:	68ba      	ldr	r2, [r7, #8]
 800df16:	429a      	cmp	r2, r3
 800df18:	bf0c      	ite	eq
 800df1a:	2301      	moveq	r3, #1
 800df1c:	2300      	movne	r3, #0
 800df1e:	b2db      	uxtb	r3, r3
 800df20:	461a      	mov	r2, r3
 800df22:	79fb      	ldrb	r3, [r7, #7]
 800df24:	429a      	cmp	r2, r3
 800df26:	d09f      	beq.n	800de68 <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800df28:	2300      	movs	r3, #0
}
 800df2a:	4618      	mov	r0, r3
 800df2c:	3740      	adds	r7, #64	; 0x40
 800df2e:	46bd      	mov	sp, r7
 800df30:	bd80      	pop	{r7, pc}
	...

0800df34 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 800df34:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800df38:	b0c0      	sub	sp, #256	; 0x100
 800df3a:	af00      	add	r7, sp, #0
 800df3c:	f8c7 00f4 	str.w	r0, [r7, #244]	; 0xf4
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800df40:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df44:	681b      	ldr	r3, [r3, #0]
 800df46:	691b      	ldr	r3, [r3, #16]
 800df48:	f423 5040 	bic.w	r0, r3, #12288	; 0x3000
 800df4c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df50:	68d9      	ldr	r1, [r3, #12]
 800df52:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df56:	681a      	ldr	r2, [r3, #0]
 800df58:	ea40 0301 	orr.w	r3, r0, r1
 800df5c:	6113      	str	r3, [r2, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 800df5e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df62:	689a      	ldr	r2, [r3, #8]
 800df64:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df68:	691b      	ldr	r3, [r3, #16]
 800df6a:	431a      	orrs	r2, r3
 800df6c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df70:	695b      	ldr	r3, [r3, #20]
 800df72:	431a      	orrs	r2, r3
 800df74:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df78:	69db      	ldr	r3, [r3, #28]
 800df7a:	4313      	orrs	r3, r2
 800df7c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
  MODIFY_REG(huart->Instance->CR1,
 800df80:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df84:	681b      	ldr	r3, [r3, #0]
 800df86:	68db      	ldr	r3, [r3, #12]
 800df88:	f423 4116 	bic.w	r1, r3, #38400	; 0x9600
 800df8c:	f021 010c 	bic.w	r1, r1, #12
 800df90:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800df94:	681a      	ldr	r2, [r3, #0]
 800df96:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800df9a:	430b      	orrs	r3, r1
 800df9c:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 800df9e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfa2:	681b      	ldr	r3, [r3, #0]
 800dfa4:	695b      	ldr	r3, [r3, #20]
 800dfa6:	f423 7040 	bic.w	r0, r3, #768	; 0x300
 800dfaa:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfae:	6999      	ldr	r1, [r3, #24]
 800dfb0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfb4:	681a      	ldr	r2, [r3, #0]
 800dfb6:	ea40 0301 	orr.w	r3, r0, r1
 800dfba:	6153      	str	r3, [r2, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
    {
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 800dfbc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfc0:	681a      	ldr	r2, [r3, #0]
 800dfc2:	4b8f      	ldr	r3, [pc, #572]	; (800e200 <UART_SetConfig+0x2cc>)
 800dfc4:	429a      	cmp	r2, r3
 800dfc6:	d005      	beq.n	800dfd4 <UART_SetConfig+0xa0>
 800dfc8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfcc:	681a      	ldr	r2, [r3, #0]
 800dfce:	4b8d      	ldr	r3, [pc, #564]	; (800e204 <UART_SetConfig+0x2d0>)
 800dfd0:	429a      	cmp	r2, r3
 800dfd2:	d104      	bne.n	800dfde <UART_SetConfig+0xaa>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 800dfd4:	f7fe fe22 	bl	800cc1c <HAL_RCC_GetPCLK2Freq>
 800dfd8:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
 800dfdc:	e003      	b.n	800dfe6 <UART_SetConfig+0xb2>
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 800dfde:	f7fe fe09 	bl	800cbf4 <HAL_RCC_GetPCLK1Freq>
 800dfe2:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
    }
  /*-------------------------- USART BRR Configuration ---------------------*/
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800dfe6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800dfea:	69db      	ldr	r3, [r3, #28]
 800dfec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800dff0:	f040 810c 	bne.w	800e20c <UART_SetConfig+0x2d8>
  {
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 800dff4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800dff8:	2200      	movs	r2, #0
 800dffa:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 800dffe:	f8c7 20ec 	str.w	r2, [r7, #236]	; 0xec
 800e002:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	; 0xe8
 800e006:	4622      	mov	r2, r4
 800e008:	462b      	mov	r3, r5
 800e00a:	1891      	adds	r1, r2, r2
 800e00c:	65b9      	str	r1, [r7, #88]	; 0x58
 800e00e:	415b      	adcs	r3, r3
 800e010:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e012:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800e016:	4621      	mov	r1, r4
 800e018:	eb12 0801 	adds.w	r8, r2, r1
 800e01c:	4629      	mov	r1, r5
 800e01e:	eb43 0901 	adc.w	r9, r3, r1
 800e022:	f04f 0200 	mov.w	r2, #0
 800e026:	f04f 0300 	mov.w	r3, #0
 800e02a:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 800e02e:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 800e032:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 800e036:	4690      	mov	r8, r2
 800e038:	4699      	mov	r9, r3
 800e03a:	4623      	mov	r3, r4
 800e03c:	eb18 0303 	adds.w	r3, r8, r3
 800e040:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800e044:	462b      	mov	r3, r5
 800e046:	eb49 0303 	adc.w	r3, r9, r3
 800e04a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 800e04e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e052:	685b      	ldr	r3, [r3, #4]
 800e054:	2200      	movs	r2, #0
 800e056:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 800e05a:	f8c7 20dc 	str.w	r2, [r7, #220]	; 0xdc
 800e05e:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	; 0xd8
 800e062:	460b      	mov	r3, r1
 800e064:	18db      	adds	r3, r3, r3
 800e066:	653b      	str	r3, [r7, #80]	; 0x50
 800e068:	4613      	mov	r3, r2
 800e06a:	eb42 0303 	adc.w	r3, r2, r3
 800e06e:	657b      	str	r3, [r7, #84]	; 0x54
 800e070:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 800e074:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	; 0xe0
 800e078:	f7f2 f8ce 	bl	8000218 <__aeabi_uldivmod>
 800e07c:	4602      	mov	r2, r0
 800e07e:	460b      	mov	r3, r1
 800e080:	4b61      	ldr	r3, [pc, #388]	; (800e208 <UART_SetConfig+0x2d4>)
 800e082:	fba3 2302 	umull	r2, r3, r3, r2
 800e086:	095b      	lsrs	r3, r3, #5
 800e088:	011c      	lsls	r4, r3, #4
 800e08a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800e08e:	2200      	movs	r2, #0
 800e090:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800e094:	f8c7 20d4 	str.w	r2, [r7, #212]	; 0xd4
 800e098:	e9d7 8934 	ldrd	r8, r9, [r7, #208]	; 0xd0
 800e09c:	4642      	mov	r2, r8
 800e09e:	464b      	mov	r3, r9
 800e0a0:	1891      	adds	r1, r2, r2
 800e0a2:	64b9      	str	r1, [r7, #72]	; 0x48
 800e0a4:	415b      	adcs	r3, r3
 800e0a6:	64fb      	str	r3, [r7, #76]	; 0x4c
 800e0a8:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800e0ac:	4641      	mov	r1, r8
 800e0ae:	eb12 0a01 	adds.w	sl, r2, r1
 800e0b2:	4649      	mov	r1, r9
 800e0b4:	eb43 0b01 	adc.w	fp, r3, r1
 800e0b8:	f04f 0200 	mov.w	r2, #0
 800e0bc:	f04f 0300 	mov.w	r3, #0
 800e0c0:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 800e0c4:	ea43 735a 	orr.w	r3, r3, sl, lsr #29
 800e0c8:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800e0cc:	4692      	mov	sl, r2
 800e0ce:	469b      	mov	fp, r3
 800e0d0:	4643      	mov	r3, r8
 800e0d2:	eb1a 0303 	adds.w	r3, sl, r3
 800e0d6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800e0da:	464b      	mov	r3, r9
 800e0dc:	eb4b 0303 	adc.w	r3, fp, r3
 800e0e0:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 800e0e4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e0e8:	685b      	ldr	r3, [r3, #4]
 800e0ea:	2200      	movs	r2, #0
 800e0ec:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 800e0f0:	f8c7 20c4 	str.w	r2, [r7, #196]	; 0xc4
 800e0f4:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 800e0f8:	460b      	mov	r3, r1
 800e0fa:	18db      	adds	r3, r3, r3
 800e0fc:	643b      	str	r3, [r7, #64]	; 0x40
 800e0fe:	4613      	mov	r3, r2
 800e100:	eb42 0303 	adc.w	r3, r2, r3
 800e104:	647b      	str	r3, [r7, #68]	; 0x44
 800e106:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800e10a:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	; 0xc8
 800e10e:	f7f2 f883 	bl	8000218 <__aeabi_uldivmod>
 800e112:	4602      	mov	r2, r0
 800e114:	460b      	mov	r3, r1
 800e116:	4611      	mov	r1, r2
 800e118:	4b3b      	ldr	r3, [pc, #236]	; (800e208 <UART_SetConfig+0x2d4>)
 800e11a:	fba3 2301 	umull	r2, r3, r3, r1
 800e11e:	095b      	lsrs	r3, r3, #5
 800e120:	2264      	movs	r2, #100	; 0x64
 800e122:	fb02 f303 	mul.w	r3, r2, r3
 800e126:	1acb      	subs	r3, r1, r3
 800e128:	00db      	lsls	r3, r3, #3
 800e12a:	f103 0232 	add.w	r2, r3, #50	; 0x32
 800e12e:	4b36      	ldr	r3, [pc, #216]	; (800e208 <UART_SetConfig+0x2d4>)
 800e130:	fba3 2302 	umull	r2, r3, r3, r2
 800e134:	095b      	lsrs	r3, r3, #5
 800e136:	005b      	lsls	r3, r3, #1
 800e138:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 800e13c:	441c      	add	r4, r3
 800e13e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800e142:	2200      	movs	r2, #0
 800e144:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 800e148:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
 800e14c:	e9d7 892e 	ldrd	r8, r9, [r7, #184]	; 0xb8
 800e150:	4642      	mov	r2, r8
 800e152:	464b      	mov	r3, r9
 800e154:	1891      	adds	r1, r2, r2
 800e156:	63b9      	str	r1, [r7, #56]	; 0x38
 800e158:	415b      	adcs	r3, r3
 800e15a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800e15c:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 800e160:	4641      	mov	r1, r8
 800e162:	1851      	adds	r1, r2, r1
 800e164:	6339      	str	r1, [r7, #48]	; 0x30
 800e166:	4649      	mov	r1, r9
 800e168:	414b      	adcs	r3, r1
 800e16a:	637b      	str	r3, [r7, #52]	; 0x34
 800e16c:	f04f 0200 	mov.w	r2, #0
 800e170:	f04f 0300 	mov.w	r3, #0
 800e174:	e9d7 ab0c 	ldrd	sl, fp, [r7, #48]	; 0x30
 800e178:	4659      	mov	r1, fp
 800e17a:	00cb      	lsls	r3, r1, #3
 800e17c:	4651      	mov	r1, sl
 800e17e:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800e182:	4651      	mov	r1, sl
 800e184:	00ca      	lsls	r2, r1, #3
 800e186:	4610      	mov	r0, r2
 800e188:	4619      	mov	r1, r3
 800e18a:	4603      	mov	r3, r0
 800e18c:	4642      	mov	r2, r8
 800e18e:	189b      	adds	r3, r3, r2
 800e190:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 800e194:	464b      	mov	r3, r9
 800e196:	460a      	mov	r2, r1
 800e198:	eb42 0303 	adc.w	r3, r2, r3
 800e19c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800e1a0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e1a4:	685b      	ldr	r3, [r3, #4]
 800e1a6:	2200      	movs	r2, #0
 800e1a8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 800e1ac:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
 800e1b0:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 800e1b4:	460b      	mov	r3, r1
 800e1b6:	18db      	adds	r3, r3, r3
 800e1b8:	62bb      	str	r3, [r7, #40]	; 0x28
 800e1ba:	4613      	mov	r3, r2
 800e1bc:	eb42 0303 	adc.w	r3, r2, r3
 800e1c0:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e1c2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 800e1c6:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	; 0xb0
 800e1ca:	f7f2 f825 	bl	8000218 <__aeabi_uldivmod>
 800e1ce:	4602      	mov	r2, r0
 800e1d0:	460b      	mov	r3, r1
 800e1d2:	4b0d      	ldr	r3, [pc, #52]	; (800e208 <UART_SetConfig+0x2d4>)
 800e1d4:	fba3 1302 	umull	r1, r3, r3, r2
 800e1d8:	095b      	lsrs	r3, r3, #5
 800e1da:	2164      	movs	r1, #100	; 0x64
 800e1dc:	fb01 f303 	mul.w	r3, r1, r3
 800e1e0:	1ad3      	subs	r3, r2, r3
 800e1e2:	00db      	lsls	r3, r3, #3
 800e1e4:	3332      	adds	r3, #50	; 0x32
 800e1e6:	4a08      	ldr	r2, [pc, #32]	; (800e208 <UART_SetConfig+0x2d4>)
 800e1e8:	fba2 2303 	umull	r2, r3, r2, r3
 800e1ec:	095b      	lsrs	r3, r3, #5
 800e1ee:	f003 0207 	and.w	r2, r3, #7
 800e1f2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e1f6:	681b      	ldr	r3, [r3, #0]
 800e1f8:	4422      	add	r2, r4
 800e1fa:	609a      	str	r2, [r3, #8]
  }
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
}
 800e1fc:	e105      	b.n	800e40a <UART_SetConfig+0x4d6>
 800e1fe:	bf00      	nop
 800e200:	40011000 	.word	0x40011000
 800e204:	40011400 	.word	0x40011400
 800e208:	51eb851f 	.word	0x51eb851f
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800e20c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800e210:	2200      	movs	r2, #0
 800e212:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 800e216:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
 800e21a:	e9d7 8928 	ldrd	r8, r9, [r7, #160]	; 0xa0
 800e21e:	4642      	mov	r2, r8
 800e220:	464b      	mov	r3, r9
 800e222:	1891      	adds	r1, r2, r2
 800e224:	6239      	str	r1, [r7, #32]
 800e226:	415b      	adcs	r3, r3
 800e228:	627b      	str	r3, [r7, #36]	; 0x24
 800e22a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800e22e:	4641      	mov	r1, r8
 800e230:	1854      	adds	r4, r2, r1
 800e232:	4649      	mov	r1, r9
 800e234:	eb43 0501 	adc.w	r5, r3, r1
 800e238:	f04f 0200 	mov.w	r2, #0
 800e23c:	f04f 0300 	mov.w	r3, #0
 800e240:	00eb      	lsls	r3, r5, #3
 800e242:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 800e246:	00e2      	lsls	r2, r4, #3
 800e248:	4614      	mov	r4, r2
 800e24a:	461d      	mov	r5, r3
 800e24c:	4643      	mov	r3, r8
 800e24e:	18e3      	adds	r3, r4, r3
 800e250:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800e254:	464b      	mov	r3, r9
 800e256:	eb45 0303 	adc.w	r3, r5, r3
 800e25a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800e25e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e262:	685b      	ldr	r3, [r3, #4]
 800e264:	2200      	movs	r2, #0
 800e266:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e26a:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
 800e26e:	f04f 0200 	mov.w	r2, #0
 800e272:	f04f 0300 	mov.w	r3, #0
 800e276:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	; 0x90
 800e27a:	4629      	mov	r1, r5
 800e27c:	008b      	lsls	r3, r1, #2
 800e27e:	4621      	mov	r1, r4
 800e280:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 800e284:	4621      	mov	r1, r4
 800e286:	008a      	lsls	r2, r1, #2
 800e288:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 800e28c:	f7f1 ffc4 	bl	8000218 <__aeabi_uldivmod>
 800e290:	4602      	mov	r2, r0
 800e292:	460b      	mov	r3, r1
 800e294:	4b60      	ldr	r3, [pc, #384]	; (800e418 <UART_SetConfig+0x4e4>)
 800e296:	fba3 2302 	umull	r2, r3, r3, r2
 800e29a:	095b      	lsrs	r3, r3, #5
 800e29c:	011c      	lsls	r4, r3, #4
 800e29e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800e2a2:	2200      	movs	r2, #0
 800e2a4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800e2a8:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 800e2ac:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	; 0x88
 800e2b0:	4642      	mov	r2, r8
 800e2b2:	464b      	mov	r3, r9
 800e2b4:	1891      	adds	r1, r2, r2
 800e2b6:	61b9      	str	r1, [r7, #24]
 800e2b8:	415b      	adcs	r3, r3
 800e2ba:	61fb      	str	r3, [r7, #28]
 800e2bc:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800e2c0:	4641      	mov	r1, r8
 800e2c2:	1851      	adds	r1, r2, r1
 800e2c4:	6139      	str	r1, [r7, #16]
 800e2c6:	4649      	mov	r1, r9
 800e2c8:	414b      	adcs	r3, r1
 800e2ca:	617b      	str	r3, [r7, #20]
 800e2cc:	f04f 0200 	mov.w	r2, #0
 800e2d0:	f04f 0300 	mov.w	r3, #0
 800e2d4:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 800e2d8:	4659      	mov	r1, fp
 800e2da:	00cb      	lsls	r3, r1, #3
 800e2dc:	4651      	mov	r1, sl
 800e2de:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800e2e2:	4651      	mov	r1, sl
 800e2e4:	00ca      	lsls	r2, r1, #3
 800e2e6:	4610      	mov	r0, r2
 800e2e8:	4619      	mov	r1, r3
 800e2ea:	4603      	mov	r3, r0
 800e2ec:	4642      	mov	r2, r8
 800e2ee:	189b      	adds	r3, r3, r2
 800e2f0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e2f4:	464b      	mov	r3, r9
 800e2f6:	460a      	mov	r2, r1
 800e2f8:	eb42 0303 	adc.w	r3, r2, r3
 800e2fc:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e300:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e304:	685b      	ldr	r3, [r3, #4]
 800e306:	2200      	movs	r2, #0
 800e308:	67bb      	str	r3, [r7, #120]	; 0x78
 800e30a:	67fa      	str	r2, [r7, #124]	; 0x7c
 800e30c:	f04f 0200 	mov.w	r2, #0
 800e310:	f04f 0300 	mov.w	r3, #0
 800e314:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	; 0x78
 800e318:	4649      	mov	r1, r9
 800e31a:	008b      	lsls	r3, r1, #2
 800e31c:	4641      	mov	r1, r8
 800e31e:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 800e322:	4641      	mov	r1, r8
 800e324:	008a      	lsls	r2, r1, #2
 800e326:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	; 0x80
 800e32a:	f7f1 ff75 	bl	8000218 <__aeabi_uldivmod>
 800e32e:	4602      	mov	r2, r0
 800e330:	460b      	mov	r3, r1
 800e332:	4b39      	ldr	r3, [pc, #228]	; (800e418 <UART_SetConfig+0x4e4>)
 800e334:	fba3 1302 	umull	r1, r3, r3, r2
 800e338:	095b      	lsrs	r3, r3, #5
 800e33a:	2164      	movs	r1, #100	; 0x64
 800e33c:	fb01 f303 	mul.w	r3, r1, r3
 800e340:	1ad3      	subs	r3, r2, r3
 800e342:	011b      	lsls	r3, r3, #4
 800e344:	3332      	adds	r3, #50	; 0x32
 800e346:	4a34      	ldr	r2, [pc, #208]	; (800e418 <UART_SetConfig+0x4e4>)
 800e348:	fba2 2303 	umull	r2, r3, r2, r3
 800e34c:	095b      	lsrs	r3, r3, #5
 800e34e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800e352:	441c      	add	r4, r3
 800e354:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800e358:	2200      	movs	r2, #0
 800e35a:	673b      	str	r3, [r7, #112]	; 0x70
 800e35c:	677a      	str	r2, [r7, #116]	; 0x74
 800e35e:	e9d7 891c 	ldrd	r8, r9, [r7, #112]	; 0x70
 800e362:	4642      	mov	r2, r8
 800e364:	464b      	mov	r3, r9
 800e366:	1891      	adds	r1, r2, r2
 800e368:	60b9      	str	r1, [r7, #8]
 800e36a:	415b      	adcs	r3, r3
 800e36c:	60fb      	str	r3, [r7, #12]
 800e36e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800e372:	4641      	mov	r1, r8
 800e374:	1851      	adds	r1, r2, r1
 800e376:	6039      	str	r1, [r7, #0]
 800e378:	4649      	mov	r1, r9
 800e37a:	414b      	adcs	r3, r1
 800e37c:	607b      	str	r3, [r7, #4]
 800e37e:	f04f 0200 	mov.w	r2, #0
 800e382:	f04f 0300 	mov.w	r3, #0
 800e386:	e9d7 ab00 	ldrd	sl, fp, [r7]
 800e38a:	4659      	mov	r1, fp
 800e38c:	00cb      	lsls	r3, r1, #3
 800e38e:	4651      	mov	r1, sl
 800e390:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800e394:	4651      	mov	r1, sl
 800e396:	00ca      	lsls	r2, r1, #3
 800e398:	4610      	mov	r0, r2
 800e39a:	4619      	mov	r1, r3
 800e39c:	4603      	mov	r3, r0
 800e39e:	4642      	mov	r2, r8
 800e3a0:	189b      	adds	r3, r3, r2
 800e3a2:	66bb      	str	r3, [r7, #104]	; 0x68
 800e3a4:	464b      	mov	r3, r9
 800e3a6:	460a      	mov	r2, r1
 800e3a8:	eb42 0303 	adc.w	r3, r2, r3
 800e3ac:	66fb      	str	r3, [r7, #108]	; 0x6c
 800e3ae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e3b2:	685b      	ldr	r3, [r3, #4]
 800e3b4:	2200      	movs	r2, #0
 800e3b6:	663b      	str	r3, [r7, #96]	; 0x60
 800e3b8:	667a      	str	r2, [r7, #100]	; 0x64
 800e3ba:	f04f 0200 	mov.w	r2, #0
 800e3be:	f04f 0300 	mov.w	r3, #0
 800e3c2:	e9d7 8918 	ldrd	r8, r9, [r7, #96]	; 0x60
 800e3c6:	4649      	mov	r1, r9
 800e3c8:	008b      	lsls	r3, r1, #2
 800e3ca:	4641      	mov	r1, r8
 800e3cc:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 800e3d0:	4641      	mov	r1, r8
 800e3d2:	008a      	lsls	r2, r1, #2
 800e3d4:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	; 0x68
 800e3d8:	f7f1 ff1e 	bl	8000218 <__aeabi_uldivmod>
 800e3dc:	4602      	mov	r2, r0
 800e3de:	460b      	mov	r3, r1
 800e3e0:	4b0d      	ldr	r3, [pc, #52]	; (800e418 <UART_SetConfig+0x4e4>)
 800e3e2:	fba3 1302 	umull	r1, r3, r3, r2
 800e3e6:	095b      	lsrs	r3, r3, #5
 800e3e8:	2164      	movs	r1, #100	; 0x64
 800e3ea:	fb01 f303 	mul.w	r3, r1, r3
 800e3ee:	1ad3      	subs	r3, r2, r3
 800e3f0:	011b      	lsls	r3, r3, #4
 800e3f2:	3332      	adds	r3, #50	; 0x32
 800e3f4:	4a08      	ldr	r2, [pc, #32]	; (800e418 <UART_SetConfig+0x4e4>)
 800e3f6:	fba2 2303 	umull	r2, r3, r2, r3
 800e3fa:	095b      	lsrs	r3, r3, #5
 800e3fc:	f003 020f 	and.w	r2, r3, #15
 800e400:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e404:	681b      	ldr	r3, [r3, #0]
 800e406:	4422      	add	r2, r4
 800e408:	609a      	str	r2, [r3, #8]
}
 800e40a:	bf00      	nop
 800e40c:	f507 7780 	add.w	r7, r7, #256	; 0x100
 800e410:	46bd      	mov	sp, r7
 800e412:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800e416:	bf00      	nop
 800e418:	51eb851f 	.word	0x51eb851f

0800e41c <__errno>:
 800e41c:	4b01      	ldr	r3, [pc, #4]	; (800e424 <__errno+0x8>)
 800e41e:	6818      	ldr	r0, [r3, #0]
 800e420:	4770      	bx	lr
 800e422:	bf00      	nop
 800e424:	2000004c 	.word	0x2000004c

0800e428 <__libc_init_array>:
 800e428:	b570      	push	{r4, r5, r6, lr}
 800e42a:	4d0d      	ldr	r5, [pc, #52]	; (800e460 <__libc_init_array+0x38>)
 800e42c:	4c0d      	ldr	r4, [pc, #52]	; (800e464 <__libc_init_array+0x3c>)
 800e42e:	1b64      	subs	r4, r4, r5
 800e430:	10a4      	asrs	r4, r4, #2
 800e432:	2600      	movs	r6, #0
 800e434:	42a6      	cmp	r6, r4
 800e436:	d109      	bne.n	800e44c <__libc_init_array+0x24>
 800e438:	4d0b      	ldr	r5, [pc, #44]	; (800e468 <__libc_init_array+0x40>)
 800e43a:	4c0c      	ldr	r4, [pc, #48]	; (800e46c <__libc_init_array+0x44>)
 800e43c:	f000 f998 	bl	800e770 <_init>
 800e440:	1b64      	subs	r4, r4, r5
 800e442:	10a4      	asrs	r4, r4, #2
 800e444:	2600      	movs	r6, #0
 800e446:	42a6      	cmp	r6, r4
 800e448:	d105      	bne.n	800e456 <__libc_init_array+0x2e>
 800e44a:	bd70      	pop	{r4, r5, r6, pc}
 800e44c:	f855 3b04 	ldr.w	r3, [r5], #4
 800e450:	4798      	blx	r3
 800e452:	3601      	adds	r6, #1
 800e454:	e7ee      	b.n	800e434 <__libc_init_array+0xc>
 800e456:	f855 3b04 	ldr.w	r3, [r5], #4
 800e45a:	4798      	blx	r3
 800e45c:	3601      	adds	r6, #1
 800e45e:	e7f2      	b.n	800e446 <__libc_init_array+0x1e>
 800e460:	08010748 	.word	0x08010748
 800e464:	08010748 	.word	0x08010748
 800e468:	08010748 	.word	0x08010748
 800e46c:	0801074c 	.word	0x0801074c

0800e470 <__itoa>:
 800e470:	1e93      	subs	r3, r2, #2
 800e472:	2b22      	cmp	r3, #34	; 0x22
 800e474:	b510      	push	{r4, lr}
 800e476:	460c      	mov	r4, r1
 800e478:	d904      	bls.n	800e484 <__itoa+0x14>
 800e47a:	2300      	movs	r3, #0
 800e47c:	700b      	strb	r3, [r1, #0]
 800e47e:	461c      	mov	r4, r3
 800e480:	4620      	mov	r0, r4
 800e482:	bd10      	pop	{r4, pc}
 800e484:	2a0a      	cmp	r2, #10
 800e486:	d109      	bne.n	800e49c <__itoa+0x2c>
 800e488:	2800      	cmp	r0, #0
 800e48a:	da07      	bge.n	800e49c <__itoa+0x2c>
 800e48c:	232d      	movs	r3, #45	; 0x2d
 800e48e:	700b      	strb	r3, [r1, #0]
 800e490:	4240      	negs	r0, r0
 800e492:	2101      	movs	r1, #1
 800e494:	4421      	add	r1, r4
 800e496:	f000 f91d 	bl	800e6d4 <__utoa>
 800e49a:	e7f1      	b.n	800e480 <__itoa+0x10>
 800e49c:	2100      	movs	r1, #0
 800e49e:	e7f9      	b.n	800e494 <__itoa+0x24>

0800e4a0 <itoa>:
 800e4a0:	f7ff bfe6 	b.w	800e470 <__itoa>

0800e4a4 <__retarget_lock_acquire_recursive>:
 800e4a4:	4770      	bx	lr

0800e4a6 <__retarget_lock_release_recursive>:
 800e4a6:	4770      	bx	lr

0800e4a8 <malloc>:
 800e4a8:	4b02      	ldr	r3, [pc, #8]	; (800e4b4 <malloc+0xc>)
 800e4aa:	4601      	mov	r1, r0
 800e4ac:	6818      	ldr	r0, [r3, #0]
 800e4ae:	f000 b88d 	b.w	800e5cc <_malloc_r>
 800e4b2:	bf00      	nop
 800e4b4:	2000004c 	.word	0x2000004c

0800e4b8 <free>:
 800e4b8:	4b02      	ldr	r3, [pc, #8]	; (800e4c4 <free+0xc>)
 800e4ba:	4601      	mov	r1, r0
 800e4bc:	6818      	ldr	r0, [r3, #0]
 800e4be:	f000 b819 	b.w	800e4f4 <_free_r>
 800e4c2:	bf00      	nop
 800e4c4:	2000004c 	.word	0x2000004c

0800e4c8 <memcpy>:
 800e4c8:	440a      	add	r2, r1
 800e4ca:	4291      	cmp	r1, r2
 800e4cc:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800e4d0:	d100      	bne.n	800e4d4 <memcpy+0xc>
 800e4d2:	4770      	bx	lr
 800e4d4:	b510      	push	{r4, lr}
 800e4d6:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e4da:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e4de:	4291      	cmp	r1, r2
 800e4e0:	d1f9      	bne.n	800e4d6 <memcpy+0xe>
 800e4e2:	bd10      	pop	{r4, pc}

0800e4e4 <memset>:
 800e4e4:	4402      	add	r2, r0
 800e4e6:	4603      	mov	r3, r0
 800e4e8:	4293      	cmp	r3, r2
 800e4ea:	d100      	bne.n	800e4ee <memset+0xa>
 800e4ec:	4770      	bx	lr
 800e4ee:	f803 1b01 	strb.w	r1, [r3], #1
 800e4f2:	e7f9      	b.n	800e4e8 <memset+0x4>

0800e4f4 <_free_r>:
 800e4f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800e4f6:	2900      	cmp	r1, #0
 800e4f8:	d044      	beq.n	800e584 <_free_r+0x90>
 800e4fa:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800e4fe:	9001      	str	r0, [sp, #4]
 800e500:	2b00      	cmp	r3, #0
 800e502:	f1a1 0404 	sub.w	r4, r1, #4
 800e506:	bfb8      	it	lt
 800e508:	18e4      	addlt	r4, r4, r3
 800e50a:	f000 f925 	bl	800e758 <__malloc_lock>
 800e50e:	4a1e      	ldr	r2, [pc, #120]	; (800e588 <_free_r+0x94>)
 800e510:	9801      	ldr	r0, [sp, #4]
 800e512:	6813      	ldr	r3, [r2, #0]
 800e514:	b933      	cbnz	r3, 800e524 <_free_r+0x30>
 800e516:	6063      	str	r3, [r4, #4]
 800e518:	6014      	str	r4, [r2, #0]
 800e51a:	b003      	add	sp, #12
 800e51c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800e520:	f000 b920 	b.w	800e764 <__malloc_unlock>
 800e524:	42a3      	cmp	r3, r4
 800e526:	d908      	bls.n	800e53a <_free_r+0x46>
 800e528:	6825      	ldr	r5, [r4, #0]
 800e52a:	1961      	adds	r1, r4, r5
 800e52c:	428b      	cmp	r3, r1
 800e52e:	bf01      	itttt	eq
 800e530:	6819      	ldreq	r1, [r3, #0]
 800e532:	685b      	ldreq	r3, [r3, #4]
 800e534:	1949      	addeq	r1, r1, r5
 800e536:	6021      	streq	r1, [r4, #0]
 800e538:	e7ed      	b.n	800e516 <_free_r+0x22>
 800e53a:	461a      	mov	r2, r3
 800e53c:	685b      	ldr	r3, [r3, #4]
 800e53e:	b10b      	cbz	r3, 800e544 <_free_r+0x50>
 800e540:	42a3      	cmp	r3, r4
 800e542:	d9fa      	bls.n	800e53a <_free_r+0x46>
 800e544:	6811      	ldr	r1, [r2, #0]
 800e546:	1855      	adds	r5, r2, r1
 800e548:	42a5      	cmp	r5, r4
 800e54a:	d10b      	bne.n	800e564 <_free_r+0x70>
 800e54c:	6824      	ldr	r4, [r4, #0]
 800e54e:	4421      	add	r1, r4
 800e550:	1854      	adds	r4, r2, r1
 800e552:	42a3      	cmp	r3, r4
 800e554:	6011      	str	r1, [r2, #0]
 800e556:	d1e0      	bne.n	800e51a <_free_r+0x26>
 800e558:	681c      	ldr	r4, [r3, #0]
 800e55a:	685b      	ldr	r3, [r3, #4]
 800e55c:	6053      	str	r3, [r2, #4]
 800e55e:	4421      	add	r1, r4
 800e560:	6011      	str	r1, [r2, #0]
 800e562:	e7da      	b.n	800e51a <_free_r+0x26>
 800e564:	d902      	bls.n	800e56c <_free_r+0x78>
 800e566:	230c      	movs	r3, #12
 800e568:	6003      	str	r3, [r0, #0]
 800e56a:	e7d6      	b.n	800e51a <_free_r+0x26>
 800e56c:	6825      	ldr	r5, [r4, #0]
 800e56e:	1961      	adds	r1, r4, r5
 800e570:	428b      	cmp	r3, r1
 800e572:	bf04      	itt	eq
 800e574:	6819      	ldreq	r1, [r3, #0]
 800e576:	685b      	ldreq	r3, [r3, #4]
 800e578:	6063      	str	r3, [r4, #4]
 800e57a:	bf04      	itt	eq
 800e57c:	1949      	addeq	r1, r1, r5
 800e57e:	6021      	streq	r1, [r4, #0]
 800e580:	6054      	str	r4, [r2, #4]
 800e582:	e7ca      	b.n	800e51a <_free_r+0x26>
 800e584:	b003      	add	sp, #12
 800e586:	bd30      	pop	{r4, r5, pc}
 800e588:	200017b0 	.word	0x200017b0

0800e58c <sbrk_aligned>:
 800e58c:	b570      	push	{r4, r5, r6, lr}
 800e58e:	4e0e      	ldr	r6, [pc, #56]	; (800e5c8 <sbrk_aligned+0x3c>)
 800e590:	460c      	mov	r4, r1
 800e592:	6831      	ldr	r1, [r6, #0]
 800e594:	4605      	mov	r5, r0
 800e596:	b911      	cbnz	r1, 800e59e <sbrk_aligned+0x12>
 800e598:	f000 f88c 	bl	800e6b4 <_sbrk_r>
 800e59c:	6030      	str	r0, [r6, #0]
 800e59e:	4621      	mov	r1, r4
 800e5a0:	4628      	mov	r0, r5
 800e5a2:	f000 f887 	bl	800e6b4 <_sbrk_r>
 800e5a6:	1c43      	adds	r3, r0, #1
 800e5a8:	d00a      	beq.n	800e5c0 <sbrk_aligned+0x34>
 800e5aa:	1cc4      	adds	r4, r0, #3
 800e5ac:	f024 0403 	bic.w	r4, r4, #3
 800e5b0:	42a0      	cmp	r0, r4
 800e5b2:	d007      	beq.n	800e5c4 <sbrk_aligned+0x38>
 800e5b4:	1a21      	subs	r1, r4, r0
 800e5b6:	4628      	mov	r0, r5
 800e5b8:	f000 f87c 	bl	800e6b4 <_sbrk_r>
 800e5bc:	3001      	adds	r0, #1
 800e5be:	d101      	bne.n	800e5c4 <sbrk_aligned+0x38>
 800e5c0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800e5c4:	4620      	mov	r0, r4
 800e5c6:	bd70      	pop	{r4, r5, r6, pc}
 800e5c8:	200017b4 	.word	0x200017b4

0800e5cc <_malloc_r>:
 800e5cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e5d0:	1ccd      	adds	r5, r1, #3
 800e5d2:	f025 0503 	bic.w	r5, r5, #3
 800e5d6:	3508      	adds	r5, #8
 800e5d8:	2d0c      	cmp	r5, #12
 800e5da:	bf38      	it	cc
 800e5dc:	250c      	movcc	r5, #12
 800e5de:	2d00      	cmp	r5, #0
 800e5e0:	4607      	mov	r7, r0
 800e5e2:	db01      	blt.n	800e5e8 <_malloc_r+0x1c>
 800e5e4:	42a9      	cmp	r1, r5
 800e5e6:	d905      	bls.n	800e5f4 <_malloc_r+0x28>
 800e5e8:	230c      	movs	r3, #12
 800e5ea:	603b      	str	r3, [r7, #0]
 800e5ec:	2600      	movs	r6, #0
 800e5ee:	4630      	mov	r0, r6
 800e5f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e5f4:	4e2e      	ldr	r6, [pc, #184]	; (800e6b0 <_malloc_r+0xe4>)
 800e5f6:	f000 f8af 	bl	800e758 <__malloc_lock>
 800e5fa:	6833      	ldr	r3, [r6, #0]
 800e5fc:	461c      	mov	r4, r3
 800e5fe:	bb34      	cbnz	r4, 800e64e <_malloc_r+0x82>
 800e600:	4629      	mov	r1, r5
 800e602:	4638      	mov	r0, r7
 800e604:	f7ff ffc2 	bl	800e58c <sbrk_aligned>
 800e608:	1c43      	adds	r3, r0, #1
 800e60a:	4604      	mov	r4, r0
 800e60c:	d14d      	bne.n	800e6aa <_malloc_r+0xde>
 800e60e:	6834      	ldr	r4, [r6, #0]
 800e610:	4626      	mov	r6, r4
 800e612:	2e00      	cmp	r6, #0
 800e614:	d140      	bne.n	800e698 <_malloc_r+0xcc>
 800e616:	6823      	ldr	r3, [r4, #0]
 800e618:	4631      	mov	r1, r6
 800e61a:	4638      	mov	r0, r7
 800e61c:	eb04 0803 	add.w	r8, r4, r3
 800e620:	f000 f848 	bl	800e6b4 <_sbrk_r>
 800e624:	4580      	cmp	r8, r0
 800e626:	d13a      	bne.n	800e69e <_malloc_r+0xd2>
 800e628:	6821      	ldr	r1, [r4, #0]
 800e62a:	3503      	adds	r5, #3
 800e62c:	1a6d      	subs	r5, r5, r1
 800e62e:	f025 0503 	bic.w	r5, r5, #3
 800e632:	3508      	adds	r5, #8
 800e634:	2d0c      	cmp	r5, #12
 800e636:	bf38      	it	cc
 800e638:	250c      	movcc	r5, #12
 800e63a:	4629      	mov	r1, r5
 800e63c:	4638      	mov	r0, r7
 800e63e:	f7ff ffa5 	bl	800e58c <sbrk_aligned>
 800e642:	3001      	adds	r0, #1
 800e644:	d02b      	beq.n	800e69e <_malloc_r+0xd2>
 800e646:	6823      	ldr	r3, [r4, #0]
 800e648:	442b      	add	r3, r5
 800e64a:	6023      	str	r3, [r4, #0]
 800e64c:	e00e      	b.n	800e66c <_malloc_r+0xa0>
 800e64e:	6822      	ldr	r2, [r4, #0]
 800e650:	1b52      	subs	r2, r2, r5
 800e652:	d41e      	bmi.n	800e692 <_malloc_r+0xc6>
 800e654:	2a0b      	cmp	r2, #11
 800e656:	d916      	bls.n	800e686 <_malloc_r+0xba>
 800e658:	1961      	adds	r1, r4, r5
 800e65a:	42a3      	cmp	r3, r4
 800e65c:	6025      	str	r5, [r4, #0]
 800e65e:	bf18      	it	ne
 800e660:	6059      	strne	r1, [r3, #4]
 800e662:	6863      	ldr	r3, [r4, #4]
 800e664:	bf08      	it	eq
 800e666:	6031      	streq	r1, [r6, #0]
 800e668:	5162      	str	r2, [r4, r5]
 800e66a:	604b      	str	r3, [r1, #4]
 800e66c:	4638      	mov	r0, r7
 800e66e:	f104 060b 	add.w	r6, r4, #11
 800e672:	f000 f877 	bl	800e764 <__malloc_unlock>
 800e676:	f026 0607 	bic.w	r6, r6, #7
 800e67a:	1d23      	adds	r3, r4, #4
 800e67c:	1af2      	subs	r2, r6, r3
 800e67e:	d0b6      	beq.n	800e5ee <_malloc_r+0x22>
 800e680:	1b9b      	subs	r3, r3, r6
 800e682:	50a3      	str	r3, [r4, r2]
 800e684:	e7b3      	b.n	800e5ee <_malloc_r+0x22>
 800e686:	6862      	ldr	r2, [r4, #4]
 800e688:	42a3      	cmp	r3, r4
 800e68a:	bf0c      	ite	eq
 800e68c:	6032      	streq	r2, [r6, #0]
 800e68e:	605a      	strne	r2, [r3, #4]
 800e690:	e7ec      	b.n	800e66c <_malloc_r+0xa0>
 800e692:	4623      	mov	r3, r4
 800e694:	6864      	ldr	r4, [r4, #4]
 800e696:	e7b2      	b.n	800e5fe <_malloc_r+0x32>
 800e698:	4634      	mov	r4, r6
 800e69a:	6876      	ldr	r6, [r6, #4]
 800e69c:	e7b9      	b.n	800e612 <_malloc_r+0x46>
 800e69e:	230c      	movs	r3, #12
 800e6a0:	603b      	str	r3, [r7, #0]
 800e6a2:	4638      	mov	r0, r7
 800e6a4:	f000 f85e 	bl	800e764 <__malloc_unlock>
 800e6a8:	e7a1      	b.n	800e5ee <_malloc_r+0x22>
 800e6aa:	6025      	str	r5, [r4, #0]
 800e6ac:	e7de      	b.n	800e66c <_malloc_r+0xa0>
 800e6ae:	bf00      	nop
 800e6b0:	200017b0 	.word	0x200017b0

0800e6b4 <_sbrk_r>:
 800e6b4:	b538      	push	{r3, r4, r5, lr}
 800e6b6:	4d06      	ldr	r5, [pc, #24]	; (800e6d0 <_sbrk_r+0x1c>)
 800e6b8:	2300      	movs	r3, #0
 800e6ba:	4604      	mov	r4, r0
 800e6bc:	4608      	mov	r0, r1
 800e6be:	602b      	str	r3, [r5, #0]
 800e6c0:	f7fd fabc 	bl	800bc3c <_sbrk>
 800e6c4:	1c43      	adds	r3, r0, #1
 800e6c6:	d102      	bne.n	800e6ce <_sbrk_r+0x1a>
 800e6c8:	682b      	ldr	r3, [r5, #0]
 800e6ca:	b103      	cbz	r3, 800e6ce <_sbrk_r+0x1a>
 800e6cc:	6023      	str	r3, [r4, #0]
 800e6ce:	bd38      	pop	{r3, r4, r5, pc}
 800e6d0:	200017b8 	.word	0x200017b8

0800e6d4 <__utoa>:
 800e6d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e6d6:	4c1f      	ldr	r4, [pc, #124]	; (800e754 <__utoa+0x80>)
 800e6d8:	b08b      	sub	sp, #44	; 0x2c
 800e6da:	4605      	mov	r5, r0
 800e6dc:	460b      	mov	r3, r1
 800e6de:	466e      	mov	r6, sp
 800e6e0:	f104 0c20 	add.w	ip, r4, #32
 800e6e4:	6820      	ldr	r0, [r4, #0]
 800e6e6:	6861      	ldr	r1, [r4, #4]
 800e6e8:	4637      	mov	r7, r6
 800e6ea:	c703      	stmia	r7!, {r0, r1}
 800e6ec:	3408      	adds	r4, #8
 800e6ee:	4564      	cmp	r4, ip
 800e6f0:	463e      	mov	r6, r7
 800e6f2:	d1f7      	bne.n	800e6e4 <__utoa+0x10>
 800e6f4:	7921      	ldrb	r1, [r4, #4]
 800e6f6:	7139      	strb	r1, [r7, #4]
 800e6f8:	1e91      	subs	r1, r2, #2
 800e6fa:	6820      	ldr	r0, [r4, #0]
 800e6fc:	6038      	str	r0, [r7, #0]
 800e6fe:	2922      	cmp	r1, #34	; 0x22
 800e700:	f04f 0100 	mov.w	r1, #0
 800e704:	d904      	bls.n	800e710 <__utoa+0x3c>
 800e706:	7019      	strb	r1, [r3, #0]
 800e708:	460b      	mov	r3, r1
 800e70a:	4618      	mov	r0, r3
 800e70c:	b00b      	add	sp, #44	; 0x2c
 800e70e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e710:	1e58      	subs	r0, r3, #1
 800e712:	4684      	mov	ip, r0
 800e714:	fbb5 f7f2 	udiv	r7, r5, r2
 800e718:	fb02 5617 	mls	r6, r2, r7, r5
 800e71c:	3628      	adds	r6, #40	; 0x28
 800e71e:	446e      	add	r6, sp
 800e720:	460c      	mov	r4, r1
 800e722:	f816 6c28 	ldrb.w	r6, [r6, #-40]
 800e726:	f80c 6f01 	strb.w	r6, [ip, #1]!
 800e72a:	462e      	mov	r6, r5
 800e72c:	42b2      	cmp	r2, r6
 800e72e:	f101 0101 	add.w	r1, r1, #1
 800e732:	463d      	mov	r5, r7
 800e734:	d9ee      	bls.n	800e714 <__utoa+0x40>
 800e736:	2200      	movs	r2, #0
 800e738:	545a      	strb	r2, [r3, r1]
 800e73a:	1919      	adds	r1, r3, r4
 800e73c:	1aa5      	subs	r5, r4, r2
 800e73e:	42aa      	cmp	r2, r5
 800e740:	dae3      	bge.n	800e70a <__utoa+0x36>
 800e742:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 800e746:	780e      	ldrb	r6, [r1, #0]
 800e748:	7006      	strb	r6, [r0, #0]
 800e74a:	3201      	adds	r2, #1
 800e74c:	f801 5901 	strb.w	r5, [r1], #-1
 800e750:	e7f4      	b.n	800e73c <__utoa+0x68>
 800e752:	bf00      	nop
 800e754:	080106b8 	.word	0x080106b8

0800e758 <__malloc_lock>:
 800e758:	4801      	ldr	r0, [pc, #4]	; (800e760 <__malloc_lock+0x8>)
 800e75a:	f7ff bea3 	b.w	800e4a4 <__retarget_lock_acquire_recursive>
 800e75e:	bf00      	nop
 800e760:	200017ac 	.word	0x200017ac

0800e764 <__malloc_unlock>:
 800e764:	4801      	ldr	r0, [pc, #4]	; (800e76c <__malloc_unlock+0x8>)
 800e766:	f7ff be9e 	b.w	800e4a6 <__retarget_lock_release_recursive>
 800e76a:	bf00      	nop
 800e76c:	200017ac 	.word	0x200017ac

0800e770 <_init>:
 800e770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e772:	bf00      	nop
 800e774:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e776:	bc08      	pop	{r3}
 800e778:	469e      	mov	lr, r3
 800e77a:	4770      	bx	lr

0800e77c <_fini>:
 800e77c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e77e:	bf00      	nop
 800e780:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800e782:	bc08      	pop	{r3}
 800e784:	469e      	mov	lr, r3
 800e786:	4770      	bx	lr
